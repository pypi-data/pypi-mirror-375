---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/metaclass_with_wildcard_imports/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
yaml_pkg_loader = _cribo.types.SimpleNamespace(__name__='yaml_pkg.loader')
yaml_pkg = _cribo.types.SimpleNamespace(__name__='yaml_pkg', __initializing__=False, __initialized__=False)
yaml_pkg.loader = yaml_pkg_loader
class BaseLoader:
    """Base loader class"""

    def __init__(self):
        self.name = "BaseLoader"

    @classmethod
    def add_constructor(cls, tag, constructor):
        print(f"{cls.__name__}: Adding constructor for {tag}")
BaseLoader.__module__ = 'yaml_pkg.loader'
class Loader(BaseLoader):
    """Standard loader class"""

    def __init__(self):
        super().__init__()
        self.name = "Loader"
Loader.__module__ = 'yaml_pkg.loader'
class FullLoader(BaseLoader):
    """Full loader with all features"""

    def __init__(self):
        super().__init__()
        self.name = "FullLoader"
FullLoader.__module__ = 'yaml_pkg.loader'
yaml_pkg_loader.BaseLoader = BaseLoader
yaml_pkg_loader.Loader = Loader
yaml_pkg_loader.FullLoader = FullLoader
yaml_pkg_dumper = _cribo.types.SimpleNamespace(__name__='yaml_pkg.dumper')
yaml_pkg.dumper = yaml_pkg_dumper
class Dumper:
    """Dumper class for YAML output"""

    def __init__(self):
        self.name = "Dumper"

    @classmethod
    def add_representer(cls, data_type, representer):
        print(f"{cls.__name__}: Adding representer for {data_type}")
Dumper.__module__ = 'yaml_pkg.dumper'
yaml_pkg_dumper.Dumper = Dumper
def _cribo_init___cribo_5b2acd_yaml_pkg(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    self.Dumper = yaml_pkg_dumper.Dumper
    self.FullLoader = yaml_pkg_loader.FullLoader
    self.Loader = yaml_pkg_loader.Loader

    class YAMLObjectMetaclass(type):
        """\n    The metaclass for YAMLObject.\n    """

        def __init__(cls, name, bases, kwds):
            super(YAMLObjectMetaclass, cls).__init__(name, bases, kwds)
            if "yaml_tag" in kwds and kwds.get("yaml_tag") is not None:
                if isinstance(cls.yaml_loader, list):
                    for loader in cls.yaml_loader:
                        print(f"Registering {name} with {loader.__name__}")
                else:
                    print(f"Registering {name} with {cls.yaml_loader.__name__}")
    YAMLObjectMetaclass.__module__ = 'yaml_pkg'
    self.YAMLObjectMetaclass = YAMLObjectMetaclass

    class YAMLObject(metaclass=YAMLObjectMetaclass):
        """\n    An object that uses a metaclass and references classes from wildcard imports.\n    This mimics PyYAML's structure.\n    """
        __slots__ = ()
        yaml_loader = [Loader, FullLoader]
        yaml_dumper = Dumper
        yaml_tag = None

        @classmethod
        def from_yaml(cls, loader, node):
            return f"Loading {cls.__name__} from YAML"

        @classmethod
        def to_yaml(cls, dumper, data):
            return f"Dumping {cls.__name__} to YAML"
    YAMLObject.__module__ = 'yaml_pkg'
    self.YAMLObject = YAMLObject
    self.dumper = yaml_pkg_dumper
    self.loader = yaml_pkg_loader
    self.dumper = yaml_pkg_dumper
    self.loader = yaml_pkg_loader
    self.__initialized__ = True
    self.__initializing__ = False
    return self
yaml_pkg.__init__ = _cribo_init___cribo_5b2acd_yaml_pkg
"""\nTest case for metaclass forward reference issue with wildcard imports.\n\nThis reproduces the PyYAML bundling issue where:\n1. A class uses a metaclass that's defined later in the same module\n2. The class body references symbols imported via wildcard imports\n3. When bundled, the metaclass definition gets placed after its usage\n"""
__cribo_init_result = _cribo_init___cribo_5b2acd_yaml_pkg(yaml_pkg)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(yaml_pkg, attr, getattr(__cribo_init_result, attr))
print("Module loaded successfully")
print(f"YAMLObject name: {yaml_pkg.YAMLObject.__name__}")
print(f"YAMLObjectMetaclass name: {yaml_pkg.YAMLObjectMetaclass.__name__}")
print(f"Loader name: {yaml_pkg.Loader.__name__}")
print(f"FullLoader name: {yaml_pkg.FullLoader.__name__}")
print(f"Dumper name: {yaml_pkg.Dumper.__name__}")
class CustomYAMLObject(yaml_pkg.YAMLObject):
    yaml_tag = "!custom"

    def __init__(self, value):
        self.value = value
obj = CustomYAMLObject("test")
print(f"Created custom object with value: {obj.value}")
print(f"Custom object class name: {obj.__class__.__name__}")
print(f"yaml_loader types: {[type(loader).__name__ for loader in CustomYAMLObject.yaml_loader]}")
print(f"yaml_dumper type: {type(CustomYAMLObject.yaml_dumper).__name__}")
dumper = yaml_pkg.dumper
loader = yaml_pkg.loader
