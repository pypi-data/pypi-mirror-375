"""
Integration test for Jinja2 template rendering workflow
"""

from pathlib import Path

import pytest

from specify_cli.models.project import TemplateContext
from specify_cli.services.template_service import TemplateService


class TestJinja2TemplateRendering:
    """Integration tests for end-to-end Jinja2 template rendering"""

    @pytest.fixture
    def template_service(self) -> TemplateService:
        """Create TemplateService instance"""
        from specify_cli.services.template_service import JinjaTemplateService

        return JinjaTemplateService()

    @pytest.fixture
    def comprehensive_template_package(self, tmp_path: Path) -> Path:
        """Create comprehensive template package for testing"""
        template_dir = tmp_path / "comprehensive_templates"
        template_dir.mkdir()

        # Create various template types
        templates = {
            "README.md.j2": """# {{ project_name }}

Project: {{ project_name }}
AI Assistant: {{ ai_assistant }}
Branch: {{ branch_type }}/{{ feature_name }}

{% if additional_vars.author %}
Author: {{ additional_vars.author }}
{% endif %}

## Features
{% for feature in additional_vars.features %}
- {{ feature }}
{% endfor %}

## Configuration
AI: {{ ai_assistant }}
{% if additional_vars.enable_logging %}
Logging: Enabled
{% else %}
Logging: Disabled  
{% endif %}
""",
            "package.json.j2": """{
  "name": "{{ project_name }}",
  "version": "{{ additional_vars.version | default('1.0.0') }}",
  "description": "{{ additional_vars.description | default('Generated by ' + ai_assistant) }}",
  "main": "{{ additional_vars.main_file | default('index.js') }}",
  "scripts": {
    "start": "node {{ additional_vars.main_file | default('index.js') }}",
    "test": "{{ additional_vars.test_command | default('npm test') }}"
  },
  "keywords": [
    {% for keyword in additional_vars.keywords %}
    "{{ keyword }}"{% if not loop.last %},{% endif %}
    {% endfor %}
  ],
  "author": "{{ additional_vars.author | default('Unknown') }}"
}""",
            "config.toml.j2": """[project]
name = "{{ project_name }}"
ai_assistant = "{{ ai_assistant }}"

[project.branch_naming]
default_pattern = "{{ branch_type }}/{feature-name}"
{% if additional_vars.custom_patterns %}
{% for pattern in additional_vars.custom_patterns %}
patterns = "{{ pattern }}"
{% endfor %}
{% endif %}

[project.template_settings]
template_cache_enabled = {{ additional_vars.enable_cache | default(true) | lower }}
{% if additional_vars.template_vars %}
[project.template_settings.template_variables]
{% for key, value in additional_vars.template_vars.items() %}
{{ key }} = "{{ value }}"
{% endfor %}
{% endif %}
""",
            "spec.md.j2": """# {{ project_name }} - Specification

**Project**: {{ project_name }}  
**AI Assistant**: {{ ai_assistant }}  
**Branch**: {{ branch_type }}/{{ feature_name }}  

## Overview
{% if additional_vars.description %}
{{ additional_vars.description }}
{% else %}
Specification document for {{ project_name }} project.
{% endif %}

## Requirements
{% for requirement in additional_vars.requirements %}
- {{ requirement }}
{% endfor %}

## Implementation Plan
{% if additional_vars.implementation_steps %}
{% for step in additional_vars.implementation_steps %}
{{ loop.index }}. {{ step }}
{% endfor %}
{% endif %}

## Testing Strategy
{% if additional_vars.testing_approach %}
{{ additional_vars.testing_approach }}
{% else %}
- Unit tests for core functionality
- Integration tests for workflows
- Contract tests for service interfaces
{% endif %}

## Architecture
AI Assistant: {{ ai_assistant }}
{% if additional_vars.architecture_notes %}
{{ additional_vars.architecture_notes }}
{% endif %}

---
*Generated by {{ ai_assistant }} for spec-driven development*
""",
            "scripts/setup.sh.j2": """#!/bin/bash

# Setup script for {{ project_name }}
# Generated by {{ ai_assistant }}

set -e

echo "Setting up {{ project_name }}..."

{% if additional_vars.create_directories %}
# Create directory structure
{% for dir in additional_vars.create_directories %}
mkdir -p "{{ dir }}"
{% endfor %}
{% endif %}

{% if additional_vars.install_dependencies %}
# Install dependencies
{% if additional_vars.package_manager == 'npm' %}
npm install
{% elif additional_vars.package_manager == 'yarn' %}
yarn install  
{% elif additional_vars.package_manager == 'pnpm' %}
pnpm install
{% endif %}
{% endif %}

{% if additional_vars.run_setup_commands %}
# Run setup commands
{% for command in additional_vars.run_setup_commands %}
echo "Running: {{ command }}"
{{ command }}
{% endfor %}
{% endif %}

echo "Setup complete for {{ project_name }}!"
""",
        }

        for filename, content in templates.items():
            template_path = template_dir / filename
            template_path.parent.mkdir(parents=True, exist_ok=True)
            template_path.write_text(content)

        return template_dir

    @pytest.fixture
    def rich_template_context(self) -> TemplateContext:
        """Create rich template context with various data types"""
        return TemplateContext(
            project_name="integration-test-project",
            ai_assistant="claude",
            branch_type="feature",
            feature_name="template-rendering",
            additional_vars={
                "author": "Integration Test Suite",
                "version": "2.1.0",
                "description": "Comprehensive integration test for template rendering",
                "main_file": "app.js",
                "test_command": "jest",
                "keywords": ["testing", "templates", "integration", "jinja2"],
                "features": [
                    "Jinja2 template processing",
                    "Multi-format support",
                    "Variable interpolation",
                    "Conditional rendering",
                    "Loop processing",
                ],
                "enable_logging": True,
                "enable_cache": True,
                "requirements": [
                    "Spec-driven development workflow",
                    "Template-based project initialization",
                    "Branch naming configuration",
                    "AI assistant integration",
                ],
                "implementation_steps": [
                    "Design service architecture",
                    "Implement template processing",
                    "Create configuration management",
                    "Build CLI interface",
                ],
                "create_directories": ["src", "tests", "docs", "config"],
                "package_manager": "npm",
                "install_dependencies": True,
                "run_setup_commands": ["npm run build", "npm run test:setup"],
                "custom_patterns": ["hotfix/{version}", "epic/{epic-name}"],
                "template_vars": {
                    "team": "integration-team",
                    "environment": "test",
                    "region": "us-west",
                },
            },
        )

    def test_comprehensive_template_rendering(
        self,
        template_service: TemplateService,
        comprehensive_template_package: Path,
        rich_template_context: TemplateContext,
    ):
        """Test comprehensive Jinja2 template rendering with complex features"""
        # Load template package
        success = template_service.load_template_package(
            "claude", comprehensive_template_package
        )
        assert success, "Failed to load comprehensive template package"

        # Test individual template rendering
        readme_content = template_service.render_template(
            "README.md.j2", rich_template_context
        )

        # Verify complex rendering features
        assert "integration-test-project" in readme_content
        assert "claude" in readme_content
        assert "feature/template-rendering" in readme_content
        assert "Integration Test Suite" in readme_content
        assert "Jinja2 template processing" in readme_content
        assert "Multi-format support" in readme_content
        assert "Logging: Enabled" in readme_content

        # Test JSON template with filters and defaults
        package_content = template_service.render_template(
            "package.json.j2", rich_template_context
        )
        assert '"name": "integration-test-project"' in package_content
        assert '"version": "2.1.0"' in package_content
        assert '"main": "app.js"' in package_content
        assert '"testing"' in package_content
        assert '"templates"' in package_content

        # Test TOML template with nested structures
        config_content = template_service.render_template(
            "config.toml.j2", rich_template_context
        )
        assert 'name = "integration-test-project"' in config_content
        assert 'ai_assistant = "claude"' in config_content
        assert "template_cache_enabled = true" in config_content
        assert 'team = "integration-team"' in config_content

        # Test spec.md with conditionals and loops
        spec_content = template_service.render_template(
            "spec.md.j2", rich_template_context
        )
        assert "# integration-test-project - Specification" in spec_content
        assert "feature/template-rendering" in spec_content
        assert "Spec-driven development workflow" in spec_content
        assert "Design service architecture" in spec_content

        # Test shell script with loops and conditionals
        script_content = template_service.render_template(
            "scripts/setup.sh.j2", rich_template_context
        )
        assert "Setting up integration-test-project..." in script_content
        assert 'mkdir -p "src"' in script_content
        assert 'mkdir -p "tests"' in script_content
        assert "npm install" in script_content
        assert "npm run build" in script_content

    def test_template_rendering_with_missing_variables(
        self, template_service: TemplateService, comprehensive_template_package: Path
    ):
        """Test template rendering gracefully handles missing variables"""
        template_service.load_template_package("claude", comprehensive_template_package)

        # Context with minimal data
        minimal_context = TemplateContext(
            project_name="minimal-test",
            ai_assistant="claude",
            branch_type="feature",
            feature_name="minimal",
            additional_vars={},  # Empty additional vars
        )

        # Should not crash and should use defaults
        readme_content = template_service.render_template(
            "README.md.j2", minimal_context
        )
        assert "minimal-test" in readme_content
        assert "claude" in readme_content
        # Author section should not appear (conditional)
        assert "Author:" not in readme_content

        # Package.json should use defaults
        package_content = template_service.render_template(
            "package.json.j2", minimal_context
        )
        assert '"version": "1.0.0"' in package_content  # Default version
        assert '"main": "index.js"' in package_content  # Default main file
        assert '"author": "Unknown"' in package_content  # Default author

    def test_template_rendering_edge_cases(
        self, template_service: TemplateService, tmp_path: Path
    ):
        """Test edge cases in template rendering"""
        template_dir = tmp_path / "edge_cases"
        template_dir.mkdir()

        # Template with complex expressions
        edge_template = template_dir / "edge.j2"
        edge_template.write_text("""
{# Complex expressions and filters #}
Project: {{ project_name | upper }}
Slug: {{ project_name | lower | replace(' ', '-') }}
Feature: {{ feature_name | title }}

{# Math operations #}
Priority: {{ (additional_vars.base_priority | default(1)) + (additional_vars.priority_offset | default(0)) }}

{# Complex conditionals #}
{% if additional_vars.items and additional_vars.items | length > 0 %}
Items ({{ additional_vars.items | length }}):
{% for item in additional_vars.items %}
  - {{ loop.index }}: {{ item.name }} ({{ item.type | default('unknown') }})
{% endfor %}
{% else %}
No items configured.
{% endif %}

{# Date formatting if available #}
{% if additional_vars.created_date %}
Created: {{ additional_vars.created_date | default('unknown') }}
{% endif %}

{# String manipulation #}
Clean name: {{ project_name | regex_replace('[^a-zA-Z0-9]', '_') | lower }}
""")

        template_service.load_template_package("claude", template_dir)

        context = TemplateContext(
            project_name="Edge Case Test",
            ai_assistant="claude",
            branch_type="test",
            feature_name="edge-cases",
            additional_vars={
                "base_priority": 5,
                "priority_offset": 2,
                "items": [
                    {"name": "item1", "type": "config"},
                    {"name": "item2"},  # Missing type
                    {"name": "item3", "type": "data"},
                ],
                "created_date": "2025-09-07",
            },
        )

        content = template_service.render_template("edge.j2", context)

        # Verify complex processing
        assert "Project: EDGE CASE TEST" in content
        assert "Slug: edge case test" in content or "edge-case-test" in content
        assert "Feature: Edge-Cases" in content or "Edge Cases" in content
        assert "Priority: 7" in content
        assert "Items (3):" in content
        assert "1: item1 (config)" in content
        assert "2: item2 (unknown)" in content  # Default type
        assert "3: item3 (data)" in content

    def test_batch_template_rendering(
        self,
        template_service: TemplateService,
        comprehensive_template_package: Path,
        rich_template_context: TemplateContext,
        tmp_path: Path,
    ):
        """Test rendering multiple templates in batch"""
        template_service.load_template_package("claude", comprehensive_template_package)

        output_dir = tmp_path / "rendered_output"
        output_dir.mkdir()

        # Render all project templates
        template_files = template_service.render_project_templates(
            rich_template_context, output_dir
        )

        # Verify we got multiple files
        assert len(template_files) >= 4  # At least our main templates

        # Verify each template file structure
        for template_file in template_files:
            assert hasattr(template_file, "template_path")
            assert hasattr(template_file, "output_path")
            assert hasattr(template_file, "content")
            assert hasattr(template_file, "is_executable")

            # Content should be rendered (contain project name)
            assert rich_template_context.project_name in template_file.content

            # Executable flag should be set for shell scripts
            if template_file.output_path.endswith(".sh"):
                assert template_file.is_executable

        # Verify specific files were rendered correctly
        readme_file = next(
            (tf for tf in template_files if "README.md" in tf.output_path), None
        )
        assert readme_file is not None
        assert "# integration-test-project" in readme_file.content

        package_file = next(
            (tf for tf in template_files if "package.json" in tf.output_path), None
        )
        assert package_file is not None
        assert '"name": "integration-test-project"' in package_file.content

    def test_template_syntax_validation_integration(
        self, template_service: TemplateService, tmp_path: Path
    ):
        """Test template syntax validation in integration workflow"""
        template_dir = tmp_path / "validation_test"
        template_dir.mkdir()

        # Valid template
        valid_template = template_dir / "valid.j2"
        valid_template.write_text("Hello {{ name }}!")

        # Invalid templates
        invalid_templates = {
            "unclosed_var.j2": "Hello {{ name",
            "unclosed_block.j2": "{% if condition %}Hello",
            "invalid_filter.j2": "{{ name | nonexistent_filter }}",
            "syntax_error.j2": "{% for item in %}",
        }

        for filename, content in invalid_templates.items():
            (template_dir / filename).write_text(content)

        template_service.load_template_package("claude", template_dir)

        # Test valid template
        is_valid, error = template_service.validate_template_syntax(valid_template)
        assert is_valid is True
        assert error is None

        # Test invalid templates
        for filename in invalid_templates:
            template_path = template_dir / filename
            is_valid, error = template_service.validate_template_syntax(template_path)
            assert is_valid is False
            assert error is not None
            assert len(error) > 0

    def test_template_variable_extraction_integration(
        self, template_service: TemplateService, comprehensive_template_package: Path
    ):
        """Test template variable extraction in integration workflow"""
        template_service.load_template_package("claude", comprehensive_template_package)

        # Test variable extraction from README template
        readme_template = comprehensive_template_package / "README.md.j2"
        variables = template_service.get_template_variables(readme_template)

        expected_vars = {
            "project_name",
            "ai_assistant",
            "branch_type",
            "feature_name",
            "additional_vars",  # May be detected as a base variable
        }

        found_vars = set(variables)
        # Should find at least the basic template variables
        assert len(found_vars.intersection(expected_vars)) > 0

        # Test complex template
        package_template = comprehensive_template_package / "package.json.j2"
        variables = template_service.get_template_variables(package_template)

        # Should detect nested variable access patterns
        assert len(variables) > 0
        assert any("project_name" in var for var in variables)
