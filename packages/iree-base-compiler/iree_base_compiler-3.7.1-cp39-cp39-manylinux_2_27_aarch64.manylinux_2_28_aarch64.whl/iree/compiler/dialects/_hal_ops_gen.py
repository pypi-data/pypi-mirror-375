
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "hal"

@_ods_cext.register_operation(_Dialect)
class AllocatorAllocateOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.allocator.allocate"

  _ODS_REGIONS = (0, True)

  def __init__(self, allocator, queue_affinity, memory_types, buffer_usage, result_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(allocator)
    operands.append(queue_affinity)
    operands.append(memory_types)
    operands.append(buffer_usage)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def allocator(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_types(self):
    return self.operation.operands[2]

  @builtins.property
  def buffer_usage(self):
    return self.operation.operands[3]

  @builtins.property
  def result_size(self):
    return self.operation.operands[4]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def allocator_allocate(allocator, queue_affinity, memory_types, buffer_usage, result_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return AllocatorAllocateOp(allocator=allocator, queue_affinity=queue_affinity, memory_types=memory_types, buffer_usage=buffer_usage, result_size=result_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AllocatorImportOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.allocator.import"

  _ODS_REGIONS = (0, True)

  def __init__(self, allocator, queue_affinity, memory_types, buffer_usage, source, offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(allocator)
    operands.append(queue_affinity)
    operands.append(memory_types)
    operands.append(buffer_usage)
    operands.append(source)
    operands.append(offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def allocator(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def memory_types(self):
    return self.operation.operands[2]

  @builtins.property
  def buffer_usage(self):
    return self.operation.operands[3]

  @builtins.property
  def source(self):
    return self.operation.operands[4]

  @builtins.property
  def offset(self):
    return self.operation.operands[5]

  @builtins.property
  def length(self):
    return self.operation.operands[6]

  @builtins.property
  def did_import(self):
    return self.operation.results[0]

  @builtins.property
  def result(self):
    return self.operation.results[1]

def allocator_import(allocator, queue_affinity, memory_types, buffer_usage, source, offset, length, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AllocatorImportOp(allocator=allocator, queue_affinity=queue_affinity, memory_types=memory_types, buffer_usage=buffer_usage, source=source, offset=offset, length=length, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AllocatorResolveMemoryPropertiesOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.allocator.resolve_memory_properties"

  _ODS_REGIONS = (0, True)

  def __init__(self, lifetime, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    attributes["lifetime"] = (lifetime if (
    isinstance(lifetime, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_LifetimeAttr')) else
      _ods_ir.AttrBuilder.get('HAL_LifetimeAttr')(lifetime, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def lifetime(self):
    return self.operation.attributes["lifetime"]

  @lifetime.setter
  def lifetime(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lifetime"] = value

  @builtins.property
  def memory_types(self):
    return self.operation.results[0]

  @builtins.property
  def buffer_usage(self):
    return self.operation.results[1]

def allocator_resolve_memory_properties(lifetime, *, affinity=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AllocatorResolveMemoryPropertiesOp(lifetime=lifetime, affinity=affinity, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class AllocatorSelectOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.allocator.select"

  _ODS_REGIONS = (0, True)

  def __init__(self, devices, queue_affinities, memory_types, buffer_usage, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(devices))
    operands.extend(_get_op_results_or_values(queue_affinities))
    operands.append(memory_types)
    operands.append(buffer_usage)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def devices(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def queue_affinities(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def memory_types(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 2)
    return self.operation.operands[start]

  @builtins.property
  def buffer_usage(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 2)
    return self.operation.operands[start]

  @builtins.property
  def selected_device(self):
    return self.operation.results[0]

  @builtins.property
  def selected_queue_affinity(self):
    return self.operation.results[1]

def allocator_select(devices, queue_affinities, memory_types, buffer_usage, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return AllocatorSelectOp(devices=devices, queue_affinities=queue_affinities, memory_types=memory_types, buffer_usage=buffer_usage, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class BufferAllocationDiscardOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer.allocation.discard"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_allocation_discard(buffer, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferAllocationDiscardOp(buffer=buffer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferAllocationIsTerminalOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer.allocation.is_terminal"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_allocation_is_terminal(buffer, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferAllocationIsTerminalOp(buffer=buffer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferAllocationPreserveOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer.allocation.preserve"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

def buffer_allocation_preserve(buffer, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferAllocationPreserveOp(buffer=buffer, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferAssertOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, message, allocator, minimum_length, memory_types, buffer_usage, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(allocator)
    operands.append(minimum_length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    attributes["memory_types"] = (memory_types if (
    isinstance(memory_types, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_MemoryTypeBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_MemoryTypeBitfieldAttr')(memory_types, context=_ods_context))
    attributes["buffer_usage"] = (buffer_usage if (
    isinstance(buffer_usage, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_BufferUsageBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_BufferUsageBitfieldAttr')(buffer_usage, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def allocator(self):
    return self.operation.operands[1]

  @builtins.property
  def minimum_length(self):
    return self.operation.operands[2]

  @builtins.property
  def message(self):
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

  @builtins.property
  def memory_types(self):
    return self.operation.attributes["memory_types"]

  @memory_types.setter
  def memory_types(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_types"] = value

  @builtins.property
  def buffer_usage(self):
    return self.operation.attributes["buffer_usage"]

  @buffer_usage.setter
  def buffer_usage(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["buffer_usage"] = value

def buffer_assert(buffer, message, allocator, minimum_length, memory_types, buffer_usage, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferAssertOp(buffer=buffer, message=message, allocator=allocator, minimum_length=minimum_length, memory_types=memory_types, buffer_usage=buffer_usage, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferLengthOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer.length"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_length(buffer, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferLengthOp(buffer=buffer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_load(result, source_buffer, source_offset, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferLoadOp(result=result, source_buffer=source_buffer, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, target_buffer, target_offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(target_buffer)
    operands.append(target_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def target_buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

def buffer_store(value, target_buffer, target_offset, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferStoreOp(value=value, target_buffer=target_buffer, target_offset=target_offset, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferSubspanOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer.subspan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source_buffer, source_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[1]

  @builtins.property
  def length(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_subspan(result, source_buffer, source_offset, length, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferSubspanOp(result=result, source_buffer=source_buffer, source_offset=source_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferUsageOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_usage"

  _ODS_REGIONS = (0, True)

  def __init__(self, usage, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["usage"] = (usage if (
    isinstance(usage, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_BufferUsageBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_BufferUsageBitfieldAttr')(usage, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def usage(self):
    return self.operation.attributes["usage"]

  @usage.setter
  def usage(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["usage"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_usage(usage, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferUsageOp(usage=usage, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewAssertOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_view.assert"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, message, element_type, encoding_type, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    operands.append(element_type)
    operands.append(encoding_type)
    operands.extend(_get_op_results_or_values(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self):
    return self.operation.operands[0]

  @builtins.property
  def element_type(self):
    return self.operation.operands[1]

  @builtins.property
  def encoding_type(self):
    return self.operation.operands[2]

  @builtins.property
  def shape(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3:3 + _ods_variadic_group_length]

  @builtins.property
  def message(self):
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

def buffer_view_assert(buffer_view, message, element_type, encoding_type, shape, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferViewAssertOp(buffer_view=buffer_view, message=message, element_type=element_type, encoding_type=encoding_type, shape=shape, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferViewBufferOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_view.buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, buffer_view, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_buffer(result, buffer_view, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewBufferOp(result=result, buffer_view=buffer_view, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_view.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, source_buffer, source_offset, source_length, element_type, encoding_type, shape, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(source_length)
    operands.append(element_type)
    operands.append(encoding_type)
    operands.extend(_get_op_results_or_values(shape))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[1]

  @builtins.property
  def source_length(self):
    return self.operation.operands[2]

  @builtins.property
  def element_type(self):
    return self.operation.operands[3]

  @builtins.property
  def encoding_type(self):
    return self.operation.operands[4]

  @builtins.property
  def shape(self):
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[5:5 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_create(source_buffer, source_offset, source_length, element_type, encoding_type, shape, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewCreateOp(source_buffer=source_buffer, source_offset=source_offset, source_length=source_length, element_type=element_type, encoding_type=encoding_type, shape=shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewDimOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_view.dim"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["index"] = (index if (
    isinstance(index, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(index, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.attributes["index"]

  @index.setter
  def index(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["index"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_dim(buffer_view, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewDimOp(buffer_view=buffer_view, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewElementTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_view.element_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_element_type(buffer_view, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewElementTypeOp(buffer_view=buffer_view, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewEncodingTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_view.encoding_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_encoding_type(buffer_view, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewEncodingTypeOp(buffer_view=buffer_view, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewRankOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_view.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer_view, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer_view)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer_view(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_view_rank(buffer_view, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferViewRankOp(buffer_view=buffer_view, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferViewTraceOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.buffer_view.trace"

  _ODS_REGIONS = (0, True)

  def __init__(self, key, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def key(self):
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

def buffer_view_trace(key, operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferViewTraceOp(key=key, operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ChannelCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.channel.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, flags, id, group, rank, count, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(id)
    operands.append(group)
    operands.append(rank)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ChannelFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ChannelFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def id(self):
    return self.operation.operands[2]

  @builtins.property
  def group(self):
    return self.operation.operands[3]

  @builtins.property
  def rank(self):
    return self.operation.operands[4]

  @builtins.property
  def count(self):
    return self.operation.operands[5]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_create(device, queue_affinity, flags, id, group, rank, count, *, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelCreateOp(device=device, queue_affinity=queue_affinity, flags=flags, id=id, group=group, rank=rank, count=count, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelRankAndCountOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.channel.rank_and_count"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    return self.operation.operands[0]

  @builtins.property
  def rank(self):
    return self.operation.results[0]

  @builtins.property
  def count(self):
    return self.operation.results[1]

def channel_rank_and_count(channel, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return ChannelRankAndCountOp(channel=channel, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ChannelSplitOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.channel.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, color, key, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    operands.append(color)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ChannelFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ChannelFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    return self.operation.operands[0]

  @builtins.property
  def color(self):
    return self.operation.operands[1]

  @builtins.property
  def key(self):
    return self.operation.operands[2]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_split(channel, color, key, flags, *, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelSplitOp(channel=channel, color=color, key=key, flags=flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CommandBufferBeginDebugGroupOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.begin_debug_group"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, label, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["label"] = (label if (
    isinstance(label, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(label, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def label(self):
    return self.operation.attributes["label"]

  @label.setter
  def label(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["label"] = value

def command_buffer_begin_debug_group(command_buffer, label, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferBeginDebugGroupOp(command_buffer=command_buffer, label=label, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferCollectiveOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.collective"

  _ODS_OPERAND_SEGMENTS = [1,1,1,0,0,0,0,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, channel, op, element_count, *, param=None, send_buffer=None, send_offset=None, send_length=None, recv_buffer=None, recv_offset=None, recv_length=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(channel)
    operands.append(element_count)
    operands.append(param)
    operands.append(send_buffer)
    operands.append(send_offset)
    operands.append(send_length)
    operands.append(recv_buffer)
    operands.append(recv_offset)
    operands.append(recv_length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op"] = (op if (
    isinstance(op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CollectiveAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CollectiveAttr')(op, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def channel(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def element_count(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def param(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def send_buffer(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def send_offset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def send_length(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def recv_buffer(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def recv_offset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 8)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def recv_length(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 9)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def op(self):
    return self.operation.attributes["op"]

  @op.setter
  def op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op"] = value

def command_buffer_collective(command_buffer, channel, op, element_count, *, param=None, send_buffer=None, send_offset=None, send_length=None, recv_buffer=None, recv_offset=None, recv_length=None, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferCollectiveOp(command_buffer=command_buffer, channel=channel, op=op, element_count=element_count, param=param, send_buffer=send_buffer, send_offset=send_offset, send_length=send_length, recv_buffer=recv_buffer, recv_offset=recv_offset, recv_length=recv_length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferCopyBufferOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.copy_buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CopyFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CopyFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_buffer(self):
    return self.operation.operands[3]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[4]

  @builtins.property
  def length(self):
    return self.operation.operands[5]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_copy_buffer(command_buffer, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferCopyBufferOp(command_buffer=command_buffer, source_buffer=source_buffer, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, modes, command_categories, queue_affinity, *, binding_capacity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    if binding_capacity is not None: operands.append(binding_capacity)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["modes"] = (modes if (
    isinstance(modes, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CommandBufferModeBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CommandBufferModeBitfieldAttr')(modes, context=_ods_context))
    attributes["command_categories"] = (command_categories if (
    isinstance(command_categories, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CommandCategoryBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CommandCategoryBitfieldAttr')(command_categories, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def binding_capacity(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def modes(self):
    return self.operation.attributes["modes"]

  @modes.setter
  def modes(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modes"] = value

  @builtins.property
  def command_categories(self):
    return self.operation.attributes["command_categories"]

  @command_categories.setter
  def command_categories(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["command_categories"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def command_buffer_create(device, modes, command_categories, queue_affinity, *, binding_capacity=None, loc=None, ip=None) -> _ods_ir.Value:
  return CommandBufferCreateOp(device=device, modes=modes, command_categories=command_categories, queue_affinity=queue_affinity, binding_capacity=binding_capacity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CommandBufferDeviceOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.device"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def device(self):
    return self.operation.results[0]

def command_buffer_device(command_buffer, *, loc=None, ip=None) -> _ods_ir.Value:
  return CommandBufferDeviceOp(command_buffer=command_buffer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CommandBufferDispatchIndirectOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.dispatch.indirect"

  _ODS_OPERAND_SEGMENTS = [1,1,1,1,1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, executable, entry_point, workgroups_buffer, workgroups_offset, constants, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(executable)
    operands.append(entry_point)
    operands.append(workgroups_buffer)
    operands.append(workgroups_offset)
    operands.append(_get_op_results_or_values(constants))
    operands.append(_get_op_results_or_values(binding_buffers))
    operands.append(_get_op_results_or_values(binding_offsets))
    operands.append(_get_op_results_or_values(binding_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_DispatchFlagsAttr')) else
      _ods_ir.AttrBuilder.get('HAL_DispatchFlagsAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def executable(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def entry_point(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def workgroups_buffer(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def workgroups_offset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def constants(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def binding_buffers(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def binding_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range

  @builtins.property
  def binding_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 8)
    return operand_range

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_dispatch_indirect(command_buffer, executable, entry_point, workgroups_buffer, workgroups_offset, constants, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferDispatchIndirectOp(command_buffer=command_buffer, executable=executable, entry_point=entry_point, workgroups_buffer=workgroups_buffer, workgroups_offset=workgroups_offset, constants=constants, binding_buffers=binding_buffers, binding_offsets=binding_offsets, binding_lengths=binding_lengths, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferDispatchOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.dispatch"

  _ODS_OPERAND_SEGMENTS = [1,1,1,1,1,1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, executable, entry_point, workgroup_x, workgroup_y, workgroup_z, constants, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(executable)
    operands.append(entry_point)
    operands.append(workgroup_x)
    operands.append(workgroup_y)
    operands.append(workgroup_z)
    operands.append(_get_op_results_or_values(constants))
    operands.append(_get_op_results_or_values(binding_buffers))
    operands.append(_get_op_results_or_values(binding_offsets))
    operands.append(_get_op_results_or_values(binding_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_DispatchFlagsAttr')) else
      _ods_ir.AttrBuilder.get('HAL_DispatchFlagsAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def executable(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def entry_point(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def workgroup_x(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def workgroup_y(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def workgroup_z(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0]

  @builtins.property
  def constants(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def binding_buffers(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range

  @builtins.property
  def binding_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 8)
    return operand_range

  @builtins.property
  def binding_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 9)
    return operand_range

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_dispatch(command_buffer, executable, entry_point, workgroup_x, workgroup_y, workgroup_z, constants, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferDispatchOp(command_buffer=command_buffer, executable=executable, entry_point=entry_point, workgroup_x=workgroup_x, workgroup_y=workgroup_y, workgroup_z=workgroup_z, constants=constants, binding_buffers=binding_buffers, binding_offsets=binding_offsets, binding_lengths=binding_lengths, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferEndDebugGroupOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.end_debug_group"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[0]

def command_buffer_end_debug_group(command_buffer, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferEndDebugGroupOp(command_buffer=command_buffer, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferExecutionBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.execution_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, source_stage_mask, target_stage_mask, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_stage_mask"] = (source_stage_mask if (
    isinstance(source_stage_mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecutionStageBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecutionStageBitfieldAttr')(source_stage_mask, context=_ods_context))
    attributes["target_stage_mask"] = (target_stage_mask if (
    isinstance(target_stage_mask, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecutionStageBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecutionStageBitfieldAttr')(target_stage_mask, context=_ods_context))
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecutionBarrierFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecutionBarrierFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def source_stage_mask(self):
    return self.operation.attributes["source_stage_mask"]

  @source_stage_mask.setter
  def source_stage_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_stage_mask"] = value

  @builtins.property
  def target_stage_mask(self):
    return self.operation.attributes["target_stage_mask"]

  @target_stage_mask.setter
  def target_stage_mask(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_stage_mask"] = value

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_execution_barrier(command_buffer, source_stage_mask, target_stage_mask, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferExecutionBarrierOp(command_buffer=command_buffer, source_stage_mask=source_stage_mask, target_stage_mask=target_stage_mask, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferFillBufferOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.fill_buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, target_buffer, target_offset, length, pattern, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(pattern)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_FillFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_FillFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def target_buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def length(self):
    return self.operation.operands[3]

  @builtins.property
  def pattern(self):
    return self.operation.operands[4]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_fill_buffer(command_buffer, target_buffer, target_offset, length, pattern, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferFillBufferOp(command_buffer=command_buffer, target_buffer=target_buffer, target_offset=target_offset, length=length, pattern=pattern, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferFinalizeOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.finalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[0]

def command_buffer_finalize(command_buffer, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferFinalizeOp(command_buffer=command_buffer, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CommandBufferUpdateBufferOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.command_buffer.update_buffer"

  _ODS_REGIONS = (0, True)

  def __init__(self, command_buffer, source_buffer, source_size, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(command_buffer)
    operands.append(source_buffer)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_UpdateFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_UpdateFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[1]

  @builtins.property
  def source_size(self):
    return self.operation.operands[2]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[3]

  @builtins.property
  def target_buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def length(self):
    return self.operation.operands[6]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def command_buffer_update_buffer(command_buffer, source_buffer, source_size, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CommandBufferUpdateBufferOp(command_buffer=command_buffer, source_buffer=source_buffer, source_size=source_size, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceAllocatorOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.allocator"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def device_allocator(device, *, loc=None, ip=None) -> _ods_ir.Value:
  return DeviceAllocatorOp(device=device, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeviceMemoizeOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.memoize"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, device, queue_affinity, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

def device_memoize(results_, device, queue_affinity, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DeviceMemoizeOp(results_=results_, device=device, queue_affinity=queue_affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DeviceQueryOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.query"

  _ODS_REGIONS = (0, True)

  def __init__(self, ok, value, device, category, key, *, default_value=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["category"] = (category if (
    isinstance(category, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(category, context=_ods_context))
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    if default_value is not None: attributes["default_value"] = (default_value if (
        isinstance(default_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
          _ods_ir.AttrBuilder.get('TypedAttrInterface')(default_value, context=_ods_context))
    results.append(ok)
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def category(self):
    return self.operation.attributes["category"]

  @category.setter
  def category(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["category"] = value

  @builtins.property
  def key(self):
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

  @builtins.property
  def default_value(self):
    if "default_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["default_value"]

  @default_value.setter
  def default_value(self, value):
    if value is not None:
      self.operation.attributes["default_value"] = value
    elif "default_value" in self.operation.attributes:
      del self.operation.attributes["default_value"]

  @default_value.deleter
  def default_value(self):
    del self.operation.attributes["default_value"]

  @builtins.property
  def ok(self):
    return self.operation.results[0]

  @builtins.property
  def value(self):
    return self.operation.results[1]

def device_query(ok, value, device, category, key, *, default_value=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return DeviceQueryOp(ok=ok, value=value, device=device, category=category, key=key, default_value=default_value, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class DeviceQueueAllocaOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, pool, memory_types, buffer_usage, result_size, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(pool)
    operands.append(memory_types)
    operands.append(buffer_usage)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_AllocaFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_AllocaFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def pool(self):
    return self.operation.operands[4]

  @builtins.property
  def memory_types(self):
    return self.operation.operands[5]

  @builtins.property
  def buffer_usage(self):
    return self.operation.operands[6]

  @builtins.property
  def result_size(self):
    return self.operation.operands[7]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def device_queue_alloca(device, queue_affinity, wait_fence, signal_fence, pool, memory_types, buffer_usage, result_size, flags, *, loc=None, ip=None) -> _ods_ir.Value:
  return DeviceQueueAllocaOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, pool=pool, memory_types=memory_types, buffer_usage=buffer_usage, result_size=result_size, flags=flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeviceQueueBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecuteFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecuteFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_barrier(device, queue_affinity, wait_fence, signal_fence, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueBarrierOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_CopyFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_CopyFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def target_buffer(self):
    return self.operation.operands[6]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[7]

  @builtins.property
  def length(self):
    return self.operation.operands[8]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_copy(device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueCopyOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, source_buffer=source_buffer, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueDeallocaOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.dealloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, buffer, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_DeallocaFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_DeallocaFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_dealloca(device, queue_affinity, wait_fence, signal_fence, buffer, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueDeallocaOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, buffer=buffer, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueExecuteIndirectOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.execute.indirect"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, command_buffer, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(command_buffer)
    operands.extend(_get_op_results_or_values(binding_buffers))
    operands.extend(_get_op_results_or_values(binding_offsets))
    operands.extend(_get_op_results_or_values(binding_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecuteFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecuteFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def queue_affinity(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 1, 0)
    return self.operation.operands[start]

  @builtins.property
  def wait_fence(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 2, 0)
    return self.operation.operands[start]

  @builtins.property
  def signal_fence(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 3, 0)
    return self.operation.operands[start]

  @builtins.property
  def command_buffer(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 4, 0)
    return self.operation.operands[start]

  @builtins.property
  def binding_buffers(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 5, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def binding_offsets(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 5, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def binding_lengths(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 5, 3, 5, 2)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_execute_indirect(device, queue_affinity, wait_fence, signal_fence, command_buffer, binding_buffers, binding_offsets, binding_lengths, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueExecuteIndirectOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, command_buffer=command_buffer, binding_buffers=binding_buffers, binding_offsets=binding_offsets, binding_lengths=binding_lengths, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueExecuteOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.execute"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, command_buffer, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(command_buffer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecuteFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecuteFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def command_buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_execute(device, queue_affinity, wait_fence, signal_fence, command_buffer, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueExecuteOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, command_buffer=command_buffer, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueFillOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.fill"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, target_buffer, target_offset, length, pattern, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    operands.append(pattern)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_FillFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_FillFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def target_buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def length(self):
    return self.operation.operands[6]

  @builtins.property
  def pattern(self):
    return self.operation.operands[7]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_fill(device, queue_affinity, wait_fence, signal_fence, target_buffer, target_offset, length, pattern, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueFillOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, target_buffer=target_buffer, target_offset=target_offset, length=length, pattern=pattern, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueFlushOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.flush"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

def device_queue_flush(device, queue_affinity, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueFlushOp(device=device, queue_affinity=queue_affinity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueReadOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, source_file, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(source_file)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ReadFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ReadFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def source_file(self):
    return self.operation.operands[4]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def target_buffer(self):
    return self.operation.operands[6]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[7]

  @builtins.property
  def length(self):
    return self.operation.operands[8]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_read(device, queue_affinity, wait_fence, signal_fence, source_file, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueReadOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, source_file=source_file, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueUpdateOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.update"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_buffer)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_UpdateFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_UpdateFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def target_buffer(self):
    return self.operation.operands[6]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[7]

  @builtins.property
  def length(self):
    return self.operation.operands[8]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_update(device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_buffer, target_offset, length, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueUpdateOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, source_buffer=source_buffer, source_offset=source_offset, target_buffer=target_buffer, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceQueueWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.queue.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_file, target_offset, length, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(wait_fence)
    operands.append(signal_fence)
    operands.append(source_buffer)
    operands.append(source_offset)
    operands.append(target_file)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_WriteFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_WriteFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def wait_fence(self):
    return self.operation.operands[2]

  @builtins.property
  def signal_fence(self):
    return self.operation.operands[3]

  @builtins.property
  def source_buffer(self):
    return self.operation.operands[4]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def target_file(self):
    return self.operation.operands[6]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[7]

  @builtins.property
  def length(self):
    return self.operation.operands[8]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

def device_queue_write(device, queue_affinity, wait_fence, signal_fence, source_buffer, source_offset, target_file, target_offset, length, flags, *, loc=None, ip=None) -> _ods_ir.Operation:
  return DeviceQueueWriteOp(device=device, queue_affinity=queue_affinity, wait_fence=wait_fence, signal_fence=signal_fence, source_buffer=source_buffer, source_offset=source_offset, target_file=target_file, target_offset=target_offset, length=length, flags=flags, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeviceResolveOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.device.resolve"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_DeviceAffinityAttr')) else
          _ods_ir.AttrBuilder.get('HAL_DeviceAffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def device_resolve(results_, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DeviceResolveOp(results_=results_, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DevicesCountOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.devices.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

def devices_count(*, loc=None, ip=None) -> _ods_ir.Value:
  return DevicesCountOp(loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DevicesGetOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.devices.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def devices_get(index, *, loc=None, ip=None) -> _ods_ir.Value:
  return DevicesGetOp(index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchExternOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.dispatch.extern"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (1, False)

  def __init__(self, results_, export_name, workload, arguments, argument_dims, result_dims, layout, targets, target_ordinals, target_objects, num_target_regions, *, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["export_name"] = (export_name if (
    isinstance(export_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(export_name, context=_ods_context))
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('HAL_PipelineLayoutAttr')(layout, context=_ods_context))
    attributes["targets"] = (targets if (
    isinstance(targets, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(targets, context=_ods_context))
    attributes["target_ordinals"] = (target_ordinals if (
    isinstance(target_ordinals, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_OrdinalArrayAttr')) else
      _ods_ir.AttrBuilder.get('HAL_OrdinalArrayAttr')(target_ordinals, context=_ods_context))
    attributes["target_objects"] = (target_objects if (
    isinstance(target_objects, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(target_objects, context=_ods_context))
    if workgroup_size is not None: attributes["workgroup_size"] = (workgroup_size if (
        isinstance(workgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_WorkgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('HAL_WorkgroupSizeAttr')(workgroup_size, context=_ods_context))
    if subgroup_size is not None: attributes["subgroup_size"] = (subgroup_size if (
        isinstance(subgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_SubgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('HAL_SubgroupSizeAttr')(subgroup_size, context=_ods_context))
    if workgroup_local_memory is not None: attributes["workgroup_local_memory"] = (workgroup_local_memory if (
        isinstance(workgroup_local_memory, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(workgroup_local_memory, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    regions = 1 + num_target_regions
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def arguments(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def argument_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def export_name(self):
    return self.operation.attributes["export_name"]

  @export_name.setter
  def export_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["export_name"] = value

  @builtins.property
  def layout(self):
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def targets(self):
    return self.operation.attributes["targets"]

  @targets.setter
  def targets(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["targets"] = value

  @builtins.property
  def target_ordinals(self):
    return self.operation.attributes["target_ordinals"]

  @target_ordinals.setter
  def target_ordinals(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_ordinals"] = value

  @builtins.property
  def target_objects(self):
    return self.operation.attributes["target_objects"]

  @target_objects.setter
  def target_objects(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_objects"] = value

  @builtins.property
  def workgroup_size(self):
    if "workgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_size"]

  @workgroup_size.setter
  def workgroup_size(self, value):
    if value is not None:
      self.operation.attributes["workgroup_size"] = value
    elif "workgroup_size" in self.operation.attributes:
      del self.operation.attributes["workgroup_size"]

  @workgroup_size.deleter
  def workgroup_size(self):
    del self.operation.attributes["workgroup_size"]

  @builtins.property
  def subgroup_size(self):
    if "subgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["subgroup_size"]

  @subgroup_size.setter
  def subgroup_size(self, value):
    if value is not None:
      self.operation.attributes["subgroup_size"] = value
    elif "subgroup_size" in self.operation.attributes:
      del self.operation.attributes["subgroup_size"]

  @subgroup_size.deleter
  def subgroup_size(self):
    del self.operation.attributes["subgroup_size"]

  @builtins.property
  def workgroup_local_memory(self):
    if "workgroup_local_memory" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.setter
  def workgroup_local_memory(self, value):
    if value is not None:
      self.operation.attributes["workgroup_local_memory"] = value
    elif "workgroup_local_memory" in self.operation.attributes:
      del self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.deleter
  def workgroup_local_memory(self):
    del self.operation.attributes["workgroup_local_memory"]

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def workgroup_count(self):
    return self.regions[0]

  @builtins.property
  def target_regions(self):
    return self.regions[1:]

def dispatch_extern(results_, export_name, workload, arguments, argument_dims, result_dims, layout, targets, target_ordinals, target_objects, num_target_regions, *, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DispatchExternOp(results_=results_, export_name=export_name, workload=workload, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, layout=layout, targets=targets, target_ordinals=target_ordinals, target_objects=target_objects, num_target_regions=num_target_regions, workgroup_size=workgroup_size, subgroup_size=subgroup_size, workgroup_local_memory=workgroup_local_memory, tied_operands=tied_operands, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ElementTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.element_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def element_type(type_, *, loc=None, ip=None) -> _ods_ir.Value:
  return ElementTypeOp(type_=type_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EncodingTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.encoding_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, encoding=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if encoding is not None: attributes["encoding"] = (encoding if (
        isinstance(encoding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(encoding, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def encoding(self):
    if "encoding" not in self.operation.attributes:
      return None
    return self.operation.attributes["encoding"]

  @encoding.setter
  def encoding(self, value):
    if value is not None:
      self.operation.attributes["encoding"] = value
    elif "encoding" in self.operation.attributes:
      del self.operation.attributes["encoding"]

  @encoding.deleter
  def encoding(self):
    del self.operation.attributes["encoding"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def encoding_type(*, encoding=None, loc=None, ip=None) -> _ods_ir.Value:
  return EncodingTypeOp(encoding=encoding, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExFileFromMemoryOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.ex.file.from_memory"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, access, buffer, offset, length, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.append(buffer)
    operands.append(offset)
    operands.append(length)
    operands.append(flags)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["access"] = (access if (
    isinstance(access, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_MemoryAccessBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_MemoryAccessBitfieldAttr')(access, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def buffer(self):
    return self.operation.operands[2]

  @builtins.property
  def offset(self):
    return self.operation.operands[3]

  @builtins.property
  def length(self):
    return self.operation.operands[4]

  @builtins.property
  def flags(self):
    return self.operation.operands[5]

  @builtins.property
  def access(self):
    return self.operation.attributes["access"]

  @access.setter
  def access(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["access"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def ex_file_from_memory(device, queue_affinity, access, buffer, offset, length, flags, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExFileFromMemoryOp(device=device, queue_affinity=queue_affinity, access=access, buffer=buffer, offset=offset, length=length, flags=flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableBinaryOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.binary"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, format, data, *, sym_visibility=None, mime_type=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["format"] = (format if (
    isinstance(format, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format, context=_ods_context))
    attributes["data"] = (data if (
    isinstance(data, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_AnySerializableAttr')) else
      _ods_ir.AttrBuilder.get('Util_AnySerializableAttr')(data, context=_ods_context))
    if mime_type is not None: attributes["mime_type"] = (mime_type if (
        isinstance(mime_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(mime_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def format(self):
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format"] = value

  @builtins.property
  def data(self):
    return self.operation.attributes["data"]

  @data.setter
  def data(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["data"] = value

  @builtins.property
  def mime_type(self):
    if "mime_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["mime_type"]

  @mime_type.setter
  def mime_type(self, value):
    if value is not None:
      self.operation.attributes["mime_type"] = value
    elif "mime_type" in self.operation.attributes:
      del self.operation.attributes["mime_type"]

  @mime_type.deleter
  def mime_type(self):
    del self.operation.attributes["mime_type"]

def executable_binary(sym_name, format, data, *, sym_visibility=None, mime_type=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableBinaryOp(sym_name=sym_name, format=format, data=data, sym_visibility=sym_visibility, mime_type=mime_type, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableCalculateWorkgroupsOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.calculate_workgroups"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, entry_point, workload, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.extend(_get_op_results_or_values(workload))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_point"] = (entry_point if (
    isinstance(entry_point, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(entry_point, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def workload(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def entry_point(self):
    return self.operation.attributes["entry_point"]

  @entry_point.setter
  def entry_point(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_point"] = value

  @builtins.property
  def workgroup_x(self):
    return self.operation.results[0]

  @builtins.property
  def workgroup_y(self):
    return self.operation.results[1]

  @builtins.property
  def workgroup_z(self):
    return self.operation.results[2]

def executable_calculate_workgroups(device, entry_point, workload, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return ExecutableCalculateWorkgroupsOp(device=device, entry_point=entry_point, workload=workload, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ExecutableConditionOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.condition"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_930')) else
      _ods_ir.AttrBuilder.get('anonymous_930')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self):
    return self.regions[0]

def executable_condition(function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableConditionOp(function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableConstantBlockOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.constant.block"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, keys, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_930')) else
      _ods_ir.AttrBuilder.get('anonymous_930')(function_type, context=_ods_context))
    attributes["keys"] = (keys if (
    isinstance(keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(keys, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def keys(self):
    return self.operation.attributes["keys"]

  @keys.setter
  def keys(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["keys"] = value

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self):
    return self.regions[0]

def executable_constant_block(function_type, keys, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableConstantBlockOp(function_type=function_type, keys=keys, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableConstantLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.constant.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, key, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def key(self):
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def executable_constant_load(result, key, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExecutableConstantLoadOp(result=result, key=key, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, queue_affinity, executable_target, constants, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    operands.append(queue_affinity)
    operands.extend(_get_op_results_or_values(constants))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["executable_target"] = (executable_target if (
    isinstance(executable_target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(executable_target, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def queue_affinity(self):
    return self.operation.operands[1]

  @builtins.property
  def constants(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def executable_target(self):
    return self.operation.attributes["executable_target"]

  @executable_target.setter
  def executable_target(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["executable_target"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def executable_create(device, queue_affinity, executable_target, constants, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExecutableCreateOp(device=device, queue_affinity=queue_affinity, executable_target=executable_target, constants=constants, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableEndOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_end(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.export"

  _ODS_REGIONS = (2, True)

  def __init__(self, sym_name, layout, *, sym_visibility=None, ordinal=None, condition_fallback=None, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, source_locs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if ordinal is not None: attributes["ordinal"] = (ordinal if (
        isinstance(ordinal, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_OrdinalAttr')) else
          _ods_ir.AttrBuilder.get('HAL_OrdinalAttr')(ordinal, context=_ods_context))
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('HAL_PipelineLayoutAttr')(layout, context=_ods_context))
    if condition_fallback is not None: attributes["condition_fallback"] = (condition_fallback if (
        isinstance(condition_fallback, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(condition_fallback, context=_ods_context))
    if workgroup_size is not None: attributes["workgroup_size"] = (workgroup_size if (
        isinstance(workgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_WorkgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('HAL_WorkgroupSizeAttr')(workgroup_size, context=_ods_context))
    if subgroup_size is not None: attributes["subgroup_size"] = (subgroup_size if (
        isinstance(subgroup_size, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_SubgroupSizeAttr')) else
          _ods_ir.AttrBuilder.get('HAL_SubgroupSizeAttr')(subgroup_size, context=_ods_context))
    if workgroup_local_memory is not None: attributes["workgroup_local_memory"] = (workgroup_local_memory if (
        isinstance(workgroup_local_memory, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(workgroup_local_memory, context=_ods_context))
    if source_locs is not None: attributes["source_locs"] = (source_locs if (
        isinstance(source_locs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(source_locs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def ordinal(self):
    if "ordinal" not in self.operation.attributes:
      return None
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value):
    if value is not None:
      self.operation.attributes["ordinal"] = value
    elif "ordinal" in self.operation.attributes:
      del self.operation.attributes["ordinal"]

  @ordinal.deleter
  def ordinal(self):
    del self.operation.attributes["ordinal"]

  @builtins.property
  def layout(self):
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def condition_fallback(self):
    if "condition_fallback" not in self.operation.attributes:
      return None
    return self.operation.attributes["condition_fallback"]

  @condition_fallback.setter
  def condition_fallback(self, value):
    if value is not None:
      self.operation.attributes["condition_fallback"] = value
    elif "condition_fallback" in self.operation.attributes:
      del self.operation.attributes["condition_fallback"]

  @condition_fallback.deleter
  def condition_fallback(self):
    del self.operation.attributes["condition_fallback"]

  @builtins.property
  def workgroup_size(self):
    if "workgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_size"]

  @workgroup_size.setter
  def workgroup_size(self, value):
    if value is not None:
      self.operation.attributes["workgroup_size"] = value
    elif "workgroup_size" in self.operation.attributes:
      del self.operation.attributes["workgroup_size"]

  @workgroup_size.deleter
  def workgroup_size(self):
    del self.operation.attributes["workgroup_size"]

  @builtins.property
  def subgroup_size(self):
    if "subgroup_size" not in self.operation.attributes:
      return None
    return self.operation.attributes["subgroup_size"]

  @subgroup_size.setter
  def subgroup_size(self, value):
    if value is not None:
      self.operation.attributes["subgroup_size"] = value
    elif "subgroup_size" in self.operation.attributes:
      del self.operation.attributes["subgroup_size"]

  @subgroup_size.deleter
  def subgroup_size(self):
    del self.operation.attributes["subgroup_size"]

  @builtins.property
  def workgroup_local_memory(self):
    if "workgroup_local_memory" not in self.operation.attributes:
      return None
    return self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.setter
  def workgroup_local_memory(self, value):
    if value is not None:
      self.operation.attributes["workgroup_local_memory"] = value
    elif "workgroup_local_memory" in self.operation.attributes:
      del self.operation.attributes["workgroup_local_memory"]

  @workgroup_local_memory.deleter
  def workgroup_local_memory(self):
    del self.operation.attributes["workgroup_local_memory"]

  @builtins.property
  def source_locs(self):
    if "source_locs" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_locs"]

  @source_locs.setter
  def source_locs(self, value):
    if value is not None:
      self.operation.attributes["source_locs"] = value
    elif "source_locs" in self.operation.attributes:
      del self.operation.attributes["source_locs"]

  @source_locs.deleter
  def source_locs(self):
    del self.operation.attributes["source_locs"]

  @builtins.property
  def workgroup_count(self):
    return self.regions[0]

  @builtins.property
  def condition(self):
    return self.regions[1]

def executable_export(sym_name, layout, *, sym_visibility=None, ordinal=None, condition_fallback=None, workgroup_size=None, subgroup_size=None, workgroup_local_memory=None, source_locs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableExportOp(sym_name=sym_name, layout=layout, sym_visibility=sym_visibility, ordinal=ordinal, condition_fallback=condition_fallback, workgroup_size=workgroup_size, subgroup_size=subgroup_size, workgroup_local_memory=workgroup_local_memory, source_locs=source_locs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOrdinalOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.export.ordinal"

  _ODS_REGIONS = (0, True)

  def __init__(self, entry_point, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_point"] = (entry_point if (
    isinstance(entry_point, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(entry_point, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def entry_point(self):
    return self.operation.attributes["entry_point"]

  @entry_point.setter
  def entry_point(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_point"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def executable_export_ordinal(entry_point, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExecutableExportOrdinalOp(entry_point=entry_point, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableLookupOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.lookup"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, executable, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["executable"] = (executable if (
    isinstance(executable, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(executable, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def executable(self):
    return self.operation.attributes["executable"]

  @executable.setter
  def executable(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["executable"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def executable_lookup(device, executable, *, loc=None, ip=None) -> _ods_ir.Value:
  return ExecutableLookupOp(device=device, executable=executable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self):
    return self.regions[0]

def executable(sym_name, *, sym_visibility=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableOp(sym_name=sym_name, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableSourceEndOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.source_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_source_end(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableSourceEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableSourceOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.source"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, objects=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    if objects is not None: attributes["objects"] = (objects if (
        isinstance(objects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_ExecutableObjectsAttr')) else
          _ods_ir.AttrBuilder.get('HAL_ExecutableObjectsAttr')(objects, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def objects(self):
    if "objects" not in self.operation.attributes:
      return None
    return self.operation.attributes["objects"]

  @objects.setter
  def objects(self, value):
    if value is not None:
      self.operation.attributes["objects"] = value
    elif "objects" in self.operation.attributes:
      del self.operation.attributes["objects"]

  @objects.deleter
  def objects(self):
    del self.operation.attributes["objects"]

  @builtins.property
  def body(self):
    return self.regions[0]

def executable_source(sym_name, *, sym_visibility=None, objects=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableSourceOp(sym_name=sym_name, sym_visibility=sym_visibility, objects=objects, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableVariantEndOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.variant_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_variant_end(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableVariantEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableVariantOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.executable.variant"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, target, *, sym_visibility=None, objects=None, sources=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_ExecutableTargetAttr')) else
      _ods_ir.AttrBuilder.get('HAL_ExecutableTargetAttr')(target, context=_ods_context))
    if objects is not None: attributes["objects"] = (objects if (
        isinstance(objects, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_ExecutableObjectArrayAttr')) else
          _ods_ir.AttrBuilder.get('HAL_ExecutableObjectArrayAttr')(objects, context=_ods_context))
    if sources is not None: attributes["sources"] = (sources if (
        isinstance(sources, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictionaryAttr')) else
          _ods_ir.AttrBuilder.get('DictionaryAttr')(sources, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def target(self):
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def objects(self):
    if "objects" not in self.operation.attributes:
      return None
    return self.operation.attributes["objects"]

  @objects.setter
  def objects(self, value):
    if value is not None:
      self.operation.attributes["objects"] = value
    elif "objects" in self.operation.attributes:
      del self.operation.attributes["objects"]

  @objects.deleter
  def objects(self):
    del self.operation.attributes["objects"]

  @builtins.property
  def sources(self):
    if "sources" not in self.operation.attributes:
      return None
    return self.operation.attributes["sources"]

  @sources.setter
  def sources(self, value):
    if value is not None:
      self.operation.attributes["sources"] = value
    elif "sources" in self.operation.attributes:
      del self.operation.attributes["sources"]

  @sources.deleter
  def sources(self):
    del self.operation.attributes["sources"]

  @builtins.property
  def body(self):
    return self.regions[0]

def executable_variant(sym_name, target, *, sym_visibility=None, objects=None, sources=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableVariantOp(sym_name=sym_name, target=target, sym_visibility=sym_visibility, objects=objects, sources=sources, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FenceAwaitOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.fence.await"

  _ODS_REGIONS = (0, True)

  def __init__(self, timeout_millis, flags, fences, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(timeout_millis)
    operands.extend(_get_op_results_or_values(fences))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_WaitFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_WaitFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def timeout_millis(self):
    return self.operation.operands[0]

  @builtins.property
  def fences(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def status(self):
    return self.operation.results[0]

def fence_await(timeout_millis, flags, fences, *, loc=None, ip=None) -> _ods_ir.Value:
  return FenceAwaitOp(timeout_millis=timeout_millis, flags=flags, fences=fences, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.fence.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, device, flags, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(device)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_FenceFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_FenceFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def device(self):
    return self.operation.operands[0]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def fence_create(device, flags, *, loc=None, ip=None) -> _ods_ir.Value:
  return FenceCreateOp(device=device, flags=flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceFailOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.fence.fail"

  _ODS_REGIONS = (0, True)

  def __init__(self, fence, status, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(fence)
    operands.append(status)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fence(self):
    return self.operation.operands[0]

  @builtins.property
  def status(self):
    return self.operation.operands[1]

def fence_fail(fence, status, *, loc=None, ip=None) -> _ods_ir.Operation:
  return FenceFailOp(fence=fence, status=status, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FenceJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.fence.join"

  _ODS_REGIONS = (0, True)

  def __init__(self, flags, fences, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(fences))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["flags"] = (flags if (
    isinstance(flags, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_FenceFlagBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_FenceFlagBitfieldAttr')(flags, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fences(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def flags(self):
    return self.operation.attributes["flags"]

  @flags.setter
  def flags(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["flags"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def fence_join(flags, fences, *, loc=None, ip=None) -> _ods_ir.Value:
  return FenceJoinOp(flags=flags, fences=fences, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceQueryOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.fence.query"

  _ODS_REGIONS = (0, True)

  def __init__(self, fence, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(fence)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fence(self):
    return self.operation.operands[0]

  @builtins.property
  def status(self):
    return self.operation.results[0]

def fence_query(fence, *, loc=None, ip=None) -> _ods_ir.Value:
  return FenceQueryOp(fence=fence, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FenceSignalOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.fence.signal"

  _ODS_REGIONS = (0, True)

  def __init__(self, fence, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(fence)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fence(self):
    return self.operation.operands[0]

def fence_signal(fence, *, loc=None, ip=None) -> _ods_ir.Operation:
  return FenceSignalOp(fence=fence, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InstrumentMemoryLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.instrument.memory.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, workgroupKey, loadValue, base, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(workgroupKey)
    operands.append(loadValue)
    operands.append(base)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def workgroupKey(self):
    return self.operation.operands[1]

  @builtins.property
  def loadValue(self):
    return self.operation.operands[2]

  @builtins.property
  def base(self):
    return self.operation.operands[3]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 5 + 1
    return self.operation.operands[4:4 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def instrument_memory_load(buffer, workgroup_key, load_value, base, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return InstrumentMemoryLoadOp(buffer=buffer, workgroupKey=workgroup_key, loadValue=load_value, base=base, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InstrumentMemoryStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.instrument.memory.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, workgroupKey, storeValue, base, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(workgroupKey)
    operands.append(storeValue)
    operands.append(base)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def workgroupKey(self):
    return self.operation.operands[1]

  @builtins.property
  def storeValue(self):
    return self.operation.operands[2]

  @builtins.property
  def base(self):
    return self.operation.operands[3]

  @builtins.property
  def indices(self):
    _ods_variadic_group_length = len(self.operation.operands) - 5 + 1
    return self.operation.operands[4:4 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def instrument_memory_store(buffer, workgroup_key, store_value, base, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return InstrumentMemoryStoreOp(buffer=buffer, workgroupKey=workgroup_key, storeValue=store_value, base=base, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InstrumentPrintOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.instrument.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, workgroupKey, format, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(workgroupKey)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["format"] = (format if (
    isinstance(format, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def workgroupKey(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def format(self):
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["format"] = value

def instrument_print(buffer, workgroup_key, format, values, *, loc=None, ip=None) -> _ods_ir.Operation:
  return InstrumentPrintOp(buffer=buffer, workgroupKey=workgroup_key, format=format, values=values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InstrumentValueOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.instrument.value"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, workgroupKey, ordinal, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(workgroupKey)
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["ordinal"] = (ordinal if (
    isinstance(ordinal, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyI8Attr')) else
      _ods_ir.AttrBuilder.get('AnyI8Attr')(ordinal, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def workgroupKey(self):
    return self.operation.operands[1]

  @builtins.property
  def operand(self):
    return self.operation.operands[2]

  @builtins.property
  def ordinal(self):
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ordinal"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def instrument_value(buffer, workgroup_key, ordinal, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return InstrumentValueOp(buffer=buffer, workgroupKey=workgroup_key, ordinal=ordinal, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InstrumentWorkgroupOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.instrument.workgroup"

  _ODS_REGIONS = (0, True)

  def __init__(self, buffer, dispatchId, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(buffer)
    operands.append(dispatchId)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def buffer(self):
    return self.operation.operands[0]

  @builtins.property
  def dispatchId(self):
    return self.operation.operands[1]

  @builtins.property
  def workgroupKey(self):
    return self.operation.results[0]

def instrument_workgroup(buffer, dispatch_id, *, loc=None, ip=None) -> _ods_ir.Value:
  return InstrumentWorkgroupOp(buffer=buffer, dispatchId=dispatch_id, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceBindingSubspanOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.interface.binding.subspan"

  _ODS_OPERAND_SEGMENTS = [0,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, layout, binding, dynamic_dims, *, byte_offset=None, alignment=None, descriptor_flags=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(byte_offset)
    operands.append(_get_op_results_or_values(dynamic_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('HAL_PipelineLayoutAttr')(layout, context=_ods_context))
    attributes["binding"] = (binding if (
    isinstance(binding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(binding, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    if descriptor_flags is not None: attributes["descriptor_flags"] = (descriptor_flags if (
        isinstance(descriptor_flags, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('HAL_DescriptorFlagsAttr')) else
          _ods_ir.AttrBuilder.get('HAL_DescriptorFlagsAttr')(descriptor_flags, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def byte_offset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def dynamic_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def layout(self):
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def binding(self):
    return self.operation.attributes["binding"]

  @binding.setter
  def binding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["binding"] = value

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def descriptor_flags(self):
    if "descriptor_flags" not in self.operation.attributes:
      return None
    return self.operation.attributes["descriptor_flags"]

  @descriptor_flags.setter
  def descriptor_flags(self, value):
    if value is not None:
      self.operation.attributes["descriptor_flags"] = value
    elif "descriptor_flags" in self.operation.attributes:
      del self.operation.attributes["descriptor_flags"]

  @descriptor_flags.deleter
  def descriptor_flags(self):
    del self.operation.attributes["descriptor_flags"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def interface_binding_subspan(result, layout, binding, dynamic_dims, *, byte_offset=None, alignment=None, descriptor_flags=None, loc=None, ip=None) -> _ods_ir.Value:
  return InterfaceBindingSubspanOp(result=result, layout=layout, binding=binding, dynamic_dims=dynamic_dims, byte_offset=byte_offset, alignment=alignment, descriptor_flags=descriptor_flags, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceConstantLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.interface.constant.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, layout, ordinal, *, alignment=None, values=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["layout"] = (layout if (
    isinstance(layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_PipelineLayoutAttr')) else
      _ods_ir.AttrBuilder.get('HAL_PipelineLayoutAttr')(layout, context=_ods_context))
    attributes["ordinal"] = (ordinal if (
    isinstance(ordinal, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_HostSizeAttr')) else
      _ods_ir.AttrBuilder.get('HAL_HostSizeAttr')(ordinal, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    if values is not None: attributes["values"] = (values if (
        isinstance(values, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
          _ods_ir.AttrBuilder.get('ArrayAttr')(values, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def layout(self):
    return self.operation.attributes["layout"]

  @layout.setter
  def layout(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["layout"] = value

  @builtins.property
  def ordinal(self):
    return self.operation.attributes["ordinal"]

  @ordinal.setter
  def ordinal(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["ordinal"] = value

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def values(self):
    if "values" not in self.operation.attributes:
      return None
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value):
    if value is not None:
      self.operation.attributes["values"] = value
    elif "values" in self.operation.attributes:
      del self.operation.attributes["values"]

  @values.deleter
  def values(self):
    del self.operation.attributes["values"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def interface_constant_load(result, layout, ordinal, *, alignment=None, values=None, loc=None, ip=None) -> _ods_ir.Value:
  return InterfaceConstantLoadOp(result=result, layout=layout, ordinal=ordinal, alignment=alignment, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceWorkgroupCountOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.interface.workgroup.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, upper_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    if upper_bound is not None: attributes["upper_bound"] = (upper_bound if (
        isinstance(upper_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(upper_bound, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def upper_bound(self):
    if "upper_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["upper_bound"]

  @upper_bound.setter
  def upper_bound(self, value):
    if value is not None:
      self.operation.attributes["upper_bound"] = value
    elif "upper_bound" in self.operation.attributes:
      del self.operation.attributes["upper_bound"]

  @upper_bound.deleter
  def upper_bound(self):
    del self.operation.attributes["upper_bound"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def interface_workgroup_count(dimension, *, upper_bound=None, loc=None, ip=None) -> _ods_ir.Value:
  return InterfaceWorkgroupCountOp(dimension=dimension, upper_bound=upper_bound, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceWorkgroupIDOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.interface.workgroup.id"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, upper_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    if upper_bound is not None: attributes["upper_bound"] = (upper_bound if (
        isinstance(upper_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(upper_bound, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def upper_bound(self):
    if "upper_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["upper_bound"]

  @upper_bound.setter
  def upper_bound(self, value):
    if value is not None:
      self.operation.attributes["upper_bound"] = value
    elif "upper_bound" in self.operation.attributes:
      del self.operation.attributes["upper_bound"]

  @upper_bound.deleter
  def upper_bound(self):
    del self.operation.attributes["upper_bound"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def interface_workgroup_id(dimension, *, upper_bound=None, loc=None, ip=None) -> _ods_ir.Value:
  return InterfaceWorkgroupIDOp(dimension=dimension, upper_bound=upper_bound, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class InterfaceWorkgroupSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.interface.workgroup.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, upper_bound=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    if upper_bound is not None: attributes["upper_bound"] = (upper_bound if (
        isinstance(upper_bound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(upper_bound, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def upper_bound(self):
    if "upper_bound" not in self.operation.attributes:
      return None
    return self.operation.attributes["upper_bound"]

  @upper_bound.setter
  def upper_bound(self, value):
    if value is not None:
      self.operation.attributes["upper_bound"] = value
    elif "upper_bound" in self.operation.attributes:
      del self.operation.attributes["upper_bound"]

  @upper_bound.deleter
  def upper_bound(self):
    del self.operation.attributes["upper_bound"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def interface_workgroup_size(dimension, *, upper_bound=None, loc=None, ip=None) -> _ods_ir.Value:
  return InterfaceWorkgroupSizeOp(dimension=dimension, upper_bound=upper_bound, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryTypeOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.memory_type"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('HAL_MemoryTypeBitfieldAttr')) else
      _ods_ir.AttrBuilder.get('HAL_MemoryTypeBitfieldAttr')(type_, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def memory_type(type_, *, loc=None, ip=None) -> _ods_ir.Value:
  return MemoryTypeOp(type_=type_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorAliasOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.tensor.alias"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_dims, storage, *, wait_fence=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(storage)
    operands.append(wait_fence)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def storage(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def wait_fence(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_alias(source, source_dims, storage, *, wait_fence=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorAliasOp(source=source, source_dims=source_dims, storage=storage, wait_fence=wait_fence, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.tensor.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, sources, signal_fence, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(sources))
    operands.append(signal_fence)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sources(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def signal_fence(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def tensor_barrier(results_, sources, signal_fence, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TensorBarrierOp(results_=results_, sources=sources, signal_fence=signal_fence, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TensorExportOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.tensor.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, source, source_encoding, source_dims, *, name=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.extend(_get_op_results_or_values(source_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    results.append(target)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source_encoding(self):
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def name(self):
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def target(self):
    return self.operation.results[0]

def tensor_export(target, source, source_encoding, source_dims, *, name=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorExportOp(target=target, source=source, source_encoding=source_encoding, source_dims=source_dims, name=name, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorImportOp(_ods_ir.OpView):
  OPERATION_NAME = "hal.tensor.import"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, source, target_encoding, target_dims, *, consume=None, wait_fence=None, name=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(target_dims))
    operands.append(wait_fence)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_encoding"] = (target_encoding if (
    isinstance(target_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_encoding, context=_ods_context))
    if bool(consume): attributes["consume"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(affinity, context=_ods_context))
    results.append(target)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def wait_fence(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def target_encoding(self):
    return self.operation.attributes["target_encoding"]

  @target_encoding.setter
  def target_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_encoding"] = value

  @builtins.property
  def consume(self):
    return "consume" in self.operation.attributes

  @consume.setter
  def consume(self, value):
    if bool(value):
      self.operation.attributes["consume"] = _ods_ir.UnitAttr.get()
    elif "consume" in self.operation.attributes:
      del self.operation.attributes["consume"]

  @consume.deleter
  def consume(self):
    del self.operation.attributes["consume"]

  @builtins.property
  def name(self):
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def target(self):
    return self.operation.results[0]

def tensor_import(target, source, target_encoding, target_dims, *, consume=None, wait_fence=None, name=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorImportOp(target=target, source=source, target_encoding=target_encoding, target_dims=target_dims, consume=consume, wait_fence=wait_fence, name=name, affinity=affinity, loc=loc, ip=ip).result
