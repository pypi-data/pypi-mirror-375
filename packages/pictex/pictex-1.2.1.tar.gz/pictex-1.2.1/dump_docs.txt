------------------------------------------------------------------------------------------
file: docs\api\builders\canvas.md
------------------------------------------------------------------------------------------
::: pictex.Canvas
    options:
      show_root_heading: false



------------------------------------------------------------------------------------------
file: docs\api\builders\column.md
------------------------------------------------------------------------------------------
::: pictex.Column
    options:
      show_root_heading: false



------------------------------------------------------------------------------------------
file: docs\api\builders\image.md
------------------------------------------------------------------------------------------
::: pictex.Image
    options:
      show_root_heading: false



------------------------------------------------------------------------------------------
file: docs\api\builders\row.md
------------------------------------------------------------------------------------------
::: pictex.Row
    options:
      show_root_heading: false



------------------------------------------------------------------------------------------
file: docs\api\builders\text.md
------------------------------------------------------------------------------------------
::: pictex.Text
    options:
      show_root_heading: false



------------------------------------------------------------------------------------------
file: docs\api\models.md
------------------------------------------------------------------------------------------
# Model Classes & Enums

These are the data classes and enumerations used for configuration.

::: pictex.LinearGradient
    options:
      filters:
        - "!apply_to_paint"

::: pictex.SolidColor
    options:
      filters:
        - "!apply_to_paint"
        - "!_from_hex"

::: pictex.Shadow
::: pictex.TextAlign
::: pictex.FontWeight
::: pictex.FontStyle
::: pictex.CropMode



------------------------------------------------------------------------------------------
file: docs\api\outputs.md
------------------------------------------------------------------------------------------
# Output Classes

These classes represent the final rendered product of a composition.

::: pictex.BitmapImage
::: pictex.VectorImage



------------------------------------------------------------------------------------------
file: docs\box_model.md
------------------------------------------------------------------------------------------
# Styling: The Box Model

Every element in PicTex is treated as a rectangular box. This guide explains how to control the size, spacing, and appearance of these boxes.

## Spacing: `margin` and `padding`

-   `.padding()`: Sets the space **inside** an element's border, between the border and the content. It accepts 1, 2, or 4 values, just like in CSS.
-   `.margin()`: Sets the space **outside** an element's border, pushing away other elements. It also accepts 1, 2, or 4 values, just like in CSS.

## Borders: `.border()` and `.border_radius()`

-   `.border(width, color, style)`: Adds a border around the element. The `style` can be `'solid'`, `'dashed'`, or `'dotted'`.
-   `.border_radius()`: Creates rounded corners. It accepts absolute pixels or percentages (`"50%"` to create a circle/ellipse). It also supports 1, 2, or 4 values for individual corner control.

```python
from pictex import *

Canvas().render(
    Row()
    .size(100, 100)
    .background_color("green")
    .border(3, "black")
    .border_radius("50%")
).save("circle.png")
```

![Circle Example](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754099219/circle_nmcf9b.png)

## Sizing (`.size()`)

The `.size()` method sets the explicit dimensions of an element's box. You can control the `width` and `height` independently.

PicTex's sizing is powerful and flexible, supporting several modes for each dimension:

| Value Type                 | Example                                     | Behavior                                                                                                                                                             |
| -------------------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`'auto'`** (Default)     | `size()` or `size(width=200)`               | **Context-dependent.** Usually wraps the content (`fit-content`), but crucially, it allows the element to be stretched by its parent's alignment properties. This is default behavior.|
| `'fit-content'`            | `size(height='fit-content')`                | **Explicit.** Forces the element to wrap its content. Use this to *prevent* an element from being stretched by its parent. |
| `'fill-available'`         | `size(width='fill-available')`              | **Flexible.** The element grows to fill the remaining space in its parent container after fixed-size siblings are accounted for. If multiple siblings are `fill-available`, they share the space equally. |
| `'fit-background-image'`   | `size(width='fit-background-image')`        | **Explicit.** Forces the element to match the dimensions of its background image. |
| **Absolute (pixels)**      | `size(width=200, height=150)`               | **Explicit.** Sets a fixed size in pixels. This will override parent stretching. |
| **Percentage**             | `size(width="50%")`                         | **Explicit.** Sets the size as a percentage of the parent's content area. This will override parent stretching. |

The key difference to understand is between `'auto'` and `'fit-content'`:

-   Use `'auto'` (or simply don't call `.size()` for an axis) when you want an element to be flexible and respect its parent's layout rules like `stretch`.
-   Use `'fit-content'` when you want to force an element to be exactly as big as its content, no matter what its parent wants.

### The `border-box` Sizing Model

When you set the size of an element in PicTex, you are defining its **total visible dimensions**, including padding and border.

If you create an element with `.size(width=200)` and then add `.padding(20)`, the element will still be **200px wide** on the final image. The padding is applied *inward*, reducing the space available for the content.

This `border-box` model makes layouts incredibly predictable and robust.

```python
# This element's final width in the layout is exactly 300px.
box = Row(Text("Content"))
    .size(width=300)
    .padding(20)
    .border(5, "blue")

# The content area inside is now 300 - (2*20 padding) - (2*5 border) = 250px wide.
```

## Backgrounds

-   `.background_color()`: Sets the background fill (can be a color string or a `LinearGradient`).
-   `.background_image(path, size_mode)`: Sets a background image. The `size_mode` can be `'cover'`, `'contain'`, or `'tile'`.
-   `.fit_background_image()`: A convenience method that is a shortcut for `size('fit-background-image', 'fit-background-image')`.

## Box Shadows (`.box_shadows()`)

Applies one or more shadows to the element's box. This method is **declarative**: calling it replaces any previously defined box shadows.

To use it, first import the `Shadow` class.

```python
from pictex import Canvas, Shadow

canvas = (
    Canvas()
    .font_size(100)
    .padding(40)
    .background_color("white")
    .border_radius(20)
    .box_shadows(Shadow(offset=(10, 10), blur_radius=3, color="black"))
)

canvas.render("Box Shadow").save("box_shadow.png")
```

![Box Shadow Example](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754099381/box_shadow_m2xhcq.png)



------------------------------------------------------------------------------------------
file: docs\colors.md
------------------------------------------------------------------------------------------
# Styling Guide: Colors & Gradients

Anywhere a `color` is required, you can use a **Solid Color** or a **Gradient**.

## Solid Colors

They can be specified using the `SolidColor` class or using a string in different formats:

| Format           | Example         | Description                               |
| ---------------- | --------------- | ----------------------------------------- |
| Named Color      | `"red"`, `"gold"` | Common CSS color names.                   |
| 6-digit Hex      | `"#FF5733"`     | Standard RRGGBB format.                   |
| 3-digit Hex      | `"#F53"`         | Shorthand for `"#FF5533"`.                |
| 8-digit Hex (HexA) | `"#FF573380"`   | RRGGBBAA, where AA is the alpha/opacity. |

For example, all these are valid ways to set the color to red:

```python
from pictex import Canvas, SolidColor

Canvas().color("#FF0000FF")
Canvas().color("#FF0000")
Canvas().color("#F00")
Canvas().color("red")
Canvas().color(SolidColor(255, 0, 0, 255))
Canvas().color(SolidColor(255, 0, 0))
```

## Linear Gradients

**You can use a `LinearGradient` object anywhere a color is accepted**: in `.color()`, `.text_stroke()`, `border()`, `.background_color()`, and even in text decorations like `.underline()`. Only shadow colors must be solid.

A `LinearGradient` has a few key parameters:
-   `colors`: A list of color strings.
-   `stops` (Optional): A list of floats (0.0 to 1.0) specifying the position of each color.
-   `start_point` & `end_point` (Optional): Define the direction of the gradient. `(0,0)` is top-left, `(1,1)` is bottom-right.

### Example: Gradient on a Background

```python
from pictex import Canvas, LinearGradient

gradient = LinearGradient(
    colors=["#43C6AC", "#191654"],
    start_point=(0.0, 0.0), # Top-left
    end_point=(1.0, 1.0)   # Bottom-right
)

canvas = (
    Canvas()
    .font_size(90)
    .color("white")
    .padding(40)
    .background_color(gradient)
    .border_radius(25)
)

canvas.render("Gradient BG").save("gradient_bg.png")
```

![Background gradient result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754099560/gradient_bg_d3ivme.png)

### Showcase: Gradients Everywhere

Let's combine everything. Here, we apply different gradients to the text fill, its outline, and its underline.

```python
from pictex import Canvas, LinearGradient

text_gradient = LinearGradient(colors=["#FFD700", "#FF6B6B"])
stroke_gradient = LinearGradient(colors=["#4A00E0", "#8E2DE2"])
underline_gradient = LinearGradient(
    colors=["#00F260", "#0575E6"],
    start_point=(0.5, 0.0),
    end_point=(0.5, 1.0)
)
border_gradient = LinearGradient(colors=["blue", "cyan"])

canvas = (
    Canvas()
    .font_family("Impact")
    .font_size(150)
    .color(text_gradient)
    .text_stroke(width=10, color=stroke_gradient)
    .underline(thickness=15, color=underline_gradient)
    .border(width=5, color=border_gradient)
)

canvas.render("GRADIENTS!").save("gradients_everywhere.png")
```

![Gradients everywhere result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754099560/gradients_everywhere_rlk3qo.png)



------------------------------------------------------------------------------------------
file: docs\core_concepts.md
------------------------------------------------------------------------------------------
# Core Concepts: Builders & Layout

Welcome to PicTex's layout engine! With version 1.0, PicTex has evolved from a text-styler into a powerful visual composition tool. This guide introduces the core concepts of building and arranging elements.

## Everything is a Builder

In PicTex, every visual piece you create is a **Builder**. There are three main types:

1.  **Content Builders**: These are the basic building blocks that hold content.
    -   `Text()`: For displaying text.
    -   `Image()`: For displaying raster images.
2.  **Layout Builders**: These are containers that arrange other builders.
    -   `Row()`: Arranges its children horizontally.
    -   `Column()`: Arranges its children vertically.
3.  **Root Builder**:
    -   `Canvas()`: The top-level container that holds your entire composition and defines global styles.

You can nest these builders to create complex layouts. For example, a `Row` can contain a mix of `Image` and `Text` builders.

```python
from pictex import *

composition = Row(
    Column(
        Text("Col1").background_color("blue"),
        Text("Col1").background_color("red")
    ),
    Column(
        Text("Col2").background_color("blue"),
        Text("Col2").background_color("red")
    )
)
Canvas().render(composition).save("introduction.png")
```

![Introduction](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754098899/introduction_gtjc6f.png)

## Layout Builders: `Row` and `Column`

The real power of PicTex lies in how you can arrange elements inside `Row` and `Column` containers.

### Main Axis and Cross Axis

Every layout builder has two axes:
-   **Main Axis**: The direction in which children are placed. For `Row`, it's **horizontal**. For `Column`, it's **vertical**.
-   **Cross Axis**: The axis perpendicular to the main axis. For `Row`, it's **vertical**. For `Column`, it's **horizontal**.

### Distribution (Main Axis)

Distribution controls how children are spaced along the **main axis**, especially when the container is larger than the children combined.

-   **On a `Row`**: Use `.horizontal_distribution()`
-   **On a `Column`**: Use `.vertical_distribution()`

**Available Modes:**
-   `'left'` / `'top'` (Default): `[X|X|X|.........]`
-   `'center'`: `[.....|X|X|X|.....]`
-   `'right'` / `'bottom'`: `[.........|X|X|X]`
-   `'space-between'`: `[X|.....|X|.....|X]` (Space is only between elements)
-   `'space-around'`: `[..|X|.....|X|.....|X|..]` (Space around each element)
-   `'space-evenly'`: `[..|X|..|X|..|X|..]` (Space is equal everywhere)

```python
from pictex import *

def create_distribution_example(distribution):
    row_with_distribution = Row(
        Text("A").background_color("blue"),
        Text("B").background_color("red"),
        Text("C").background_color("green"),
    ).horizontal_distribution(distribution).border(4, "black").size(width=300)
    return Column(
        Text(distribution).font_size(40),
        row_with_distribution
    ).background_color("pink")

distributions = [
    "left",
    "center",
    "right",
    "space-between",
    "space-around",
    "space-evenly",
]
examples = []
for d in distributions:
    examples.append(create_distribution_example(d))


image = Canvas().font_size(80).render(Column(*examples).gap(20))
image.save("distribution.png")
```

![Distribution Example](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754098899/distribution_vr3al5.png)

### Alignment (Cross Axis)

Alignment controls how children are positioned along the **cross axis**.

-   **On a `Row`**: Use `.vertical_align()`
-   **On a `Column`**: Use `.horizontal_align()`

**Available Modes:**
-   `'top'` / `'left'` (Default): Aligns children to the start of the cross axis.
-   `'center'`: Centers children along the cross axis.
-   `'bottom'` / `'right'`: Aligns children to the end of the cross axis.
-   `'stretch'`: Resizes children to fill the container along the cross axis.

```python
from pictex import *

def create_alignment_example(align):
    row_with_alignment = Row(
        Text("A").background_color("blue").font_size(80),
        Text("B").background_color("red").font_size(65),
        Text("C").background_color("green").font_size(50),
    ).vertical_align(align).border(4, "black").gap(30)
    return Column(
        Text(align).font_size(40),
        row_with_alignment
    ).background_color("pink")

aligns = [
    "top",
    "center",
    "bottom",
    "stretch"
]
examples = []
for a in aligns:
    examples.append(create_alignment_example(a))

image = Canvas().font_size(80).render(Column(*examples).gap(20))
image.save("alignment.png")
```

![Alignment Example](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754774757/alignment_m66sum.png)

#### How `stretch` Works

The `'stretch'` alignment is particularly powerful. It makes all children in a container have the same height (in a `Row`) or width (in a `Column`), creating clean, uniform layouts.

**`stretch` only affects children whose size for that axis is set to `'auto'` (the default).**

If you give a child an explicit size (e.g., `.size(height=50)` or `.size(height='fit-content')`), that child will **opt out** of being stretched and will keep its specified size. This allows you to create flexible layouts with specific exceptions.

```python
from pictex import *

col = Column(
    Text("I will stretch").background_color("blue"),
    Text("I am fixed").background_color("green").size(width="fit-content"),
    Text("I will also stretch").background_color("red")
).horizontal_align('stretch')

Canvas().render(col).save("stretch.png")
```

![Stretch Example](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754774789/stretch_lxinzt.png)

### Spacing with `.gap()`

Instead of adding margins to each child, the cleanest way to add space between elements is with `.gap()`. This applies a consistent spacing on the **main axis**.

```python
# Add a 20px gap between all children in the column
card = Column(
    product_image,
    header,
    description
).gap(20)
```

### Breaking the Flow: `position()` and `absolute_position()`

Sometimes you need to place an element at a specific coordinate, ignoring the normal `Row` or `Column` flow. PicTex offers two powerful methods for this, each with a different frame of reference. When you use either method, the element is removed from the layout flow, and other elements will behave as if it isn't there.

#### Relative Positioning with `.position()`

This is the most common method for positioning. It places an element relative to its **direct parent's content area**. This means the `(0, 0)` origin is the corner *inside* the parent's padding and border. This is perfect for overlays within a component, like placing a badge on an image, because the positioned element will move along with its parent.

#### Absolute Positioning with `.absolute_position()`

This method provides an "escape hatch" from all parent containers. It places an element relative to the **root canvas**. The `(0, 0)` origin is the absolute top-left corner of the final rendered image, ignoring any margin, border, or padding on the root container itself. This is best for global elements like watermarks.

#### Visualizing the Difference

The following example makes the distinction clear. We create a `Canvas` with a large margin, border, and padding. Inside, we place two `Text` elements, both at `(0, 0)`—one with `absolute_position` and one with `position`.

```python
from pictex import Canvas, Text

(
    Canvas()
    .margin(25)
    .padding(25)
    .border(25, "red")
    .background_color("blue")
    .size(200, 200)
    .font_size(20)
    .color("orange")
    .render(
        Text("ABSOLUTE").absolute_position(0, 0),
        Text("RELATIVE").position(0, 0)
    )
).save("position.png")
```

![Positioning Example](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754260873/position_uxawu1.png)

As you can see:
-   **`ABSOLUTE`** is rendered at the true `(0, 0)` of the final image, ignoring the canvas's own box model.
-   **`RELATIVE`** is rendered at `(0, 0)` relative to the parent's **content area**. Its final position is correctly offset by the canvas's 25px margin, 25px border, and 25px padding.



------------------------------------------------------------------------------------------
file: docs\exporting.md
------------------------------------------------------------------------------------------
# Exporting Your Image

Once you have built your visual composition, PicTex provides flexible options for exporting it to both raster (pixel-based) and vector (path-based) formats.

## Exporting to Raster Images (.png, .jpg)

To generate a raster image, use the `.render()` method. This returns a `BitmapImage` object, which holds the pixel data and provides helpful methods to save, display, or convert it.

```python
from pictex import Canvas

canvas = Canvas().font_size(80).color("blue")
image = canvas.render("Hello, World!")

# Save to a file (format is inferred from extension)
image.save("output.png")
image.save("output.jpg", quality=90)
```

### Controlling Raster Size with `crop_mode`

The `.render()` method accepts a `crop_mode` argument to give you full control over the final image dimensions.

-   `CropMode.NONE` (Default): The canvas will be large enough to include all effects, including the full extent of shadows.
-   `CropMode.CONTENT_BOX`: The canvas will be cropped to the "content box" of the root element. This is useful if you want to ignore shadows for layout purposes.
-   `CropMode.SMART`: A smart crop that trims all fully transparent pixels from the edges of the image. This is often the best choice for the tightest possible output.

```python
from pictex import Canvas, CropMode

canvas = Canvas().font_size(100).add_shadow(offset=(10,10), blur_radius=20, color="white")
canvas.background_color("blue")

# Render with different exporting modes
img_none = canvas.render("Test", crop_mode=CropMode.NONE)
img_smart = canvas.render("Test", crop_mode=CropMode.SMART)
img_content_box = canvas.render("Test", crop_mode=CropMode.CONTENT_BOX)

# We save them as JPG images to force a black background instead of transparent, so it's easier to see the difference
img_none.save("test_none.jpg")
img_smart.save("test_smart.jpg")
img_content_box.save("test_content_box.jpg")
```

**`CropMode.NONE`** (default):

![None crop result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754099896/test_none_qayqye.jpg)

**`CropMode.SMART`**:

![Smart crop result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754099896/test_smart_c8vl7j.jpg)

**`CropMode.CONTENT_BOX`**:

![Content-box crop result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754099895/test_content_box_eecjyp.jpg)

### Converting to Other Formats

The `Image` object can be easily converted for use with other popular libraries.
```python
# Get a Pillow Image object (requires `pip install Pillow`)
pil_image = image.to_pillow()

# Get a NumPy array for use with OpenCV (BGRA format) or Matplotlib (RGBA).
numpy_array = image.to_numpy(mode="RGBA")
```

## Exporting to Vector Images (.svg)

To generate an SVG, use the `.render_as_svg()` method. This returns a `VectorImage` object.

```python
vector_image = canvas.render_as_svg("Hello, SVG!")
vector_image.save("output.svg")
```

> Note: Shadows are not supported yet in SVG

### Understanding Font Handling in SVG

Handling fonts is the most critical aspect of creating portable SVGs. `PicTex` gives you precise control over this via the `embed_font` parameter in the `render_as_svg()` method.

The behavior changes depending on whether you are using a **font file** (e.g., from a `.ttf` path) or a **system font** (e.g., `"Arial"`).

### Scenario 1: Using a Font File (e.g., `.font_family("path/to/font.ttf")`)

This is the recommended approach for achieving consistent visual results.

#### `embed_font=True` (default)
-   **What it does:** The entire font file is encoded in Base64 and embedded directly within the SVG file using a `@font-face` rule.
-   **Result:** The SVG is **fully self-contained and portable**. It will render identically on any device, regardless of a user's installed fonts.
-   **Trade-off:** The file size of the SVG will increase by roughly 133% of the original font file's size.

```python
# This creates a completely portable SVG
vector_image = canvas.render_as_svg("Portable & Perfect", embed_font=True)
vector_image.save("portable_text.svg")
```

#### `embed_font=False`
-   **What it does:** The SVG will still contain a `@font-face` rule, but instead of embedding the font data, it will reference the font file using a relative path (e.g., `src: url('path/to/font.ttf')`).
-   **Result:** The SVG file itself is very small. However, for it to render correctly, the font file **must be distributed alongside the SVG** and kept in the same relative path. This is useful for web projects where you manage fonts and SVGs as separate assets.
-   **Trade-off:** The SVG is no longer self-contained.

```python
# This creates a lightweight SVG that depends on an external font file
vector_image = canvas.render_as_svg("Linked Font", embed_font=False)
vector_image.save("linked_text.svg")
# You must also provide the font file for "linked_text.svg" to work correctly.
```

### Scenario 2: Using a System Font (e.g., `.font_family("Arial")`)

This applies when you specify a font by name or when `PicTex` uses a system font as a fallback (e.g., for an emoji).

-   **What it does:** In this case, the `embed_font` parameter has **no effect**, as `PicTex` does not have access to the font's file path to be able to read and embed it.
-   **Result:** The SVG will always reference the font by its family name (e.g., `font-family: 'Arial'`). The rendering completely relies on the viewing system having that specific font installed. If the font is not found, the viewer will substitute it with a default, which may alter the appearance.
-   **Warning:** If you use `embed_font=True` with a system font, `PicTex` will issue a warning to inform you that the font could not be embedded.

### Summary of Font Handling

| Font Source          | `embed_font=True` (Default)                                   | `embed_font=False`                                         |
| -------------------- | ------------------------------------------------------------- | ---------------------------------------------------------- |
| **Font from File**   | **Fully Portable SVG.** Font is embedded (Base64).            | **Linked SVG.** Relies on external font file at a relative path. |
| **System Font**      | **System-Dependent SVG.** Font is referenced by name. (Warning issued) | **System-Dependent SVG.** Font is referenced by name.      |



------------------------------------------------------------------------------------------
file: docs\getting_started.md
------------------------------------------------------------------------------------------
# Getting Started

Welcome to PicTex! This guide will get you from installation to your first composed image in just a few minutes.

## The Core Idea: Composing Builders

The core idea of PicTex is to build complex visuals by **composing simple builders**.

1.  **Builders**: These are the fundamental building blocks of your image. You have content builders like `Text` and `Image`, and layout builders like `Row` and `Column` to arrange them.

2.  **`Canvas`**: This is the top-level container for your entire image. You can use it to set global styles (like a default font or a background color) and to kick off the final render.

The workflow is simple: you create and nest builders to form a tree structure representing your visual, and then you tell the `Canvas` to render it.

### Quickstart: Creating a User Banner

Let's build a simple user banner to see these concepts in action.

```python
from pictex import Canvas, Row, Column, Text, Image

# 1. Create the individual content builders
avatar = (
    Image("avatar.jpg")
    .size(60, 60)
    .border_radius('50%') # Make it circular
)

user_info = Column(
    Text("Alex Doe").font_size(20).font_weight(700),
    Text("@alexdoe").color("#657786")
).gap(4) # Add a 4px vertical gap between the texts

# 2. Compose the builders in a layout container
user_banner = Row(
    avatar,
    user_info
).gap(15).vertical_align('center') # Vertically center the avatar and user info

# 3. Create a Canvas and render the final composition
canvas = Canvas().padding(20).background_color("#F5F8FA")
image = canvas.render(user_banner)

# 4. Save the result
image.save("user_banner.png")
```

![User Banner Example](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754102204/user_banner_ujadrv.png)

This example shows the power of composition: an `Image` and a `Column` are nested inside a `Row` to create a clean, aligned component.

## Working with the `BitmapImage` Object

The `BitmapImage` object is the final rendered product from `canvas.render()`. It holds the pixel data and provides helpful methods.

```python
# Assuming 'image' is an Image object from the example above

# Save to a file (format is inferred from extension)
image.save("output.png")

# Get a Pillow Image object (requires `pip install Pillow`)
pil_image = image.to_pillow()
pil_image.show()

# Get a NumPy array for use with other libraries
numpy_array_bgra = image.to_numpy()
```

## Working with the `VectorImage` Object

The `VectorImage` object, returned by `canvas.render_as_svg()`, holds the SVG content as a string.

```python
vector_image = canvas.render_as_svg(user_banner)

# Save to a file
vector_image.save("output.svg")

# Get the raw SVG string
svg_string = vector_image.svg
```

## What's Next?

You now understand the basic workflow of PicTex. To master its full potential, explore our detailed guides in the following order:

1.  **[Core Concepts: Builders & Layout](./core_concepts.md)**
    *A deep dive into `Row` and `Column`, and how to control distribution, alignment, and spacing.*

2.  **[Styling: The Box Model](./box_model.md)**
    *Learn how sizing, padding, borders, and backgrounds work with the powerful `border-box` model.*

3.  **[Styling: Text & Fonts](./text.md)**
    *Master custom fonts, variable fonts, text shadows, and decorations.*

4.  **[Styling: Colors & Gradients](./colors.md)**
    *Discover how to apply solid colors and beautiful linear gradients to any part of your composition.*

5.  **[Exporting Your Image](./exporting.md)**
    *Take full control over the final output, including cropping strategies and SVG font embedding.*



------------------------------------------------------------------------------------------
file: docs\index.md
------------------------------------------------------------------------------------------
# Welcome to PicTex

![PicTex](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1753831765/readme-1_vqnohh.png)

**`PicTex` is a Python library for creating beautifully styled visual compositions.**

Whether you're generating dynamic images for social media, creating video overlays, or building tools for digital art, `PicTex` simplifies the process. It abstracts away the complexity of low-level graphics engines, offering a component-based and chainable interface inspired by modern layout systems.

This documentation will guide you through everything `PicTex` has to offer. You'll learn how to leverage its powerful layout engine to compose elements, how to style them with a flexible box model, and how to export your creations to both raster and vector formats.

## Where to Go Next

Whether you're new to `PicTex` or an experienced user, here's where to find what you need.

-   __Getting Started__

    New to `PicTex`? This is the place to start. Learn the core concepts and create your first image in minutes.

    [Go to Getting Started](./getting_started.md)

-   __Guides__
    
    Ready to build? Our guides will teach you how to compose and style complex visuals. We recommend starting with the Core Concepts.

    [Go to the Guides](./core_concepts.md)

-   __API Reference__

    Need the technical details? Jump straight into the full API reference for all classes, methods, and parameters.

    [Go to the API Reference](./api/builders/canvas.md)



------------------------------------------------------------------------------------------
file: docs\text.md
------------------------------------------------------------------------------------------
# Styling Guide: Text & Fonts

This guide covers all options related to fonts, typography, and text decorations.

## Font Family, Size, Weight, and Style

You can use system-installed fonts by name or provide a path to a `.ttf` or `.otf` file.

```python
from pictex import Canvas, FontWeight, FontStyle

# Using a system font
canvas_system = (
    Canvas()
    .font_family("Georgia")
    .font_size(80)
    .font_weight(FontWeight.BOLD)
    .font_style(FontStyle.ITALIC)
)

# Using a local font file
canvas_local = Canvas().font_family("assets/fonts/Inter-Variable.ttf").font_size(80)
```

## Font Fallbacks and Emoji Support

One of `PicTex`'s most powerful features is its automatic font fallback system. If your primary font doesn't support a specific character (like an emoji `✨` or a symbol `→`), `PicTex` will automatically search through a list of fallback fonts to find one that does.

This means you can render complex, multi-lingual text and emojis without worrying about missing characters (often shown as `□`).

### How It Works

The fallback chain is:
1.  Your primary font set with `.font_family()`.
2.  Any custom fallback fonts you provide with `.font_fallbacks()`.
3.  A list of default system emoji fonts (`Segoe UI Emoji` on Windows, `Apple Color Emoji` on macOS, `Noto Color Emoji` on Linux).

If a provided font is not found, a warning message is displayed and the font is ignored.

### Providing Custom Fallbacks

You can specify your own list of fallback fonts. This is useful if you are working with multiple languages and want to ensure a specific look.

```python
from pictex import Canvas

# A font that doesn't support Japanese or emojis
primary_font = "Lato-BoldItalic.ttf" 

# A Japanese font
japanese_font = "NotoSansJP-Regular.ttf"

canvas = (
    Canvas()
    .font_family(primary_font)
    .font_fallbacks(japanese_font)
    .font_size(80)
    .color("olive")
    .padding(20)
)

text = "Hello, 世界 ✨"
canvas.render(text).save("font_fallback_example.png")
```

![Font fallback result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754102756/font_fallback_example_bhrkg1.png)

## Variable Fonts

`PicTex` has support for **Variable Fonts**. If you provide a variable font file, it will automatically apply the `weight` and `style` settings to the font's variation axes (`wght`, `ital`, `slnt`).

```python
from pictex import Canvas, FontWeight, FontStyle

# Using a variable font file and setting its axes
canvas = (
    Canvas()
    .font_family("Oswald-VariableFont_wght.ttf")
    .font_size(80)
    .font_weight(FontWeight.BLACK) # Sets 'wght' axis to 900
    .color("orange")
)

canvas.render("Variable Font").save("variable_font.png")
```

![Variable font result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754102764/variable_font_skmjc6.png)

`FontWeight` can be an enum member (e.g., `FontWeight.BOLD`) or an integer from 100 to 900.

## Multi-line Text and Alignment

`PicTex` fully supports multi-line text using newline characters (`\n`). Additionally, text can automatically wrap when placed in containers with fixed widths.

-   `.text_align()`: Controls how text lines are aligned within the text block. Accepts `TextAlign.LEFT`, `TextAlign.CENTER`, or `TextAlign.RIGHT`.
-   `.line_height()`: Sets the spacing between lines as a multiplier of the font size. A value of `1.5` means 150% spacing.
-   `.text_wrap()`: Controls whether text automatically wraps to fit container width. Accepts `"normal"` (default, wrapping enabled) or `"nowrap"` (wrapping disabled).

```python
from pictex import Canvas, TextAlign

canvas = (
    Canvas()
    .font_family("Times New Roman")
    .font_weight(700)
    .font_size(50)
    .color("magenta")
    .text_align(TextAlign.CENTER)  # a string is also accepted ("center")
    .line_height(1.2)
    .padding(20)
)

text = "This is an example of centered,\nmulti-line text\nwith custom line spacing."
canvas.render(text).save("alignment_example.png")
```

![Multiline result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754102754/alignment_example_dnk5t4.png)

### Text Wrapping

When text is placed inside containers with fixed widths, it can automatically wrap to multiple lines:

```python
from pictex import Canvas, Text, Column

canvas = Canvas().font_family("Arial").font_size(16)

# Text will automatically wrap to fit the 200px width
long_text = "This is a very long sentence that will automatically wrap to multiple lines when placed inside a container with a fixed width."

wrapped_text = Text(long_text)
container = Column(wrapped_text).size(width=200).padding(10)

canvas.render(container).save("text_wrapping_example.png")
```

You can also disable text wrapping:

```python
# This text will not wrap and may overflow the container
no_wrap_text = Text(long_text).text_wrap("nowrap")
container = Column(no_wrap_text).size(width=200).padding(10)
```

## Text Decorations

You can add `underline` and `strikethrough` decorations. As shown in the Gradients guide, the `color` for a decoration can also be a `LinearGradient`.

If the `color` is not defined, it will use the font color.

```python
from pictex import Canvas

# Simple underline
canvas1 = Canvas().font_size(80).color("blue").underline(10)
canvas1.render("Underlined").save("underline.png")

# Styled strikethrough
canvas2 = Canvas().font_size(80).color("blue").strikethrough(thickness=10, color="red")
canvas2.render("Strikethrough").save("strikethrough.png")
```

![Underline result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754102761/underline_lqz7fy.png)


![Strikethrough result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754102759/strikethrough_jaofgg.png)

## Text Shadows

Applies one or more shadows directly to the text glyphs. To add multiple shadows, pass multiple `Shadow` objects. This method is declarative and will override any previous text shadows.

A `Shadow` instance has:
-   `offset`: A tuple `(x, y)` for the shadow's position.
-   `blur_radius`: The amount of blur to apply.
-   `color`: The color of the shadow.

```python
from pictex import Canvas, Text, Shadow

canvas =(
    Canvas()
    .font_size(120)
    .font_family("Impact")
    .color("#00FFAA")
    .text_shadows(
        Shadow(offset=(0, 0), blur_radius=2, color="#00FFAA"),
        Shadow(offset=(0, 0), blur_radius=5, color="#FFFFFF")
    )
)
canvas.render("NEON").save("neon.png")
```

![Text shadows result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754102759/neon_w7hnrf.png)

## Outline Stroke

The `.text_stroke()` method adds a contour around the text. This is great for creating impactful, cartoon-style, or sticker-like text.

```python
from pictex import Canvas

canvas = (
    Canvas()
    .font_size(150)
    .font_family("Impact")
    .color("yellow")
    .text_stroke(width=14, color="black")
)

canvas.render("COMIC").save("comic_style.png")
```

![Outline stroke result](https://res.cloudinary.com/dlvnbnb9v/image/upload/v1754102755/comic_style_ysnmlf.png)


