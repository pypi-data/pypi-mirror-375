from __future__ import annotations
import numpy
import ostk.core.type
import ostk.mathematics.geometry.d2
import typing
__all__ = ['Composite', 'Line', 'LineString', 'MultiPolygon', 'Point', 'PointSet', 'Polygon', 'Segment', 'set_point_2_array', 'set_point_array']
class Composite(ostk.mathematics.geometry.d2.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def empty() -> Composite:
        ...
    @staticmethod
    def undefined() -> Composite:
        ...
    def __add__(self, arg0: Composite) -> Composite:
        ...
    def __eq__(self, arg0: Composite) -> bool:
        ...
    def __iadd__(self, arg0: Composite) -> Composite:
        ...
    def __init__(self, object: ostk.mathematics.geometry.d2.Object) -> None:
        ...
    def __ne__(self, arg0: Composite) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def access_object_at(self, index: int) -> ostk.mathematics.geometry.d2.Object:
        ...
    @typing.overload
    def any_contains(self, object: ostk.mathematics.geometry.d2.Object) -> bool:
        ...
    @typing.overload
    def any_contains(self, composite: Composite) -> bool:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def as_composite(self) -> Composite:
        ...
    def as_line(self) -> Line:
        ...
    def as_line_string(self) -> LineString:
        ...
    def as_point(self) -> Point:
        ...
    def as_point_set(self) -> PointSet:
        ...
    def as_polygon(self) -> Polygon:
        ...
    def as_segment(self) -> Segment:
        ...
    @typing.overload
    def contains(self, object: ostk.mathematics.geometry.d2.Object) -> bool:
        ...
    @typing.overload
    def contains(self, composite: Composite) -> bool:
        ...
    def get_object_count(self) -> int:
        ...
    @typing.overload
    def intersects(self, object: ostk.mathematics.geometry.d2.Object) -> bool:
        ...
    @typing.overload
    def intersects(self, composite: Composite) -> bool:
        ...
    def is_composite(self) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_empty(self) -> bool:
        ...
    def is_line(self) -> bool:
        ...
    def is_line_string(self) -> bool:
        ...
    def is_point(self) -> bool:
        ...
    def is_point_set(self) -> bool:
        ...
    def is_polygon(self) -> bool:
        ...
    def is_segment(self) -> bool:
        ...
class Line(ostk.mathematics.geometry.d2.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def points(first_point: Point, second_point: Point) -> Line:
        ...
    @staticmethod
    def undefined() -> Line:
        ...
    def __eq__(self, arg0: Line) -> bool:
        ...
    def __init__(self, point: Point, direction: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    def __ne__(self, arg0: Line) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    def get_direction(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def get_origin(self) -> Point:
        ...
    def intersects(self, point: Point) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class LineString(ostk.mathematics.geometry.d2.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def empty() -> LineString:
        ...
    def __eq__(self, arg0: LineString) -> bool:
        ...
    def __getitem__(self, index: int) -> Point:
        ...
    def __init__(self, points: list[Point]) -> None:
        ...
    def __iter__(self) -> typing.Iterator[Point]:
        ...
    def __len__(self) -> int:
        ...
    def __ne__(self, arg0: LineString) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def get_point_closest_to(self, point: Point) -> Point:
        ...
    def get_point_count(self) -> int:
        ...
    def is_defined(self) -> bool:
        ...
    def is_empty(self) -> bool:
        ...
    def is_near(self, line_string: LineString, tolerance: ostk.core.type.Real) -> bool:
        ...
    def to_string(self, format: ostk.mathematics.geometry.d2.Object.Format = ..., precision: ostk.core.type.Integer = ...) -> ostk.core.type.String:
        ...
class MultiPolygon(ostk.mathematics.geometry.d2.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def polygon(polygon: Polygon) -> MultiPolygon:
        ...
    @staticmethod
    def undefined() -> MultiPolygon:
        ...
    def __eq__(self, arg0: MultiPolygon) -> bool:
        ...
    def __init__(self, polygons: list[Polygon]) -> None:
        ...
    def __ne__(self, arg0: MultiPolygon) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    def get_convex_hull(self) -> Polygon:
        ...
    def get_polygon_count(self) -> int:
        ...
    def get_polygons(self) -> list[Polygon]:
        ...
    def is_defined(self) -> bool:
        ...
    def to_string(self, format: ostk.mathematics.geometry.d2.Object.Format = ..., precision: ostk.core.type.Integer = ...) -> ostk.core.type.String:
        ...
    def union_with(self, multipolygon: MultiPolygon) -> MultiPolygon:
        ...
class Point(ostk.mathematics.geometry.d2.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def origin() -> Point:
        ...
    @staticmethod
    def undefined() -> Point:
        ...
    @staticmethod
    def vector(vector: numpy.ndarray[numpy.float64[2, 1]]) -> Point:
        ...
    def __add__(self, arg0: numpy.ndarray[numpy.float64[2, 1]]) -> Point:
        ...
    def __eq__(self, arg0: Point) -> bool:
        ...
    def __init__(self, x: ostk.core.type.Real, y: ostk.core.type.Real) -> None:
        ...
    def __ne__(self, arg0: Point) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: Point) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def __sub__(self, arg0: numpy.ndarray[numpy.float64[2, 1]]) -> Point:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def as_vector(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    def is_defined(self) -> bool:
        ...
    def is_near(self, point: Point, tolerance: ostk.core.type.Real) -> bool:
        ...
    def to_string(self, format: ostk.mathematics.geometry.d2.Object.Format = ..., precision: ostk.core.type.Integer = ...) -> ostk.core.type.String:
        ...
    def x(self) -> ostk.core.type.Real:
        ...
    def y(self) -> ostk.core.type.Real:
        ...
class PointSet(ostk.mathematics.geometry.d2.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def empty() -> PointSet:
        ...
    def __eq__(self, arg0: PointSet) -> bool:
        ...
    def __getitem__(self, arg0: int) -> Point:
        ...
    def __init__(self, points: list[Point]) -> None:
        ...
    def __iter__(self) -> typing.Iterator[Point]:
        ...
    def __len__(self) -> int:
        ...
    def __ne__(self, arg0: PointSet) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    def get_point_closest_to(self, point: Point) -> Point:
        ...
    def get_size(self) -> int:
        ...
    def is_defined(self) -> bool:
        ...
    def is_empty(self) -> bool:
        ...
    def is_near(self, point_set: PointSet, tolerance: ostk.core.type.Real) -> bool:
        ...
    def to_string(self, format: ostk.mathematics.geometry.d2.Object.Format = ..., precision: ostk.core.type.Integer = ...) -> ostk.core.type.String:
        ...
class Polygon(ostk.mathematics.geometry.d2.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Polygon:
        ...
    def __eq__(self, arg0: Polygon) -> bool:
        ...
    @typing.overload
    def __init__(self, outer_ring: list[Point], inner_rings: list[list[Point]]) -> None:
        ...
    @typing.overload
    def __init__(self, outer_ring: list[Point]) -> None:
        ...
    def __ne__(self, arg0: Polygon) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    def difference_with(self, polygon: Polygon) -> ...:
        ...
    def get_convex_hull(self) -> Polygon:
        ...
    def get_edge_at(self, index: int) -> Segment:
        ...
    def get_edge_count(self) -> int:
        ...
    def get_edges(self) -> list[Segment]:
        ...
    def get_inner_ring_at(self, index: int) -> LineString:
        ...
    def get_inner_ring_count(self) -> int:
        ...
    def get_outer_ring(self) -> LineString:
        ...
    def get_vertex_at(self, index: int) -> Point:
        ...
    def get_vertex_count(self) -> int:
        ...
    def get_vertices(self) -> list[Point]:
        ...
    def intersection_with(self, polygon: Polygon) -> ...:
        ...
    def intersects(self, polygon: Polygon) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_near(self, polygon: Polygon, tolerance: ostk.core.type.Real) -> bool:
        ...
    def to_string(self, format: ostk.mathematics.geometry.d2.Object.Format = ..., precision: ostk.core.type.Integer = ...) -> ostk.core.type.String:
        ...
    def union_with(self, polygon: Polygon) -> ...:
        ...
class Segment(ostk.mathematics.geometry.d2.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Segment:
        ...
    def __eq__(self, arg0: Segment) -> bool:
        ...
    def __init__(self, start_point: Point, end_point: Point) -> None:
        ...
    def __ne__(self, arg0: Segment) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    @typing.overload
    def distance_to(self, point_set: PointSet) -> ostk.core.type.Real:
        ...
    def get_center(self) -> Point:
        ...
    def get_direction(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def get_first_point(self) -> Point:
        ...
    def get_length(self) -> ostk.core.type.Real:
        ...
    def get_second_point(self) -> Point:
        ...
    def is_defined(self) -> bool:
        ...
    def is_degenerate(self) -> bool:
        ...
    def to_line(self) -> Line:
        ...
    def to_string(self, format: ostk.mathematics.geometry.d2.Object.Format = ..., precision: ostk.core.type.Integer = ...) -> ostk.core.type.String:
        ...
def set_point_2_array(arg0: list[list[Point]]) -> None:
    ...
def set_point_array(arg0: list[Point]) -> None:
    ...
