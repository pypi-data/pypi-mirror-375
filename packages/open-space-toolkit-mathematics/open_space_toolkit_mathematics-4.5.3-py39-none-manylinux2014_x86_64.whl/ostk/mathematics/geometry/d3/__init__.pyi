from __future__ import annotations
import numpy
import ostk.core.type
import typing
from . import object
from . import transformation
__all__ = ['Intersection', 'Object', 'Transformation', 'object', 'transformation']
class Intersection:
    class Type:
        """
        Members:
        
          Undefined
        
          Empty
        
          Point
        
          PointSet
        
          Line
        
          Ray
        
          Segment
        
          Plane
        
          Sphere
        
          Ellipsoid
        
          Complex
        """
        Complex: typing.ClassVar[Intersection.Type]  # value = <Type.Complex: 14>
        Ellipsoid: typing.ClassVar[Intersection.Type]  # value = <Type.Ellipsoid: 12>
        Empty: typing.ClassVar[Intersection.Type]  # value = <Type.Empty: 1>
        Line: typing.ClassVar[Intersection.Type]  # value = <Type.Line: 4>
        Plane: typing.ClassVar[Intersection.Type]  # value = <Type.Plane: 9>
        Point: typing.ClassVar[Intersection.Type]  # value = <Type.Point: 2>
        PointSet: typing.ClassVar[Intersection.Type]  # value = <Type.PointSet: 3>
        Ray: typing.ClassVar[Intersection.Type]  # value = <Type.Ray: 5>
        Segment: typing.ClassVar[Intersection.Type]  # value = <Type.Segment: 6>
        Sphere: typing.ClassVar[Intersection.Type]  # value = <Type.Sphere: 11>
        Undefined: typing.ClassVar[Intersection.Type]  # value = <Type.Undefined: 0>
        __members__: typing.ClassVar[dict[str, Intersection.Type]]  # value = {'Undefined': <Type.Undefined: 0>, 'Empty': <Type.Empty: 1>, 'Point': <Type.Point: 2>, 'PointSet': <Type.PointSet: 3>, 'Line': <Type.Line: 4>, 'Ray': <Type.Ray: 5>, 'Segment': <Type.Segment: 6>, 'Plane': <Type.Plane: 9>, 'Sphere': <Type.Sphere: 11>, 'Ellipsoid': <Type.Ellipsoid: 12>, 'Complex': <Type.Complex: 14>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def empty() -> Intersection:
        ...
    @staticmethod
    def line(line: object.Line) -> Intersection:
        ...
    @staticmethod
    def point(point: object.Point) -> Intersection:
        ...
    @staticmethod
    def point_set(point_set: object.PointSet) -> Intersection:
        ...
    @staticmethod
    def ray(ray: object.Ray) -> Intersection:
        ...
    @staticmethod
    def segment(segment: object.Segment) -> Intersection:
        ...
    @staticmethod
    def string_from_type(type: typing.Any) -> ostk.core.type.String:
        ...
    @staticmethod
    def undefined() -> Intersection:
        ...
    def __add__(self, arg0: Intersection) -> Intersection:
        ...
    def __eq__(self, arg0: Intersection) -> bool:
        ...
    def __iadd__(self, arg0: Intersection) -> Intersection:
        ...
    def __ne__(self, arg0: Intersection) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def access_composite(self) -> object.Composite:
        ...
    def as_composite(self) -> object.Composite:
        ...
    def as_ellipsoid(self) -> object.Ellipsoid:
        ...
    def as_line(self) -> object.Line:
        ...
    def as_line_string(self) -> object.LineString:
        ...
    def as_plane(self) -> object.Plane:
        ...
    def as_point(self) -> object.Point:
        ...
    def as_point_set(self) -> object.PointSet:
        ...
    def as_polygon(self) -> object.Polygon:
        ...
    def as_pyramid(self) -> object.Pyramid:
        ...
    def as_ray(self) -> object.Ray:
        ...
    def as_segment(self) -> object.Segment:
        ...
    def as_sphere(self) -> object.Sphere:
        ...
    def get_type(self) -> ...:
        ...
    def is_complex(self) -> bool:
        ...
    def is_composite(self) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_ellipsoid(self) -> bool:
        ...
    def is_empty(self) -> bool:
        ...
    def is_line(self) -> bool:
        ...
    def is_line_string(self) -> bool:
        ...
    def is_plane(self) -> bool:
        ...
    def is_point(self) -> bool:
        ...
    def is_point_set(self) -> bool:
        ...
    def is_polygon(self) -> bool:
        ...
    def is_pyramid(self) -> bool:
        ...
    def is_ray(self) -> bool:
        ...
    def is_segment(self) -> bool:
        ...
    def is_sphere(self) -> bool:
        ...
class Object:
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: Object) -> bool:
        ...
    def __ne__(self, arg0: Object) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def as_cone(self) -> ...:
        ...
    def as_ellipsoid(self) -> ...:
        ...
    def as_line(self) -> ...:
        ...
    def as_line_string(self) -> ...:
        ...
    def as_plane(self) -> ...:
        ...
    def as_point(self) -> ...:
        ...
    def as_point_set(self) -> ...:
        ...
    def as_polygon(self) -> ...:
        ...
    def as_pyramid(self) -> ...:
        ...
    def as_ray(self) -> ...:
        ...
    def as_segment(self) -> ...:
        ...
    def as_sphere(self) -> ...:
        ...
    def contains(self, arg0: Object) -> bool:
        ...
    def intersects(self, arg0: Object) -> bool:
        ...
    def is_cone(self) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_ellipsoid(self) -> bool:
        ...
    def is_line(self) -> bool:
        ...
    def is_line_string(self) -> bool:
        ...
    def is_plane(self) -> bool:
        ...
    def is_point(self) -> bool:
        ...
    def is_point_set(self) -> bool:
        ...
    def is_polygon(self) -> bool:
        ...
    def is_pyramid(self) -> bool:
        ...
    def is_ray(self) -> bool:
        ...
    def is_segment(self) -> bool:
        ...
    def is_sphere(self) -> bool:
        ...
class Transformation:
    class Type:
        """
        Members:
        
          Undefined
        
          Identity
        
          Translation
        
          Rotation
        
          Scaling
        
          Reflection
        
          Shear
        
          Affine
        """
        Affine: typing.ClassVar[Transformation.Type]  # value = <Type.Affine: 7>
        Identity: typing.ClassVar[Transformation.Type]  # value = <Type.Identity: 1>
        Reflection: typing.ClassVar[Transformation.Type]  # value = <Type.Reflection: 5>
        Rotation: typing.ClassVar[Transformation.Type]  # value = <Type.Rotation: 3>
        Scaling: typing.ClassVar[Transformation.Type]  # value = <Type.Scaling: 4>
        Shear: typing.ClassVar[Transformation.Type]  # value = <Type.Shear: 6>
        Translation: typing.ClassVar[Transformation.Type]  # value = <Type.Translation: 2>
        Undefined: typing.ClassVar[Transformation.Type]  # value = <Type.Undefined: 0>
        __members__: typing.ClassVar[dict[str, Transformation.Type]]  # value = {'Undefined': <Type.Undefined: 0>, 'Identity': <Type.Identity: 1>, 'Translation': <Type.Translation: 2>, 'Rotation': <Type.Rotation: 3>, 'Scaling': <Type.Scaling: 4>, 'Reflection': <Type.Reflection: 5>, 'Shear': <Type.Shear: 6>, 'Affine': <Type.Affine: 7>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def identity() -> Transformation:
        ...
    @staticmethod
    @typing.overload
    def rotation(rotation_vector: typing.Any) -> Transformation:
        ...
    @staticmethod
    @typing.overload
    def rotation(rotation_matrix: typing.Any) -> Transformation:
        ...
    @staticmethod
    def rotation_around(point: object.Point, rotation_vector: typing.Any) -> Transformation:
        ...
    @staticmethod
    def string_from_type(type: typing.Any) -> ostk.core.type.String:
        ...
    @staticmethod
    def translation(translation_vector: numpy.ndarray[numpy.float64[3, 1]]) -> Transformation:
        ...
    @staticmethod
    def type_of_matrix(matrix: numpy.ndarray[numpy.float64[4, 4]]) -> ...:
        ...
    @staticmethod
    def undefined() -> Transformation:
        ...
    def __eq__(self, arg0: Transformation) -> bool:
        ...
    def __init__(self, matrix: numpy.ndarray[numpy.float64[4, 4]]) -> None:
        ...
    def __ne__(self, arg0: Transformation) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def apply_to(self, point: object.Point) -> object.Point:
        ...
    @typing.overload
    def apply_to(self, vector: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_inverse(self) -> Transformation:
        ...
    def get_matrix(self) -> numpy.ndarray[numpy.float64[4, 4]]:
        ...
    def get_type(self) -> ...:
        ...
    def is_defined(self) -> bool:
        ...
