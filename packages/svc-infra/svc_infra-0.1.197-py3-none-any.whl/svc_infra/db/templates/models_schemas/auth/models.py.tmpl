from __future__ import annotations
from datetime import datetime
import uuid
from typing import Any, Callable, Dict, Iterable, Optional, Sequence, Tuple, Union

from sqlalchemy import (
    String, Boolean, DateTime, JSON, Text, func
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy.ext.mutable import MutableDict, MutableList

from fastapi_users.password import PasswordHelper

from svc_infra.db.base import ModelBase
from svc_infra.db.uniq import make_unique_indexes
from svc_infra.db.uniq_hooks import dedupe_service
from svc_infra.api.fastapi.db.repository import Repository

# ------------------------------ Model ------------------------------

class User(ModelBase):
    __tablename__ = "users"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    email: Mapped[str] = mapped_column(String(320), index=True, nullable=False)
    full_name: Mapped[Optional[str]] = mapped_column(String(255))
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    is_superuser: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    is_verified: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)

    # auth state
    password_hash: Mapped[str] = mapped_column(String(512), nullable=False)

    # Write-only facade over password
    @property
    def password(self) -> str:
        raise AttributeError("password is write-only")

    @password.setter
    def password(self, raw: str) -> None:
        self.password_hash = _pwd.hash(raw)

    last_login: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    disabled_reason: Mapped[Optional[str]] = mapped_column(Text)

    # org / roles / mfa
    tenant_id: Mapped[Optional[str]] = mapped_column(String(64), index=True)
    roles: Mapped[list[str]] = mapped_column(MutableList.as_mutable(JSON), default=list)
    mfa_enabled: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)

    # misc (avoid attr name 'metadata' clash)
    extra: Mapped[dict] = mapped_column("metadata", MutableDict.as_mutable(JSON), default=dict)

    # auditing (DB-side timestamps)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False
    )

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email!r}>"

# --- Uniqueness policy --------------------------------------------------------

# Unique indexes, including case-insensitive and/or tenant-scoped.
for _ix in make_unique_indexes(
        User,
        unique_ci=["email"],            # case-insensitive unique email
        tenant_field="tenant_id",       # scoped by tenant if provided
):
    # Simply iterating keeps them registered with the Table metadata.
    # (No further action needed if you use Alembic autogenerate or metadata.create_all.)
    pass

# --- User service factory ------------------------------------------------------

_pwd = PasswordHelper()

PreHook = Callable[[Dict[str, Any]], Dict[str, Any]]
ColumnSpec = Union[str, Sequence[str]]


def _map_user_fields(data: Dict[str, Any]) -> Dict[str, Any]:
    """Normalize inbound payload for our User model."""
    d = dict(data)
    # password -> password_hash
    if "password" in d:
        d["password_hash"] = _pwd.hash(d.pop("password"))
    # metadata(alias) -> extra(column)
    if "metadata" in d:
        d["extra"] = d.pop("metadata")
    # roles default
    d.setdefault("roles", [])
    return d


def _compose(*hooks: Optional[PreHook]) -> PreHook:
    """Chain multiple pre-hooks left-to-right, skipping Nones."""
    def _runner(payload: Dict[str, Any]) -> Dict[str, Any]:
        out = payload
        for h in hooks:
            if h:
                out = h(out)
        return out
    return _runner


def make_user_service(
        repo: Repository,
        *,
        # Uniqueness settings (rarely changed)
        unique_ci: Iterable[ColumnSpec] = ("email",),
        tenant_field: Optional[str] = "tenant_id",
        # Optional: caller can inject extra transforms/validation
        extra_pre_create: Optional[PreHook] = None,
        extra_pre_update: Optional[PreHook] = None,
        # Optional: customize 409 messages per spec if you want
        messages: Optional[dict[Tuple[str, ...], str]] = None,
):
    """
    Build a user-aware Service that:
      • Hashes passwords and maps payload fields (pre_create / pre_update)
      • Enforces case-insensitive unique email (optionally tenant-scoped)
      • Returns 409s like: "Record with email='x' already exists."
      • Lets you add extra pre-hooks if needed (kept simple for most apps)
    """
    # Compose our field mapper with any project-specific hooks
    pre_create = _compose(_map_user_fields, extra_pre_create)
    pre_update = _compose(_map_user_fields, extra_pre_update)

    # Reuse the generic dedupe service but inject our user pre-hooks
    return dedupe_service(
        repo,
        unique_ci=unique_ci,
        tenant_field=tenant_field,
        messages=messages,
        pre_create=pre_create,
        pre_update=pre_update,
    )