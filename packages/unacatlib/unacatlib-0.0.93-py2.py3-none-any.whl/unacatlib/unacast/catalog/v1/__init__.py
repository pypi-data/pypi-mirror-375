# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: unacast/catalog/v1/catalog.proto, unacast/catalog/v1/catalog_service.proto, unacast/catalog/v1/data_delivery.proto, unacast/catalog/v1/data_product_listing.proto, unacast/catalog/v1/data_product_listing_service.proto, unacast/catalog/v1/file_download_service.proto, unacast/catalog/v1/query_service.proto
# plugin: python-betterproto
# This file has been @generated
import warnings
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ... import unatype as __unatype__
from ...maps import v1 as __maps_v1__
from ...metric import v1 as __metric_v1__
from ...subscription import v1 as __subscription_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class TrimToPeriodOfExistence(betterproto.Enum):
    UNSPECIFIED = 0
    TRIM = 1
    IGNORE = 2


class DestinationConfigType(betterproto.Enum):
    BIG_QUERY = 0
    GCS = 1
    S3 = 2
    AZURE = 3


class DataDeliveryStatusType(betterproto.Enum):
    ENABLED = 0
    DISABLED = 1


class DataDeliveryStrategy(betterproto.Enum):
    UNSPECIFIED = 0
    FORWARD = 1
    EVERYTHING = 2
    DELTA = 3


class ColumnType(betterproto.Enum):
    UNSPECIFIED = 0
    INTEGER = 1
    FLOAT = 2
    DATE = 3
    BOOLEAN = 4
    STRING = 5


class Visibility(betterproto.Enum):
    UNSPECIFIED = 0
    EVERYONE = 1
    ACCESS_ONLY = 2
    HIDDEN = 3


class TargetKind(betterproto.Enum):
    UNSPECIFIED = 0
    FEATURE = 1
    ADDRESS_COMPONENT = 2
    RELATED_FEATURE = 3
    RELATED_ADDRESS_COMPONENT = 4
    DIMENSION = 5


class DeliverySourceType(betterproto.Enum):
    """! COPIES from catalo v2 to prevent cyclic dependencies"""

    METRIC = 0
    DATASET = 1
    LAYER_SERIES = 2


@dataclass(eq=False, repr=False)
class SearchMetricValuesRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    metric_id: str = betterproto.string_field(2)
    billing_context: str = betterproto.string_field(3)
    track_total_hits_boolean: bool = betterproto.bool_field(4, group="track_total_hits")
    track_total_hits_integer: int = betterproto.int64_field(
        12, group="track_total_hits"
    )
    best_effort_query_when_not_allowed: bool = betterproto.bool_field(11)
    """
    If true, the query will be executed even if the user filters on items it is not allowed to see
    """

    invert_sort_order: bool = betterproto.bool_field(9)
    """
    Temporary fix to get random feature IDs, if this view sticks this should be extracted into a separate API
    """

    feature_filter: List[str] = betterproto.string_field(5)
    """List of features by ID to limit the search to"""

    related_feature_filter: List[str] = betterproto.string_field(16)
    """List of related-features by ID to limit the search to"""

    observation_period_filter: "__metric_v1__.Period" = betterproto.message_field(6)
    """Filter clause to limit the time period of the search"""

    address_component_filter: List["__maps_v1__.AddressComponentFilter"] = (
        betterproto.message_field(7)
    )
    """
    Filter clause to limit the search to certain Address Component Values.
    """

    related_address_component_filter: List["__maps_v1__.AddressComponentFilter"] = (
        betterproto.message_field(10)
    )
    """
    Filter clause to limit the search to certain related Address Component Values.
    """

    dimension_filter: List["__metric_v1__.DimensionFilter"] = betterproto.message_field(
        8
    )
    """Filter clause to limit the search to certain Dimension Values."""

    value_filter: List["__metric_v1__.ValueFilter"] = betterproto.message_field(17)
    """
    Filter clause to limit the search to certain Metric Values which have Numeric Value Kind(COUNT; NUMBER).
    """

    request_tags: Dict[str, str] = betterproto.map_field(
        13, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    page_size: int = betterproto.int32_field(14)
    page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class SearchMetricValuesResponse(betterproto.Message):
    values: List["__metric_v1__.MetricValue"] = betterproto.message_field(1)
    applied_filters: "QueryMetricFilters" = betterproto.message_field(2)
    """All the filters applied to the request"""

    total_size: int = betterproto.int32_field(14)
    next_page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class SearchLayerFeaturesRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    layer_id: str = betterproto.string_field(2)
    billing_context: str = betterproto.string_field(3)
    feature_filter: List[str] = betterproto.string_field(5)
    """List of features by ID to limit the search to"""

    address_component_filter: List["__maps_v1__.AddressComponentFilter"] = (
        betterproto.message_field(7)
    )
    """
    Filter clause to limit the search to certain Address Component Values.
    """

    bounding_box_filter: "SearchFeatureBoundingBox" = betterproto.message_field(8)
    """
    If the bounding box is set, only return Features that falls within or intersects the bounding box
    """

    query: str = betterproto.string_field(9)
    """
    free text search query.
     This only sorts by relevance, and does not filter out any results.
     Setting this works in combination with filters.
     The query has fuzziness with edit-distance of 2 per word and splits on whitespace.
     The query is against address component display_names, and short_names.
    """

    track_total_hits: bool = betterproto.bool_field(10)
    page_size: int = betterproto.int32_field(14)
    page_token: str = betterproto.string_field(15)
    existed_in_date_range: "DateRange" = betterproto.message_field(16)
    address_component_whitelist: List[str] = betterproto.string_field(17)
    skip_polygon: bool = betterproto.bool_field(18)


@dataclass(eq=False, repr=False)
class DateRange(betterproto.Message):
    start_date: str = betterproto.string_field(1)
    end_date: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class SearchFeatureBoundingBox(betterproto.Message):
    """
    BoundingBox describes a square geofence - ie the "display area" of a map.
     Values are lat/lon (degrees)
    """

    west: float = betterproto.double_field(1)
    north: float = betterproto.double_field(2)
    east: float = betterproto.double_field(3)
    south: float = betterproto.double_field(4)


@dataclass(eq=False, repr=False)
class SearchLayerFeaturesResponse(betterproto.Message):
    features: List["__maps_v1__.Feature"] = betterproto.message_field(1)
    query_scores: List[float] = betterproto.float_field(10)
    """
    the score for each resulting record, zeros if not applicable
     higher score means higher relevance
     order is same as features, so match on index. e.g. features[0] has score[0]
    """

    total_size: int = betterproto.int32_field(14)
    next_page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class SearchAddressComponentValuesRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    component: str = betterproto.string_field(3)
    query: str = betterproto.string_field(5)
    value_ids: List[str] = betterproto.string_field(6)
    free_form_target: str = betterproto.string_field(7)
    page_size: int = betterproto.int32_field(14)
    page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class SearchAddressComponentValuesResponse(betterproto.Message):
    address_component_values: List["__maps_v1__.AddressComponentValue"] = (
        betterproto.message_field(1)
    )
    total_size: int = betterproto.int32_field(14)
    next_page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class SearchMetricReportRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    metric_id: str = betterproto.string_field(2)
    billing_context: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class QueryMetricFilters(betterproto.Message):
    period_filters: List["__metric_v1__.Period"] = betterproto.message_field(1)
    dimension_filters: List["__metric_v1__.DimensionFilter"] = (
        betterproto.message_field(2)
    )
    address_component_filters: List["__maps_v1__.AddressComponentFilter"] = (
        betterproto.message_field(3)
    )
    related_address_component_filters: List["__maps_v1__.AddressComponentFilter"] = (
        betterproto.message_field(7)
    )
    feature_filters: List[str] = betterproto.string_field(4)
    related_feature_filters: List[str] = betterproto.string_field(5)
    value_filters: List["__metric_v1__.ValueFilter"] = betterproto.message_field(6)
    trim_to_period_of_existence: "TrimToPeriodOfExistence" = betterproto.enum_field(8)
    """
    Trim to period of existence
     Optional. Only returns records within the period of existence of the feature.
     Default behaviour is to TRIM.
    
     Example: A feature has existed from 2020-01-01 to 2020-01-05.
     If TRIM is specified, only records from 2020-01-01 to 2020-01-05 are returned.
     If IGNORE is specified, all records are returned, but only the period of existence of the feature is considered when evaluating other filters.
    """


@dataclass(eq=False, repr=False)
class SearchMetricReportResponse(betterproto.Message):
    report: "__metric_v1__.MetricReport" = betterproto.message_field(1)
    applied_filters: "QueryMetricFilters" = betterproto.message_field(2)
    """All the filters applied to the request"""


@dataclass(eq=False, repr=False)
class SearchDimensionValuesRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    dimension_id: str = betterproto.string_field(2)
    query: str = betterproto.string_field(5)
    page_size: int = betterproto.int32_field(14)
    page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class SearchDimensionValuesResponse(betterproto.Message):
    dimension_values: List["__metric_v1__.DimensionValue"] = betterproto.message_field(
        1
    )
    total_size: int = betterproto.int32_field(14)
    next_page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class RankRequest(betterproto.Message):
    billing_context: str = betterproto.string_field(1)
    rank_group_configs: List["RankGroupConfig"] = betterproto.message_field(4)
    comparison_filters: List["__unatype__.FilterClause"] = betterproto.message_field(5)
    result_filters: List["__unatype__.FilterClause"] = betterproto.message_field(6)
    post_result_filters: List["__unatype__.FilterClause"] = betterproto.message_field(7)
    order_by: str = betterproto.string_field(12)
    page_size: int = betterproto.int32_field(14)
    page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class RankResponse(betterproto.Message):
    ranks: List["ValueRanks"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class ValueRanks(betterproto.Message):
    name: str = betterproto.string_field(1)
    display_name: str = betterproto.string_field(2)
    observation_period_start: str = betterproto.string_field(3)
    observation_period_end: str = betterproto.string_field(4)
    value_info: Dict[str, str] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    rank_groups: List["RankGroupValue"] = betterproto.message_field(7)
    cardinality: int = betterproto.int32_field(8)
    result_rank: int = betterproto.int32_field(9)


@dataclass(eq=False, repr=False)
class RankGroupConfig(betterproto.Message):
    name: str = betterproto.string_field(1)
    group_key: str = betterproto.string_field(2)
    value_name: str = betterproto.string_field(3)
    value_agg: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class RankGroupValue(betterproto.Message):
    rank_group: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    value: float = betterproto.double_field(3)
    rank: int = betterproto.int32_field(4)
    group_size: int = betterproto.int32_field(5)
    group_avg_value: float = betterproto.double_field(6)


@dataclass(eq=False, repr=False)
class BigQueryDestination(betterproto.Message):
    project_id: str = betterproto.string_field(1)
    dataset_id: str = betterproto.string_field(2)
    table_id: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class FileConfig(betterproto.Message):
    filename: str = betterproto.string_field(1)
    format: str = betterproto.string_field(2)
    compression: str = betterproto.string_field(3)
    field_delimiter: str = betterproto.string_field(4)
    header: bool = betterproto.bool_field(5)


@dataclass(eq=False, repr=False)
class GcsDestination(betterproto.Message):
    bucket: str = betterproto.string_field(1)
    path: str = betterproto.string_field(2)
    region: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class S3Destination(betterproto.Message):
    bucket: str = betterproto.string_field(1)
    path: str = betterproto.string_field(2)
    region: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class AzureDestination(betterproto.Message):
    blob_access_url: str = betterproto.string_field(1)
    container_name: str = betterproto.string_field(2)
    path: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class FileDestination(betterproto.Message):
    file_config: "FileConfig" = betterproto.message_field(2)
    s3_destination: "S3Destination" = betterproto.message_field(
        5, group="bucket_config"
    )
    gcs_destination: "GcsDestination" = betterproto.message_field(
        6, group="bucket_config"
    )
    azure_destination: "AzureDestination" = betterproto.message_field(
        7, group="bucket_config"
    )


@dataclass(eq=False, repr=False)
class DataDeliveryFilters(betterproto.Message):
    feature_filter: List[str] = betterproto.string_field(1)
    """List of features by ID to limit the delivery to"""

    related_feature_filter: List[str] = betterproto.string_field(6)
    """List of related features by ID to limit the delivery to"""

    address_component_filter: List["__maps_v1__.AddressComponentFilter"] = (
        betterproto.message_field(2)
    )
    """
    Filter clause to limit the delivery to certain Address Component Values.
    """

    related_address_component_filter: List["__maps_v1__.AddressComponentFilter"] = (
        betterproto.message_field(7)
    )
    """
    Filter clause to limit the delivery to certain related Address Component Values.
    """

    dimension_filter: List["__metric_v1__.DimensionFilter"] = betterproto.message_field(
        3
    )
    """Filter clause to limit the delivery to certain Dimension Values."""

    start_date: "__unatype__.Date" = betterproto.message_field(4)
    """Date from which the delivery will be started"""

    end_date: "__unatype__.Date" = betterproto.message_field(5)
    """
    TODO turn into an optional field once it is supported by proto-gen-validate https://github.com/envoyproxy/protoc-gen-validate/issues/431
     Optional end date of the delivery, if not set (all zeros), it will be continuously delivered ad infinitum
     The date can be in the future, meaning the delivery will be updated until that end_date
    """

    trim_to_period_of_existence: "TrimToPeriodOfExistence" = betterproto.enum_field(8)
    """
    Trim to period of existence
     Optional. Only returns records within the period of existence of the feature.
     Default behaviour is to TRIM.
    
     Example: A feature has existed from 2020-01-01 to 2020-01-05.
     If TRIM is specified, only records from 2020-01-01 to 2020-01-05 are returned.
     If IGNORE is specified, all records are returned, but only the period of existence of the feature is considered when evaluating other filters.
    """


@dataclass(eq=False, repr=False)
class DataProductListing(betterproto.Message):
    name: str = betterproto.string_field(1)
    display_name: str = betterproto.string_field(2)
    layer_id: str = betterproto.string_field(3)
    data_listings: List["DataListing"] = betterproto.message_field(4)
    filters: List["__unatype__.FilterClause"] = betterproto.message_field(5)
    available_filters: List["DataProductListingFilterDefinition"] = (
        betterproto.message_field(6)
    )
    default_start_date: str = betterproto.string_field(7)
    created_time: str = betterproto.string_field(8)
    created_by: str = betterproto.string_field(9)
    description: str = betterproto.string_field(10)
    short_description: str = betterproto.string_field(11)
    visibility: "Visibility" = betterproto.enum_field(12)
    country: str = betterproto.string_field(13)
    location_kind: str = betterproto.string_field(14)
    location_name: str = betterproto.string_field(15)
    product_type: str = betterproto.string_field(16)


@dataclass(eq=False, repr=False)
class OperatingOrganization(betterproto.Message):
    name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DataListing(betterproto.Message):
    name: str = betterproto.string_field(1)
    source_id: str = betterproto.string_field(2)
    source_type: "DeliverySourceType" = betterproto.enum_field(3)
    catalog_id: str = betterproto.string_field(4)
    delivery_columns: List["DataListingColumn"] = betterproto.message_field(5)
    display_name: str = betterproto.string_field(6)
    included_by_default: bool = betterproto.bool_field(7)
    created_time: str = betterproto.string_field(8)
    created_by: str = betterproto.string_field(9)
    data_product_listing_name: str = betterproto.string_field(10)
    description: str = betterproto.string_field(11)
    short_description: str = betterproto.string_field(12)
    visibility: "Visibility" = betterproto.enum_field(13)
    operating_organizations: List["OperatingOrganization"] = betterproto.message_field(
        14
    )
    local_name: str = betterproto.string_field(15)
    supply_source: str = betterproto.string_field(16)
    product_type: str = betterproto.string_field(17)


@dataclass(eq=False, repr=False)
class DataListingColumn(betterproto.Message):
    source_column: str = betterproto.string_field(1)
    """
    Structure: [Namespace].[column_id].[type]
     Namespace because columns are sourced from different aspects and may not have unique IDs across asspects (address_component and features may both have a column with id X)
     Type because the same column can be included in different ways (ie id or value of related item). Maps internally to `unacast.v2.metric.ColumnKind`/`unacast.v2.metric.Column.type`
    """

    target_column_name: str = betterproto.string_field(2)
    included_by_default: bool = betterproto.bool_field(3)
    description: str = betterproto.string_field(4)
    type: "ColumnType" = betterproto.enum_field(5)
    documentation_url: str = betterproto.string_field(6)
    example_value: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class DataProductListingFilterDefinition(betterproto.Message):
    ref: str = betterproto.string_field(1)
    label: str = betterproto.string_field(2)
    kind: "TargetKind" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DeliveryColumn(betterproto.Message):
    """
    Provided as a way of explicitly describe a column to deliver. Can translate to unacast.v2.metric.DataSchema that is usually provided with the metric creation, but removes the fuzz and allows ordering of columns
    """

    source_column: str = betterproto.string_field(1)
    """
    Structure: [Namespace].[column_id].[type] - to be provided alongside the Column in the default_schema to the frontend?
     Namespace because columns are sourced from different aspects and may not have unique IDs across asspects (address_component and features may both have a column with id X)
     Type because the same column can be included in different ways (ie id or value of related item). Maps internally to `unacast.v2.metric.ColumnKind`/`unacast.v2.metric.Column.type`
    """

    target_column_name: str = betterproto.string_field(2)
    """
    The columns name in the delivery. Maps to `user_friendly_name` of unacast.v2.metric.DataSchema
    """


@dataclass(eq=False, repr=False)
class Catalog(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class GetCatalogRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ListCatalogsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListCatalogsResponse(betterproto.Message):
    catalogs: List["Catalog"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GetMetricRequestOptions(betterproto.Message):
    skip_layers: bool = betterproto.bool_field(1)
    skip_dimensions: bool = betterproto.bool_field(2)
    skip_subscription_status: bool = betterproto.bool_field(3)
    skip_observation_period: bool = betterproto.bool_field(4)
    skip_lens: bool = betterproto.bool_field(5)


@dataclass(eq=False, repr=False)
class GetMetricRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    metric_id: str = betterproto.string_field(2)
    billing_context: str = betterproto.string_field(3)
    options: "GetMetricRequestOptions" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class GetMetricResponse(betterproto.Message):
    metric: "__metric_v1__.Metric" = betterproto.message_field(1)
    complete_observation_period: "__metric_v1__.Period" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ListMetricsRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    billing_context: str = betterproto.string_field(2)
    layer_filter: List[str] = betterproto.string_field(5)
    availability_filter: List["__unatype__.AvailabilityKind"] = betterproto.enum_field(
        6
    )
    page_size: int = betterproto.int32_field(14)
    page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class ListMetricsResponse(betterproto.Message):
    metrics: List["__metric_v1__.Metric"] = betterproto.message_field(1)
    next_page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class GetLayerRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    layer_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetLayerResponse(betterproto.Message):
    layer: "__maps_v1__.Layer" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryLayerRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    layer_id: str = betterproto.string_field(2)
    address_component_filter: List["__maps_v1__.AddressComponentFilter"] = (
        betterproto.message_field(5)
    )
    page_size: int = betterproto.int32_field(14)
    page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class QueryLayerResponse(betterproto.Message):
    features: List["__maps_v1__.Feature"] = betterproto.message_field(4)
    total_size: int = betterproto.int32_field(14)
    next_page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class DownloadMetricRequest(betterproto.Message):
    catalog_id: str = betterproto.string_field(1)
    metric_id: str = betterproto.string_field(2)
    billing_context: str = betterproto.string_field(3)
    file_name: str = betterproto.string_field(6)
    expiry_in_hours: int = betterproto.int64_field(10)


@dataclass(eq=False, repr=False)
class DownloadResponse(betterproto.Message):
    download_id: str = betterproto.string_field(1)
    file_urls: List[str] = betterproto.string_field(2)
    expires_at: str = betterproto.string_field(10)


@dataclass(eq=False, repr=False)
class GetDataProductListingRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    billing_context: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GetDataProductListingResponse(betterproto.Message):
    data_product_listing: "DataProductListing" = betterproto.message_field(1)
    data_listing_accesses: Dict[str, "DataListingAccess"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class ListDataProductListingsRequest(betterproto.Message):
    filter: str = betterproto.string_field(1)
    billing_context: str = betterproto.string_field(2)
    page_size: int = betterproto.int32_field(14)
    page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class ListDataProductListingsResponse(betterproto.Message):
    data_product_listings: List["DataProductListing"] = betterproto.message_field(1)
    data_listing_accesses: Dict[str, "DataListingAccess"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    next_page_token: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class DataListingAccess(betterproto.Message):
    access_kind: "__subscription_v1__.SubscriptionAccessKind" = betterproto.enum_field(
        2
    )


@dataclass(eq=False, repr=False)
class CreateDataProductListingRequest(betterproto.Message):
    """
    The editorial fileds (display_name, description, etc.) of the data product listing is managed by sanity. Sanity refers to the data product listing by the name.
    """

    name: str = betterproto.string_field(1)
    layer_id: str = betterproto.string_field(3)
    """string display_name = 2;"""

    data_listings: List["DataListing"] = betterproto.message_field(4)
    filters: List["__unatype__.FilterClause"] = betterproto.message_field(5)
    available_filters: List["DataProductListingFilterDefinition"] = (
        betterproto.message_field(6)
    )
    default_start_date: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class CreateDataListingRequest(betterproto.Message):
    """
    The editorial fileds (display_name, description, etc.) of the data listing is managed by sanity. Sanity refers to the data listing by the name.
    """

    name: str = betterproto.string_field(1)
    source_id: str = betterproto.string_field(2)
    source_type: "DeliverySourceType" = betterproto.enum_field(3)
    catalog_id: str = betterproto.string_field(4)
    delivery_columns: List["DeliveryColumn"] = betterproto.message_field(5)
    included_by_default: bool = betterproto.bool_field(6)


@dataclass(eq=False, repr=False)
class GetDataListingRequest(betterproto.Message):
    data_product_listing_name: str = betterproto.string_field(1)
    data_listing_name: str = betterproto.string_field(2)
    billing_context: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class GetDataListingResponse(betterproto.Message):
    data_listing: "DataListing" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class UpdateDataProductListingRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    field_mask: str = betterproto.string_field(2)
    filters: List["__unatype__.FilterClause"] = betterproto.message_field(3)
    available_filters: List["DataProductListingFilterDefinition"] = (
        betterproto.message_field(4)
    )
    default_start_date: str = betterproto.string_field(5)


class QueryServiceStub(betterproto.ServiceStub):
    async def search_metric_values(
        self,
        search_metric_values_request: "SearchMetricValuesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SearchMetricValuesResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.QueryService/SearchMetricValues",
            search_metric_values_request,
            SearchMetricValuesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_layer_features(
        self,
        search_layer_features_request: "SearchLayerFeaturesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SearchLayerFeaturesResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.QueryService/SearchLayerFeatures",
            search_layer_features_request,
            SearchLayerFeaturesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_address_component_values(
        self,
        search_address_component_values_request: "SearchAddressComponentValuesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SearchAddressComponentValuesResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.QueryService/SearchAddressComponentValues",
            search_address_component_values_request,
            SearchAddressComponentValuesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_dimension_values(
        self,
        search_dimension_values_request: "SearchDimensionValuesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SearchDimensionValuesResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.QueryService/SearchDimensionValues",
            search_dimension_values_request,
            SearchDimensionValuesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def search_metric_report(
        self,
        search_metric_report_request: "SearchMetricReportRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "SearchMetricReportResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.QueryService/SearchMetricReport",
            search_metric_report_request,
            SearchMetricReportResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def rank(
        self,
        rank_request: "RankRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RankResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.QueryService/Rank",
            rank_request,
            RankResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class CatalogServiceStub(betterproto.ServiceStub):
    async def list_catalogs(
        self,
        list_catalogs_request: "ListCatalogsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListCatalogsResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.CatalogService/ListCatalogs",
            list_catalogs_request,
            ListCatalogsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_metric(
        self,
        get_metric_request: "GetMetricRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetMetricResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.CatalogService/GetMetric",
            get_metric_request,
            GetMetricResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_metrics(
        self,
        list_metrics_request: "ListMetricsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListMetricsResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.CatalogService/ListMetrics",
            list_metrics_request,
            ListMetricsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_layer(
        self,
        get_layer_request: "GetLayerRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetLayerResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.CatalogService/GetLayer",
            get_layer_request,
            GetLayerResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_layer(
        self,
        query_layer_request: "QueryLayerRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryLayerResponse":
        warnings.warn("CatalogService.query_layer is deprecated", DeprecationWarning)

        return await self._unary_unary(
            "/unacast.catalog.v1.CatalogService/QueryLayer",
            query_layer_request,
            QueryLayerResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class FileDownloadServiceStub(betterproto.ServiceStub):
    async def download_metric(
        self,
        download_metric_request: "DownloadMetricRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DownloadResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.FileDownloadService/DownloadMetric",
            download_metric_request,
            DownloadResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class DataProductListingServiceStub(betterproto.ServiceStub):
    async def get_data_product_listing(
        self,
        get_data_product_listing_request: "GetDataProductListingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDataProductListingResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.DataProductListingService/GetDataProductListing",
            get_data_product_listing_request,
            GetDataProductListingResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_data_product_listings(
        self,
        list_data_product_listings_request: "ListDataProductListingsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListDataProductListingsResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.DataProductListingService/ListDataProductListings",
            list_data_product_listings_request,
            ListDataProductListingsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_data_product_listing(
        self,
        create_data_product_listing_request: "CreateDataProductListingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DataProductListing":
        return await self._unary_unary(
            "/unacast.catalog.v1.DataProductListingService/CreateDataProductListing",
            create_data_product_listing_request,
            DataProductListing,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_data_listing(
        self,
        get_data_listing_request: "GetDataListingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDataListingResponse":
        return await self._unary_unary(
            "/unacast.catalog.v1.DataProductListingService/GetDataListing",
            get_data_listing_request,
            GetDataListingResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_data_product_listing(
        self,
        update_data_product_listing_request: "UpdateDataProductListingRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DataProductListing":
        return await self._unary_unary(
            "/unacast.catalog.v1.DataProductListingService/UpdateDataProductListing",
            update_data_product_listing_request,
            DataProductListing,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryServiceBase(ServiceBase):

    async def search_metric_values(
        self, search_metric_values_request: "SearchMetricValuesRequest"
    ) -> "SearchMetricValuesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_layer_features(
        self, search_layer_features_request: "SearchLayerFeaturesRequest"
    ) -> "SearchLayerFeaturesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_address_component_values(
        self,
        search_address_component_values_request: "SearchAddressComponentValuesRequest",
    ) -> "SearchAddressComponentValuesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_dimension_values(
        self, search_dimension_values_request: "SearchDimensionValuesRequest"
    ) -> "SearchDimensionValuesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def search_metric_report(
        self, search_metric_report_request: "SearchMetricReportRequest"
    ) -> "SearchMetricReportResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def rank(self, rank_request: "RankRequest") -> "RankResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_search_metric_values(
        self,
        stream: "grpclib.server.Stream[SearchMetricValuesRequest, SearchMetricValuesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_metric_values(request)
        await stream.send_message(response)

    async def __rpc_search_layer_features(
        self,
        stream: "grpclib.server.Stream[SearchLayerFeaturesRequest, SearchLayerFeaturesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_layer_features(request)
        await stream.send_message(response)

    async def __rpc_search_address_component_values(
        self,
        stream: "grpclib.server.Stream[SearchAddressComponentValuesRequest, SearchAddressComponentValuesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_address_component_values(request)
        await stream.send_message(response)

    async def __rpc_search_dimension_values(
        self,
        stream: "grpclib.server.Stream[SearchDimensionValuesRequest, SearchDimensionValuesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_dimension_values(request)
        await stream.send_message(response)

    async def __rpc_search_metric_report(
        self,
        stream: "grpclib.server.Stream[SearchMetricReportRequest, SearchMetricReportResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.search_metric_report(request)
        await stream.send_message(response)

    async def __rpc_rank(
        self, stream: "grpclib.server.Stream[RankRequest, RankResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.rank(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/unacast.catalog.v1.QueryService/SearchMetricValues": grpclib.const.Handler(
                self.__rpc_search_metric_values,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchMetricValuesRequest,
                SearchMetricValuesResponse,
            ),
            "/unacast.catalog.v1.QueryService/SearchLayerFeatures": grpclib.const.Handler(
                self.__rpc_search_layer_features,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchLayerFeaturesRequest,
                SearchLayerFeaturesResponse,
            ),
            "/unacast.catalog.v1.QueryService/SearchAddressComponentValues": grpclib.const.Handler(
                self.__rpc_search_address_component_values,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchAddressComponentValuesRequest,
                SearchAddressComponentValuesResponse,
            ),
            "/unacast.catalog.v1.QueryService/SearchDimensionValues": grpclib.const.Handler(
                self.__rpc_search_dimension_values,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchDimensionValuesRequest,
                SearchDimensionValuesResponse,
            ),
            "/unacast.catalog.v1.QueryService/SearchMetricReport": grpclib.const.Handler(
                self.__rpc_search_metric_report,
                grpclib.const.Cardinality.UNARY_UNARY,
                SearchMetricReportRequest,
                SearchMetricReportResponse,
            ),
            "/unacast.catalog.v1.QueryService/Rank": grpclib.const.Handler(
                self.__rpc_rank,
                grpclib.const.Cardinality.UNARY_UNARY,
                RankRequest,
                RankResponse,
            ),
        }


class CatalogServiceBase(ServiceBase):

    async def list_catalogs(
        self, list_catalogs_request: "ListCatalogsRequest"
    ) -> "ListCatalogsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_metric(
        self, get_metric_request: "GetMetricRequest"
    ) -> "GetMetricResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_metrics(
        self, list_metrics_request: "ListMetricsRequest"
    ) -> "ListMetricsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_layer(
        self, get_layer_request: "GetLayerRequest"
    ) -> "GetLayerResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_layer(
        self, query_layer_request: "QueryLayerRequest"
    ) -> "QueryLayerResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_list_catalogs(
        self, stream: "grpclib.server.Stream[ListCatalogsRequest, ListCatalogsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_catalogs(request)
        await stream.send_message(response)

    async def __rpc_get_metric(
        self, stream: "grpclib.server.Stream[GetMetricRequest, GetMetricResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_metric(request)
        await stream.send_message(response)

    async def __rpc_list_metrics(
        self, stream: "grpclib.server.Stream[ListMetricsRequest, ListMetricsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_metrics(request)
        await stream.send_message(response)

    async def __rpc_get_layer(
        self, stream: "grpclib.server.Stream[GetLayerRequest, GetLayerResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_layer(request)
        await stream.send_message(response)

    async def __rpc_query_layer(
        self, stream: "grpclib.server.Stream[QueryLayerRequest, QueryLayerResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_layer(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/unacast.catalog.v1.CatalogService/ListCatalogs": grpclib.const.Handler(
                self.__rpc_list_catalogs,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListCatalogsRequest,
                ListCatalogsResponse,
            ),
            "/unacast.catalog.v1.CatalogService/GetMetric": grpclib.const.Handler(
                self.__rpc_get_metric,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetMetricRequest,
                GetMetricResponse,
            ),
            "/unacast.catalog.v1.CatalogService/ListMetrics": grpclib.const.Handler(
                self.__rpc_list_metrics,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListMetricsRequest,
                ListMetricsResponse,
            ),
            "/unacast.catalog.v1.CatalogService/GetLayer": grpclib.const.Handler(
                self.__rpc_get_layer,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetLayerRequest,
                GetLayerResponse,
            ),
            "/unacast.catalog.v1.CatalogService/QueryLayer": grpclib.const.Handler(
                self.__rpc_query_layer,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLayerRequest,
                QueryLayerResponse,
            ),
        }


class FileDownloadServiceBase(ServiceBase):

    async def download_metric(
        self, download_metric_request: "DownloadMetricRequest"
    ) -> "DownloadResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_download_metric(
        self, stream: "grpclib.server.Stream[DownloadMetricRequest, DownloadResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.download_metric(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/unacast.catalog.v1.FileDownloadService/DownloadMetric": grpclib.const.Handler(
                self.__rpc_download_metric,
                grpclib.const.Cardinality.UNARY_UNARY,
                DownloadMetricRequest,
                DownloadResponse,
            ),
        }


class DataProductListingServiceBase(ServiceBase):

    async def get_data_product_listing(
        self, get_data_product_listing_request: "GetDataProductListingRequest"
    ) -> "GetDataProductListingResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_data_product_listings(
        self, list_data_product_listings_request: "ListDataProductListingsRequest"
    ) -> "ListDataProductListingsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_data_product_listing(
        self, create_data_product_listing_request: "CreateDataProductListingRequest"
    ) -> "DataProductListing":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_data_listing(
        self, get_data_listing_request: "GetDataListingRequest"
    ) -> "GetDataListingResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_data_product_listing(
        self, update_data_product_listing_request: "UpdateDataProductListingRequest"
    ) -> "DataProductListing":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_data_product_listing(
        self,
        stream: "grpclib.server.Stream[GetDataProductListingRequest, GetDataProductListingResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_data_product_listing(request)
        await stream.send_message(response)

    async def __rpc_list_data_product_listings(
        self,
        stream: "grpclib.server.Stream[ListDataProductListingsRequest, ListDataProductListingsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_data_product_listings(request)
        await stream.send_message(response)

    async def __rpc_create_data_product_listing(
        self,
        stream: "grpclib.server.Stream[CreateDataProductListingRequest, DataProductListing]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_data_product_listing(request)
        await stream.send_message(response)

    async def __rpc_get_data_listing(
        self,
        stream: "grpclib.server.Stream[GetDataListingRequest, GetDataListingResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_data_listing(request)
        await stream.send_message(response)

    async def __rpc_update_data_product_listing(
        self,
        stream: "grpclib.server.Stream[UpdateDataProductListingRequest, DataProductListing]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_data_product_listing(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/unacast.catalog.v1.DataProductListingService/GetDataProductListing": grpclib.const.Handler(
                self.__rpc_get_data_product_listing,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDataProductListingRequest,
                GetDataProductListingResponse,
            ),
            "/unacast.catalog.v1.DataProductListingService/ListDataProductListings": grpclib.const.Handler(
                self.__rpc_list_data_product_listings,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListDataProductListingsRequest,
                ListDataProductListingsResponse,
            ),
            "/unacast.catalog.v1.DataProductListingService/CreateDataProductListing": grpclib.const.Handler(
                self.__rpc_create_data_product_listing,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateDataProductListingRequest,
                DataProductListing,
            ),
            "/unacast.catalog.v1.DataProductListingService/GetDataListing": grpclib.const.Handler(
                self.__rpc_get_data_listing,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDataListingRequest,
                GetDataListingResponse,
            ),
            "/unacast.catalog.v1.DataProductListingService/UpdateDataProductListing": grpclib.const.Handler(
                self.__rpc_update_data_product_listing,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateDataProductListingRequest,
                DataProductListing,
            ),
        }
