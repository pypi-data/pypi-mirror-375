.. _template-label:

===============
Template module
===============

Introduction
============

To configure a JETTO run, you start by creating a *template*. Templates are based on files taken from an existing JETTO
run. A template may consist of a large number of files, depending on the complexity of the run, but at minimum it will
contain the following:

- A JETTO settings (JSET) file (typically called ``jetto.jset``)
- A JETTO namelist file (typically called ``jetto.in``)

Most templates will also contain a lookup file (typically called ``lookup.json``), but this is not strictly required.
Omitting a lookup file can be convenient if you wish to make no or only very basic changes to the template before
running it. For modification of most template parameters, a lookup file will be required.

The JSET file is generated by the JAMS application when a JETTO run is submitted: it contains a complete copy of the
JAMS internal configuration. See the :ref:`jset <jset-label>` module documenation for more information about the
contents, format and handling of JSET files.(Note that initializing a template will **automatically collapse** any
arrays within its internal JSET instance, in order to facilitate settings modification and setting up scans. These
arrays will be **automatically expanded** upon export. See also :ref:`Collapsing JSET vector settings <jset-collapse-vectors-label>`).

The JETTO namelist file consists of parameters passed to the JETTO executable at run time, in Fortran namelist format.
See the :ref:`namelist <nml-label>` module documentation for more information about the contents, format and handling of
namelist files.

A lookup file is used by the ``template`` module to relate the contents of the JSET file to those of the namelist file.
See the :ref:`lookup <lookup-label>` module documentation for more information about the contents, format and handling
of lookup files.

In addition to these files, a template can optionally contain a large number of other files, including:

* A *SANCO namelist* file (``jetto.sin``)
* An *ex-file* (``jetto.ex``)
* GRAY parameter files (``gray.data`` and ``graybeam.data``)
* ... and many others

The full list (at the time of writing) can be found in the file ``cmg/configs/retrieve/jetto`` within the ``JINTRAC``
source tree. The majority of these extra files are handled by the ``template`` module in a simple way, whereby the
files are included in a template, but cannot be modified via this API. The exception is the SANCO namelist file, which
if present is handled in an identical way to the mandatory JETTO namelist file, and can be modified via the
configuration API (see the :ref:`config <config-label>` module documentation for more information).

Basic usage
===========

Creating a template
-------------------

We will first of all show the manual way of creating a template, to demonstrate how templates are
constructed from individual components, before demonstrating some short-cuts that can be used in a variety of standard
situations.

As an example, let's assume that the current working directory contains JETTO run, with a JSET, JETTO namelist and
lookup file (the minimum set of files required to create a template). We start by creating Python objects corresponding
to each of the files, using the functionality provided by their respective ``jetto_tools`` modules:

.. highlight:: python

>>> import jetto_tools.jset
>>> import jetto_tools.namelist
>>> import jetto_tools.lookup
>>> jset = jetto_tools.jset.read('jetto.jset')
>>> namelist = jetto_tools.namelist.read('jetto.in')
>>> lookup = jetto_tools.lookup.from_file('lookup.json')

Now that we have the objects we need, we can combine them into a template:

.. highlight:: python

>>> import jetto_tools.template
>>> template = jetto_tools.template.Template(jset, namelist, lookup)

The ``Template`` class performs some :ref:`validation <template_checks-label>`to make sure that the provided files are
consistent with each other.

If we want to include a SANCO namelists file (typically called ``jetto.sin``) in the template, we can also pass it to
the template constructor as an optional keyword argument. Since the SANCO namelist file is in the same format as the
JETTO namelist file, we can use the ``namelist`` module to handle it in the same way:

.. highlight:: python

>>> sanco_namelist = jetto_tools.namelist.read('jetto.sin')
>>> template = jetto_tools.template.Template(jset, namelist, lookup, sanco_namelist=sanco_namelist)

If there are other non-mandatory files which we want to include in the template (e.g. ``jetto.ex``), then we can pass
their paths to the ``Template`` constructor using the ``extra_files`` keyword argument. This argument is a dictionary
whose keys are the relative paths to the extra template files, with respect to the run directory, and whose values are
the full paths to the files:

.. highlight:: python

>>> sanco_namelist = jetto_tools.namelist.read('jetto.sin')
>>> template = jetto_tools.template.Template(jset, namelist, lookup, extra_files={'jetto.ex': '/path/to/jetto.ex', 'jetto.bnd': '/path/to/jetto.bnd'})

Note that although the SANCO namelist file (``jetto.sin``) is an optional file, it cannot be handled using the
``extra_files`` argument: it must be supplied to the Template as an object using the ``sanco_namelist`` argument.

Loading a template from a run directory
---------------------------------------

Since it will often be the case that we want to use an existing JETTO run directory as a template, the ``template``
module provides a short-cut function which simplifies the process of creating a template from the contents of a
directory, by simply passing the path to the directory to the ``from_directory`` function. For example:

.. highlight:: python

>>> template = jetto_tools.template.from_directory('~/jetto/runs/myrun')

Note that the ``from_directory`` function is greedy, in the sense that it will include as many template files as
possible from the run directory.

Also note that ``from_directory`` does not currently support restarted cases. This is due to the JINTRAC ``retrieve``
script not supporting private cases, which causes JETTO to use the wrong restart files and give incorect output.

Loading a template from the catalogue
-------------------------------------

A template can be loaded from a catalogued JETTO run, if there is a local catalogue available. In a similar manner to
JAMS, the load requires the components of the catalogue location: namely, the ``owner``, ``machine``, ``shot``, ``date``
and ``sequence`` identifiers, in addition to the path to the template lookup file e.g.

.. highlight:: python

>>> template = jetto_tools.template.from_catalogue('fcasson', 'jet', 92398, 'dec1318', 1, './lookup.json')

Note that, unlike in JAMS, it is not required to supply a ``code`` identifier: the ``code`` is automatically set
to ``'jetto'``. By default, the catalogue files are retrieved to the directory ``.retrieval`` in the current working
directory: this can be overridden using the ``retrieval_dir`` keyword argument.

Calling ``from_catalogue`` triggers a call to the ``retrieve`` script provided by the active JINTRAC module. The
catalogue files are retrieved to the retrieval directory, from where they are loaded into the returned ``template``
object.

If the user wishes to retrieve a case to continue rather than repeat, the ``from_catalogue`` function provides an
keyword argument, ``continue_run``, which if set to ``True``, causes the call to the ``retrieve`` script to
include the ``-c`` switch indicating a continuing run e.g.

.. highlight:: python

>>> template = jetto_tools.template.from_catalogue('fcasson', 'jet', 92398, 'dec1318', 1, './lookup.json', continue_run=True)

Note that if no explicit retrieval directory is provided, the ``from_catalogue`` call will create a directory in the
current working directory which will hold the retrieved catalogue files. It is the user's responsibility to clean up
this directory when they are finished with the ``template`` instance (note that the ``template`` instance will contain
references to the files within the retrieval directory: deleting the directory prior to the ``template`` instance being
deleted will cause the template to be invalid).

Accessing template contents
---------------------------

Each of the constituents of the template can be accessed as a property of the ``Template`` class. For the JSET, JETTO
namelist, SANCO namelist and lookup files, they can be accessed via the properties ``jset``, ``namelist``,
``sanco_namelist`` and ``lookup``, respectively. These properties all return the corresponding object. If no SANCO
namelist exists in the template, its property will return ``None``.

For the extra files, there is also a property, ``extra_files``. This property returns the extra files as a dictionary,
where the file name is the key and the file path is the value. For example:

.. highlight:: python

>>> template = jetto_tools.template.Template(jset, namelist, lookup, extra_files=['/path/to/jetto.ex'])
>>> template.extra_files
{'jetto.ex': '/path/to/jetto.ex'}

This facilitates checking of whether a particular file is in the extra files or not.

.. _template_checks-label:

Template checks
===============

The main purpose of the ``Template`` class is to enforce consistency between the multiple files making up the JETTO
configuration. To this end, the ``Template`` class constructor performs a number of consistency checks. These all
revolve around using the lookup file as a source of truth: the template checks then involve checking the JSET and
namelist file(s) against the lookup file.

The checks are as follows:

* The lookup file is validated against the general lookup schema defined by the ``lookup`` module.
* For each parameter in the lookup file, the parameter's ``jset_id`` must exist within the JSET file (unless the
  ``jset_id`` is ``null`` - see below)
* For each parameter in the lookup file, the parameter's ``field`` must exist within the JETTO extra namelists or the
  SANCO extra namelists
* If the parameter's ``jset_id`` is ``null``, then the ``field`` part of the ``nml_id`` must exist within the JETTO
  extra namelists or the SANCO extra namelists.
* If the parameter's ``jset_id`` is ``null``, then the mapping of the lookup file's ``nml_id`` to the JETTO/SANCO
  namelist file must match the mapping to the JSET's JETTO/SANCO extra namelist section i.e. if a parameter's ``nml_id``
  appears in the JETTO namelist file, it must also appear in the JETTO extra namelist section of the JSET, and
  correspondingly for parameters which appear in the SANCO namelist file.
* The type of the parameter (given by the ``type`` field) must match the value of the parameter in the JSET file (or the
  value must be trivially convertible to that type). It is not allowed for the parameter's value to be empty in the JSET.
* If the parameter's ``jset_id`` is ``null``, then the parameter must be a scalar parameter within the corresponding
  extra namelists section of the JSET
* If the ``jset.impurities`` field is ``True``, and the ``jset.sanco`` field is True (indicating that impurities are
  enabled and that SANCO is selected as the impurities source), then a SANCO namelist file must exist in the template.

Failure of any of the above checks will trigger a ``TemplateError`` when the ``Template`` class constructor is called.

API reference
=============

.. autoclass:: jetto_tools.template.Template
    :members: __init__, jset, namelist, lookup, sanco_namelist, extra_files, is_regular_param, validate_regular_param, validate_extra_namelist_param, validate_extra_namelist_param_details, collapse_jset, expand_jset

.. autofunction:: jetto_tools.template.from_directory
.. autofunction:: jetto_tools.template.from_catalogue
