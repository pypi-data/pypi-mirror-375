
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "util"

@_ods_cext.register_operation(_Dialect)
class AlignOp(_ods_ir.OpView):
  OPERATION_NAME = "util.align"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, alignment, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(alignment)
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def alignment(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def align(value, alignment, *, loc=None, ip=None) -> _ods_ir.Value:
  return AlignOp(value=value, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AssumeIntOp(_ods_ir.OpView):
  OPERATION_NAME = "util.assume.int"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, assumptions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["assumptions"] = (assumptions if (
    isinstance(assumptions, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_MultiValueIntAssumptionAttrList')) else
      _ods_ir.AttrBuilder.get('Util_MultiValueIntAssumptionAttrList')(assumptions, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def assumptions(self):
    return self.operation.attributes["assumptions"]

  @assumptions.setter
  def assumptions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["assumptions"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def assume_int(results_, operands_, assumptions, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AssumeIntOp(results_=results_, operands_=operands_, assumptions=assumptions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BufferAllocOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, storage_size, *, alignment=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(storage_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage_size(self):
    return self.operation.operands[0]

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_alloc(storage_size, *, alignment=None, loc=None, ip=None) -> _ods_ir.Value:
  return BufferAllocOp(storage_size=storage_size, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCompareOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.compare"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, lhs_size, lhs_offset, rhs, rhs_size, rhs_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(lhs_size)
    operands.append(lhs_offset)
    operands.append(rhs)
    operands.append(rhs_size)
    operands.append(rhs_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def lhs_size(self):
    return self.operation.operands[1]

  @builtins.property
  def lhs_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def rhs(self):
    return self.operation.operands[3]

  @builtins.property
  def rhs_size(self):
    return self.operation.operands[4]

  @builtins.property
  def rhs_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def length(self):
    return self.operation.operands[6]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_compare(lhs, lhs_size, lhs_offset, rhs, rhs_size, rhs_offset, length, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferCompareOp(lhs=lhs, lhs_size=lhs_size, lhs_offset=lhs_offset, rhs=rhs, rhs_size=rhs_size, rhs_offset=rhs_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, name=None, alignment=None, mime_type=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Util_AnySerializableAttr')) else
      _ods_ir.AttrBuilder.get('Util_AnySerializableAttr')(value, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    if mime_type is not None: attributes["mime_type"] = (mime_type if (
        isinstance(mime_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(mime_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def name(self):
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def mime_type(self):
    if "mime_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["mime_type"]

  @mime_type.setter
  def mime_type(self, value):
    if value is not None:
      self.operation.attributes["mime_type"] = value
    elif "mime_type" in self.operation.attributes:
      del self.operation.attributes["mime_type"]

  @mime_type.deleter
  def mime_type(self):
    del self.operation.attributes["mime_type"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_constant(value, *, name=None, alignment=None, mime_type=None, loc=None, ip=None) -> _ods_ir.Value:
  return BufferConstantOp(value=value, name=name, alignment=alignment, mime_type=mime_type, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, target, target_size, target_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target(self):
    return self.operation.operands[3]

  @builtins.property
  def target_size(self):
    return self.operation.operands[4]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def length(self):
    return self.operation.operands[6]

def buffer_copy(source, source_size, source_offset, target, target_size, target_offset, length, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferCopyOp(source=source, source_size=source_size, source_offset=source_offset, target=target, target_size=target_size, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferDeallocOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.dealloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self):
    return self.operation.operands[1]

def buffer_dealloc(operand, operand_size, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferDeallocOp(operand=operand, operand_size=operand_size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferFillOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.fill"

  _ODS_REGIONS = (0, True)

  def __init__(self, pattern, target, target_size, target_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(pattern)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pattern(self):
    return self.operation.operands[0]

  @builtins.property
  def target(self):
    return self.operation.operands[1]

  @builtins.property
  def target_size(self):
    return self.operation.operands[2]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[3]

  @builtins.property
  def length(self):
    return self.operation.operands[4]

def buffer_fill(pattern, target, target_size, target_offset, length, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferFillOp(pattern=pattern, target=target, target_size=target_size, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferHashOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.hash"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def length(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_hash(source, source_size, source_offset, length, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferHashOp(source=source, source_size=source_size, source_offset=source_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, source_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def length(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_load(result, source, source_size, source_offset, length, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferLoadOp(result=result, source=source, source_size=source_size, source_offset=source_offset, length=length, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_size(operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferSizeOp(operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, result_size, *, alignment=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('IndexAttr')) else
          _ods_ir.AttrBuilder.get('IndexAttr')(alignment, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def result_size(self):
    return self.operation.operands[3]

  @builtins.property
  def alignment(self):
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_slice(source, source_size, source_offset, result_size, *, alignment=None, loc=None, ip=None) -> _ods_ir.Value:
  return BufferSliceOp(source=source, source_size=source_size, source_offset=source_offset, result_size=result_size, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BufferStorageOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.storage"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, offset, operand, operand_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    results.append(offset)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def offset(self):
    return self.operation.results[1]

def buffer_storage(result, offset, operand, operand_size, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return BufferStorageOp(result=result, offset=offset, operand=operand, operand_size=operand_size, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class BufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, target, target_size, target_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def target(self):
    return self.operation.operands[1]

  @builtins.property
  def target_size(self):
    return self.operation.operands[2]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[3]

  @builtins.property
  def length(self):
    return self.operation.operands[4]

def buffer_store(source, target, target_size, target_offset, length, *, loc=None, ip=None) -> _ods_ir.Operation:
  return BufferStoreOp(source=source, target=target, target_size=target_size, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BufferSubspanOp(_ods_ir.OpView):
  OPERATION_NAME = "util.buffer.subspan"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, result_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def result_size(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_subspan(source, source_size, source_offset, result_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return BufferSubspanOp(source=source, source_size=source_size, source_offset=source_offset, result_size=result_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  OPERATION_NAME = "util.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, operands_, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self):
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call(results_, callee, operands_, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CallOp(results_=results_, callee=callee, operands_=operands_, tied_operands=tied_operands, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CastOp(_ods_ir.OpView):
  OPERATION_NAME = "util.cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cast(result, operand, *, loc=None, ip=None) -> _ods_ir.Value:
  return CastOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpEQOp(_ods_ir.OpView):
  OPERATION_NAME = "util.cmp.eq"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cmp_eq(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CmpEQOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmpNEOp(_ods_ir.OpView):
  OPERATION_NAME = "util.cmp.ne"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def cmp_ne(lhs, rhs, *, loc=None, ip=None) -> _ods_ir.Value:
  return CmpNEOp(lhs=lhs, rhs=rhs, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  OPERATION_NAME = "util.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, inlining_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_647')) else
      _ods_ir.AttrBuilder.get('anonymous_647')(function_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def inlining_policy(self):
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

  @builtins.property
  def body(self):
    return self.regions[0]

def func(sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, inlining_policy=None, loc=None, ip=None) -> _ods_ir.Operation:
  return FuncOp(sym_name=sym_name, function_type=function_type, tied_operands=tied_operands, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, inlining_policy=inlining_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalAddressOp(_ods_ir.OpView):
  OPERATION_NAME = "util.global.address"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self):
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self):
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def global_address(result, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.Value:
  return GlobalAddressOp(result=result, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadIndirectOp(_ods_ir.OpView):
  OPERATION_NAME = "util.global.load.indirect"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self):
    return self.operation.operands[0]

  @builtins.property
  def is_immutable(self):
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def global_load_indirect(result, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.Value:
  return GlobalLoadIndirectOp(result=result, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "util.global.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, is_immutable=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(global_, context=_ods_context))
    if bool(is_immutable): attributes["is_immutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self):
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def is_immutable(self):
    return "is_immutable" in self.operation.attributes

  @is_immutable.setter
  def is_immutable(self, value):
    if bool(value):
      self.operation.attributes["is_immutable"] = _ods_ir.UnitAttr.get()
    elif "is_immutable" in self.operation.attributes:
      del self.operation.attributes["is_immutable"]

  @is_immutable.deleter
  def is_immutable(self):
    del self.operation.attributes["is_immutable"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def global_load(result, global_, *, is_immutable=None, loc=None, ip=None) -> _ods_ir.Value:
  return GlobalLoadOp(result=result, global_=global_, is_immutable=is_immutable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalOp(_ods_ir.OpView):
  OPERATION_NAME = "util.global"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if initial_value is not None: attributes["initial_value"] = (initial_value if (
        isinstance(initial_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
          _ods_ir.AttrBuilder.get('TypedAttrInterface')(initial_value, context=_ods_context))
    if inlining_policy is not None: attributes["inlining_policy"] = (inlining_policy if (
        isinstance(inlining_policy, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_InliningPolicyAttrInterface')) else
          _ods_ir.AttrBuilder.get('Util_InliningPolicyAttrInterface')(inlining_policy, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self):
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self):
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def initial_value(self):
    if "initial_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["initial_value"]

  @initial_value.setter
  def initial_value(self, value):
    if value is not None:
      self.operation.attributes["initial_value"] = value
    elif "initial_value" in self.operation.attributes:
      del self.operation.attributes["initial_value"]

  @initial_value.deleter
  def initial_value(self):
    del self.operation.attributes["initial_value"]

  @builtins.property
  def inlining_policy(self):
    if "inlining_policy" not in self.operation.attributes:
      return None
    return self.operation.attributes["inlining_policy"]

  @inlining_policy.setter
  def inlining_policy(self, value):
    if value is not None:
      self.operation.attributes["inlining_policy"] = value
    elif "inlining_policy" in self.operation.attributes:
      del self.operation.attributes["inlining_policy"]

  @inlining_policy.deleter
  def inlining_policy(self):
    del self.operation.attributes["inlining_policy"]

def global_(sym_name, type_, *, sym_visibility=None, is_mutable=None, initial_value=None, inlining_policy=None, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalOp(sym_name=sym_name, type_=type_, sym_visibility=sym_visibility, is_mutable=is_mutable, initial_value=initial_value, inlining_policy=inlining_policy, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreIndirectOp(_ods_ir.OpView):
  OPERATION_NAME = "util.global.store.indirect"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(global_)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def global_(self):
    return self.operation.operands[1]

def global_store_indirect(value, global_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalStoreIndirectOp(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "util.global.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, global_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(global_, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def global_(self):
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store(value, global_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalStoreOp(value=value, global_=global_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InitializerOp(_ods_ir.OpView):
  OPERATION_NAME = "util.initializer"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_647')) else
      _ods_ir.AttrBuilder.get('anonymous_647')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self):
    return self.regions[0]

def initializer(function_type, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return InitializerOp(function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "util.list.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, initial_capacity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if initial_capacity is not None: operands.append(initial_capacity)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initial_capacity(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_create(result, *, initial_capacity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ListCreateOp(result=result, initial_capacity=initial_capacity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListGetOp(_ods_ir.OpView):
  OPERATION_NAME = "util.list.get"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, list, index, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_get(result, list, index, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListGetOp(result=result, list=list, index=index, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ListResizeOp(_ods_ir.OpView):
  OPERATION_NAME = "util.list.resize"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, new_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(new_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def new_size(self):
    return self.operation.operands[1]

def list_resize(list, new_size, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ListResizeOp(list=list, new_size=new_size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSetOp(_ods_ir.OpView):
  OPERATION_NAME = "util.list.set"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, index, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(list)
    operands.append(index)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def index(self):
    return self.operation.operands[1]

  @builtins.property
  def value(self):
    return self.operation.operands[2]

def list_set(list, index, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ListSetOp(list=list, index=index, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ListSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "util.list.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(list)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_size(list, *, loc=None, ip=None) -> _ods_ir.Value:
  return ListSizeOp(list=list, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NullOp(_ods_ir.OpView):
  OPERATION_NAME = "util.null"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self):
    return self.operation.results[0]

def null(result, *, loc=None, ip=None) -> _ods_ir.Value:
  return NullOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class NumericOptionalNarrowOp(_ods_ir.OpView):
  OPERATION_NAME = "util.numeric.optional_narrow"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, semantic_type, *, min_value=None, max_value=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["semantic_type"] = (semantic_type if (
    isinstance(semantic_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(semantic_type, context=_ods_context))
    if min_value is not None: attributes["min_value"] = (min_value if (
        isinstance(min_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('APIntAttr')) else
          _ods_ir.AttrBuilder.get('APIntAttr')(min_value, context=_ods_context))
    if max_value is not None: attributes["max_value"] = (max_value if (
        isinstance(max_value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('APIntAttr')) else
          _ods_ir.AttrBuilder.get('APIntAttr')(max_value, context=_ods_context))
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def semantic_type(self):
    return self.operation.attributes["semantic_type"]

  @semantic_type.setter
  def semantic_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantic_type"] = value

  @builtins.property
  def min_value(self):
    if "min_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["min_value"]

  @min_value.setter
  def min_value(self, value):
    if value is not None:
      self.operation.attributes["min_value"] = value
    elif "min_value" in self.operation.attributes:
      del self.operation.attributes["min_value"]

  @min_value.deleter
  def min_value(self):
    del self.operation.attributes["min_value"]

  @builtins.property
  def max_value(self):
    if "max_value" not in self.operation.attributes:
      return None
    return self.operation.attributes["max_value"]

  @max_value.setter
  def max_value(self, value):
    if value is not None:
      self.operation.attributes["max_value"] = value
    elif "max_value" in self.operation.attributes:
      del self.operation.attributes["max_value"]

  @max_value.deleter
  def max_value(self):
    del self.operation.attributes["max_value"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def numeric_optional_narrow(operand, semantic_type, *, min_value=None, max_value=None, loc=None, ip=None) -> _ods_ir.Value:
  return NumericOptionalNarrowOp(operand=operand, semantic_type=semantic_type, min_value=min_value, max_value=max_value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OptimizationBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "util.optimization_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def optimization_barrier(results_, operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(OptimizationBarrierOp(results_=results_, operands_=operands_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class RangeExtentsOp(_ods_ir.OpView):
  OPERATION_NAME = "util.range.extents"

  _ODS_REGIONS = (0, True)

  def __init__(self, offsets, lengths, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(offsets))
    operands.extend(_get_op_results_or_values(lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 2)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def offsets(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def lengths(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def min(self):
    return self.operation.results[0]

  @builtins.property
  def max(self):
    return self.operation.results[1]

def range_extents(offsets, lengths, *, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return RangeExtentsOp(offsets=offsets, lengths=lengths, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class RangeMaxOp(_ods_ir.OpView):
  OPERATION_NAME = "util.range.max"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def range_max(operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return RangeMaxOp(operands_=operands_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RangeMinOp(_ods_ir.OpView):
  OPERATION_NAME = "util.range.min"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend([operands[0].type] * 1)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def range_min(operands_, *, loc=None, ip=None) -> _ods_ir.Value:
  return RangeMinOp(operands_=operands_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "util.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SizeOfOp(_ods_ir.OpView):
  OPERATION_NAME = "util.sizeof"

  _ODS_REGIONS = (0, True)

  def __init__(self, sizedType, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sizedType"] = (sizedType if (
    isinstance(sizedType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(sizedType, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sizedType(self):
    return self.operation.attributes["sizedType"]

  @sizedType.setter
  def sizedType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sizedType"] = value

  @builtins.property
  def size(self):
    return self.operation.results[0]

def sizeof(sized_type, *, loc=None, ip=None) -> _ods_ir.Value:
  return SizeOfOp(sizedType=sized_type, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StatusCheckOkOp(_ods_ir.OpView):
  OPERATION_NAME = "util.status.check_ok"

  _ODS_REGIONS = (0, True)

  def __init__(self, status, *, message=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(status)
    _ods_context = _ods_get_default_loc_context(loc)
    if message is not None: attributes["message"] = (message if (
        isinstance(message, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def status(self):
    return self.operation.operands[0]

  @builtins.property
  def message(self):
    if "message" not in self.operation.attributes:
      return None
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value):
    if value is not None:
      self.operation.attributes["message"] = value
    elif "message" in self.operation.attributes:
      del self.operation.attributes["message"]

  @message.deleter
  def message(self):
    del self.operation.attributes["message"]

def status_check_ok(status, *, message=None, loc=None, ip=None) -> _ods_ir.Operation:
  return StatusCheckOkOp(status=status, message=message, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SwitchOp(_ods_ir.OpView):
  OPERATION_NAME = "util.switch"

  _ODS_REGIONS = (0, True)

  def __init__(self, index, default_value, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(index)
    operands.append(default_value)
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def index(self):
    return self.operation.operands[0]

  @builtins.property
  def default_value(self):
    return self.operation.operands[1]

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def switch(index, default_value, values, *, loc=None, ip=None) -> _ods_ir.Value:
  return SwitchOp(index=index, default_value=default_value, values=values, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnfoldableConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "util.unfoldable_constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

def unfoldable_constant(result, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return UnfoldableConstantOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnreachableOp(_ods_ir.OpView):
  OPERATION_NAME = "util.unreachable"

  _ODS_REGIONS = (0, True)

  def __init__(self, message, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["message"] = (message if (
    isinstance(message, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(message, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def message(self):
    return self.operation.attributes["message"]

  @message.setter
  def message(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["message"] = value

def unreachable(message, *, loc=None, ip=None) -> _ods_ir.Operation:
  return UnreachableOp(message=message, loc=loc, ip=ip)
