from pathlib import Path
import typer
from rich import print
import os
import sys
import subprocess
from typer import Option
import questionary
from importlib.metadata import version
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
import platform

packageFileName = "conanfile.py"
preset="release"
debugPreset="debug"
execulableExtention=".exe" if os.name =="nt" else ""
app = typer.Typer(no_args_is_help=True)
buildType="Release"

@app.command()
def about():
    """Show information about the Sage project and CLI."""

    console = Console()
    title = Text(f"Sage v{version("cppsage")}", style="bold cyan")
    subtitle = Text("A unified build and dependency system for C/C++", style="white")
    hint = Text("Use '--help' to explore commands", style="dim white")

    console.print(Panel.fit(
        Text.assemble(title, "\n", subtitle, "\n", hint),
        border_style="cyan",
        title="Version 6",
        subtitle="Sage CLI for C/C++"
    ))

def _change_directory(path: str):
    if path:
        try:
            os.chdir(path)
        except FileNotFoundError:
            print(f"[bold red]Directory not found: {path}[/bold red]")
            raise typer.Exit()

@app.command()
def compile(path: str = typer.Option(None, "--path", "-p", help="Path to the project directory.")):
    """Compile the project using the current preset and build directory."""
    _change_directory(path)
    onCompile()

def onCompile():
    if not os.path.isfile("CMakeLists.txt"):
        print("[bold red]Missing CMakeLists.txt[/bold red]")
        return
    
    build_dir = f"build/{preset}"
    if not os.path.isdir(build_dir):
        runInstall()
        result = subprocess.run(["cmake", "--preset", preset])
        if result.returncode != 0:
            print("[bold red]CMake configuration failed[/bold red]")
            return
    
    subprocess.run(["cmake", "--build", build_dir, "--parallel"])

@app.command()
def run(args: list[str] = typer.Argument(None), path: str = typer.Option(None, "--path", "-p", help="Path to the project directory.")):
    """
    Run one or more compiled executables from the build directory.

    Arguments should match target names generated by the build.
    Example:
        sage run main test_game
    Searches inside build/{preset}/ for matching executables.
    """
    _change_directory(path)
    onRun(args)

def onRun(args:list[str]=[]):
    if not args:
        args = [os.path.basename(os.getcwd())]

    for arg in args:
        path_direct = f"build/{arg}{execulableExtention}"
        path_nested = (f"build/{arg}/{arg}{execulableExtention}")
        if os.path.isfile(path_direct):
            subprocess.run([path_direct])
        elif os.path.isfile(path_nested):
            subprocess.run([path_nested])
        else:
            print(f"[bold red]Executable '{arg}' not found in {path_direct} or {path_nested}[/bold red]")

@app.command()
def build(args: list[str] = typer.Argument(None), path: str = typer.Option(None, "--path", "-p", help="Path to the project directory.")):
    """
    Build and Run one or more compiled executables from the build directory.

    Arguments should match target names generated by the build.
    Example:
        sage build main test_game
    Searches inside build/{preset}/ for matching executables.
    """
    _change_directory(path)
    onCompile()
    onRun(args=args)

@app.command()
def install(
    package: str = Option(None, "--package", "-p", help="Package name to install"),
    version: str = Option(None, "--version", "-v", help="Optional package version"),
    path: str = Option(None, "--path", help="Path to the project directory."),
    build_type: str = Option("Release", "--build-type", "-b", help="Build type for conan install (Debug or Release)")
):
    """Install dependencies from requirements.txt or add new ones , sage install --help"""
    if build_type not in ["Debug", "Release"]:
        print("[bold red]Invalid build type. Must be 'debug' or 'release'[/bold red]")
        raise typer.Exit()
    _change_directory(path)
    runInstall(package,version,build_type)


@app.command()
def doctor():
    """
    Run diagnostics and automatically configure your development environment.

    This command will:
    - Detect missing tools (e.g. compiler, CMake, Conan, Ninja) and install them if necessary.
    - Validate your toolchain setup across platforms.
    - Configure a working Conan profile tailored for Clang with sane defaults.
    - Inspect CMake presets and verify project integrity.
    - Ensure compatibility for cross-platform development with static linking options.

    [ðŸ’¡] Future versions will include environment summary, version checks,
    and auto-fix suggestions for broken configs.
    """
    tools = {
        "cmake": {"version_cmd": ["cmake", "--version"], "install": {
            "Windows": "winget install Kitware.CMake",
            "Linux": "sudo apt-get install cmake",
            "Darwin": "brew install cmake"
        }},
        "ninja": {"version_cmd": ["ninja", "--version"], "install": {
            "Windows": "winget install Ninja-build.Ninja",
            "Linux": "sudo apt-get install ninja-build",
            "Darwin": "brew install ninja"
        }},
        "clang": {"version_cmd": ["clang", "--version"], "install": {
            "Windows": "winget install LLVM.LLVM",
            "Linux": "sudo apt-get install clang clang-tools",
            "Darwin": "brew install llvm"
        }},
        "conan": {"version_cmd": ["conan", "--version"], "install": {
            "Windows": "pip install conan",
            "Linux": "pip install conan",
            "Darwin": "pip install conan"
        }},
    }

    if os.name == "nt":
        tools["msvc"] = {"version_cmd": ["C:/Program Files (x86)/Microsoft Visual Studio/Installer/vswhere.exe", "-latest", "-property", "displayName"], "install": {
            "Windows": "Install Visual Studio Build Tools: https://aka.ms/vs/17/release/vs_BuildTools.exe"
        }}

    print("[bold blue]Running CppSage Doctor...[/bold blue]")
    
    os_map = {
        "win32": "Windows",
        "linux": "Linux",
        "darwin": "Darwin"
    }
    current_os = os_map.get(sys.platform)

    for tool, details in tools.items():
        try:
            result = subprocess.run(details["version_cmd"], capture_output=True, text=True, check=True, shell=True)
            lines = result.stdout.strip().splitlines()
            if lines:
                version = lines[0]
                print(f"[green]-> {tool} found: {version}[/green]")
            else:
                print(f"[bold red]-> {tool} not found or version not detected.[/bold red]")
                continue
            print(f"[green]-> {tool} found: {version}[/green]")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(f"[bold red]-> {tool} not found.[/bold red]")
            if current_os:
                install_cmd = details["install"].get(current_os)
                if install_cmd:
                    print(f"  To install, run: [bold cyan]{install_cmd}[/bold cyan]")
                else:
                    print(f"  Installation instructions not available for {current_os}")
            else:
                print(f"  Installation instructions not available for your OS: {sys.platform}")


    if subprocess.run(["pip","install","conan"],capture_output=True).returncode!=0:
        print("failed to install conan")
    code=subprocess.run(["conan","profile","detect"],capture_output=True).returncode
    if code==0 or code==1:
        print("[green]-> default conan profile created[/green]")
    else:
        print("[bold red]-> error while creating conan profile[/bold red]")
        return
    conan_profile_path=subprocess.run(["conan","profile","path","default"],capture_output=True).stdout.strip()
    modifyConanProfile(conan_profile_path)

@app.command()
def create():
    """
    Generate a new starter C/C++ project with predefined structure.

    Prompts for project name and programming language (C or C++).
    Creates folders, CMake configuration, Clang-format/tidy files, presets,
    and a minimal entry point with Conan-ready setup.
    """

    project_name = questionary.text("Enter project name:").ask()
    if not project_name:
        print("[bold red]Project name cannot be empty[/bold red]")
        raise typer.Exit()

    lang = questionary.select(
        "Choose language:",
        choices=["C", "C++"],
    ).ask()

    project_type = questionary.select(
        "Choose project type:",
        choices=["Library", "Executable"],
    ).ask()

    if not lang or not project_type:
        raise typer.Exit()


    ext = "c" if lang == "C" else "cpp"
    root = Path(project_name)
    print(f"[bold green]Scaffolding {lang.upper()} project: {project_name}[/bold green]")

    # Create directory structure
    for folder in [
         "cmake",
        f"{project_name}/src", f"{project_name}/include"
    ]:
        (root / folder).mkdir(parents=True, exist_ok=True)

    # Root CMakeLists.txt
    cmake_root = f"""#Auto Generated Root CMake file by Sage
#Copyright(c) 2025 None.All rights reerved.
cmake_minimum_required(VERSION 3.6...3.31)
include(cmake/clang.toolchain.cmake)
project({project_name} VERSION 0.1.0 LANGUAGES CXX C)
include(cmake/config.cmake)
#@add_find_package Warning: Do not remove this line

#@add_subproject Warning: Do not remove this line
add_subdirectory({project_name})
"""
    (root / "CMakeLists.txt").write_text(cmake_root)

    # config.cmake
    config_cmake = rf"""#Auto Generated Root CMake file by Sage
#None
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
option(CRT_STATIC_LINK ON)
message(STATUS "Static Link C Runtime ${{CRT_STATIC_LINK}}")
if(CRT_STATIC_LINK)
  if (WIN32)
      set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
  else()
      set(CMAKE_EXE_LINKER_FLAGS "${{CMAKE_EXE_LINKER_FLAGS}} -static")
  endif()
else()
  if(WIN32)
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL")
  endif()
endif()
set(COMPANY "None")
string(TIMESTAMP CURRENT_YEAR "%Y")
set(COPYRIGHT "Copyright(c) ${{CURRENT_YEAR}} ${{COMPANY}}.")
include_directories(${{CMAKE_BINARY_DIR}} ${{CMAKE_SOURCE_DIR}})
configure_file(cmake/{project_name}config.h.in {project_name}config.h)
if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    message(STATUS "Enabling secure coding features for Clang")
    add_compile_options(
        -Xclang
        -Wall -Wextra -Wpedantic
        -Wshadow -Wold-style-cast
        -Wcast-align -Wnull-dereference
        -Wformat=2 -Wformat-security
        # -D_FORTIFY_SOURCE=2
        #-Werror
    )
endif()
"""
    (root / "cmake/config.cmake").write_text(config_cmake)
    (root/"cmake/clang.toolchain.cmake").write_text("""if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "Debug")
endif()

# Show a message for clarity
message(STATUS "Forcing Clang compiler")

# Detect host system
if(NOT DEFINED CMAKE_SYSTEM_NAME)
    set(CMAKE_SYSTEM_NAME ${CMAKE_HOST_SYSTEM_NAME})
endif()

# Force Ninja generator if not already set
if(NOT ${CMAKE_GENERATOR} STREQUAL "Ninja")
    message(STATUS "Warning: CMake Generator: ${CMAKE_GENERATOR}, Use Ninja for faster builds")
else()
    message(STATUS "CMake Generator: ${CMAKE_GENERATOR}")
endif()

# Windows: use clang-cl
if(${CMAKE_SYSTEM_NAME} STREQUAL "Windows")
    message(STATUS "Targeting Windows â€” using clang-cl")
    # You can customize this path if needed
    set(CMAKE_C_COMPILER "clang-cl" CACHE STRING "C compiler")
    set(CMAKE_CXX_COMPILER "clang-cl" CACHE STRING "C++ compiler")

    # Optional: specify MSVC-like flags
    set(CMAKE_C_FLAGS "/nologo /EHsc" CACHE STRING "C flags")
    set(CMAKE_CXX_FLAGS "/nologo /EHsc" CACHE STRING "C++ flags")

# Android: use NDK toolchain
elseif(${CMAKE_SYSTEM_NAME} STREQUAL "Android")
    message(STATUS "Targeting Android â€” using NDK Clang")

    set(CMAKE_ANDROID_NDK "/path/to/ndk" CACHE PATH "Path to Android NDK")
    set(CMAKE_SYSTEM_VERSION 21)
    set(CMAKE_ANDROID_ARCH_ABI arm64-v8a)

    set(CMAKE_TOOLCHAIN_FILE "${CMAKE_ANDROID_NDK}/build/cmake/android.toolchain.cmake")

# Linux/macOS: use regular clang
else()
    message(STATUS "Targeting Unix-like system â€” using clang/clang++")

    set(CMAKE_C_COMPILER "clang" CACHE STRING "C compiler")
    set(CMAKE_CXX_COMPILER "clang++" CACHE STRING "C++ compiler")
endif()

""")
    # res/config.h.in
    config_h = rf"""#ifndef __{project_name}__
    #define __{project_name}__
#include <string_view>
namespace Project {{
    constexpr std::string_view VERSION_STRING = "@{project_name}_VERSION_MAJOR@.@{project_name}_VERSION_MINOR@.@{project_name}_VERSION_PATCH@";
    constexpr std::string_view COMPANY_NAME = "@COMPANY@";
    constexpr std::string_view COPYRIGHT_STRING = "@COPYRIGHT@";
    constexpr std::string_view PROJECT_NAME = "@PROJECT_NAME@";
}}
#endif
"""
    (root / f"cmake/{project_name}config.h.in").write_text(config_h)

    # Subproject CMakeLists.txt
    if not project_type == "Library":
        subproject_cmake = f"""add_executable({project_name} src/main.{ext}) # Add your Source Files here
#@add_target_link_libraries Warning: Do not remove this line
"""
        (root / project_name / f"src/main.{ext}").write_text("int main() {\n    return 0;\n}")
    else:
        subproject_cmake = f"""add_library({project_name} src/{project_name}.{ext}) # Add your Source Files here
#@add_target_link_libraries Warning: Do not remove this line
"""
        (root / project_name / f"src/{project_name}.{ext}").write_text(f'#include "../include/{project_name}.h"\n\nvoid {project_name}() {{}}')
        (root / project_name / "include" / f"{project_name}.h").write_text(f"#ifndef {project_name.upper()}_H\n#define {project_name.upper()}_H\n\nvoid {project_name}();\n\n#endif // {project_name.upper()}_H")

    (root / project_name / "CMakeLists.txt").write_text(subproject_cmake)


    # Other essential files
    (root / "CMakePresets.json").write_text("""{
  "version": 4,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 20,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "debug",
      "displayName": "Debug",
      "description": "Configure for Debug builds. Requires running 'conan install . -of .install -s build_type=Debug' for Debug first.",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/.build/Debug",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "${sourceDir}/.install/build/Debug/generators/conan_toolchain.cmake"
      }
    },
    {
      "name": "release",
      "displayName": "Release",
      "description": "Configure for Release builds. Requires running 'conan install . -of .install -s build_type=Debug' for Release first.",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/.build/Release",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_TOOLCHAIN_FILE": "${sourceDir}/.install/build/Release/generators/conan_toolchain.cmake"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "debug",
      "configurePreset": "debug"
    },
    {
      "name": "release",
      "configurePreset": "release"
    }
  ]
}
""")
    
    (root/"conanfile.py").write_text("""from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout, CMakeDeps
    
class ProjectConan(ConanFile):
    name = "undefined" # The package name should be the library's name
    version = "0.1.0"
    settings = "os", "compiler", "build_type", "arch"
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
        "build_app": [True, False]
    }
    default_options = {
        "shared": False,
        "fPIC": True,
        "build_app": False
    }
    # Make sure to export ALL necessary source code.
    exports_sources = "CMakeLists.txt", "libs/*","cmake/*"
    
    def requirements(self):
        #self.requires("Libname/version")
        if self.options.build_app:  # Only for the app
            pass
        else: # Only for the libs
            pass
    def layout(self):
        cmake_layout(self)

    def generate(self):
        deps = CMakeDeps(self)
        deps.generate()
        tc = CMakeToolchain(self)
        #NOTE: This is if you want to publish apps with libs too
        tc.variables["BUILD_APPLICATION"] = self.options.build_app
        tc.generate()

    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()

    def package(self):
        cmake = CMake(self)
        cmake.install()

    def package_info(self):
        pass
        # This package only exposes information about the library.
        #self.cpp_info.libs = ["undefined"] #Only if you have single lib if you component then
        # # Define the "yourlib" library component
        # self.cpp_info.components["yourlib"].libs = ["yourlib"]
        # self.cpp_info.components["yourlib"].requires = ["fmt::fmt"] # Example if generator depends on fmt""")
    
    for name, content in {
        ".clang-format": "BasedOnStyle: Google",
        ".clangd": "CompileFlags:\n CompilationDatabase: .build/Debug\n",
        ".editorconfig": "root = true",
        ".gitignore": "build/\npackages/install/\n.vscode/\n.vs\n.idea\n.install\n.build\n",
    }.items():
        (root / name).write_text(content)

    print(f"[bold cyan]{project_name} has been created successfully![/bold cyan]")






import re

def _process_conan_output(output: str):
    """Parses the output of a conan install command to find package information."""
    find_packages = []
    target_link_libraries = []
    
    find_package_regex = re.compile(r"find_package\(([^)]+)\)")
    target_link_regex = re.compile(r"target_link_libraries\(\.\.\. ([^)]+)\)")

    for line in output.splitlines():
        find_match = find_package_regex.search(line)
        if find_match:
            find_packages.append(f"find_package({find_match.group(1)})")

        target_match = target_link_regex.search(line)
        if target_match:
            target_link_libraries.append(target_match.group(1))
            
    return find_packages, target_link_libraries

def runInstall(package:str=None,version:str=None,build_type:str="Release"):
    req_path = f"conanfile.py"
    result = None
    commands=["conan", "install",".", "--output-folder", ".install", "--build=missing",
                                   "-c","tools.cmake.cmaketoolchain:generator=Ninja",
                                   "-s",f"build_type={build_type}","-o","&:build_app=True","-c","tools.cmake.cmaketoolchain:user_presets="]
    
    if not package:
        if os.path.isfile(req_path):
            print("[bold yellow]Installing dependencies from requirements.txt[/bold yellow]")
            result = subprocess.run(commands, capture_output=True, text=True)
            print(result.stdout)
            print(result.stderr)
            if result.returncode != 0:
                print("[bold red]Conan installation failed.[/bold red]")
                exit(0)
            return
        else:
            print("[bold red]Missing requirements.txt[/bold red]")
            return
    else:

        if not os.path.isfile(req_path):
            with open(req_path, "w") as f:
                f.write("""from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout, CMakeDeps
    
class ProjectConan(ConanFile):
    name = "undefined" # The package name should be the library's name
    version = "0.1.0"
    settings = "os", "compiler", "build_type", "arch"
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
        "build_app": [True, False]
    }
    default_options = {
        "shared": False,
        "fPIC": True,
        "build_app": False
    }
    # Make sure to export ALL necessary source code.
    exports_sources = "CMakeLists.txt", "libs/*","cmake/*"
    
    def requirements(self):
        #self.requires("Libname/version")
        if self.options.build_app:  # Only for the app
            pass
        else: # Only for the libs
            pass
    def layout(self):
        cmake_layout(self)

    def generate(self):
        deps = CMakeDeps(self)
        deps.generate()
        tc = CMakeToolchain(self)
        #NOTE: This is if you want to publish apps with libs too
        tc.variables["BUILD_APPLICATION"] = self.options.build_app
        tc.generate()

    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()

    def package(self):
        cmake = CMake(self)
        cmake.install()

    def package_info(self):
        pass
        # This package only exposes information about the library.
        #self.cpp_info.libs = ["undefined"] #Only if you have single lib if you component then
        # # Define the "yourlib" library component
        # self.cpp_info.components["yourlib"].libs = ["yourlib"]
        # self.cpp_info.components["yourlib"].requires = ["fmt::fmt"] # Example if generator depends on fmt""")

        if not version:
            print(f"[bold green]No version provided for {package}. Fetching latest...[/bold green]")
            search = subprocess.run(["conan", "search", package], capture_output=True, text=True)
            if search.returncode != 0:
                print(f"[bold red]Conan search failed for {package}[/bold red]")
                return
            lines = search.stdout.strip().splitlines()
            version = lines[-1].split("/")[1] if lines else ""

        if not version:
            print(f"[bold red]No available versions found for {package}[/bold red]")
            return

        full_package = f"{package}/{version}"
        if len(full_package)>0:
            print(f"[bold yellow]Installing: {full_package}[/bold yellow]")

            with open(req_path, "r") as f:
                lines = f.readlines()

            if full_package + "\n" not in lines:
                for i, line in enumerate(lines):
                    if line.strip() == "[requires]":
                        lines.insert(i + 1, full_package + "\n")
                        break
                with open(req_path, "w") as f:
                    f.writelines(lines)
            else:
                print(f"[bold yellow]{full_package} is already listed[/bold yellow]")


        result = subprocess.run(commands, capture_output=True, text=True)
        print(result.stdout)
        print(result.stderr)
        if result.returncode != 0:
            print("[bold red]Conan installation failed.[/bold red]")
            return

    if not result:
        return

    # --- Auto-update CMakeLists.txt from conan output ---
    find_packages, target_link_libraries = _process_conan_output(result.stderr)
    
    if find_packages:
        with open("CMakeLists.txt", "r+") as f:
            content = f.read()
            f.seek(0)
            lines = content.splitlines()
            # Find the placeholder and insert the new packages
            for i, line in enumerate(lines):
                if "#@add_find_package" in line:
                    for pkg in find_packages:
                        if pkg not in content:
                            print(f"Adding {pkg} to CMakeLists.txt")
                            lines.insert(i + 1, pkg)
                    break
            f.write('\n'.join(lines))


    if target_link_libraries:
        subprojects = []
        with open("CMakeLists.txt", "r") as f:
            for line in f:
                if line.strip().startswith("add_subdirectory"):
                    subproject = line.strip().split("(")[1].split(")")[0]
                    subprojects.append(subproject)
        
        for subproject in subprojects:
            cmake_path = os.path.join(subproject, "CMakeLists.txt")
            if os.path.isfile(cmake_path):
                with open(cmake_path, "r+") as f:
                    content = f.read()
                    target_name_match = re.search(r"(?:add_executable|add_library)\s*\(\s*(\w+)", content)
                    if not target_name_match:
                        continue
                    target_name = target_name_match.group(1)

                    lines = content.splitlines()
                    
                    # Remove old libraries to avoid duplication
                    new_lines = []
                    for line in lines:
                        if not line.strip().startswith("target_link_libraries"):
                            new_lines.append(line)
                    lines = new_lines
                    
                    placeholder_index = -1
                    for i, line in enumerate(lines):
                        if "#@add_target_link_libraries" in line:
                            placeholder_index = i
                            break
                    
                    if placeholder_index != -1:
                        for lib in target_link_libraries:
                            link_str = f"target_link_libraries({target_name} PRIVATE {lib})"
                            lines.insert(placeholder_index + 1, link_str)
                        
                        f.seek(0)
                        f.truncate()
                        f.write('\n'.join(lines))

@app.command()
def add():
    """Add a new subproject to the current project."""
    subproject_name = questionary.text("Enter subproject name:").ask()
    if not subproject_name:
        print("[bold red]Subproject name cannot be empty[/bold red]")
        raise typer.Exit()

    project_type = questionary.select(
        "Choose project type:",
        choices=["Library", "Executable"],
    ).ask()
    if not project_type:
        raise typer.Exit()

    print(f"[bold green]Adding subproject: {subproject_name}[/bold green]")

    # Create directory structure
    for folder in [
        f"{subproject_name}/src", f"{subproject_name}/include"
    ]:
        Path(folder).mkdir(parents=True, exist_ok=True)

    # Subproject CMakeLists.txt
    if not project_type == "Library":
        subproject_cmake = f"""add_executable({subproject_name} src/main.cpp) # Add your Source Files here
#@add_target_link_libraries Warning: Do not remove this line
"""
        (Path(subproject_name) / "src/main.cpp").write_text("int main() {\n    return 0;\n}")
    else:
        subproject_cmake = f"""add_library({subproject_name} src/{subproject_name}.cpp) # Add your Source Files here
#@add_target_link_libraries Warning: Do not remove this line
"""
        (Path(subproject_name) / f"src/{subproject_name}.cpp").write_text(f'#include "../include/{subproject_name}.h"\n\nvoid {subproject_name}() {{}}')
        (Path(subproject_name) / "include" / f"{subproject_name}.h").write_text(f"#ifndef {subproject_name.upper()}_H\n#define {subproject_name.upper()}_H\n\nvoid {subproject_name}();\n\n#endif // {subproject_name.upper()}_H")

    (Path(subproject_name) / "CMakeLists.txt").write_text(subproject_cmake)

    # Add subdirectory to root CMakeLists.txt
    with open("CMakeLists.txt", "r+") as f:
        content = f.read()
        f.seek(0)
        lines = content.splitlines()
        for i, line in enumerate(lines):
            if "#@add_subproject" in line:
                lines.insert(i + 1, f"add_subdirectory({subproject_name})")
                break
        f.write('\n'.join(lines))

    print(f"[bold cyan]Subproject '{subproject_name}' has been added successfully![/bold cyan]")



def onCompile():
    global preset
    if not os.path.isfile("CMakeLists.txt"):
        print("[bold red]Missing CMakeLists.txt[/bold red]")
        return
    
    build_dir = f".build/{buildType}"
    if not os.path.isdir(build_dir):
        runInstall(None,None,build_type=buildType)
        result = subprocess.run(["cmake", "--preset", preset])
        if result.returncode != 0:
            print("[bold red]CMake configuration failed[/bold red]")
            return
    
    subprocess.run(["cmake", "--build", "--preset",f"{preset}", "--parallel"])

def onRun(args:list[str]=[]):
    if not args:
        args = [os.path.basename(os.getcwd())]

    for arg in args:
        path_direct = f".build/{buildType}/{arg}{execulableExtention}"
        path_nested = (f".build/{buildType}/{arg}/{arg}{execulableExtention}")
        if os.path.isfile(path_direct):
            subprocess.run([path_direct])
        elif os.path.isfile(path_nested):
            subprocess.run([path_nested])
        else:
            print(f"[bold red]Executable '{arg}' not found in {path_direct} or {path_nested}[/bold red]")

@app.command()
def debug(path: str = typer.Option(None, "--path", "-p", help="Path to the project directory.")):
    """Run the debug build of the project."""
    _change_directory(path)
    global buildType
    buildType="Debug"
    global preset
    preset=debugPreset
    req_path = f"{packageFileName}"
    if os.path.isfile(req_path):
        runInstall()
    else:
        print(f"[bold red]Missing {req_path}[/bold red]")
        return
    onCompile()



def modifyConanProfile(conan_profile_path: str):
    #Update profile
    if not os.path.isfile(conan_profile_path):
        print(f"[WARN] {conan_profile_path} doesn't exist!")
    else:
        with open(conan_profile_path, "r") as file:
            file_data = file.readlines()

        # compiler.cppstd=20
        found_cppstd = False
        for index, line in enumerate(file_data):
            if line.strip().startswith("compiler.cppstd"):
                if line.strip() != "compiler.cppstd=20":
                    file_data[index] = "compiler.cppstd=20\n"
                    print("[INFO] Updated compiler.cppstd=20")
                found_cppstd = True
                break
        if not found_cppstd:
            file_data.append("compiler.cppstd=20\n")
            print("[INFO] Added compiler.cppstd=20")

        # &:compiler=clang
        found_compiler = False
        for line in file_data:
            if line.strip() == "&:compiler=clang":
                found_compiler = True
                break
        if not found_compiler:
            file_data.append("&:compiler=clang\n")
            print("[INFO] Added &:compiler=clang")

        with open(conan_profile_path, "w") as file:
            file.writelines(file_data)
        print(f"[OK] Updated profile: {conan_profile_path}")

    # Update global.conf (Linux/macOS only)
    if platform.system() in ("Linux", "Darwin"):
        global_conf = os.path.expanduser("~/.conan2/global.conf")
        os.makedirs(os.path.dirname(global_conf), exist_ok=True)

        if os.path.isfile(global_conf):
            with open(global_conf, "r") as file:
                global_data = file.readlines()
        else:
            global_data = []

        pm_settings = {
            "tools.system.package_manager:mode": "install",
            "tools.system.package_manager:sudo": "True",
        }

        for key, value in pm_settings.items():
            found = False
            for index, line in enumerate(global_data):
                if line.strip().startswith(key):
                    if line.strip() != f"{key} = {value}":
                        global_data[index] = f"{key} = {value}\n"
                        print(f"[INFO] Updated {key} = {value}")
                    found = True
                    break
            if not found:
                global_data.append(f"{key} = {value}\n")
                print(f"[INFO] Added {key} = {value}")

        with open(global_conf, "w") as file:
            file.writelines(global_data)
        print(f"[OK] Updated global.conf: {global_conf}")
    else:
        print("[SKIP] global.conf update not required on Windows")
 
def processConanLogAndFindPackageStr(result:str):
    find_packages=[]
    target_link:str=""
    for line in result.splitlines():
        if line.strip().find("find_package"):
            find_packages.append(line.strip())
        if line.strip().find("target_link"):
            target_link=line.strip()

    return [find_packages,target_link]
