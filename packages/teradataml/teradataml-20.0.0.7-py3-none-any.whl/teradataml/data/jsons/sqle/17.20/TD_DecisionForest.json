{
  "json_schema_major_version": "1",
  "json_schema_minor_version": "2",
  "json_content_version": "1",
  "function_name": "TD_DecisionForest",
  "function_version": "1.0",
  "function_type": "fastpath",
  "function_category": "Model Training",
  "function_alias_name": "TD_DecisionForest",
  "function_r_name": "aa.td_decisionforest",
  "short_description": "DecisionForest (also known as Random Forest) performs classification and regression analysis on datasets.",
  "long_description": "The TD_DecisionForest is an ensemble algorithm and widely used across a range of classification and regression predictive modeling problems. It is an extension of bootstrap aggregation (bagging) of decision trees. In bagging, a number of decision trees are created where each tree is created from a different bootstrap sample of the training dataset. A bootstrap sample is a sample of the training dataset where a sample may appear more than once, referred to as sampling with replacement. It also involves selecting a subset of input features (columns or variables) at each split point in the construction of trees. Typically, constructing a decision tree involves evaluating the value for each input variable in the data in order to select a split point. By reducing the features to a random subset that may be considered at each split point, it forces each decision tree in the ensemble to be more different. The TD_DecisionForest function uses a training data set to create a predictive model. You can input the model to the TD_DecisionForestPredict function, which uses it to make predictions.  A prediction on a regression problem is the average of the prediction across the trees in the ensemble. A prediction on a classification problem is the majority vote for the class label across the trees in the ensemble.",
  "input_tables": [
    {
      "requiredInputKind": [
        "PartitionByAny"
      ],
      "isOrdered": false,
      "partitionByOne": false,
      "name": "input",
      "alternateNames": [],
      "isRequired": true,
      "rDescription": "Specifies the table containing the input data.",
      "description": "Specifies the table containing the input data.",
      "datatype": "TABLE_NAME",
      "allowsLists": false,
      "rName": "data",
      "useInR": true,
      "rOrderNum": 1
    }
  ],
  "argument_clauses": [
    {
      "targetTable": [
        "input"
      ],
      "checkDuplicate": true,
      "allowedTypes": [],
      "allowedTypeGroups": [
        "NUMERIC"
      ],
      "matchLengthOfArgument": "",
      "allowPadding": false,
      "name": "InputColumns",
      "alternateNames": [],
      "isRequired": true,
      "rDescription": "Specify the names of the input table columns that need to be used for training the model (predictors, features or independent variables).",
      "description": "Specify the names of the input table columns that need to be used for training the model (predictors, features or independent variables).",
      "datatype": "COLUMNS",
      "allowsLists": true,
      "rName": "input.columns",
      "useInR": true,
      "rFormulaUsage": true,
      "rOrderNum": -1
    },
    {
      "targetTable": [
        "input"
      ],
      "checkDuplicate": true,
      "allowedTypes": [],
      "allowedTypeGroups": [
        "NUMERIC"
      ],
      "matchLengthOfArgument": "",
      "allowPadding": false,
      "name": "ResponseColumn",
      "alternateNames": [],
      "isRequired": true,
      "rDescription": "Specify the name of the column that contains the class label for classification or target value (dependent variable) for regression.",
      "description": "Specify the name of the column that contains the class label for classification or target value (dependent variable) for regression.",
      "datatype": "COLUMNS",
      "allowsLists": false,
      "rName": "response.column",
      "useInR": true,
      "rFormulaUsage": true,
      "rOrderNum": 0
    },
    {
      "defaultValue": 5,
      "lowerBound": 0,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "MaxDepth",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify a decision tree stopping criterion. If the tree reaches a depth past this value, the algorithm stops looking for splits. Decision trees can grow to (2^(max_depth+1)-1) nodes. This stopping criterion has the greatest effect on the performance of the function.",
      "description": "Specify a decision tree stopping criterion. If the tree reaches a depth past this value, the algorithm stops looking for splits. Decision trees can grow to (2^(max_depth+1)-1) nodes. This stopping criterion has the greatest effect on the performance of the function.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "max.depth",
      "useInR": true,
      "rOrderNum": 2
    },
    {
      "defaultValue": -1,
      "lowerBound": -1,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "NumTrees",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the number of trees to grow in the forest model. When specified, the number of trees must be greater than or equal to the number of AMPs with data. By default, the function builds the minimum number of trees that provides the input data set with coverage based on coverageFactor.",
      "description": "Specify the number of trees to grow in the forest model. When specified, the number of trees must be greater than or equal to the number of AMPs with data. By default, the function builds the minimum number of trees that provides the input data set with coverage based on coverageFactor.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "num.trees",
      "useInR": true,
      "rOrderNum": 3
    },
    {
      "defaultValue": 1,
      "lowerBound": 1,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "MinNodeSize",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the minimum number of observations in a tree node. The algorithm stops splitting a node if the number of observations in the node is equal to or smaller than this value. You must specify a non-negative integer value.",
      "description": "Specify the minimum number of observations in a tree node. The algorithm stops splitting a node if the number of observations in the node is equal to or smaller than this value. You must specify a non-negative integer value.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "min.node.size",
      "useInR": true,
      "rOrderNum": 4
    },
    {
      "defaultValue": -1,
      "lowerBound": -1,
      "upperBound": 2048,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "Mtry",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the number of variables to randomly sample from each input value. For example, if mtry is 3, then the function randomly samples 3 variables from each input at each split. The mtry must be an INTEGER. When mtry is -1, all variables will be used for each split.",
      "description": "Specify the number of variables to randomly sample from each input value. For example, if mtry is 3, then the function randomly samples 3 variables from each input at each split. The mtry must be an INTEGER. When mtry is -1, all variables will be used for each split.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "mtry",
      "useInR": true,
      "rOrderNum": 5
    },
    {
      "defaultValue": 1,
      "lowerBound": -2147483648,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "MtrySeed",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify an integer value to use in determining the random seed for mtry. By default, mtryseed is 1.",
      "description": "Specify an integer value to use in determining the random seed for mtry. By default, mtryseed is 1.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "mtry.seed",
      "useInR": true,
      "rOrderNum": 6
    },
    {
      "defaultValue": 1,
      "lowerBound": -2147483648,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "Seed",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the random seed the algorithm uses for repeatable results. By default, seed is 1.",
      "description": "Specify the random seed the algorithm uses for repeatable results. By default, seed is 1.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "seed",
      "useInR": true,
      "rOrderNum": 7
    },
    {
      "permittedValues": [
        "REGRESSION", 
        "CLASSIFICATION"
      ],
      "defaultValue": "REGRESSION",
      "isOutputColumn": false,
      "name": "ModelType",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify whether the analysis is a regression (continuous response variable) or a multiple-class classification (predicting result from the number of classes).",
      "description": "Specify whether the analysis is a regression (continuous response variable) or a multiple-class classification (predicting result from the number of classes).",
      "datatype": "STRING",
      "allowsLists": false,
      "rName": "tree.type",
      "useInR": true,
      "rOrderNum": 8
    },
    {
      "defaultValue": -1,
      "lowerBound": -1,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "TreeSize",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the number of rows that each tree uses as its input data set. The function builds a tree using either the number of rows on an AMP,  the number of rows that fit into the AMP's memory (whichever is less), or the number of rows given by the TreeSize argument. By default, this value is computed as the minimum of the number of rows on an AMP, and the number of rows that fit into the AMP's memory.",
      "description": "Specify the number of rows that each tree uses as its input data set. The function builds a tree using either the number of rows on an AMP,  the number of rows that fit into the AMP's memory (whichever is less), or the number of rows given by the TreeSize argument. By default, this value is computed as the minimum of the number of rows on an AMP, and the number of rows that fit into the AMP's memory.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "tree.size",
      "useInR": true,
      "rOrderNum": 9
    },
    {
      "defaultValue": 1.0,
      "lowerBound": 1e-10,
      "upperBound": 10.0,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "CoverageFactor",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the level of coverage for the dataset while building trees (in percentage, e.g., 1.25 = 125% coverage). CoverageFactor can only be used if NumTrees is not supplied. When NumTrees is specified, coverage depends on the value of NumTrees. If NumTrees is not specified, NumTrees is chosen to achieve this level of coverage. The default coverage value is 100% (1.0) if NumTrees argument is not supplied. Because of internal sampling in bootstrapping, some rows may be chosen multiple times, and some not at all. A higher coverage level will ensure a higher probability of each row in input data to be selected during the tree building process (at the cost of building more trees).",
      "description": "Specify the level of coverage for the dataset while building trees (in percentage, e.g., 1.25 = 125% coverage). CoverageFactor can only be used if NumTrees is not supplied. When NumTrees is specified, coverage depends on the value of NumTrees. If NumTrees is not specified, NumTrees is chosen to achieve this level of coverage. The default coverage value is 100% (1.0) if NumTrees argument is not supplied. Because of internal sampling in bootstrapping, some rows may be chosen multiple times, and some not at all. A higher coverage level will ensure a higher probability of each row in input data to be selected during the tree building process (at the cost of building more trees).",
      "datatype": "DOUBLE",
      "allowsLists": false,
      "rName": "coverage.factor",
      "useInR": true,
      "rOrderNum": 10
    },
    {
      "defaultValue": 0.0,
      "lowerBound": 0.0,
      "upperBound": 1.79769313486231570815e+308,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "MinImpurity",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the minimum impurity at which the tree stops splitting further down. For regression, a criteria of squared error is used whereas for classification, gini impurity is used.",
      "description": "Specify the minimum impurity at which the tree stops splitting further down. For regression, a criteria of squared error is used whereas for classification, gini impurity is used.",
      "datatype": "DOUBLE",
      "allowsLists": false,
      "rName": "min.impurity",
      "useInR": true,
      "rOrderNum": 11
    }
  ]
}