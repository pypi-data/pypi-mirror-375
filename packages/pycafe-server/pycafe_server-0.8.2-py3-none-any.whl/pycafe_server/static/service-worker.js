(()=>{"use strict";const e=["trace","debug","info","warn","error","fatal"],s=new class{constructor(s,t){this.prefix=s,this.level=e.indexOf(t)}trace(...e){this.level<=0&&console.log(this.prefix,...e)}debug(...e){this.level<=1&&console.log(this.prefix,...e)}info(...e){this.level<=2&&console.log(this.prefix,...e)}warn(...e){this.level<=3&&console.warn(this.prefix,...e)}error(...e){this.level<=3&&console.error(this.prefix,...e)}fatal(...e){this.level<=4&&console.error(this.prefix,...e)}}("service-worker:","info");s.info("jcafe service-worker.js v4"),new BroadcastChannel("/api/drive.v1");const t={},n={},r={},a={},o={};let i=0;const c="pycafe-external-v1",d={},p={},h={};function f(e){s.info("initChannels",e);const i=function(e){const n=new BroadcastChannel("/api/fs/"+e);return n.onmessage=e=>{const t=e.data,n=t.fetchId,r=t.response,a=d[n];d[n]=async e=>{s.error("deferred response already exists",{fetchId:n,response:r,extraResponse:await e.text()})},a?(s.debug("fsChannel.onmessage",t),a(new Response(JSON.stringify(r)))):s.error("no deferred response",t.fetchId,t)},t[e]=n,n}(e),c=function(e){const t=new BroadcastChannel("/api/fetch/"+e);n[e]=t,t.onmessage=e=>{const t=e.data;if(s.debug("fetch",t),"fetch"===t.type){const e={status:t.status,headers:new Headers(t.headers)},n=d[t.fetchId];if(n){if(101==t.status||204==t.status||205==t.status||304==t.status)n(new Response(null,e));else if("chunked"==e.headers.get("Transfer-Encoding")){s.debug("chunked response",t.fetchId,t.body);let r=new ReadableStream({start(e){p[t.fetchId]=e,e.enqueue(t.body)}});n(new Response(r,e))}else n(new Response(t.body,e));delete d[t.fetchId]}else{if(p[t.fetchId])return s.debug("continue with stream",t.fetchId,t.body),void(t.body?p[t.fetchId].enqueue(t.body):(p[t.fetchId].close(),delete p[t.fetchId]));s.error("No deferred response or stream for",t.fetchId)}}}}(e),h=function(e){const t=new BroadcastChannel("/api/ws/"+e);return r[e]=t,t.onmessage=e=>{const t=e.data,n=t.fetchId;if("websocket_connect_reply"==e.data.type){s.debug("service worker ws message!!",t);const e=d[n],r={status:t.status,headers:new Headers(t.headers)};e(new Response(t.body,r))}},t}(e),f=function(e){const t=new BroadcastChannel("/api/input/"+e);return a[e]=t,t.onmessage=e=>{const t=e.data,n=t.inputId,r=t.response,a=d[n];d[n]=async e=>{s.error("deferred response already exists",{inputId:n,response:r,extraResponse:await e.text()})},a?(s.debug("inputChannel.onmessage",t),a(new Response(JSON.stringify(r)))):s.error("no deferred response",t.inputId,t)},t}(e),u=function(e){const t=new BroadcastChannel("/api/secrets/"+e);return o[e]=t,t.onmessage=e=>{const t=e.data,n=t.secretsId,r=t.response,a=d[n];d[n]=async e=>{s.error("deferred response already exists",{secretsId:n,response:r,extraResponse:await e.text()})},a?a(new Response(r)):s.error("no deferred response",t.secretsId,t)},t}(e);return{fsChannel:i,fetchChannel:c,wsChannel:h,inputChannel:f,secretsChannel:u}}self.addEventListener("fetch",(e=>{const p=e,u=p.clientId||p.resultingClientId;let l=h[u],g=p.request;const w=new URL(g.url);function I(e){t[e]||f(e)}async function y(){const e=i++,s=new Promise((s=>{d[e]=s})),t=await p.request.arrayBuffer(),o=[...p.request.headers.entries()];if(l||(l=w.pathname.split("/")[2]||"",h[u]=l),!l)return console.error("no pageId",u,w.toString()),new Response("no pageId",{status:500});I(l);const c=n[l],f=r[l],g=(a[l],{type:"fetch",pageId:l,url:w.pathname+w.search,fetchId:e,method:p.request.method,headers:o,body:t});return w.pathname.startsWith("/_ws")?(g.type="websocket_connect",f.postMessage(g)):c.postMessage(g),await s}function m(){l||(l=w.searchParams.get("pageId")||"",I(l),s.debug("using pageId from url",l))}if(w.pathname.startsWith("/_ping"))p.respondWith(new Response("pong"));else if(w.pathname.startsWith("/_app"))p.respondWith(y());else if(w.pathname.startsWith("/_pageId"))p.respondWith(async function(){const e=await p.request.json(),n=e.pageId;return console.info("linkPageId:",{clientId:u,pageId:l,newPageId:n,request:e,event:p}),u?h[u]=n:s.warn("no clientId to link to pageId"),t[n]||f(n),new Response('{"status": "ok"}',{headers:{"Content-Type":"application/json"}})}());else if(w.pathname.startsWith("/_ws"))p.respondWith(y());else if(w.pathname.startsWith("/_fs")){if(m(),!l)return s.error("no pageId for",u,w),new Response("no pageId",{status:500});p.respondWith(async function(){const e=await p.request.json(),n=i++;s.debug("mounted fs",p.request.url,e,n);const r=new Promise((e=>{d[n]=e}));return t[l]?t[l].postMessage({fetchId:n,request:e,pageId:l}):s.error("no fsChannel for, use /_pageId first",{pageId:l,request:e}),await r}())}else if(w.pathname.startsWith("/_input")){if(m(),!l)return s.error("no pageId for",u,w),new Response("no pageId",{status:500});const e=async()=>{const e=i++,s=new Promise((s=>{d[e]=s})),t=await p.request.json(),n=a[l],r={type:"input",inputId:e,inputData:t};return n.postMessage(r),s};p.respondWith(e())}else if(w.pathname.startsWith("/_secrets")){if(m(),!l)return s.error("no pageId for",u,w),new Response("no pageId",{status:500});const e=async()=>{const e=i++,s=new Promise((s=>{d[e]=s})),t=await p.request.text(),n=o[l],r={type:"secret",secretsId:e,data:t};return n.postMessage(r),s};p.respondWith(e())}else w.pathname.startsWith("/_jupyter/extensions/")||w.pathname.startsWith("/_jupyter/jupyter-lite.json")||"/static/assets/style.css"==w.pathname?p.respondWith(y()):"pypi.org"!=w.hostname&&"files.pythonhosted.org"!=w.hostname||p.respondWith(async function(e){const s=await caches.open(c),t=await s.match(e.request);if(t)return t;const n=await fetch(e.request.url);return s.put(e.request,n.clone()),n}(p))})),self.addEventListener("install",(function(e){e.waitUntil(caches.open(c)),self.skipWaiting()})),self.addEventListener("activate",(function(e){e.waitUntil(self.clients.claim())}))})();