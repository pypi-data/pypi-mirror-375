from __future__ import annotations
import numpy
import ostk.core.type
import ostk.mathematics.geometry.d2.object
import ostk.mathematics.geometry.d3
import typing
__all__ = ['Composite', 'Cone', 'Cuboid', 'Ellipsoid', 'Line', 'LineString', 'Plane', 'Point', 'PointSet', 'Polygon', 'Pyramid', 'Ray', 'Segment', 'Sphere', 'set_point_3_array']
class Composite(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def empty() -> Composite:
        ...
    @staticmethod
    def undefined() -> Composite:
        ...
    def __add__(self, arg0: Composite) -> Composite:
        ...
    def __eq__(self, arg0: Composite) -> bool:
        ...
    def __iadd__(self, arg0: Composite) -> Composite:
        ...
    def __init__(self, object: ostk.mathematics.geometry.d3.Object) -> None:
        ...
    def __ne__(self, arg0: Composite) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def access_object_at(self, index: int) -> ostk.mathematics.geometry.d3.Object:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def as_composite(self) -> Composite:
        ...
    def as_cone(self) -> Cone:
        ...
    def as_ellipsoid(self) -> Ellipsoid:
        ...
    def as_line(self) -> Line:
        ...
    def as_line_string(self) -> LineString:
        ...
    def as_plane(self) -> Plane:
        ...
    def as_point(self) -> Point:
        ...
    def as_point_set(self) -> PointSet:
        ...
    def as_polygon(self) -> Polygon:
        ...
    def as_pyramid(self) -> Pyramid:
        ...
    def as_ray(self) -> Ray:
        ...
    def as_segment(self) -> Segment:
        ...
    def as_sphere(self) -> Sphere:
        ...
    @typing.overload
    def contains(self, object: ostk.mathematics.geometry.d3.Object) -> bool:
        ...
    @typing.overload
    def contains(self, composite: Composite) -> bool:
        ...
    def get_object_count(self) -> int:
        ...
    @typing.overload
    def intersection_with(self, object: ostk.mathematics.geometry.d3.Object) -> ...:
        ...
    @typing.overload
    def intersection_with(self, composite: Composite) -> ...:
        ...
    @typing.overload
    def intersects(self, object: ostk.mathematics.geometry.d3.Object) -> bool:
        ...
    @typing.overload
    def intersects(self, composite: Composite) -> bool:
        ...
    def is_composite(self) -> bool:
        ...
    def is_cone(self) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_ellipsoid(self) -> bool:
        ...
    def is_empty(self) -> bool:
        ...
    def is_line(self) -> bool:
        ...
    def is_line_string(self) -> bool:
        ...
    def is_plane(self) -> bool:
        ...
    def is_point(self) -> bool:
        ...
    def is_point_set(self) -> bool:
        ...
    def is_polygon(self) -> bool:
        ...
    def is_pyramid(self) -> bool:
        ...
    def is_ray(self) -> bool:
        ...
    def is_segment(self) -> bool:
        ...
    def is_sphere(self) -> bool:
        ...
class Cone(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Cone:
        ...
    def __eq__(self, arg0: Cone) -> bool:
        ...
    def __init__(self, apex: Point, axis: numpy.ndarray[numpy.float64[3, 1]], angle: typing.Any) -> None:
        ...
    def __ne__(self, arg0: Cone) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    @typing.overload
    def contains(self, segment: Segment) -> bool:
        ...
    @typing.overload
    def contains(self, ray: Ray) -> bool:
        ...
    @typing.overload
    def contains(self, sphere: Sphere) -> bool:
        ...
    @typing.overload
    def contains(self, ellipsoid: Ellipsoid) -> bool:
        ...
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    def get_angle(self) -> ...:
        ...
    def get_apex(self) -> Point:
        ...
    def get_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_rays_of_lateral_surface(self, ray_count: int = 0) -> list[Ray]:
        ...
    @typing.overload
    def intersection_with(self, sphere: Sphere, only_in_sight: bool = False, discretization_level: int = 40) -> ...:
        ...
    @typing.overload
    def intersection_with(self, ellipsoid: Ellipsoid, only_in_sight: bool = False, discretization_level: int = 40) -> ...:
        ...
    @typing.overload
    def intersects(self, sphere: Sphere, discretization_level: int = 40) -> bool:
        ...
    @typing.overload
    def intersects(self, ellipsoid: Ellipsoid, discretization_level: int = 40) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class Cuboid(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def cube(center: Point, extent: ostk.core.type.Real) -> Cuboid:
        ...
    @staticmethod
    def undefined() -> Cuboid:
        ...
    def __eq__(self, arg0: Cuboid) -> bool:
        ...
    def __init__(self, center: Point, axes: list, extent: list) -> None:
        ...
    def __ne__(self, arg0: Cuboid) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def get_center(self) -> Point:
        ...
    def get_first_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_first_extent(self) -> ostk.core.type.Real:
        ...
    def get_second_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_second_extent(self) -> ostk.core.type.Real:
        ...
    def get_third_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_third_extent(self) -> ostk.core.type.Real:
        ...
    def get_vertices(self) -> list[Point]:
        ...
    @typing.overload
    def intersects(self, point: Point) -> bool:
        ...
    @typing.overload
    def intersects(self, point_set: PointSet) -> bool:
        ...
    @typing.overload
    def intersects(self, line: Line) -> bool:
        ...
    @typing.overload
    def intersects(self, cuboid: Cuboid) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_near(self, arg0: Cuboid, arg1: ostk.core.type.Real) -> bool:
        ...
class Ellipsoid(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Ellipsoid:
        ...
    def __eq__(self, arg0: Ellipsoid) -> bool:
        ...
    @typing.overload
    def __init__(self, center: Point, first_principal_semi_axis: ostk.core.type.Real, second_principal_semi_axis: ostk.core.type.Real, third_principal_semi_axis: ostk.core.type.Real) -> None:
        ...
    @typing.overload
    def __init__(self, center: Point, first_principal_semi_axis: ostk.core.type.Real, second_principal_semi_axis: ostk.core.type.Real, third_principal_semi_axis: ostk.core.type.Real, orientation: typing.Any) -> None:
        ...
    def __ne__(self, arg0: Ellipsoid) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    @typing.overload
    def contains(self, segment: Segment) -> bool:
        ...
    def get_center(self) -> Point:
        ...
    def get_first_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_first_principal_semi_axis(self) -> ostk.core.type.Real:
        ...
    def get_matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def get_orientation(self) -> ...:
        ...
    def get_second_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_second_principal_semi_axis(self) -> ostk.core.type.Real:
        ...
    def get_third_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_third_principal_semi_axis(self) -> ostk.core.type.Real:
        ...
    @typing.overload
    def intersection(self, line: Line) -> ...:
        ...
    @typing.overload
    def intersection(self, ray: Ray, only_in_sight: bool) -> ...:
        ...
    @typing.overload
    def intersection(self, segment: Segment) -> ...:
        ...
    @typing.overload
    def intersection(self, pyramid: typing.Any, only_in_sight: bool) -> ...:
        ...
    @typing.overload
    def intersection(self, cone: typing.Any, only_in_sight: bool) -> ...:
        ...
    @typing.overload
    def intersects(self, point: Point) -> bool:
        ...
    @typing.overload
    def intersects(self, point_set: PointSet) -> bool:
        ...
    @typing.overload
    def intersects(self, line: Line) -> bool:
        ...
    @typing.overload
    def intersects(self, ray: Ray) -> bool:
        ...
    @typing.overload
    def intersects(self, segment: Segment) -> bool:
        ...
    @typing.overload
    def intersects(self, plane: Plane) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class Line(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def points(first_point: Point, second_point: Point) -> Line:
        ...
    @staticmethod
    def undefined() -> Line:
        ...
    def __eq__(self, arg0: Line) -> bool:
        ...
    def __init__(self, origin: Point, direction: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def __ne__(self, arg0: Line) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    def get_direction(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_origin(self) -> Point:
        ...
    def intersection_with(self, plane: typing.Any) -> ...:
        ...
    @typing.overload
    def intersects(self, point: Point) -> bool:
        ...
    @typing.overload
    def intersects(self, plane: typing.Any) -> bool:
        ...
    @typing.overload
    def intersects(self, sphere: typing.Any) -> bool:
        ...
    @typing.overload
    def intersects(self, ellipsoid: typing.Any) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class LineString(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def empty() -> LineString:
        ...
    @staticmethod
    def segment(segment: Segment) -> LineString:
        ...
    def __eq__(self, arg0: LineString) -> bool:
        ...
    def __getitem__(self, index: int) -> Point:
        ...
    def __init__(self, points: list[Point]) -> None:
        ...
    def __iter__(self) -> typing.Iterator[Point]:
        ...
    def __len__(self) -> int:
        ...
    def __ne__(self, arg0: LineString) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def access_point_at(self, index: int) -> Point:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def get_point_closest_to(self, point: Point) -> Point:
        ...
    def get_point_count(self) -> int:
        ...
    def is_defined(self) -> bool:
        ...
    def is_empty(self) -> bool:
        ...
    def is_near(self, line_string: LineString, tolerance: ostk.core.type.Real) -> bool:
        ...
class Plane(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Plane:
        ...
    def __eq__(self, arg0: Plane) -> bool:
        ...
    def __init__(self, point: Point, normal_vector: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def __ne__(self, arg0: Plane) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    @typing.overload
    def contains(self, line: Line) -> bool:
        ...
    @typing.overload
    def contains(self, ray: Ray) -> bool:
        ...
    @typing.overload
    def contains(self, segment: Segment) -> bool:
        ...
    def get_normal_vector(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_point(self) -> Point:
        ...
    @typing.overload
    def intersection_with(self, point: Point) -> ...:
        ...
    @typing.overload
    def intersection_with(self, point_set: PointSet) -> ...:
        ...
    @typing.overload
    def intersection_with(self, line: Line) -> ...:
        ...
    @typing.overload
    def intersection_with(self, ray: Ray) -> ...:
        ...
    @typing.overload
    def intersection_with(self, segment: Segment) -> ...:
        ...
    @typing.overload
    def intersects(self, point: Point) -> bool:
        ...
    @typing.overload
    def intersects(self, point_set: PointSet) -> bool:
        ...
    @typing.overload
    def intersects(self, line: Line) -> bool:
        ...
    @typing.overload
    def intersects(self, ray: Ray) -> bool:
        ...
    @typing.overload
    def intersects(self, segment: Segment) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class Point(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def origin() -> Point:
        ...
    @staticmethod
    def undefined() -> Point:
        ...
    @staticmethod
    def vector(arg0: numpy.ndarray[numpy.float64[3, 1]]) -> Point:
        ...
    def __add__(self, arg0: numpy.ndarray[numpy.float64[3, 1]]) -> Point:
        ...
    def __eq__(self, arg0: Point) -> bool:
        ...
    def __init__(self, first_coordinate: ostk.core.type.Real, second_coordinate: ostk.core.type.Real, third_coordinate: ostk.core.type.Real) -> None:
        ...
    def __ne__(self, arg0: Point) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def __sub__(self, arg0: numpy.ndarray[numpy.float64[3, 1]]) -> Point:
        ...
    @typing.overload
    def __sub__(self, arg0: Point) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def as_vector(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    def is_defined(self) -> bool:
        ...
    def is_near(self, point: Point, tolerance: ostk.core.type.Real) -> bool:
        ...
    def to_string(self, precision: ostk.core.type.Integer = ...) -> ostk.core.type.String:
        ...
    def x(self) -> ostk.core.type.Real:
        ...
    def y(self) -> ostk.core.type.Real:
        ...
    def z(self) -> ostk.core.type.Real:
        ...
class PointSet(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def empty() -> PointSet:
        ...
    def __eq__(self, arg0: PointSet) -> bool:
        ...
    def __getitem__(self, arg0: int) -> Point:
        ...
    def __init__(self, points: list[Point]) -> None:
        ...
    def __iter__(self) -> typing.Iterator[Point]:
        ...
    def __len__(self) -> int:
        ...
    def __ne__(self, arg0: PointSet) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    def get_point_closest_to(self, point: Point) -> Point:
        ...
    def get_size(self) -> int:
        ...
    def is_defined(self) -> bool:
        ...
    def is_empty(self) -> bool:
        ...
    def is_near(self, point_set: PointSet, tolerance: ostk.core.type.Real) -> bool:
        ...
class Polygon(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Polygon:
        ...
    def __eq__(self, arg0: Polygon) -> bool:
        ...
    def __init__(self, polygon: ostk.mathematics.geometry.d2.object.Polygon, origin: Point, x_axis: numpy.ndarray[numpy.float64[3, 1]], y_axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def __ne__(self, arg0: Polygon) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def get_edge_at(self, index: int) -> Segment:
        ...
    def get_edge_count(self) -> int:
        ...
    def get_normal_vector(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_origin(self) -> Point:
        ...
    def get_polygon2d(self) -> ostk.mathematics.geometry.d2.object.Polygon:
        ...
    def get_vertex_at(self, index: int) -> Point:
        ...
    def get_vertex_count(self) -> int:
        ...
    def get_vertices(self) -> list[Point]:
        ...
    def get_x_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_y_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def is_defined(self) -> bool:
        ...
    def is_near(self, polygon: Polygon, tolerance: ostk.core.type.Real) -> bool:
        ...
class Pyramid(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Pyramid:
        ...
    def __eq__(self, arg0: Pyramid) -> bool:
        ...
    def __init__(self, base: Polygon, apex: Point) -> None:
        ...
    def __ne__(self, arg0: Pyramid) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    @typing.overload
    def contains(self, segment: Segment) -> bool:
        ...
    @typing.overload
    def contains(self, ellipsoid: Ellipsoid) -> bool:
        ...
    def get_apex(self) -> Point:
        ...
    def get_base(self) -> Polygon:
        ...
    def get_lateral_face_at(self, arg0: int) -> Polygon:
        ...
    def get_lateral_face_count(self) -> int:
        ...
    def get_rays_of_lateral_face_at(self, lateral_face_index: int, ray_count: int = 2) -> list[Ray]:
        ...
    def get_rays_of_lateral_faces(self, ray_count: int = 0) -> list[Ray]:
        ...
    @typing.overload
    def intersection_with(self, sphere: Sphere, only_in_sight: bool = False, discretization_level: int = 40) -> ...:
        ...
    @typing.overload
    def intersection_with(self, ellipsoid: Ellipsoid, only_in_sight: bool = False, discretization_level: int = 40) -> ...:
        ...
    def intersects(self, ellipsoid: Ellipsoid, discretization_level: int = 40) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class Ray(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Ray:
        ...
    def __eq__(self, arg0: Ray) -> bool:
        ...
    def __init__(self, origin: Point, direction: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def __ne__(self, arg0: Ray) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    def get_direction(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_origin(self) -> Point:
        ...
    @typing.overload
    def intersection_with(self, plane: typing.Any) -> ...:
        ...
    @typing.overload
    def intersection_with(self, sphere: typing.Any, only_in_sight: bool = False) -> ...:
        ...
    @typing.overload
    def intersection_with(self, ellipsoid: typing.Any, only_in_sight: bool = False) -> ...:
        ...
    @typing.overload
    def intersects(self, point: Point) -> bool:
        ...
    @typing.overload
    def intersects(self, plane: typing.Any) -> bool:
        ...
    @typing.overload
    def intersects(self, sphere: typing.Any) -> bool:
        ...
    @typing.overload
    def intersects(self, ellipsoid: typing.Any) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class Segment(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Segment:
        ...
    def __eq__(self, arg0: Segment) -> bool:
        ...
    def __init__(self, first_point: Point, second_point: Point) -> None:
        ...
    def __ne__(self, arg0: Segment) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def distance_to(self, point: Point) -> ostk.core.type.Real:
        ...
    @typing.overload
    def distance_to(self, point_set: PointSet) -> ostk.core.type.Real:
        ...
    def get_center(self) -> Point:
        ...
    def get_direction(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_first_point(self) -> Point:
        ...
    def get_length(self) -> ostk.core.type.Real:
        ...
    def get_second_point(self) -> Point:
        ...
    def intersection_with(self, plane: typing.Any) -> ...:
        ...
    @typing.overload
    def intersects(self, plane: typing.Any) -> bool:
        ...
    @typing.overload
    def intersects(self, sphere: typing.Any) -> bool:
        ...
    @typing.overload
    def intersects(self, ellipsoid: typing.Any) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_degenerate(self) -> bool:
        ...
    def to_line(self) -> Line:
        ...
class Sphere(ostk.mathematics.geometry.d3.Object):
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def undefined() -> Sphere:
        ...
    @staticmethod
    def unit(center: Point) -> Sphere:
        ...
    def __eq__(self, arg0: Sphere) -> bool:
        ...
    def __init__(self, center: Point, radius: ostk.core.type.Real) -> None:
        ...
    def __ne__(self, arg0: Sphere) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    @typing.overload
    def contains(self, point: Point) -> bool:
        ...
    @typing.overload
    def contains(self, point_set: PointSet) -> bool:
        ...
    def get_center(self) -> Point:
        ...
    def get_radius(self) -> ostk.core.type.Real:
        ...
    @typing.overload
    def intersection_with(self, line: Line) -> ...:
        ...
    @typing.overload
    def intersection_with(self, ray: Ray, only_in_sight: bool = False) -> ...:
        ...
    @typing.overload
    def intersects(self, point: Point) -> bool:
        ...
    @typing.overload
    def intersects(self, point_set: PointSet) -> bool:
        ...
    @typing.overload
    def intersects(self, line: Line) -> bool:
        ...
    @typing.overload
    def intersects(self, ray: Ray) -> bool:
        ...
    @typing.overload
    def intersects(self, segment: Segment) -> bool:
        ...
    @typing.overload
    def intersects(self, plane: Plane) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_unitary(self) -> bool:
        ...
def set_point_3_array(arg0: list[Point]) -> None:
    ...
