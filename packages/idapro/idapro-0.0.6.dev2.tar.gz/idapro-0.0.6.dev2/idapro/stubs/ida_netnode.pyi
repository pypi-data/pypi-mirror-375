from typing import Any, Optional, List, Dict, Tuple, Callable, Union

r"""Functions that provide the lowest level public interface to the database. Namely, we use Btree. To learn more about BTree:

[https://en.wikipedia.org/wiki/B-tree](https://en.wikipedia.org/wiki/B-tree)
We do not use Btree directly. Instead, we have another layer built on the top of Btree. Here is a brief explanation of this layer.
An object called "netnode" is modeled on the top of Btree. Each netnode has a unique id: a 32-bit value (64-bit for ida64). Initially there is a trivial mapping of the linear addresses used in the program to netnodes (later this mapping may be modified using ea2node and node2ea functions; this is used for fast database rebasings). If we have additional information about an address (for example, a comment is attached to it), this information is stored in the corresponding netnode. See nalt.hpp to see how the kernel uses netnodes. Also, some netnodes have no corresponding linear address (however, they still have an id). They are used to store information not related to a particular address.
Each netnode _may_ have the following attributes:

* a name: an arbitrary non-empty string, up to 255KB-1 bytes
* a value: arbitrary sized object, max size is MAXSPECSIZE
* altvals: a sparse array of 32-bit values. indexes in this array may be 8-bit or 32-bit values
* supvals: an array of arbitrary sized objects. (size of each object is limited by MAXSPECSIZE) indexes in this array may be 8-bit or 32-bit values
* charvals: a sparse array of 8-bit values. indexes in this array may be 8-bit or 32-bit values
* hashvals: a hash (an associative array). indexes in this array are strings values are arbitrary sized (max size is MAXSPECSIZE)


Initially a new netnode contains no information at all so no disk space is used for it. As you add new information, the netnode grows.
All arrays that are attached to the netnode behave in the same manner. Initially:
* all members of altvals/charvals array are zeroes
* all members of supvals/hashvals array are undefined


If you need to store objects bigger that MAXSPECSIZE, please note that there are high-level functions to store arbitrary sized objects in supvals. See setblob/getblob and other blob-related functions.
You may use netnodes to store additional information about the program. Limitations on the use of netnodes are the following:

* use netnodes only if you could not find a kernel service to store your type of information
* do not create netnodes with valid identifier names. Use the "$ " prefix (or any other prefix with characters not allowed in the identifiers for the names of your netnodes. Although you will probably not destroy anything by accident, using already defined names for the names of your netnodes is still discouraged.
* you may create as many netnodes as you want (creation of an unnamed netnode does not increase the size of the database). however, since each netnode has a number, creating too many netnodes could lead to the exhaustion of the netnode numbers (the numbering starts at 0xFF000000)
* remember that netnodes are automatically saved to the disk by the kernel.


Advanced info:
In fact a netnode may contain up to 256 arrays of arbitrary sized objects (not only the 4 listed above). Each array has an 8-bit tag. Usually tags are represented by character constants. For example, altvals and supvals are simply 2 of 256 arrays, with the tags 'A' and 'S' respectively. 
    
"""

class netnode:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, args: Any) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, args: Any) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def altdel(self, args: Any) -> bool:
        ...
    def altdel_all(self, args: Any) -> bool:
        ...
    def altdel_ea(self, args: Any) -> bool:
        ...
    def altdel_idx8(self, alt: uchar, tag: uchar) -> bool:
        ...
    def altfirst(self, args: Any) -> nodeidx_t:
        ...
    def altfirst_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def altlast(self, args: Any) -> nodeidx_t:
        ...
    def altlast_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def altnext(self, args: Any) -> nodeidx_t:
        ...
    def altnext_idx8(self, cur: uchar, tag: uchar) -> nodeidx_t:
        ...
    def altprev(self, args: Any) -> nodeidx_t:
        ...
    def altprev_idx8(self, cur: uchar, tag: uchar) -> nodeidx_t:
        ...
    def altset(self, args: Any) -> bool:
        ...
    def altset_ea(self, args: Any) -> bool:
        ...
    def altset_idx8(self, alt: uchar, val: nodeidx_t, tag: uchar) -> bool:
        ...
    def altshift(self, args: Any) -> int:
        ...
    def altval(self, args: Any) -> nodeidx_t:
        ...
    def altval_ea(self, args: Any) -> nodeidx_t:
        ...
    def altval_idx8(self, alt: uchar, tag: uchar) -> nodeidx_t:
        ...
    def blobshift(self, _from: nodeidx_t, to: nodeidx_t, size: nodeidx_t, tag: uchar) -> int:
        ...
    def blobsize(self, _start: nodeidx_t, tag: uchar) -> int:
        ...
    def blobsize_ea(self, ea: ida_idaapi.ea_t, tag: uchar) -> int:
        ...
    def chardel(self, alt: nodeidx_t, tag: uchar) -> bool:
        ...
    def chardel_ea(self, ea: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def chardel_idx8(self, alt: uchar, tag: uchar) -> bool:
        ...
    def charfirst(self, tag: uchar) -> nodeidx_t:
        ...
    def charfirst_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def charlast(self, tag: uchar) -> nodeidx_t:
        ...
    def charlast_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def charnext(self, cur: nodeidx_t, tag: uchar) -> nodeidx_t:
        ...
    def charnext_idx8(self, cur: uchar, tag: uchar) -> nodeidx_t:
        ...
    def charprev(self, cur: nodeidx_t, tag: uchar) -> nodeidx_t:
        ...
    def charprev_idx8(self, cur: uchar, tag: uchar) -> nodeidx_t:
        ...
    def charset(self, alt: nodeidx_t, val: uchar, tag: uchar) -> bool:
        ...
    def charset_ea(self, ea: ida_idaapi.ea_t, val: uchar, tag: uchar) -> bool:
        ...
    def charset_idx8(self, alt: uchar, val: uchar, tag: uchar) -> bool:
        ...
    def charshift(self, _from: nodeidx_t, to: nodeidx_t, size: nodeidx_t, tag: uchar) -> int:
        ...
    def charval(self, alt: nodeidx_t, tag: uchar) -> uchar:
        ...
    def charval_ea(self, ea: ida_idaapi.ea_t, tag: uchar) -> uchar:
        ...
    def charval_idx8(self, alt: uchar, tag: uchar) -> uchar:
        ...
    def copyto(self, destnode: netnode, count: nodeidx_t = 1) -> int:
        ...
    def create(self, args: Any) -> bool:
        ...
    def delblob(self, _start: nodeidx_t, tag: uchar) -> int:
        ...
    def delblob_ea(self, ea: ida_idaapi.ea_t, tag: uchar) -> int:
        ...
    def delvalue(self) -> bool:
        ...
    def eadel(self, ea: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def eadel_idx8(self, idx: uchar, tag: uchar) -> bool:
        ...
    def eaget(self, ea: ida_idaapi.ea_t, tag: uchar) -> ida_idaapi.ea_t:
        ...
    def eaget_idx(self, idx: nodeidx_t, tag: uchar) -> ida_idaapi.ea_t:
        ...
    def eaget_idx8(self, idx: uchar, tag: uchar) -> ida_idaapi.ea_t:
        ...
    def easet(self, ea: ida_idaapi.ea_t, addr: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def easet_idx(self, idx: nodeidx_t, addr: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def easet_idx8(self, idx: uchar, addr: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def end(self) -> bool:
        ...
    def exist(self, _name: str) -> bool:
        r"""Does the netnode with the specified name exist?
        
        """
        ...
    def get_name(self) -> ssize_t:
        ...
    def getblob(self, start: Any, tag: Any) -> Any:
        r"""Get a blob from a netnode.
        
        :param start: the index where the blob starts (it may span on multiple indexes)
        :param tag: the netnode tag
        :returns: a blob, or None
        """
        ...
    def getblob_ea(self, ea: ida_idaapi.ea_t, tag: char) -> Any:
        ...
    def getclob(self, start: Any, tag: Any) -> Any:
        r"""Get a large amount of text from a netnode.
        
        :param start: the index where the clob starts (it may span on multiple indexes)
        :param tag: the netnode tag
        :returns: a clob, or None
        """
        ...
    def hashdel(self, args: Any) -> bool:
        ...
    def hashdel_all(self, args: Any) -> bool:
        ...
    def hashfirst(self, args: Any) -> ssize_t:
        ...
    def hashlast(self, args: Any) -> ssize_t:
        ...
    def hashnext(self, args: Any) -> ssize_t:
        ...
    def hashprev(self, args: Any) -> ssize_t:
        ...
    def hashset(self, args: Any) -> bool:
        ...
    def hashset_buf(self, args: Any) -> bool:
        ...
    def hashset_idx(self, args: Any) -> bool:
        ...
    def hashstr(self, args: Any) -> ssize_t:
        ...
    def hashstr_buf(self, args: Any) -> Any:
        ...
    def hashval(self, args: Any) -> ssize_t:
        ...
    def hashval_long(self, args: Any) -> nodeidx_t:
        ...
    def index(self) -> nodeidx_t:
        ...
    def kill(self) -> None:
        ...
    def long_value(self) -> nodeidx_t:
        ...
    def lower_bound(self, args: Any) -> nodeidx_t:
        ...
    def lower_bound_ea(self, args: Any) -> nodeidx_t:
        ...
    def lower_bound_idx8(self, alt: uchar, tag: uchar) -> nodeidx_t:
        ...
    def moveto(self, destnode: netnode, count: nodeidx_t = 1) -> int:
        ...
    def next(self) -> bool:
        ...
    def prev(self) -> bool:
        ...
    def rename(self, newname: str, namlen: size_t = 0) -> bool:
        ...
    def set(self, value: void) -> bool:
        ...
    def set_long(self, x: nodeidx_t) -> bool:
        ...
    def setblob(self, buf: void, _start: nodeidx_t, tag: uchar) -> bool:
        ...
    def setblob_ea(self, buf: void, ea: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def start(self) -> bool:
        ...
    def supdel(self, args: Any) -> bool:
        ...
    def supdel_all(self, tag: uchar) -> bool:
        ...
    def supdel_ea(self, args: Any) -> bool:
        ...
    def supdel_idx8(self, alt: uchar, tag: uchar) -> bool:
        ...
    def supdel_range(self, idx1: nodeidx_t, idx2: nodeidx_t, tag: uchar) -> int:
        ...
    def supdel_range_idx8(self, idx1: uchar, idx2: uchar, tag: uchar) -> int:
        ...
    def supfirst(self, args: Any) -> nodeidx_t:
        ...
    def supfirst_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def suplast(self, args: Any) -> nodeidx_t:
        ...
    def suplast_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def supnext(self, args: Any) -> nodeidx_t:
        ...
    def supnext_idx8(self, alt: uchar, tag: uchar) -> nodeidx_t:
        ...
    def supprev(self, args: Any) -> nodeidx_t:
        ...
    def supprev_idx8(self, alt: uchar, tag: uchar) -> nodeidx_t:
        ...
    def supset(self, args: Any) -> bool:
        ...
    def supset_ea(self, args: Any) -> bool:
        ...
    def supset_idx8(self, alt: uchar, value: void, tag: uchar) -> bool:
        ...
    def supshift(self, args: Any) -> int:
        ...
    def supstr(self, args: Any) -> ssize_t:
        ...
    def supstr_ea(self, args: Any) -> ssize_t:
        ...
    def supstr_idx8(self, alt: uchar, tag: uchar) -> ssize_t:
        ...
    def supval(self, args: Any) -> ssize_t:
        ...
    def supval_ea(self, args: Any) -> ssize_t:
        ...
    def supval_idx8(self, args: Any) -> ssize_t:
        ...
    def valobj(self, args: Any) -> ssize_t:
        ...
    def valstr(self) -> ssize_t:
        ...
    def value_exists(self) -> bool:
        ...

def exist(n: netnode) -> bool:
    ...

def netnode_exist(_name: str) -> bool:
    r"""Does the netnode with the specified name exist?
    
    """
    ...

BADNODE: int  # 18446744073709551615
MAXNAMESIZE: int  # 512
MAXSPECSIZE: int  # 1024
MAX_NODENAME_SIZE: int  # 32768
NETMAP_IDX: int  # 256
NETMAP_STR: int  # 1024
NETMAP_V8: int  # 4096
NETMAP_VAL: int  # 512
NETMAP_VAL_NDX: int  # 8192
NETMAP_X8: int  # 2048
SIZEOF_nodeidx_t: int  # 8
SWIG_PYTHON_LEGACY_BOOL: int  # 1
annotations: _Feature  # _Feature((3, 7, 0, 'beta', 1), None, 16777216)
atag: int  # 65
cvar: swigvarlink
htag: int  # 72
ida_idaapi: module
ltag: int  # 76
ntag: int  # 78
stag: int  # 83
vtag: int  # 86
weakref: module