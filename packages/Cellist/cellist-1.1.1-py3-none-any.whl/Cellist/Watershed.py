# -*- coding: utf-8 -*-
# @Author: dongqing
# @Date:   2024-01-05 20:29:00
# @Last Modified by:   Dongqing
# @Last Modified time: 2025-08-25 18:58:38


import sys, os, gc
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import matplotlib
matplotlib.rcParams['font.family'] = 'sans-serif'
matplotlib.rcParams['font.sans-serif'] = ['Arial']

import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s  %(message)s')

from skimage.io import imread, imsave
from skimage.filters import threshold_otsu, threshold_multiotsu, threshold_niblack, threshold_local
from skimage.feature import peak_local_max
from skimage.measure import label, regionprops_table
from skimage.segmentation import watershed, expand_labels, mark_boundaries
from skimage.color import label2rgb, rgb2gray, rgb2hed
from skimage.segmentation import mark_boundaries
from skimage.morphology import remove_small_holes

from scipy.sparse import csc_matrix, save_npz, load_npz, csr_matrix
from scipy import ndimage as ndi

from Cellist.Utility import *
from Cellist.IO import write_10X_h5, write_segmentation_h5, write_segmentation_cell_coord, gem_to_mat
from Cellist.Plot import *

'''
cellist watershed --gem /mnt/Venus/home/dongxin/Projects/heart/202401_Stereo_seq/result_C02942B3/041.cellcut/C02942B3.adjusted.gem \
--tif Alignment/ssDNA_C02942B3_regist_regist_transposed_aligned_by_Spateo.tiff \
--outdir Watershed --outprefix C02942B3

cellist watershed --gem /fs/home/dongxin/Projects/heart/202401_Stereo_seq/result_C02942B3/041.cellcut/C02942B3.adjusted.gem \
--tif Alignment/ssDNA_C02942B3_regist_regist_transposed_aligned_by_Spateo.tiff \
--outdir Watershed --outprefix C02942B3
'''

def WatershedParser(subparsers):
    parser = subparsers.add_parser("watershed", 
        help = "Run initial watershed segmentation on the staining image. ")
    group_input = parser.add_argument_group("Input arguments")
    group_input.add_argument("--platform", dest = "platform", default = 'barcoding', choices = ['barcoding', 'imaging'],
        help = "Supported high-resoultion ST platform: 'barcoding' (e.g., Stereo-seq, Seq-scope) or "
        "'imaging' (e.g., seqFISH, STARmap, 10x Xenium). Default: barcoding.")
    group_input.add_argument("--gem", dest = "spot_expr_file", default = None,
        help = "Bin1 gem file generated by SAW pipeline located in '041.cellcut' or '04.tissuecut'. ")
    group_input.add_argument("--tif", dest = "regist_tif_file", default = None,
        help = "Registered tif file generated by SAW pipeline located in '04.tissuecut' or the refined tif file generated by 'cellist align'. ")
    group_input.add_argument("--min-distance", dest = "min_distance", type = int, default = 6,
        help = "The minimal allowed distance (in pixel) separating peaks for watershed segmentation. "
        "Peaks are the local maxima in a region of 2 * min_distance + 1 (i.e. peaks are separated by at least min_distance). Default: 6. ")
    group_input.add_argument("--no-local-threshold", dest = "no_local_threshold", action = "store_true", 
        help = "Whether or not to perform local thresholding on the image. "
        "If not set, Cellist will perform local thresholding. If set, the local thresholding will be skipped. ")
    group_input.add_argument("--expansion", dest = "expansion", action = "store_true", 
        help = "Whether or not to perform expansion after watershed segmentation. "
        "If set, expansion based on watershed segmentation will be performed. ")
    group_input.add_argument("--expansion-dist", dest = "expansion_dist", type = int, default = 8,
        help = "The expansion distance (in pixel). Default: 8. ")

    group_output = parser.add_argument_group("Output arguments")
    group_output.add_argument("--outdir", dest = "out_dir", default = '.',
        help = "The output directory. ")
    group_output.add_argument("--outprefix", dest = "out_prefix", default = None,
        help = "The output prefix. ")
    return(parser)

def Thresholding(platform, img_path, out_dir, out_img_prefix, no_local_threshold = False):
    img = imread(img_path)
    logging.info("Read image done. ")
    # 0. multiotsu thresholding
    logging.info("Thresholding... ")
    threshold = threshold_multiotsu(img, 3)[0]
    mask = img > threshold
    img_mask = img.copy()
    img_mask[~mask] = 0
    if no_local_threshold: 
        otsu_local = img_mask.copy()
        otsu_local_hole_rm = remove_small_holes(otsu_local)
        fig, ax = plt.subplots(1, 2, figsize=(30, 17), sharex=True, sharey=True)
        ax[0].imshow(img, cmap="gray")
        ax[0].set_title("Original", fontsize = 20)
        ax[1].imshow(mask, cmap = "gray")
        ax[1].set_title('Mask', fontsize = 20)
        for a in ax.ravel():
            a.axis('off')
        plt.savefig(os.path.join(out_dir, "%s_thresholding.png" %out_img_prefix), bbox_inches='tight')
    else:
        # 1. local thresholding
        local_thresh = threshold_local(img, block_size = 51, offset=0)
        local = img > local_thresh
        # 2. combine two thresholding results
        mask_local = img_mask > local_thresh
        otsu_local = np.logical_and(local, mask_local)        
        # 3. remove small holes
        otsu_local_hole_rm = remove_small_holes(otsu_local)
        if platform == "imaging":
            otsu_local_hole_rm = mask.copy()
        fig, ax = plt.subplots(2, 2, figsize=(30, 34), sharex=True, sharey=True)
        ax[0, 0].imshow(img, cmap="gray")
        ax[0, 0].set_title("Original", fontsize = 20)
        ax[0, 1].imshow(mask, cmap = "gray")
        ax[0, 1].set_title('Mask', fontsize = 20)
        ax[1, 0].imshow(local, cmap = "gray")
        ax[1, 0].set_title('Local thresholding', fontsize = 20)
        ax[1, 1].imshow(otsu_local_hole_rm, cmap = "gray")
        ax[1, 1].set_title('Mask + local thresholding', fontsize = 20)
        for a in ax.ravel():
            a.axis('off')
        plt.savefig(os.path.join(out_dir, "%s_thresholding.png" %out_img_prefix), bbox_inches='tight')
    imsave(os.path.join(out_dir, "%s_thresholding.tif" %out_img_prefix), otsu_local_hole_rm)
    logging.info("Threshold done. ")
    return img, otsu_local_hole_rm

def watershed_seg(img, otsu_local_hole_rm, out_dir, out_img_prefix, min_distance = 6, expansion = False, expansion_dist = 8):
    logging.info("Wartershed segmentation... ")
    # 0. find local markers
    distance_local = ndi.distance_transform_edt(otsu_local_hole_rm)
    local_max_coords = peak_local_max(distance_local, min_distance = min_distance, exclude_border=False)
    local_max_mask = np.zeros(distance_local.shape, dtype=bool)
    local_max_mask[tuple(local_max_coords.T)] = True
    markers = label(local_max_mask)
    fig, ax = plt.subplots(figsize=(20, 20))
    ax.imshow(img, cmap='gray')
    ax.plot(local_max_coords[:,1], local_max_coords[:,0], 'r*', markersize = 2)
    ax.set_title('Markers (%s local maxima)' % local_max_coords.shape[0], fontsize = 20)
    plt.savefig(os.path.join(out_dir, "%s_markers.png" %out_img_prefix), bbox_inches='tight')
    # 1. watershed segmentation
    segmented_cells = watershed(-distance_local, markers, mask = otsu_local_hole_rm)
    logging.info("Watershed number of segments: %s" %(len(np.unique(segmented_cells))))
    watershed_seg_file = os.path.join(out_dir, "%s_Watershed_nucleus_matrix.npz" %out_img_prefix)
    segmented_cells_mat = csc_matrix(segmented_cells, dtype=np.int32)
    save_npz(watershed_seg_file, segmented_cells_mat)
    fig, ax = plt.subplots(figsize=(20, 20))
    ax.imshow(mark_boundaries(img, segmented_cells, color = (1,0,0)))
    plt.savefig(os.path.join(out_dir, "%s_cell_boundary.png" %out_img_prefix), bbox_inches='tight')
    props = regionprops_table(segmented_cells, 
                              properties=['label', 'area','centroid',
                                          'equivalent_diameter_area'])
    props_df = pd.DataFrame(props)
    props_df.to_csv(os.path.join(out_dir, "%s_Watershed_nucleus_property.txt" %out_img_prefix), sep = "\t", index = False)
    if expansion:
        expanded = expand_labels(segmented_cells, distance = expansion_dist)
        watershed_seg_file = os.path.join(out_dir, "%s_Watershed_expansion_%s_cells_matrix.npz" %(out_img_prefix, expansion_dist))
        expanded_mat = csc_matrix(expanded, dtype=np.int32)
        save_npz(watershed_seg_file, expanded_mat)
        props_expanded = regionprops_table(expanded, 
                                  properties=['label', 'area','centroid',
                                              'equivalent_diameter_area'])
        props_df_expanded = pd.DataFrame(props_expanded)
        props_df_expanded.to_csv(os.path.join(out_dir, "%s_Watershed_expansion_%s_cells_property.txt" %(out_img_prefix, expansion_dist)), sep = "\t", index = False)
        return segmented_cells, expanded
    else:
        return segmented_cells

def write_segmentation_coord(segmented_cells, coord_df, out_dir, out_gem_prefix, seg_method = "Watershed", expansion = False, expanded = None, expansion_dist = 8):
    logging.info("Writing segmentation results... ")
    nucleus_loc = np.where(segmented_cells != 0)
    nucleus_coord_df = pd.DataFrame({'x': nucleus_loc[0],'y': nucleus_loc[1], 'Nucleus':1, seg_method: segmented_cells[nucleus_loc]})
    nucleus_barcode_df = pd.merge(coord_df, nucleus_coord_df, how = "left", on = ['x', 'y'])
    nucleus_barcode_df['Nucleus'] = nucleus_barcode_df['Nucleus'].fillna(0)
    nucleus_barcode_df['Nucleus'] = nucleus_barcode_df['Nucleus'].astype(int)
    nucleus_barcode_df = nucleus_barcode_df.sort_values(['x', 'y'])
    nucl_coord_out_file = os.path.join(out_dir, "%s_%s_nucleus_coord.txt" %(out_gem_prefix, seg_method))
    nucleus_barcode_df.to_csv(nucl_coord_out_file, sep = "\t", index = False)
    nucleus_barcode_df = nucleus_barcode_df.loc[nucleus_barcode_df[seg_method] != 0, :]
    nucleus_coord_nspot = write_segmentation_cell_coord(coord_df_seg = nucleus_barcode_df, seg_res = seg_method, 
        out_prefix = "%s_%s" %(out_gem_prefix, seg_method), out_dir = out_dir)
    nucleus_label_nspot_over20 = nucleus_coord_nspot.loc[nucleus_coord_nspot['nSpot'] >= 20,:].index.tolist()
    logging.info("Writing segmentation results is done.")
    if expansion:
        expanded_loc = np.where(expanded != 0)
        exp_seg_method = '%s_expansion_%s' %(seg_method, expansion_dist)
        expanded_coord_df = pd.DataFrame({'x': expanded_loc[0],'y': expanded_loc[1], exp_seg_method: expanded[expanded_loc]})
        expanded_barcode_df = pd.merge(nucleus_barcode_df[['x', 'y', 'x_y', 'Nucleus']], expanded_coord_df, how = "left", on = ['x', 'y'])
        expanded_barcode_df = expanded_barcode_df.sort_values(['x', 'y'])
        expanded_barcode_df = expanded_barcode_df.loc[expanded_barcode_df[exp_seg_method].isin(nucleus_label_nspot_over20),:]
        cell_coord_out_file = os.path.join(out_dir, "%s_%s_expansion_%s_cells_coord.txt" %(out_gem_prefix, seg_method, expansion_dist))
        expanded_barcode_df.to_csv(cell_coord_out_file, sep = "\t", index = False)
        expanded_barcode_df = expanded_barcode_df.loc[expanded_barcode_df[exp_seg_method] != 0, :]
        expanded_coord_nspot = write_segmentation_cell_coord(coord_df_seg = expanded_barcode_df, seg_res = exp_seg_method, 
            out_prefix = "%s_%s" %(out_gem_prefix, exp_seg_method), out_dir = out_dir)
        return nucleus_barcode_df, expanded_barcode_df
    else:
        return nucleus_barcode_df

def write_segmentation_cell(nucleus_barcode_df, count_df, out_gem_prefix, out_dir, seg_method = "Watershed", expansion = False, expanded_barcode_df = None, expansion_dist = 8):
    logging.info("Writing cell-level expression matrix... ")
    count_df_segmentation = pd.merge(count_df, nucleus_barcode_df[['x_y', seg_method]], how = "right", on = 'x_y')
    count_name = count_df_segmentation.columns[3]
    count_df_segmentation = count_df_segmentation.loc[count_df_segmentation[seg_method] != 0, :]
    write_segmentation_h5(count_df_seg = count_df_segmentation, seg_res = seg_method, out_prefix = "%s_%s" %(out_gem_prefix, seg_method), 
        out_dir = out_dir, count_name = count_name)
    if expansion:
        exp_seg_method = '%s_expansion_%s' %(seg_method, expansion_dist)
        count_df_expansion = pd.merge(count_df, expanded_barcode_df[['x_y', exp_seg_method]], how = "right", on = 'x_y')
        count_name = count_df_expansion.columns[3]
        count_df_expansion = count_df_expansion.loc[count_df_expansion[exp_seg_method] != 0, :]
        write_segmentation_h5(count_df_seg = count_df_expansion, seg_res = exp_seg_method, out_prefix = "%s_%s" %(out_gem_prefix, exp_seg_method), 
            out_dir = out_dir, count_name = count_name)
    logging.info("Writing cell-level expression matrix is done.")

def Watershed(platform, gem_path, img_path, out_dir, out_prefix, min_distance, no_local_threshold, expansion, expansion_dist):
    if not out_prefix:
        file_name, file_extension = os.path.splitext(gem_path)
        base_name = os.path.basename(file_name)
        out_gem_prefix = base_name
        file_name, file_extension = os.path.splitext(img_path)
        base_name = os.path.basename(file_name)
        out_img_prefix = base_name
    else:
        out_gem_prefix = out_prefix
        out_img_prefix = out_prefix
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)
    # --------------------- read image file and thresholding --------------------- 
    threshold_file = os.path.join(out_dir, "%s_thresholding.tif" %out_img_prefix)
    if os.path.exists(threshold_file):
        otsu_local_hole_rm = imread(threshold_file)
        img = imread(img_path)
    else:
        img, otsu_local_hole_rm = Thresholding(platform, img_path, out_dir, out_img_prefix, no_local_threshold)
    # --------------------- watershed segmentation --------------------- 
    if expansion:
        segmented_cells, expanded = watershed_seg(img, otsu_local_hole_rm, out_dir, out_img_prefix, min_distance = min_distance, expansion = expansion, expansion_dist = expansion_dist)
    else:
        segmented_cells = watershed_seg(img, otsu_local_hole_rm, out_dir, out_img_prefix, min_distance = min_distance, expansion = expansion, expansion_dist = expansion_dist)
    # --------------------- read gem file --------------------- 
    logging.info("Reading count file...")
    gem_df = pd.read_csv(gem_path, sep = "\t", comment = "#")
    bin1_out_file = os.path.join(out_dir, "%s_bin1.h5" %out_gem_prefix)
    countname = gem_df.columns[3]
    gem_df = gem_to_mat(gem_df = gem_df, outfile = bin1_out_file, countname = countname)
    coord_df = gem_df.drop_duplicates(subset = ['x_y'])
    coord_df = coord_df[["x", "y", "x_y"]]
    # --------------------- write segmentation result ---------------------
    if expansion:
        nucleus_barcode_df, expanded_barcode_df = write_segmentation_coord(segmented_cells, coord_df, out_dir, out_gem_prefix, seg_method = "Watershed", expansion = expansion, expanded = expanded, expansion_dist = expansion_dist)
    else:
        nucleus_barcode_df = write_segmentation_coord(segmented_cells, coord_df, out_dir, out_gem_prefix, seg_method = "Watershed")
        expanded_barcode_df = None
    write_segmentation_cell(nucleus_barcode_df, gem_df, out_gem_prefix, out_dir, seg_method = "Watershed", expansion = expansion, expanded_barcode_df = expanded_barcode_df, expansion_dist = expansion_dist)
    logging.info("Drawing segmentation plot...")
    draw_segmentation(nucleus_barcode_df, seg_res = "Watershed", out_prefix = "%s_Watershed" %out_gem_prefix,
        out_dir = out_dir, x = "x", y = "y", figsize = (80, 80))
    if expansion:
        draw_segmentation(expanded_barcode_df, seg_res = 'Watershed_expansion_%s' %(expansion_dist), out_prefix = "%s_Watershed_expansion_%s" %(out_gem_prefix, expansion_dist),
            out_dir = out_dir, x = "x", y = "y", figsize = (80, 80))
    logging.info("Drawing segmentation plot is done.")
    logging.info("All done!")

if __name__ == '__main__':
    parser = WatershedParser()
    platform = parser.platform
    gem_path = parser.spot_expr_file
    img_path = parser.regist_tif_file
    out_dir = parser.out_dir
    out_prefix = parser.out_prefix
    min_distance = parser.min_distance
    no_local_threshold = parser.no_local_threshold
    expansion = parser.expansion
    expansion_dist = parser.expansion_dist
    Watershed(platform = platform, gem_path = gem_path, img_path = img_path, out_dir = out_dir, out_prefix = out_prefix, min_distance = min_distance, no_local_threshold = no_local_threshold, expansion = expansion, expansion_dist = expansion_dist)
