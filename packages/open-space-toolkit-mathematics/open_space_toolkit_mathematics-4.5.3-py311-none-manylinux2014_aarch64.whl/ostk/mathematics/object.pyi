from __future__ import annotations
import ostk.core.type
import typing
__all__ = ['RealInterval']
class RealInterval:
    class Type:
        """
        Members:
        
          Undefined
        
          Closed
        
          Open
        
          HalfOpenLeft
        
          HalfOpenRight
        """
        Closed: typing.ClassVar[RealInterval.Type]  # value = <Type.Closed: 1>
        HalfOpenLeft: typing.ClassVar[RealInterval.Type]  # value = <Type.HalfOpenLeft: 3>
        HalfOpenRight: typing.ClassVar[RealInterval.Type]  # value = <Type.HalfOpenRight: 4>
        Open: typing.ClassVar[RealInterval.Type]  # value = <Type.Open: 2>
        Undefined: typing.ClassVar[RealInterval.Type]  # value = <Type.Undefined: 0>
        __members__: typing.ClassVar[dict[str, RealInterval.Type]]  # value = {'Undefined': <Type.Undefined: 0>, 'Closed': <Type.Closed: 1>, 'Open': <Type.Open: 2>, 'HalfOpenLeft': <Type.HalfOpenLeft: 3>, 'HalfOpenRight': <Type.HalfOpenRight: 4>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def clip(intervals: list[RealInterval], clipping_interval: RealInterval) -> list[RealInterval]:
        ...
    @staticmethod
    def closed(lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real) -> RealInterval:
        ...
    @staticmethod
    def get_gaps(intervals: list[RealInterval], bound: RealInterval = ...) -> list[RealInterval]:
        ...
    @staticmethod
    def half_open_left(lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real) -> RealInterval:
        ...
    @staticmethod
    def half_open_right(lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real) -> RealInterval:
        ...
    @staticmethod
    def logical_and(intervals_1: list[RealInterval], intervals_2: list[RealInterval]) -> list[RealInterval]:
        ...
    @staticmethod
    def logical_or(intervals_1: list[RealInterval], intervals_2: list[RealInterval]) -> list[RealInterval]:
        ...
    @staticmethod
    def merge(intervals: list[RealInterval]) -> list[RealInterval]:
        ...
    @staticmethod
    def open(lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real) -> RealInterval:
        ...
    @staticmethod
    def sort(intervals: list[RealInterval], by_lower_bound: bool = True, ascending: bool = True) -> list[RealInterval]:
        ...
    @staticmethod
    def undefined() -> RealInterval:
        ...
    def __eq__(self, arg0: RealInterval) -> bool:
        ...
    def __init__(self, lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real, type: typing.Any) -> None:
        ...
    def __ne__(self, arg0: RealInterval) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def contains(self, real: ostk.core.type.Real) -> bool:
        ...
    @typing.overload
    def contains(self, interval: RealInterval) -> bool:
        ...
    def get_intersection_with(self, interval: RealInterval) -> RealInterval:
        ...
    def get_lower_bound(self) -> ostk.core.type.Real:
        ...
    def get_union_with(self, interval: RealInterval) -> RealInterval:
        ...
    def get_upper_bound(self) -> ostk.core.type.Real:
        ...
    def intersects(self, interval: RealInterval) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_degenerate(self) -> bool:
        ...
    def to_string(self) -> ostk.core.type.String:
        ...
