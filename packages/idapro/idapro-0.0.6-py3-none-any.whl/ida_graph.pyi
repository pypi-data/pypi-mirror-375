from typing import Any, Optional, List, Dict, Tuple, Callable, Union

r"""Graph view management.

"""

class GraphViewer:
    def AddCommand(self, title: Any, shortcut: Any) -> Any:
        ...
    def AddEdge(self, src_node: Any, dest_node: Any) -> Any:
        r"""Creates an edge between two given node ids"""
        ...
    def AddNode(self, obj: Any) -> Any:
        r"""Creates a node associated with the given object and returns the node id"""
        ...
    def Clear(self) -> Any:
        r"""Clears all the nodes and edges"""
        ...
    def Close(self) -> Any:
        r"""
        Closes the graph.
        It is possible to call Show() again (which will recreate the graph)
        
        """
        ...
    def Count(self) -> Any:
        r"""Returns the node count"""
        ...
    def CreateGroups(self, groups_infos: Any) -> Any:
        r"""
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.
        
        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }
        
        :param groups_infos: A list of objects that describe those groups.
        :returns: A [<int>, <int>, ...] list of group nodes, or None (failure).
        
        """
        ...
    def DelNodesInfos(self, nodes: Any) -> Any:
        r"""
        Delete the properties for the given node(s).
        
        :param nodes: A list of node IDs
        
        """
        ...
    def DeleteGroups(self, groups: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to delete the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param new_current: A node to focus on after the groups have been deleted
        :returns: True on success, False otherwise.
        
        """
        ...
    def GetCurrentRendererType(self) -> Any:
        ...
    def GetNodeInfo(self, args: Any) -> Any:
        r"""
        Get the properties for the given node.
        
        :param ni: A node_info_t instance
        :param node: The index of the node.
        :returns: success
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def GetWidgetAsGraphViewer(self) -> Any:
        r"""
        Return the graph_viewer_t underlying this view.
        
        :returns: The graph_viewer_t underlying this view, or None.
        
        """
        ...
    def OnCommand(self, cmd_id: Any) -> Any:
        ...
    def OnPopup(self, widget: Any, popup_handle: Any) -> Any:
        ...
    def OnRefresh(self) -> Any:
        r"""
        Event called when the graph is refreshed or first created.
        From this event you are supposed to create nodes and edges.
        This callback is mandatory.
        
        NOTE: ***It is important to clear previous nodes before adding nodes.***
        
        :returns: Returning True tells the graph viewer to use the items. Otherwise old items will be used.
        
        """
        ...
    def Refresh(self) -> Any:
        r"""
        Refreshes the view. This causes the OnRefresh() to be called
        
        """
        ...
    def Select(self, node_id: Any) -> Any:
        r"""Selects a node on the graph"""
        ...
    def SetCurrentRendererType(self, rtype: Any) -> Any:
        r"""
        Set the current view's renderer.
        
        :param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        
        """
        ...
    def SetGroupsVisibility(self, groups: Any, expand: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param expand: True to expand the group, False otherwise.
        :param new_current: A node to focus on after the groups have been expanded/collapsed.
        :returns: True on success, False otherwise.
        
        """
        ...
    def SetNodeInfo(self, node_index: Any, node_info: Any, flags: Any) -> Any:
        r"""
        Set the properties for the given node.
        
        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
        
        :param node_index: The node index.
        :param node_info: An idaapi.node_info_t instance.
        :param flags: An OR'ed value of NIF_* values.
        
        """
        ...
    def SetNodesInfos(self, values: Any) -> Any:
        r"""
        Set the properties for the given nodes.
        
        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
        
        :param values: A dictionary of 'int -> node_info_t' objects.
        
        """
        ...
    def Show(self) -> Any:
        r"""
        Shows an existing graph or creates a new one
        
        :returns: Boolean
        
        """
        ...
    def UI_Hooks_Trampoline(self, v: Any) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, idx: Any) -> Any:
        r"""Returns a reference to the object associated with this node id"""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, title: Any, close_open: Any = False) -> Any:
        r"""
        Constructs the GraphView object.
        Please do not remove or rename the private fields
        
        :param title: The title of the graph window
        :param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?
        
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...
    def view_activated(self, view: Any) -> Any:
        ...
    def view_click(self, view: Any, ve: Any) -> Any:
        ...
    def view_close(self, view: Any, args: Any) -> Any:
        ...
    def view_created(self, view: TWidget) -> None:
        r"""A view is being created. 
                  
        :param view: (TWidget *)
        """
        ...
    def view_curpos(self, view: Any, args: Any) -> Any:
        ...
    def view_dblclick(self, view: Any, ve: Any) -> Any:
        ...
    def view_deactivated(self, view: Any) -> Any:
        ...
    def view_keydown(self, view: Any, key: Any, state: Any) -> Any:
        ...
    def view_loc_changed(self, view: Any, now: Any, was: Any) -> Any:
        ...
    def view_mouse_moved(self, view: Any, ve: Any) -> Any:
        ...
    def view_mouse_over(self, view: Any, ve: Any) -> Any:
        ...
    def view_switched(self, view: Any, rt: Any) -> Any:
        ...

class TPointDouble:
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: TPointDouble) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: TPointDouble) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, r: TPointDouble) -> None:
        ...
    def negate(self) -> None:
        ...
    def sub(self, r: TPointDouble) -> None:
        ...

class abstract_graph_t:
    @property
    def callback_ud(self) -> Any: ...
    @property
    def circle_center(self) -> Any: ...
    @property
    def circle_radius(self) -> Any: ...
    @property
    def current_layout(self) -> Any: ...
    @property
    def rect_edges_made(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> node_iterator:
        ...
    def create_circle_layout(self, p: point_t, radius: int) -> bool:
        ...
    def create_tree_layout(self) -> bool:
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_edge(self, e: edge_t) -> edge_info_t:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def grcall(self, code: int) -> ssize_t:
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nrect(self, n: int) -> rect_t:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def set_callback(self, _callback: hook_cb_t, _ud: void) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class drawable_graph_t:
    @property
    def callback_ud(self) -> Any: ...
    @property
    def circle_center(self) -> Any: ...
    @property
    def circle_radius(self) -> Any: ...
    @property
    def current_layout(self) -> Any: ...
    @property
    def rect_edges_made(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> node_iterator:
        ...
    def create_circle_layout(self, p: point_t, radius: int) -> bool:
        ...
    def create_tree_layout(self) -> bool:
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_edge(self, e: edge_t) -> edge_info_t:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def grcall(self, code: int) -> ssize_t:
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nrect(self, n: int) -> rect_t:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def set_callback(self, _callback: hook_cb_t, _ud: void) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class edge_info_t:
    @property
    def color(self) -> Any: ...
    @property
    def dstoff(self) -> Any: ...
    @property
    def layout(self) -> Any: ...
    @property
    def srcoff(self) -> Any: ...
    @property
    def width(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def reverse_layout(self) -> None:
        ...

class edge_infos_wrapper_t:
    @property
    def ptr(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def clear(self) -> None:
        ...

class edge_layout_point_t:
    @property
    def e(self) -> Any: ...
    @property
    def pidx(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: edge_layout_point_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: edge_layout_point_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: edge_layout_point_t) -> int:
        ...

class edge_segment_t:
    @property
    def e(self) -> Any: ...
    @property
    def nseg(self) -> Any: ...
    @property
    def x0(self) -> Any: ...
    @property
    def x1(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: edge_segment_t) -> bool:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def length(self) -> int:
        ...
    def toright(self) -> bool:
        ...

class edge_t:
    @property
    def dst(self) -> Any: ...
    @property
    def src(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, y: edge_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, x: int = 0, y: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, y: edge_t) -> bool:
        ...
    def __ne__(self, y: edge_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class graph_item_t:
    @property
    def b(self) -> Any: ...
    @property
    def e(self) -> Any: ...
    @property
    def elp(self) -> Any: ...
    @property
    def n(self) -> Any: ...
    @property
    def p(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_edge(self) -> bool:
        ...
    def is_node(self) -> bool:
        ...

class graph_node_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_forbidden_edge(self, arg0: int, arg1: int) -> bool:
        r"""Should the edge between 'n' and 'm' be ignored?
        
        """
        ...
    def is_visited(self, n: int) -> bool:
        r"""Have we already visited the given node?
        
        """
        ...
    def reinit(self) -> None:
        r"""Reset visited nodes.
        
        """
        ...
    def set_visited(self, n: int) -> None:
        r"""Mark node as visited.
        
        """
        ...
    def visit_node(self, arg0: int) -> int:
        r"""Implements action to take when a node is visited.
        
        """
        ...

class graph_path_visitor_t:
    @property
    def path(self) -> Any: ...
    @property
    def prune(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def walk_backward(self, arg0: int) -> int:
        ...
    def walk_forward(self, arg0: int) -> int:
        ...

class graph_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_edge(self, arg2: edge_t, arg3: edge_info_t) -> int:
        ...
    def visit_node(self, arg2: int, arg3: rect_t) -> int:
        ...

class group_crinfo_t:
    @property
    def nodes(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class interactive_graph_t(drawable_graph_t):
    @property
    def belongs(self) -> Any: ...
    @property
    def callback_ud(self) -> Any: ...
    @property
    def circle_center(self) -> Any: ...
    @property
    def circle_radius(self) -> Any: ...
    @property
    def current_layout(self) -> Any: ...
    @property
    def edges(self) -> Any: ...
    @property
    def gid(self) -> Any: ...
    @property
    def node_flags(self) -> Any: ...
    @property
    def nodes(self) -> Any: ...
    @property
    def org_preds(self) -> Any: ...
    @property
    def org_succs(self) -> Any: ...
    @property
    def preds(self) -> Any: ...
    @property
    def rect_edges_made(self) -> Any: ...
    @property
    def succs(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_edge(self, i: int, j: int, ei: edge_info_t) -> bool:
        ...
    def add_node(self, r: rect_t) -> int:
        r"""Add a node, possibly with a specific geometry
        
        :param r: the node geometry (can be nullptr)
        :returns: the new node
        """
        ...
    def begin(self) -> node_iterator:
        ...
    def calc_group_ea(self, arg2: intvec_t) -> ida_idaapi.ea_t:
        ...
    def change_group_visibility(self, group: int, expand: bool) -> bool:
        r"""Expand/collapse a group node
        
        :param group: the group node
        :param expand: whether to expand or collapse
        :returns: success
        """
        ...
    def create_circle_layout(self, p: point_t, radius: int) -> bool:
        ...
    def create_digraph_layout(self) -> bool:
        ...
    def create_group(self, nodes: intvec_t) -> int:
        r"""Create a new group node, that will contain all the nodes in 'nodes'.
        
        :param nodes: the nodes that will be part of the group
        :returns: the group node, or -1 in case of error
        """
        ...
    def create_tree_layout(self) -> bool:
        ...
    def del_custom_layout(self) -> None:
        ...
    def del_edge(self, i: int, j: int) -> bool:
        ...
    def del_node(self, n: int) -> ssize_t:
        r"""Delete a node
        
        :param n: the node to delete
        :returns: the number of deleted edges
        """
        ...
    def delete_group(self, group: int) -> bool:
        r"""Delete a group node.
        This deletes the group node only; it does not delete nodes that are part of the group.
        
        :param group: the group node
        :returns: success
        """
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        r"""Is the graph (visually) empty? 
                
        :returns: true if there are no visible nodes
        """
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        r"""Is the node visible?
        
        :param node: the node number
        :returns: success
        """
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_custom_layout(self) -> bool:
        ...
    def get_edge(self, e: edge_t) -> edge_info_t:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_first_subgraph_node(self, group: int) -> int:
        ...
    def get_graph_groups(self) -> bool:
        ...
    def get_next_subgraph_node(self, group: int, current: int) -> int:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_group(self, node: int) -> int:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def get_node_representative(self, node: int) -> int:
        r"""Get the node that currently visually represents 'node'. This will find the "closest" parent group node that's visible, by attempting to walk up the group nodes that contain 'node', and will stop when it finds a node that is currently visible.
        See also get_group_node() 
                
        :param node: the node
        :returns: the node that represents 'node', or 'node' if it's not part of any group
        """
        ...
    def grcall(self, code: int) -> ssize_t:
        ...
    def is_collapsed_node(self, node: int) -> bool:
        ...
    def is_deleted_node(self, node: int) -> bool:
        ...
    def is_displayable_node(self, node: int) -> bool:
        ...
    def is_dot_node(self, node: int) -> bool:
        ...
    def is_group_node(self, node: int) -> bool:
        ...
    def is_simple_node(self, node: int) -> bool:
        ...
    def is_subgraph_node(self, node: int) -> bool:
        ...
    def is_uncollapsed_node(self, node: int) -> bool:
        ...
    def is_user_graph(self) -> bool:
        ...
    def is_visible_node(self, node: int) -> bool:
        r"""Is the node currently visible?
        An invisible node is a node that's part of a group that's currently collapsed.
        
        :param node: the node
        :returns: success
        """
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        r"""Get the number of visible nodes (the list can be retrieved using gdl.hpp's node_iterator)
        See also size()
        
        :returns: the number of visible nodes
        """
        ...
    def npred(self, b: int) -> int:
        ...
    def nrect(self, n: int) -> rect_t:
        ...
    def nsucc(self, b: int) -> int:
        ...
    def pred(self, b: int, i: int) -> int:
        ...
    def predset(self, b: int) -> intvec_t:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def redo_layout(self) -> bool:
        r"""Recompute the layout, according to the value of 'current_layout'.
        
        :returns: success
        """
        ...
    def refresh(self) -> bool:
        r"""Refresh the graph
        A graph needs refreshing when it's "backing data". E.g., if the number (or contents) of the objects in the above example, change.
        Let's say the user's plugin ends up finding a 5th piece of scattered data. It should then add it to its internal list of known objects, and tell IDA that the graph needs to be refreshed, using refresh_viewer(). This will cause IDA to:
        * discard all its internal rendering information,
        * call interactive_graph_t::refresh() on the graph so that the user's plugin has a chance to "sync" the number of nodes & edges that this graph contains, to the information that the plugin has collected so far
        * re-create internal rendering information, and
        * repaint the view
        
        
        
        :returns: success
        """
        ...
    def replace_edge(self, i: int, j: int, x: int, y: int) -> bool:
        ...
    def reset(self) -> None:
        ...
    def resize(self, n: int) -> None:
        r"""Resize the graph to 'n' nodes
        
        :param n: the new size
        """
        ...
    def set_callback(self, _callback: hook_cb_t, _ud: void) -> None:
        ...
    def set_custom_layout(self) -> None:
        ...
    def set_deleted_node(self, node: int) -> None:
        ...
    def set_edge(self, e: edge_t, ei: edge_info_t) -> bool:
        ...
    def set_graph_groups(self) -> None:
        ...
    def set_node_group(self, node: int, group: int) -> None:
        ...
    def set_nrect(self, n: int, r: rect_t) -> bool:
        ...
    def size(self) -> int:
        r"""Get the total number of nodes (including group nodes, and including hidden nodes.)
        See also node_qty()
        
        :returns: the total number of nodes in the graph
        """
        ...
    def succ(self, b: int, i: int) -> int:
        ...
    def succset(self, b: int) -> intvec_t:
        ...

class interval_t:
    @property
    def x0(self) -> Any: ...
    @property
    def x1(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: interval_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: interval_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def contains(self, x: int) -> bool:
        ...
    def empty(self) -> bool:
        ...
    def intersect(self, r: interval_t) -> None:
        ...
    def length(self) -> int:
        ...
    def make_union(self, r: interval_t) -> None:
        ...
    def move_by(self, shift: int) -> None:
        ...

class mutable_graph_t(drawable_graph_t):
    @property
    def belongs(self) -> Any: ...
    @property
    def callback_ud(self) -> Any: ...
    @property
    def circle_center(self) -> Any: ...
    @property
    def circle_radius(self) -> Any: ...
    @property
    def current_layout(self) -> Any: ...
    @property
    def edges(self) -> Any: ...
    @property
    def gid(self) -> Any: ...
    @property
    def node_flags(self) -> Any: ...
    @property
    def nodes(self) -> Any: ...
    @property
    def org_preds(self) -> Any: ...
    @property
    def org_succs(self) -> Any: ...
    @property
    def preds(self) -> Any: ...
    @property
    def rect_edges_made(self) -> Any: ...
    @property
    def succs(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_edge(self, i: int, j: int, ei: edge_info_t) -> bool:
        ...
    def add_node(self, r: rect_t) -> int:
        r"""Add a node, possibly with a specific geometry
        
        :param r: the node geometry (can be nullptr)
        :returns: the new node
        """
        ...
    def begin(self) -> node_iterator:
        ...
    def calc_group_ea(self, arg2: intvec_t) -> ida_idaapi.ea_t:
        ...
    def change_group_visibility(self, group: int, expand: bool) -> bool:
        r"""Expand/collapse a group node
        
        :param group: the group node
        :param expand: whether to expand or collapse
        :returns: success
        """
        ...
    def create_circle_layout(self, p: point_t, radius: int) -> bool:
        ...
    def create_digraph_layout(self) -> bool:
        ...
    def create_group(self, nodes: intvec_t) -> int:
        r"""Create a new group node, that will contain all the nodes in 'nodes'.
        
        :param nodes: the nodes that will be part of the group
        :returns: the group node, or -1 in case of error
        """
        ...
    def create_tree_layout(self) -> bool:
        ...
    def del_custom_layout(self) -> None:
        ...
    def del_edge(self, i: int, j: int) -> bool:
        ...
    def del_node(self, n: int) -> ssize_t:
        r"""Delete a node
        
        :param n: the node to delete
        :returns: the number of deleted edges
        """
        ...
    def delete_group(self, group: int) -> bool:
        r"""Delete a group node.
        This deletes the group node only; it does not delete nodes that are part of the group.
        
        :param group: the group node
        :returns: success
        """
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        r"""Is the graph (visually) empty? 
                
        :returns: true if there are no visible nodes
        """
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        r"""Is the node visible?
        
        :param node: the node number
        :returns: success
        """
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_custom_layout(self) -> bool:
        ...
    def get_edge(self, e: edge_t) -> edge_info_t:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_first_subgraph_node(self, group: int) -> int:
        ...
    def get_graph_groups(self) -> bool:
        ...
    def get_next_subgraph_node(self, group: int, current: int) -> int:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_group(self, node: int) -> int:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def get_node_representative(self, node: int) -> int:
        r"""Get the node that currently visually represents 'node'. This will find the "closest" parent group node that's visible, by attempting to walk up the group nodes that contain 'node', and will stop when it finds a node that is currently visible.
        See also get_group_node() 
                
        :param node: the node
        :returns: the node that represents 'node', or 'node' if it's not part of any group
        """
        ...
    def grcall(self, code: int) -> ssize_t:
        ...
    def is_collapsed_node(self, node: int) -> bool:
        ...
    def is_deleted_node(self, node: int) -> bool:
        ...
    def is_displayable_node(self, node: int) -> bool:
        ...
    def is_dot_node(self, node: int) -> bool:
        ...
    def is_group_node(self, node: int) -> bool:
        ...
    def is_simple_node(self, node: int) -> bool:
        ...
    def is_subgraph_node(self, node: int) -> bool:
        ...
    def is_uncollapsed_node(self, node: int) -> bool:
        ...
    def is_user_graph(self) -> bool:
        ...
    def is_visible_node(self, node: int) -> bool:
        r"""Is the node currently visible?
        An invisible node is a node that's part of a group that's currently collapsed.
        
        :param node: the node
        :returns: success
        """
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        r"""Get the number of visible nodes (the list can be retrieved using gdl.hpp's node_iterator)
        See also size()
        
        :returns: the number of visible nodes
        """
        ...
    def npred(self, b: int) -> int:
        ...
    def nrect(self, n: int) -> rect_t:
        ...
    def nsucc(self, b: int) -> int:
        ...
    def pred(self, b: int, i: int) -> int:
        ...
    def predset(self, b: int) -> intvec_t:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def redo_layout(self) -> bool:
        r"""Recompute the layout, according to the value of 'current_layout'.
        
        :returns: success
        """
        ...
    def refresh(self) -> bool:
        r"""Refresh the graph
        A graph needs refreshing when it's "backing data". E.g., if the number (or contents) of the objects in the above example, change.
        Let's say the user's plugin ends up finding a 5th piece of scattered data. It should then add it to its internal list of known objects, and tell IDA that the graph needs to be refreshed, using refresh_viewer(). This will cause IDA to:
        * discard all its internal rendering information,
        * call interactive_graph_t::refresh() on the graph so that the user's plugin has a chance to "sync" the number of nodes & edges that this graph contains, to the information that the plugin has collected so far
        * re-create internal rendering information, and
        * repaint the view
        
        
        
        :returns: success
        """
        ...
    def replace_edge(self, i: int, j: int, x: int, y: int) -> bool:
        ...
    def reset(self) -> None:
        ...
    def resize(self, n: int) -> None:
        r"""Resize the graph to 'n' nodes
        
        :param n: the new size
        """
        ...
    def set_callback(self, _callback: hook_cb_t, _ud: void) -> None:
        ...
    def set_custom_layout(self) -> None:
        ...
    def set_deleted_node(self, node: int) -> None:
        ...
    def set_edge(self, e: edge_t, ei: edge_info_t) -> bool:
        ...
    def set_graph_groups(self) -> None:
        ...
    def set_node_group(self, node: int, group: int) -> None:
        ...
    def set_nrect(self, n: int, r: rect_t) -> bool:
        ...
    def size(self) -> int:
        r"""Get the total number of nodes (including group nodes, and including hidden nodes.)
        See also node_qty()
        
        :returns: the total number of nodes in the graph
        """
        ...
    def succ(self, b: int, i: int) -> int:
        ...
    def succset(self, b: int) -> intvec_t:
        ...

class node_info_t:
    @property
    def bg_color(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def frame_color(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_flags_for_valid(self) -> int:
        r"""Get combination of Node info flags describing which attributes are valid.
        
        """
        ...
    def valid_bg_color(self) -> bool:
        r"""Has valid bg_color?
        
        """
        ...
    def valid_ea(self) -> bool:
        r"""Has valid ea?
        
        """
        ...
    def valid_flags(self) -> bool:
        r"""Has valid flags?
        
        """
        ...
    def valid_frame_color(self) -> bool:
        r"""Has valid frame_color?
        
        """
        ...
    def valid_text(self) -> bool:
        r"""Has non-empty text?
        
        """
        ...

class node_layout_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: node_layout_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> rect_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: node_layout_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: rect_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: rect_t) -> bool:
        ...
    def append(self, x: rect_t) -> None:
        ...
    def at(self, _idx: size_t) -> rect_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: node_layout_t) -> None:
        ...
    def extract(self) -> rect_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: rect_t) -> bool:
        ...
    def inject(self, s: rect_t, len: size_t) -> None:
        ...
    def insert(self, it: rect_t, x: rect_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> rect_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: node_layout_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class node_ordering_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def clr(self, _node: int) -> bool:
        ...
    def node(self, _order: size_t) -> int:
        ...
    def order(self, _node: int) -> int:
        ...
    def resize(self, n: int) -> None:
        ...
    def set(self, _node: int, num: int) -> None:
        ...
    def size(self) -> int:
        ...

class point_t:
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: point_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: point_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, r: point_t) -> point_t:
        ...
    def negate(self) -> None:
        ...
    def sub(self, r: point_t) -> point_t:
        ...

class pointseq_t(pointvec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: pointvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> point_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: pointvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: point_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: point_t) -> bool:
        ...
    def append(self, x: point_t) -> None:
        ...
    def at(self, _idx: size_t) -> point_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: pointvec_t) -> None:
        ...
    def extract(self) -> point_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: point_t) -> bool:
        ...
    def inject(self, s: point_t, len: size_t) -> None:
        ...
    def insert(self, it: point_t, x: point_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> point_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: pointvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class pointvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: pointvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> point_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: pointvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: point_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: point_t) -> bool:
        ...
    def append(self, x: point_t) -> None:
        ...
    def at(self, _idx: size_t) -> point_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: pointvec_t) -> None:
        ...
    def extract(self) -> point_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: point_t) -> bool:
        ...
    def inject(self, s: point_t, len: size_t) -> None:
        ...
    def insert(self, it: point_t, x: point_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> point_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: pointvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class rect_t:
    @property
    def bottom(self) -> Any: ...
    @property
    def left(self) -> Any: ...
    @property
    def right(self) -> Any: ...
    @property
    def top(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: rect_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: rect_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def area(self) -> int:
        ...
    def bottomright(self) -> point_t:
        ...
    def center(self) -> point_t:
        ...
    def contains(self, p: point_t) -> bool:
        ...
    def empty(self) -> bool:
        ...
    def grow(self, delta: int) -> None:
        ...
    def height(self) -> int:
        ...
    def intersect(self, r: rect_t) -> None:
        ...
    def is_intersection_empty(self, r: rect_t) -> bool:
        ...
    def make_union(self, r: rect_t) -> None:
        ...
    def move_by(self, p: point_t) -> None:
        ...
    def move_to(self, p: point_t) -> None:
        ...
    def topleft(self) -> point_t:
        ...
    def verify(self) -> None:
        ...
    def width(self) -> int:
        ...

class row_info_t:
    @property
    def bottom(self) -> Any: ...
    @property
    def nodes(self) -> Any: ...
    @property
    def top(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def height(self) -> int:
        ...

class screen_graph_selection_base_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: screen_graph_selection_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> selection_item_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: screen_graph_selection_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: selection_item_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: selection_item_t) -> bool:
        ...
    def append(self, x: selection_item_t) -> None:
        ...
    def at(self, _idx: size_t) -> selection_item_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: screen_graph_selection_base_t) -> None:
        ...
    def extract(self) -> selection_item_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: selection_item_t) -> bool:
        ...
    def inject(self, s: selection_item_t, len: size_t) -> None:
        ...
    def insert(self, it: selection_item_t, x: selection_item_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> selection_item_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: screen_graph_selection_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class screen_graph_selection_t(screen_graph_selection_base_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: screen_graph_selection_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> selection_item_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: screen_graph_selection_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: selection_item_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, s: screen_graph_selection_t) -> None:
        ...
    def add_node(self, node: int) -> None:
        ...
    def add_point(self, e: edge_t, idx: int) -> None:
        ...
    def add_unique(self, x: selection_item_t) -> bool:
        ...
    def append(self, x: selection_item_t) -> None:
        ...
    def at(self, _idx: size_t) -> selection_item_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def del_node(self, node: int) -> None:
        ...
    def del_point(self, e: edge_t, idx: int) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: screen_graph_selection_base_t) -> None:
        ...
    def extract(self) -> selection_item_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, item: selection_item_t) -> bool:
        ...
    def inject(self, s: selection_item_t, len: size_t) -> None:
        ...
    def insert(self, it: selection_item_t, x: selection_item_t) -> iterator:
        ...
    def items_count(self, look_for_nodes: bool) -> int:
        ...
    def nodes_count(self) -> int:
        ...
    def points_count(self) -> int:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> selection_item_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def sub(self, s: screen_graph_selection_t) -> None:
        ...
    def swap(self, r: screen_graph_selection_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class selection_item_t:
    @property
    def elp(self) -> Any: ...
    @property
    def is_node(self) -> Any: ...
    @property
    def node(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: selection_item_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: selection_item_t) -> bool:
        ...
    def __ne__(self, r: selection_item_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: selection_item_t) -> int:
        ...

class user_graph_place_t:
    @property
    def node(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

def calc_dist(p: point_t, q: point_t) -> double:
    r"""Calculate distance between p and q.
    
    """
    ...

def clr_node_info(gid: graph_id_t, node: int, flags: int) -> None:
    r"""Clear node info for the given node. 
            
    :param gid: id of desired graph
    :param node: node number
    :param flags: combination of Node info flags, identifying which fields of node_info_t will be cleared
    """
    ...

def create_disasm_graph(args: Any) -> interactive_graph_t:
    r"""This function has the following signatures:
    
        0. create_disasm_graph(ea: ida_idaapi.ea_t) -> interactive_graph_t *
        1. create_disasm_graph(ranges: const rangevec_t &) -> interactive_graph_t *
    
    # 0: create_disasm_graph(ea: ida_idaapi.ea_t) -> interactive_graph_t *
    
    Create a graph for the function that contains 'ea'.
    
    
    # 1: create_disasm_graph(ranges: const rangevec_t &) -> interactive_graph_t *
    
    Create a graph using an arbitrary set of ranges.
    
    
    """
    ...

def create_graph_viewer(title: str, id: int, callback: hook_cb_t, ud: void, title_height: int, parent: TWidget = None) -> graph_viewer_t:
    r"""Create a custom graph viewer. 
            
    :param title: the widget title
    :param id: graph id
    :param callback: callback to handle graph notifications (graph_notification_t)
    :param ud: user data passed to callback
    :param title_height: node title height
    :param parent: the parent widget of the graph viewer
    :returns: new viewer
    """
    ...

def create_interactive_graph(id: int) -> interactive_graph_t:
    r"""Create a new empty graph with given id.
    
    """
    ...

def create_mutable_graph(id: int) -> interactive_graph_t:
    r"""Create a new empty graph with given id.
    
    """
    ...

def create_user_graph_place(node: int, lnnum: int) -> user_graph_place_t:
    r"""Get a copy of a user_graph_place_t (returns a pointer to static storage)
    
    """
    ...

def del_node_info(gid: graph_id_t, node: int) -> None:
    r"""Delete the node_info_t for the given node.
    
    """
    ...

def delete_interactive_graph(g: interactive_graph_t) -> None:
    r"""Delete graph object. 
            
    """
    ...

def delete_mutable_graph(g: interactive_graph_t) -> None:
    r"""Delete graph object. 
            
    """
    ...

def get_graph_viewer(parent: TWidget) -> graph_viewer_t:
    r"""Get custom graph viewer for given form.
    
    """
    ...

def get_node_info(out: node_info_t, gid: graph_id_t, node: int) -> bool:
    r"""Get node info. 
            
    :param out: result
    :param gid: id of desired graph
    :param node: node number
    :returns: success
    """
    ...

def get_viewer_graph(gv: graph_viewer_t) -> interactive_graph_t:
    r"""Get graph object for given custom graph viewer.
    
    """
    ...

def pyg_close(_self: Any) -> None:
    ...

def pyg_select_node(_self: Any, nid: int) -> None:
    ...

def pyg_show(_self: Any) -> bool:
    ...

def refresh_viewer(gv: graph_viewer_t) -> None:
    r"""Redraw the graph in the given view.
    
    """
    ...

def set_node_info(gid: graph_id_t, node: int, ni: node_info_t, flags: int) -> None:
    r"""Set node info. 
            
    :param gid: id of desired graph
    :param node: node number
    :param ni: node info to use
    :param flags: combination of Node info flags, identifying which fields of 'ni' will be used
    """
    ...

def set_viewer_graph(gv: graph_viewer_t, g: interactive_graph_t) -> None:
    r"""Set the underlying graph object for the given viewer.
    
    """
    ...

def viewer_attach_menu_item(g: graph_viewer_t, name: str) -> bool:
    r"""Attach a previously-registered action to the view's context menu. See kernwin.hpp for how to register actions. 
            
    :param g: graph viewer
    :param name: action name
    :returns: success
    """
    ...

def viewer_center_on(gv: graph_viewer_t, node: int) -> None:
    r"""Center the graph view on the given node.
    
    """
    ...

def viewer_create_groups(gv: graph_viewer_t, out_group_nodes: intvec_t, gi: groups_crinfos_t) -> bool:
    r"""This will perform an operation similar to what happens when a user manually selects a set of nodes, right-clicks and selects "Create group". This is a wrapper around interactive_graph_t::create_group that will, in essence:
    * clone the current graph
    * for each group_crinfo_t, attempt creating group in that new graph
    * if all were successful, animate to that new graph.
    
    
    
    """
    ...

def viewer_del_node_info(gv: graph_viewer_t, n: int) -> None:
    r"""Delete node info for node in given viewer (see del_node_info())
    
    """
    ...

def viewer_delete_groups(gv: graph_viewer_t, groups: intvec_t, new_current: int = -1) -> bool:
    r"""Wrapper around interactive_graph_t::delete_group. This function will:
    * clone the current graph
    * attempt deleting the groups in that new graph
    * if successful, animate to that new graph. 
    
    
            
    """
    ...

def viewer_fit_window(gv: graph_viewer_t) -> None:
    r"""Fit graph viewer to its parent form.
    
    """
    ...

def viewer_get_curnode(gv: graph_viewer_t) -> int:
    r"""Get number of currently selected node (-1 if none)
    
    """
    ...

def viewer_get_gli(out: graph_location_info_t, gv: graph_viewer_t, flags: int = 0) -> bool:
    r"""Get location info for given graph view If flags contains GLICTL_CENTER, then the gli that will be retrieved, will be the one at the center of the view. Otherwise it will be the top-left. 
            
    """
    ...

def viewer_get_node_info(gv: graph_viewer_t, out: node_info_t, n: int) -> bool:
    r"""Get node info for node in given viewer (see get_node_info())
    
    """
    ...

def viewer_get_selection(gv: graph_viewer_t, sgs: screen_graph_selection_t) -> bool:
    r"""Get currently selected items for graph viewer.
    
    """
    ...

def viewer_set_gli(gv: graph_viewer_t, gli: graph_location_info_t, flags: int = 0) -> None:
    r"""Set location info for given graph view If flags contains GLICTL_CENTER, then the gli will be set to be the center of the view. Otherwise it will be the top-left. 
            
    """
    ...

def viewer_set_groups_visibility(gv: graph_viewer_t, groups: intvec_t, expand: bool, new_current: int = -1) -> bool:
    r"""Wrapper around interactive_graph_t::change_visibility. This function will:
    * clone the current graph
    * attempt changing visibility of the groups in that new graph
    * if successful, animate to that new graph. 
    
    
            
    """
    ...

def viewer_set_node_info(gv: graph_viewer_t, n: int, ni: node_info_t, flags: int) -> None:
    r"""Set node info for node in given viewer (see set_node_info())
    
    """
    ...

def viewer_set_titlebar_height(gv: graph_viewer_t, height: int) -> int:
    r"""Set height of node title bars (grcode_set_titlebar_height)
    
    """
    ...

COLLAPSED_NODE: int  # -2147483648
GLICTL_CENTER: int  # 1
MTG_DOT_NODE: int  # 2
MTG_GROUP_NODE: int  # 1
MTG_NON_DISPLAYABLE_NODE: int  # 8
NIFF_SHOW_CONTENTS: int  # 1
NIF_ALL: int  # 31
NIF_BG_COLOR: int  # 1
NIF_EA: int  # 4
NIF_FLAGS: int  # 16
NIF_FRAME_COLOR: int  # 2
NIF_TEXT: int  # 8
SWIG_PYTHON_LEGACY_BOOL: int  # 1
annotations: _Feature  # _Feature((3, 7, 0, 'beta', 1), None, 16777216)
arrow_height: int  # 10
arrow_width: int  # 8
cvar: swigvarlink
git_edge: int  # 1
git_elp: int  # 5
git_node: int  # 2
git_none: int  # 0
git_text: int  # 4
git_tool: int  # 3
grcode_attach_menu_item: int  # 301
grcode_calculating_layout: int  # 0
grcode_center_on: int  # 264
grcode_change_group_visibility: int  # 281
grcode_changed_graph: int  # 2
grcode_clear: int  # 269
grcode_clicked: int  # 4
grcode_create_circle_layout: int  # 272
grcode_create_digraph_layout: int  # 270
grcode_create_disasm_graph1: int  # 287
grcode_create_disasm_graph2: int  # 288
grcode_create_graph_viewer: int  # 256
grcode_create_group: int  # 275
grcode_create_interactive_graph: int  # 259
grcode_create_mutable_graph: int  # 259
grcode_create_tree_layout: int  # 271
grcode_create_user_graph_place: int  # 286
grcode_creating_group: int  # 6
grcode_dblclicked: int  # 5
grcode_del_custom_layout: int  # 266
grcode_del_node_info: int  # 291
grcode_delete_group: int  # 280
grcode_delete_interactive_graph: int  # 298
grcode_deleting_group: int  # 7
grcode_destroyed: int  # 18
grcode_edge_infos_wrapper_clear: int  # 300
grcode_edge_infos_wrapper_copy: int  # 299
grcode_empty: int  # 278
grcode_find_subgraph_node: int  # 274
grcode_fit_window: int  # 262
grcode_get_curnode: int  # 263
grcode_get_custom_layout: int  # 276
grcode_get_gli: int  # 303
grcode_get_graph_groups: int  # 277
grcode_get_graph_viewer: int  # 257
grcode_get_node_info: int  # 290
grcode_get_node_representative: int  # 273
grcode_get_selection: int  # 265
grcode_get_viewer_graph: int  # 258
grcode_gotfocus: int  # 9
grcode_group_visibility: int  # 8
grcode_is_visible_node: int  # 279
grcode_layout_calculated: int  # 1
grcode_lostfocus: int  # 10
grcode_node_qty: int  # 283
grcode_nrect: int  # 284
grcode_refresh_viewer: int  # 261
grcode_reserved: int  # 3
grcode_reserved2: int  # 12
grcode_set_custom_layout: int  # 267
grcode_set_edge: int  # 282
grcode_set_gli: int  # 302
grcode_set_graph_groups: int  # 268
grcode_set_node_info: int  # 289
grcode_set_titlebar_height: int  # 285
grcode_set_viewer_graph: int  # 260
grcode_user_draw: int  # 16
grcode_user_hint: int  # 17
grcode_user_refresh: int  # 11
grcode_user_size: int  # 14
grcode_user_text: int  # 13
grcode_user_title: int  # 15
grcode_viewer_create_groups: int  # 292
grcode_viewer_create_groups_vec: int  # 295
grcode_viewer_delete_groups: int  # 293
grcode_viewer_delete_groups_vec: int  # 296
grcode_viewer_groups_visibility: int  # 294
grcode_viewer_groups_visibility_vec: int  # 297
ida_gdl: module
ida_idaapi: module
ida_kernwin: module
layout_circle: int  # 3
layout_digraph: int  # 1
layout_none: int  # 0
layout_orthogonal: int  # 5
layout_polar_tree: int  # 4
layout_radial_tree: int  # 6
layout_tree: int  # 2
weakref: module
xgap: int  # 10
ygap: int  # 30