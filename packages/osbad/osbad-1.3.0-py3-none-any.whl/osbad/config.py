# Standard library
import logging
import os
import pathlib
from pathlib import Path


SHOW_FIG_STATUS = True
"""
Global flag to control whether Matplotlib figures are displayed.

When set to True, all figures generated by the pipeline and notebooks are
shown interactively. When set to False, figures are saved to
``PIPELINE_OUTPUT_DIR`` but not displayed.

.. note::

    Set ``SHOW_FIG_STATUS = False`` when running the pipeline in batch
    mode for multiple cells to avoid unnecessary rendering of figures.
"""

# Modify this global directory path for storing pipeline artifacts if needed.
PIPELINE_OUTPUT_DIR = Path.cwd().joinpath("artifacts_output_dir")
"""
Global directory path for storing pipeline artifacts.

All figures, plots, and intermediate artifacts generated by the pipeline
or Jupyter notebooks are written to this directory. If the directory does
not already exist, it will be created at runtime.

.. note::

    ``PIPELINE_OUTPUT_DIR`` defines the root location where all results
    (per-cell artifacts, exported plots, metrics, and hyperparameters)
    are stored. Ensure this path points to a valid writable location
    before running the pipeline.
"""

if not os.path.exists(PIPELINE_OUTPUT_DIR):
    os.mkdir(PIPELINE_OUTPUT_DIR)


def artifacts_output_dir(selected_cell_label: str) -> pathlib.PosixPath:
    """
    Ensure and return the artifacts directory for a given cell.

    Creates (if missing) a per-cell subdirectory under
    ``PIPELINE_OUTPUT_DIR`` and returns its path. All figures and
    artifacts for the selected cell should be written to this location.

    Args:
        selected_cell_label (str): Identifier of the evaluated cell used
            to name the subdirectory.

    Returns:
        pathlib.PosixPath: Path to the cell-specific artifacts directory.
    """
    # create a new folder for each evaluated cell
    # store all figures output for each evaluated
    # cell into its corresponding folder
    selected_cell_artifacts_dir = PIPELINE_OUTPUT_DIR.joinpath(
        selected_cell_label)

    if not os.path.exists(selected_cell_artifacts_dir):
        os.mkdir(selected_cell_artifacts_dir)

    return selected_cell_artifacts_dir


class CustomFormatter(logging.Formatter):
    """
    Custom logging formatter with colorized output.

    This formatter applies ANSI escape codes to add colors for different
    logging levels and customizes the format string for messages. INFO
    messages are displayed as plain text, while DEBUG, WARNING, ERROR, and
    CRITICAL messages include timestamps, file names, and line numbers for
    better context.

    Logging level styles:
        - INFO: Grey text, message only.
        - DEBUG: Red text with timestamp, name, file, and line number.
        - WARNING: Bold red text with extended debug-style format.
        - ERROR: Bold red text with extended debug-style format.
        - CRITICAL: Bold red text with extended debug-style format.
    """
    # https://talyian.github.io/ansicolors/
    # orange = "\x1b[38;5;215m"
    # darkred = "\x1b[38;5;1m"
    grey = "\x1b[38;21m"
    yellow = "\x1b[33;21m"
    red = "\x1b[31;21m"
    bold_red = "\x1b[31;1m"
    reset = "\x1b[0m"
    debug_format = ("%(asctime)s - %(name)s - %(levelname)s"
            + "\n%(message)s (%(filename)s:%(lineno)d)")
    info_format = "%(message)s"

    # Logging levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
    FORMATS = {
        logging.INFO: grey + info_format,
        logging.DEBUG: red + debug_format + reset,
        logging.WARNING: bold_red + debug_format + reset,
        logging.ERROR: bold_red + debug_format + reset,
        logging.CRITICAL: bold_red + debug_format + reset
    }

    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)