"""
üõ†Ô∏è –û—Å–Ω–æ–≤–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å FFmpeg –∏ –≤–∏–¥–µ–æ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π

–≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è:
- –ó–∞–ø—É—Å–∫–∞ FFmpeg –∫–æ–º–∞–Ω–¥
- –ê–Ω–∞–ª–∏–∑–∞ –≤–∏–¥–µ–æ—Ñ–∞–π–ª–æ–≤ —á–µ—Ä–µ–∑ FFprobe
- –°–æ–∑–¥–∞–Ω–∏—è HLS –∏ DASH —Å—Ç—Ä–∏–º–æ–≤
- –ò–∑–≤–ª–µ—á–µ–Ω–∏—è –ø—Ä–µ–≤—å—é –∫–∞–¥—Ä–æ–≤
- –†–∞–±–æ—Ç—ã —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ —Ñ–∞–π–ª–∞–º–∏ –∏ storage

–ê–≤—Ç–æ—Ä: akula993
–õ–∏—Ü–µ–Ω–∑–∏—è: MIT
"""

import json
import logging
import os
import shutil
import subprocess
import tempfile
import time
from contextlib import contextmanager
from pathlib import Path
from typing import Any, Dict, List, Optional, Union
# –ó–∞–º–µ–Ω–∏—Ç–µ —Å—Ç—Ä–æ–∫—É 26 –≤ utils.py:
try:
    from celery.exceptions import SecurityError
except ImportError:
    class SecurityError(Exception):
        pass
from . import defaults
from .exceptions import (
    FFmpegError,
    FFmpegNotFoundError,
    InvalidVideoError,
    StorageError,
    TimeoutError,
    TranscodingError,
    ConfigurationError,
)

logger = logging.getLogger(__name__)


# ==============================================================================
# –ö–û–ù–¢–ï–ö–°–¢–ù–´–ï –ú–ï–ù–ï–î–ñ–ï–†–´
# ==============================================================================


@contextmanager
def tempdir(prefix: str = "hlsfield_"):
    """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π"""
    temp_path = Path(tempfile.mkdtemp(prefix=prefix))
    try:
        logger.debug(f"Created temporary directory: {temp_path}")
        yield temp_path
    finally:
        try:
            shutil.rmtree(temp_path, ignore_errors=True)
            logger.debug(f"Cleaned up temporary directory: {temp_path}")
        except Exception as e:
            logger.warning(f"Could not clean up temporary directory {temp_path}: {e}")


def ensure_binary_available(binary_name: str, path: str) -> str:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–∞–π–ª–∞"""
    if os.path.isabs(path) and os.path.isfile(path) and os.access(path, os.X_OK):
        return path

    full_path = shutil.which(path)
    if full_path:
        return full_path

    raise FFmpegNotFoundError(f"{binary_name} not found: {path}")


# ==============================================================================
# –í–´–ü–û–õ–ù–ï–ù–ò–ï –ö–û–ú–ê–ù–î FFMPEG
# ==============================================================================


def run(cmd: List[str], timeout_sec: Optional[int] = None) -> subprocess.CompletedProcess:
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –∫–æ–º–∞–Ω–¥—É —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫ –∏ —Ç–∞–π–º–∞—É—Ç–∞–º–∏"""
    if not cmd:
        raise ValueError("Command cannot be empty")

    # –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–æ–º–∞–Ω–¥
    if any(dangerous in str(cmd) for dangerous in ['rm -rf', '>', '>>', '&', '|', ';']):
        raise SecurityError("Potentially dangerous command detected")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∏–Ω–∞—Ä–Ω—ã–µ —Ñ–∞–π–ª—ã —Ç–æ–ª—å–∫–æ –¥–ª—è FFmpeg –∫–æ–º–∞–Ω–¥
    if cmd[0] in [defaults.FFMPEG, defaults.FFPROBE, 'ffmpeg', 'ffprobe']:
        binary_path = ensure_binary_available(cmd[0], cmd[0])
        cmd[0] = binary_path
    else:
        # –î–ª—è –¥—Ä—É–≥–∏—Ö –∫–æ–º–∞–Ω–¥ –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ–Ω–∏ –¥–æ—Å—Ç—É–ø–Ω—ã
        # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ shell (echo, dir, etc.)
        builtin_commands = ['echo', 'dir', 'type', 'copy', 'move', 'del']

        if cmd[0].lower() in builtin_commands:
            # –î–ª—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –∏—Å–ø–æ–ª—å–∑—É–µ–º shell=True –≤ subprocess
            pass  # –û—Å—Ç–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –∫–∞–∫ –µ—Å—Ç—å
        else:
            binary_path = shutil.which(cmd[0])
            if not binary_path:
                raise FileNotFoundError(f"Command not found: {cmd[0]}")
            cmd[0] = binary_path

    if timeout_sec is None:
        timeout_sec = defaults.FFMPEG_TIMEOUT

    cmd_str = " ".join(cmd)
    logger.debug(f"Executing command: {cmd_str}")

    start_time = time.time()

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω—É–∂–µ–Ω –ª–∏ shell –¥–ª—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
    builtin_commands = ['echo', 'dir', 'type', 'copy', 'move', 'del']
    use_shell = cmd[0].lower() in builtin_commands

    try:
        result = subprocess.run(
            cmd, capture_output=True, text=True, timeout=timeout_sec, check=False, shell=use_shell,
            encoding='utf-8',  # –Ø–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–¥–∏—Ä–æ–≤–∫—É UTF-8
        )

        elapsed = time.time() - start_time
        logger.debug(f"Command completed in {elapsed:.2f}s with code {result.returncode}")

        if defaults.VERBOSE_LOGGING:
            if result.stdout:
                logger.debug(f"STDOUT: {result.stdout}")
            if result.stderr:
                logger.debug(f"STDERR: {result.stderr}")

        if result.returncode != 0:
            _handle_ffmpeg_error(cmd, result.returncode, result.stdout, result.stderr)

        return result

    except subprocess.TimeoutExpired as e:
        logger.error(f"Command timed out after {timeout_sec}s: {cmd_str}")
        raise TimeoutError(f"Command timed out after {timeout_sec} seconds", timeout_sec) from e

    except FileNotFoundError as e:
        raise FFmpegNotFoundError(cmd[0]) from e

    except Exception as e:
        logger.error(f"Unexpected error running command {cmd_str}: {e}")
        raise FFmpegError(cmd, -1, "", str(e)) from e


def _handle_ffmpeg_error(cmd: List[str], returncode: int, stdout: str, stderr: str):
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ—à–∏–±–∫–∏ FFmpeg"""
    error_message = stderr.lower()

    if "no such file or directory" in error_message:
        raise InvalidVideoError("Input file not found or inaccessible")
    if "invalid data found" in error_message or "moov atom not found" in error_message:
        raise InvalidVideoError("File is corrupted or not a valid video")
    if "permission denied" in error_message:
        raise StorageError("Permission denied accessing file")
    if "no space left" in error_message or "disk full" in error_message:
        raise StorageError("Insufficient disk space")
    if "unknown encoder" in error_message or "encoder not found" in error_message:
        raise ConfigurationError("Required encoder not available in FFmpeg")

    raise FFmpegError(cmd, returncode, stdout, stderr)


# ==============================================================================
# –ê–ù–ê–õ–ò–ó –í–ò–î–ï–û–§–ê–ô–õ–û–í
# ==============================================================================


def ffprobe_streams(input_path: Union[str, Path]) -> Dict[str, Any]:
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–∏–¥–µ–æ—Ñ–∞–π–ª –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Ç–æ–∫–∞—Ö"""
    cmd = [
        defaults.FFPROBE,
        "-v",
        "error",
        "-print_format",
        "json",
        "-show_format",
        "-show_streams",
        str(input_path),
    ]

    try:
        result = run(cmd, timeout_sec=30)
        data = json.loads(result.stdout)

        if "streams" not in data:
            raise InvalidVideoError("No streams found in video file")

        return data

    except FFmpegError as e:
        if "Invalid data found" in str(e):
            raise InvalidVideoError("File is not a valid video or is corrupted") from e
        elif "No such file" in str(e):
            raise InvalidVideoError(f"Video file not found: {input_path}") from e
        else:
            raise InvalidVideoError(f"Cannot analyze video file: {e}") from e


def pick_video_audio_streams(info: Dict[str, Any]) -> tuple[Optional[Dict], Optional[Dict]]:
    """–í—ã–±–∏—Ä–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ –≤–∏–¥–µ–æ –∏ –∞—É–¥–∏–æ –ø–æ—Ç–æ–∫–∏"""
    video_stream = None
    audio_stream = None

    streams = info.get("streams", [])

    for stream in streams:
        codec_type = stream.get("codec_type")

        if codec_type == "video" and video_stream is None:
            video_stream = stream

        if codec_type == "audio" and audio_stream is None:
            audio_stream = stream

    return video_stream, audio_stream


def get_video_info_quick(file_path: Union[str, Path]) -> Dict[str, Any]:
    """–ë—ã—Å—Ç—Ä–æ –ø–æ–ª—É—á–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ"""
    try:
        cmd = [
            defaults.FFPROBE,
            "-v",
            "error",
            "-print_format",
            "json",
            "-show_format",
            str(file_path),
        ]

        result = run(cmd, timeout_sec=15)
        data = json.loads(result.stdout)
        format_info = data.get("format", {})

        return {
            "duration": float(format_info.get("duration", 0)),
            "size": int(format_info.get("size", 0)),
            "bitrate": int(format_info.get("bit_rate", 0)),
            "format_name": format_info.get("format_name", "unknown"),
            "nb_streams": int(format_info.get("nb_streams", 0)),
        }

    except Exception as e:
        logger.warning(f"Quick video info failed: {e}")
        return {
            "duration": 0,
            "size": 0,
            "bitrate": 0,
            "format_name": "unknown",
            "nb_streams": 0,
        }


# ==============================================================================
# –ò–ó–í–õ–ï–ß–ï–ù–ò–ï –ü–†–ï–í–¨–Æ
# ==============================================================================


def extract_preview(
    input_path: Path,
    out_image: Path,
    at_sec: float = 3.0,
    width: Optional[int] = None,
    height: Optional[int] = None,
) -> Path:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –ø—Ä–µ–≤—å—é –∫–∞–¥—Ä –∏–∑ –≤–∏–¥–µ–æ"""
    max_attempts = 3
    attempt_times = [at_sec, 1.0, 0.0]

    for attempt in range(max_attempts):
        try:
            seek_time = attempt_times[attempt] if attempt < len(attempt_times) else attempt

            cmd = [
                defaults.FFMPEG,
                "-y",
                "-ss",
                str(seek_time),
                "-i",
                str(input_path),
                "-frames:v",
                "1",
                "-q:v",
                "2",
                "-f",
                "image2",
            ]

            if width or height:
                if width and height:
                    scale = f"scale={width}:{height}"
                elif width:
                    scale = f"scale={width}:-1"
                else:
                    scale = f"scale=-1:{height}"
                cmd.extend(["-vf", scale])

            cmd.append(str(out_image))

            run(cmd, timeout_sec=60)

            if out_image.exists() and out_image.stat().st_size > 100:
                logger.debug(f"Preview extracted at {seek_time}s on attempt {attempt + 1}")
                return out_image
            else:
                logger.warning(f"Preview file too small on attempt {attempt + 1}")

        except Exception as e:
            logger.warning(f"Preview extraction attempt {attempt + 1} failed: {e}")

            if out_image.exists():
                try:
                    out_image.unlink()
                except:
                    pass

    raise TranscodingError(f"Failed to extract preview after {max_attempts} attempts")


# ==============================================================================
# HLS –¢–†–ê–ù–°–ö–û–î–ò–ù–ì
# ==============================================================================


def transcode_hls_variants(
    input_path: Path, out_dir: Path, ladder: List[Dict], segment_duration: int = 6
) -> Path:
    """–°–æ–∑–¥–∞–µ—Ç HLS –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Å—Ç—Ä–∏–º"""
    try:
        from .fields import validate_ladder

        validate_ladder(ladder)

        out_dir.mkdir(parents=True, exist_ok=True)

        logger.info(f"Analyzing input video: {input_path}")
        info = ffprobe_streams(input_path)
        video_stream, audio_stream = pick_video_audio_streams(info)

        if not video_stream:
            raise InvalidVideoError("No video stream found in input file")

        has_audio = audio_stream is not None
        source_height = int(video_stream.get("height", 0))

        filtered_ladder = _filter_ladder_by_source(ladder, source_height)
        logger.info(f"Transcoding {len(filtered_ladder)} HLS variants")

        variant_infos = []

        for rung in filtered_ladder:
            try:
                variant_info = _create_hls_variant(
                    input_path, out_dir, rung, segment_duration, has_audio
                )
                variant_infos.append(variant_info)
                logger.info(f"Created HLS variant: {variant_info['height']}p")

            except Exception as e:
                logger.error(f"Failed to create {rung['height']}p HLS variant: {e}")
                continue

        if not variant_infos:
            raise TranscodingError("No HLS variants were successfully created")

        master_playlist = _create_hls_master_playlist(out_dir, variant_infos)
        logger.info(f"HLS master playlist created: {master_playlist}")

        return master_playlist

    except Exception as e:
        logger.error(f"HLS transcoding failed: {e}")
        if isinstance(e, (TranscodingError, ConfigurationError, InvalidVideoError)):
            raise
        raise TranscodingError(f"HLS transcoding failed: {e}") from e


def _filter_ladder_by_source(ladder: List[Dict], source_height: int) -> List[Dict]:
    """–§–∏–ª—å—Ç—Ä—É–µ—Ç –ª–µ—Å—Ç–Ω–∏—Ü—É –∫–∞—á–µ—Å—Ç–≤ –ø–æ –∏—Å—Ö–æ–¥–Ω–æ–º—É —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—é"""
    filtered = [r for r in ladder if r["height"] <= source_height * 1.1]

    if not filtered:
        filtered = [min(ladder, key=lambda x: x["height"])]
        logger.warning(f"All ladder heights exceed source {source_height}p, using lowest")

    return sorted(filtered, key=lambda x: x["height"])


def _create_hls_variant(
    input_path: Path, out_dir: Path, rung: Dict, segment_duration: int, has_audio: bool
) -> Dict:
    """–°–æ–∑–¥–∞–µ—Ç –æ–¥–∏–Ω –≤–∞—Ä–∏–∞–Ω—Ç –∫–∞—á–µ—Å—Ç–≤–∞ HLS"""
    height = int(rung["height"])
    v_bitrate = int(rung["v_bitrate"])
    a_bitrate = int(rung["a_bitrate"]) if has_audio else 0

    variant_dir = out_dir / f"v{height}"
    variant_dir.mkdir(exist_ok=True)
    playlist_file = variant_dir / "index.m3u8"

    cmd = [
        defaults.FFMPEG,
        "-y",
        "-i",
        str(input_path),
        "-map",
        "0:v:0",
    ]

    # –í–∏–¥–µ–æ —Ñ–∏–ª—å—Ç—Ä—ã
    vf_parts = [
        f"scale=w=-2:h={height}:force_original_aspect_ratio=decrease",
        "pad=ceil(iw/2)*2:ceil(ih/2)*2",
    ]

    cmd.extend(
        [
            "-vf",
            ",".join(vf_parts),
            "-c:v",
            "libx264",
            "-profile:v",
            defaults.H264_PROFILE,
            "-preset",
            defaults.FFMPEG_PRESET,
            "-b:v",
            f"{v_bitrate}k",
            "-maxrate",
            f"{int(v_bitrate * 1.07)}k",
            "-bufsize",
            f"{v_bitrate * 2}k",
            "-pix_fmt",
            defaults.PIXEL_FORMAT,
            "-g",
            str(segment_duration * 30),
            "-keyint_min",
            str(segment_duration * 30),
            "-sc_threshold",
            "0",
        ]
    )

    # –ê—É–¥–∏–æ
    if has_audio and a_bitrate > 0:
        cmd.extend(
            [
                "-map",
                "0:a:0",
                "-c:a",
                defaults.AUDIO_CODEC,
                "-b:a",
                f"{a_bitrate}k",
                "-ac",
                str(defaults.AUDIO_CHANNELS),
                "-ar",
                str(defaults.AUDIO_SAMPLE_RATE),
            ]
        )
    else:
        cmd.append("-an")

    # HLS –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    cmd.extend(
        [
            "-f",
            "hls",
            "-hls_time",
            str(segment_duration),
            "-hls_playlist_type",
            "vod",
            "-hls_segment_type",
            "mpegts",
            "-hls_segment_filename",
            str(variant_dir / "seg_%04d.ts"),
            "-hls_flags",
            "single_file+independent_segments",
            str(playlist_file),
        ]
    )

    run(cmd, timeout_sec=600)

    if not playlist_file.exists():
        raise TranscodingError(f"HLS playlist not created: {playlist_file}")

    segment_files = list(variant_dir.glob("seg_*.ts"))
    if not segment_files:
        raise TranscodingError(f"No HLS segments created in {variant_dir}")

    approx_width = int((height * 16 / 9) // 2 * 2)

    return {
        "height": height,
        "width": approx_width,
        "bandwidth": (v_bitrate + a_bitrate) * 1000,
        "playlist": playlist_file.name,
        "dir": variant_dir.name,
        "resolution": f"{approx_width}x{height}",
        "segments_count": len(segment_files),
    }


def _create_hls_master_playlist(out_dir: Path, variants: List[Dict]) -> Path:
    """–°–æ–∑–¥–∞–µ—Ç master.m3u8 –ø–ª–µ–π–ª–∏—Å—Ç"""
    master_file = out_dir / "master.m3u8"

    lines = ["#EXTM3U", "#EXT-X-VERSION:3"]

    sorted_variants = sorted(variants, key=lambda x: x["height"])

    for variant in sorted_variants:
        stream_inf = f"#EXT-X-STREAM-INF:BANDWIDTH={variant['bandwidth']}"
        stream_inf += f",RESOLUTION={variant['resolution']}"
        stream_inf += f',CODECS="avc1.42E01E,mp4a.40.2"'

        lines.append(stream_inf)
        lines.append(f"{variant['dir']}/{variant['playlist']}")
    master_file.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return master_file


# ==============================================================================
# DASH –¢–†–ê–ù–°–ö–û–î–ò–ù–ì
# ==============================================================================

def transcode_dash_variants(
    input_path: Path, out_dir: Path, ladder: List[Dict], segment_duration: int = 4
) -> Path:
    """–°–æ–∑–¥–∞–µ—Ç DASH –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Å—Ç—Ä–∏–º"""

    try:
        from .fields import validate_ladder

        validate_ladder(ladder)

        out_dir.mkdir(parents=True, exist_ok=True)

        info = ffprobe_streams(input_path)
        video_stream, audio_stream = pick_video_audio_streams(info)

        if not video_stream:
            raise InvalidVideoError("No video stream found")

        has_audio = audio_stream is not None
        source_height = int(video_stream.get("height", 0))
        filtered_ladder = _filter_ladder_by_source(ladder, source_height)

        logger.info(f"Creating DASH with {len(filtered_ladder)} representations")

        # –ü—Ä–æ—Å—Ç–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è DASH
        manifest_file = out_dir / "manifest.mpd"

        cmd = [
            defaults.FFMPEG,
            "-y",
            "-i", str(input_path),
        ]

        # –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
        for i, rung in enumerate(filtered_ladder):
            height = int(rung["height"])
            v_bitrate = int(rung["v_bitrate"])

            cmd.extend([
                "-map", "0:v:0",
                "-c:v", "libx264",
                "-preset", "veryfast",
                "-profile:v", "main",
                "-b:v", f"{v_bitrate}k",
                "-maxrate", f"{int(v_bitrate * 1.07)}k",
                "-bufsize", f"{v_bitrate * 2}k",
                "-vf", f"scale=-2:{height}",
                "-pix_fmt", "yuv420p",
            ])

            if has_audio:
                a_bitrate = int(rung["a_bitrate"])
                cmd.extend([
                    "-map", "0:a:0",
                    "-c:a", "aac",
                    "-b:a", f"{a_bitrate}k",
                    "-ac", "2",
                    "-ar", "48000",
                ])

        # –ë–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã DASH
        cmd.extend([
            "-f", "dash",
            "-seg_duration", str(segment_duration),
            "-use_template", "1",
            "-use_timeline", "1",
            "-init_seg_name", str(out_dir / "init_$RepresentationID$.m4s"),
            "-media_seg_name", str(out_dir / "chunk_$RepresentationID$_$Number%05d$.m4s"),
            "-adaptation_sets", "id=0,streams=v id=1,streams=a" if has_audio else "id=0,streams=v",
            str(manifest_file)
        ])

        logger.debug(f"DASH command: {' '.join(cmd)}")
        run(cmd, timeout_sec=900)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        if not manifest_file.exists():
            raise TranscodingError("DASH manifest not created")

        # –ò—â–µ–º —Å–µ–≥–º–µ–Ω—Ç—ã —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º–∏
        segment_files = list(out_dir.glob("chunk_*.m4s"))
        init_files = list(out_dir.glob("init_*.m4s"))
        
        logger.debug(f"Found {len(segment_files)} segment files and {len(init_files)} init files")
        logger.debug(f"All files in output dir: {[f.name for f in out_dir.glob('*')]}")
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
        all_dash_files = segment_files + init_files

        if not all_dash_files:
            # –ü–æ—Å–º–æ—Ç—Ä–∏–º —á—Ç–æ –≤–æ–æ–±—â–µ –µ—Å—Ç—å –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            all_files = list(out_dir.glob("*"))
            logger.warning(f"No DASH files found. All files in output dir: {[f.name for f in all_files]}")
            raise TranscodingError("No DASH segments created")

        logger.info(f"DASH successfully created with {len(segment_files)} segments and {len(init_files)} init files")
        
        # –û—á–∏—â–∞–µ–º –ª–∏—à–Ω–∏–µ —Ñ–∞–π–ª—ã –∏–∑ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ (–µ—Å–ª–∏ –æ–Ω–∏ —Ç–∞–º –æ—Å—Ç–∞–ª–∏—Å—å)
        _cleanup_dash_files_from_current_dir()
        
        return manifest_file

    except Exception as e:
        logger.error(f"DASH transcoding failed: {e}")
        if isinstance(e, (TranscodingError, ConfigurationError, InvalidVideoError)):
            raise
        raise TranscodingError(f"DASH transcoding failed: {e}") from e
# ==============================================================================
# –ö–û–ú–ë–ò–ù–ò–†–û–í–ê–ù–ù–´–ô HLS + DASH
# ==============================================================================


def transcode_adaptive_variants(
    input_path: Path, out_dir: Path, ladder: List[Dict], segment_duration: int = 6
) -> Dict[str, Path]:
    """–°–æ–∑–¥–∞–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ HLS –∏ DASH —Å—Ç—Ä–∏–º—ã"""
    try:
        out_dir.mkdir(parents=True, exist_ok=True)

        hls_dir = out_dir / "hls"
        dash_dir = out_dir / "dash"

        logger.info(f"Starting adaptive transcoding (HLS + DASH) for {input_path.name}")

        # –°–æ–∑–¥–∞–µ–º HLS
        logger.info("Creating HLS stream...")
        hls_master = transcode_hls_variants(input_path, hls_dir, ladder, segment_duration)

        # –°–æ–∑–¥–∞–µ–º DASH
        logger.info("Creating DASH stream...")
        dash_segment_duration = max(2, segment_duration - 2)
        dash_manifest = transcode_dash_variants(input_path, dash_dir, ladder, dash_segment_duration)

        logger.info("Adaptive transcoding completed successfully")

        return {
            "hls_master": hls_master,
            "dash_manifest": dash_manifest,
            "hls_dir": hls_dir,
            "dash_dir": dash_dir,
        }

    except Exception as e:
        logger.error(f"Adaptive transcoding failed: {e}")
        if isinstance(e, (TranscodingError, ConfigurationError, InvalidVideoError)):
            raise
        raise TranscodingError(f"Adaptive transcoding failed: {e}") from e


# ==============================================================================
# –†–ê–ë–û–¢–ê –°–û STORAGE
# ==============================================================================


def pull_to_local(storage, name: str, dst_dir: Path) -> Path:
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Ñ–∞–π–ª –∏–∑ storage –≤ –ª–æ–∫–∞–ª—å–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é"""
    try:
        # –ü—Ä—è–º–æ–π –ø—É—Ç—å –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ storage
        try:
            direct_path = Path(storage.path(name))
            if direct_path.exists() and direct_path.is_file():
                logger.debug(f"Using direct file access: {direct_path}")
                return direct_path
        except (AttributeError, NotImplementedError):
            pass

        # –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ storage API
        dst = dst_dir / Path(name).name
        logger.debug(f"Downloading {name} to {dst}")

        with storage.open(name, "rb") as src:
            with dst.open("wb") as out:
                shutil.copyfileobj(src, out, length=defaults.MAX_FILE_SIZE)

        if not dst.exists() or dst.stat().st_size == 0:
            raise StorageError(f"Downloaded file is empty: {dst}")

        logger.debug(f"Successfully downloaded {dst.stat().st_size} bytes")
        return dst

    except Exception as e:
        logger.error(f"Error pulling file {name}: {e}")
        if "dst" in locals() and dst.exists():
            try:
                dst.unlink()
            except:
                pass
        if isinstance(e, StorageError):
            raise
        raise StorageError(f"Cannot download file {name}: {e}") from e


def save_tree_to_storage(local_root: Path, storage, base_path: str) -> List[str]:
    """–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–µ—Ä–µ–≤–æ —Ñ–∞–π–ª–æ–≤ –≤ storage"""
    saved_paths = []

    try:
        for root, dirs, files in os.walk(local_root):
            for filename in files:
                local_file_path = Path(root) / filename
                rel_path = local_file_path.relative_to(local_root)
                storage_key = f"{base_path.rstrip('/')}/{str(rel_path).replace(os.sep, '/')}"

                logger.debug(f"Saving {local_file_path} -> {storage_key}")

                try:
                    with local_file_path.open("rb") as fh:
                        saved_name = storage.save(storage_key, fh)
                        saved_paths.append(saved_name)
                except Exception as e:
                    logger.error(f"Failed to save {storage_key}: {e}")
                    raise StorageError(f"Cannot save file {storage_key}: {e}") from e

        logger.info(f"Saved {len(saved_paths)} files to storage under {base_path}")
        return saved_paths

    except Exception as e:
        logger.error(f"Error saving file tree: {e}")
        if isinstance(e, StorageError):
            raise
        raise StorageError(f"Cannot save file tree: {e}") from e


# ==============================================================================
# –í–ê–õ–ò–î–ê–¶–ò–Ø
# ==============================================================================


def validate_video_file(file_path: Union[str, Path]) -> Dict[str, Any]:
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –±–∞–∑–æ–≤—É—é –≤–∞–ª–∏–¥–∞—Ü–∏—é –≤–∏–¥–µ–æ—Ñ–∞–π–ª–∞"""
    path = Path(file_path)

    validation = {"valid": False, "issues": [], "warnings": [], "info": {}}

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
    if not path.exists():
        validation["issues"].append("File does not exist")
        return validation

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞
    size = path.stat().st_size
    validation["info"]["size"] = size

    if size < defaults.MIN_FILE_SIZE:
        validation["issues"].append(f"File too small: {size} bytes")

    if size > defaults.MAX_FILE_SIZE:
        validation["issues"].append(f"File too large: {size} bytes")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
    ext = path.suffix.lower()
    validation["info"]["extension"] = ext

    if ext not in defaults.ALLOWED_EXTENSIONS:
        validation["issues"].append(f"Unsupported file extension: {ext}")

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ FFprobe
    try:
        info = ffprobe_streams(path)
        video_stream, audio_stream = pick_video_audio_streams(info)

        validation["info"]["has_video"] = video_stream is not None
        validation["info"]["has_audio"] = audio_stream is not None

        if video_stream:
            width = int(video_stream.get("width", 0))
            height = int(video_stream.get("height", 0))

            validation["info"]["width"] = width
            validation["info"]["height"] = height
            validation["info"]["codec"] = video_stream.get("codec_name", "unknown")

            if height < defaults.MIN_VIDEO_HEIGHT:
                validation["issues"].append(f"Height too small: {height}p")
            if height > defaults.MAX_VIDEO_HEIGHT:
                validation["issues"].append(f"Height too large: {height}p")
            if width % 2 != 0 or height % 2 != 0:
                validation["warnings"].append("Odd dimensions may cause encoding issues")
        else:
            validation["issues"].append("No video stream found")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        if format_info := info.get("format"):
            try:
                duration = float(format_info.get("duration", 0))
                validation["info"]["duration"] = duration
                if duration > defaults.MAX_VIDEO_DURATION:
                    validation["issues"].append(f"Video too long: {duration}s")
            except (ValueError, TypeError):
                validation["warnings"].append("Could not determine video duration")

    except Exception as e:
        validation["issues"].append(f"Cannot analyze video: {e}")

    validation["valid"] = len(validation["issues"]) == 0
    return validation


# ==============================================================================
# –≠–ö–°–ü–û–†–¢ –§–£–ù–ö–¶–ò–ô
# ==============================================================================

__all__ = [
    # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ –º–µ–Ω–µ–¥–∂–µ—Ä—ã
    "tempdir",
    # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥
    "run",
    "ensure_binary_available",
    # –ê–Ω–∞–ª–∏–∑ –≤–∏–¥–µ–æ
    "ffprobe_streams",
    "pick_video_audio_streams",
    "get_video_info_quick",
    # –ü—Ä–µ–≤—å—é
    "extract_preview",
    # –¢—Ä–∞–Ω—Å–∫–æ–¥–∏–Ω–≥
    "transcode_hls_variants",
    "transcode_dash_variants",
    "transcode_adaptive_variants",
    # Storage
    "pull_to_local",
    "save_tree_to_storage",
    # –í–∞–ª–∏–¥–∞—Ü–∏—è
    "validate_video_file",
]
