from __future__ import annotations
import numpy
import ostk.core.type
import typing
from . import d2
from . import d3
__all__ = ['Angle', 'd2', 'd3']
class Angle:
    class Unit:
        """
        Members:
        
          Undefined
        
          Radian
        
          Degree
        
          Arcminute
        
          Arcsecond
        
          Revolution
        """
        Arcminute: typing.ClassVar[Angle.Unit]  # value = <Unit.Arcminute: 3>
        Arcsecond: typing.ClassVar[Angle.Unit]  # value = <Unit.Arcsecond: 4>
        Degree: typing.ClassVar[Angle.Unit]  # value = <Unit.Degree: 2>
        Radian: typing.ClassVar[Angle.Unit]  # value = <Unit.Radian: 1>
        Revolution: typing.ClassVar[Angle.Unit]  # value = <Unit.Revolution: 5>
        Undefined: typing.ClassVar[Angle.Unit]  # value = <Unit.Undefined: 0>
        __members__: typing.ClassVar[dict[str, Angle.Unit]]  # value = {'Undefined': <Unit.Undefined: 0>, 'Radian': <Unit.Radian: 1>, 'Degree': <Unit.Degree: 2>, 'Arcminute': <Unit.Arcminute: 3>, 'Arcsecond': <Unit.Arcsecond: 4>, 'Revolution': <Unit.Revolution: 5>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def arcminutes(value: ostk.core.type.Real) -> Angle:
        ...
    @staticmethod
    def arcseconds(value: ostk.core.type.Real) -> Angle:
        ...
    @staticmethod
    @typing.overload
    def between(first_vector: numpy.ndarray[numpy.float64[2, 1]], second_vector: numpy.ndarray[numpy.float64[2, 1]]) -> Angle:
        ...
    @staticmethod
    @typing.overload
    def between(first_vector: numpy.ndarray[numpy.float64[3, 1]], second_vector: numpy.ndarray[numpy.float64[3, 1]]) -> Angle:
        ...
    @staticmethod
    def degrees(value: ostk.core.type.Real) -> Angle:
        ...
    @staticmethod
    def half_pi() -> Angle:
        ...
    @staticmethod
    def pi() -> Angle:
        ...
    @staticmethod
    def radians(value: ostk.core.type.Real) -> Angle:
        ...
    @staticmethod
    def revolutions(value: ostk.core.type.Real) -> Angle:
        ...
    @staticmethod
    def string_from_unit(unit: typing.Any) -> ostk.core.type.String:
        ...
    @staticmethod
    def symbol_from_unit(unit: typing.Any) -> ostk.core.type.String:
        ...
    @staticmethod
    def two_pi() -> Angle:
        ...
    @staticmethod
    def undefined() -> Angle:
        ...
    @staticmethod
    def zero() -> Angle:
        ...
    def __add__(self, arg0: Angle) -> Angle:
        ...
    def __eq__(self, arg0: Angle) -> bool:
        ...
    def __iadd__(self, arg0: Angle) -> Angle:
        ...
    def __imul__(self, arg0: ostk.core.type.Real) -> Angle:
        ...
    def __init__(self, value: ostk.core.type.Real, unit: typing.Any) -> None:
        ...
    def __isub__(self, arg0: Angle) -> Angle:
        ...
    def __itruediv__(self, arg0: ostk.core.type.Real) -> Angle:
        ...
    def __mul__(self, arg0: ostk.core.type.Real) -> Angle:
        ...
    def __ne__(self, arg0: Angle) -> bool:
        ...
    def __neg__(self) -> Angle:
        ...
    def __pos__(self) -> Angle:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Angle) -> Angle:
        ...
    def __truediv__(self, arg0: ostk.core.type.Real) -> Angle:
        ...
    def get_unit(self) -> ...:
        ...
    @typing.overload
    def in_arcminutes(self) -> ostk.core.type.Real:
        ...
    @typing.overload
    def in_arcminutes(self, lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real) -> ostk.core.type.Real:
        ...
    @typing.overload
    def in_arcseconds(self) -> ostk.core.type.Real:
        ...
    @typing.overload
    def in_arcseconds(self, lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real) -> ostk.core.type.Real:
        ...
    @typing.overload
    def in_degrees(self) -> ostk.core.type.Real:
        ...
    @typing.overload
    def in_degrees(self, lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real) -> ostk.core.type.Real:
        ...
    @typing.overload
    def in_radians(self) -> ostk.core.type.Real:
        ...
    @typing.overload
    def in_radians(self, lower_bound: ostk.core.type.Real, upper_bound: ostk.core.type.Real) -> ostk.core.type.Real:
        ...
    def in_revolutions(self) -> ostk.core.type.Real:
        ...
    def in_unit(self, unit: typing.Any) -> ostk.core.type.Real:
        ...
    def is_defined(self) -> bool:
        ...
    def is_near(self, angle: Angle, tolerance: Angle) -> bool:
        ...
    def is_negative(self) -> bool:
        ...
    def is_zero(self) -> bool:
        ...
    def to_string(self, do_sanitize: ostk.core.type.Integer = False) -> ostk.core.type.String:
        ...
