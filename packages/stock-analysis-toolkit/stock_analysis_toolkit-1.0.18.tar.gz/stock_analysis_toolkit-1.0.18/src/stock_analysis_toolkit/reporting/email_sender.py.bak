"""
Email notification module.

This module provides functionality to send stock analysis reports
via email with HTML formatting and attachments.
"""

import logging
import os
import smtplib
import mimetypes
from datetime import datetime
import html2text
from email import encoders
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from pathlib import Path
from typing import Any, Dict, List, Optional, Union
from jinja2 import Environment, FileSystemLoader, select_autoescape


logger = logging.getLogger(__name__)


class EmailSender:
    """
    Handles sending emails with reports and notifications.

    This class provides methods to send emails with HTML content
    and file attachments, specifically designed for sending
    stock analysis reports.
    """

    def __init__(self, smtp_server: str, smtp_port: int, username: str, password: str):
        """
        Initialize the email sender with SMTP credentials.

        Args:
            smtp_server: SMTP server address (e.g., 'smtp.gmail.com')
            smtp_port: SMTP server port (e.g., 465 for SSL)
            username: Email username for authentication
            password: Email password or app password
        """
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password

        # Initialize template environment
        templates_dir = os.path.join(
            os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "templates"
        )

        # Define format_currency filter
        def format_currency(value, is_percent=False):
            if value is None or value == "":
                return "N/A"

            # Convert string to float if needed
            try:
                if isinstance(value, str):
                    value = float(value.replace(",", ""))  # Handle numbers with commas
                value = float(value)  # Ensure it's a float
            except (ValueError, TypeError):
                return str(value)  # Return as-is if conversion fails

            if is_percent:
                return f"{value:.2%}"

            abs_value = abs(value)
            if abs_value >= 1e12:  # Trillions
                return f"₹{value/1e12:.2f}T"
            if abs_value >= 1e9:  # Billions
                return f"₹{value/1e9:.2f}B"
            if abs_value >= 1e6:  # Millions
                return f"₹{value/1e6:.2f}M"
            if abs_value >= 1e3:  # Thousands
                return f"₹{value/1e3:.2f}K"
            return f"₹{value:.2f}"

        # Initialize Jinja2 environment with the filter
        self.template_env = Environment(
            loader=FileSystemLoader(templates_dir),
            autoescape=select_autoescape(["html", "xml"]),
        )

        # Register the filter
        self.template_env.filters["format_currency"] = format_currency

    def _create_message(
        self,
        to_email: Union[str, List[str]],
        subject: str,
        html_content: str,
        text_content: Optional[str] = None,
        attachments: Optional[List[Union[str, Path]]] = None,
        cc: Optional[Union[str, List[str]]] = None,
        bcc: Optional[Union[str, List[str]]] = None,
        reply_to: Optional[str] = None,
        from_name: Optional[str] = None,
    ) -> MIMEMultipart:
        """
        Create a MIME message with optional HTML, text, and attachments.

        Args:
            to_email: Recipient email address(es)
            subject: Email subject
            html_content: HTML content of the email
            text_content: Plain text alternative (optional)
            attachments: List of file paths to attach
            cc: CC recipient(s)
            bcc: BCC recipient(s)
            reply_to: Reply-to email address
            from_name: Display name for the sender

        Returns:
            MIMEMultipart: The constructed email message
        """
        # Convert single strings to lists
        if isinstance(to_email, str):
            to_email = [to_email]
        if isinstance(cc, str):
            cc = [cc]
        if isinstance(bcc, str):
            bcc = [bcc]

        # Create the root message
        msg = MIMEMultipart()
        msg["Subject"] = subject
        msg["From"] = f'"{from_name}" <{self.username}>' if from_name else self.username
        msg["To"] = ", ".join(to_email) if isinstance(to_email, list) else to_email

        if cc:
            msg["Cc"] = ", ".join(cc) if isinstance(cc, list) else cc
        if bcc:
            msg["Bcc"] = ", ".join(bcc) if isinstance(bcc, list) else bcc
        if reply_to:
            msg["Reply-To"] = reply_to

        # Create the main alternative part for text/plain and text/html
        msg_alternative = MIMEMultipart("alternative")

        # Add text part if provided
        if text_content:
            part_text = MIMEText(text_content, "plain")
            msg_alternative.attach(part_text)

        # Create a related part for the HTML and inline images
        msg_related = MIMEMultipart("related")

        # Add HTML part to the related part
        part_html = MIMEText(html_content, "html")
        msg_related.attach(part_html)

        # Add the related part to the alternative part
        msg_alternative.attach(msg_related)

        # Add the alternative part to the root message
        msg.attach(msg_alternative)

        # Track which attachments we've processed to avoid duplicates
        processed_attachments = set()

        # Process all attachments (including inline images)
        if attachments:
            for file_path in attachments:
                file_path = Path(file_path)
                if not file_path.exists():
                    logger.warning(f"Attachment not found: {file_path}")
                    continue

                # Skip if we've already processed this file
                if str(file_path) in processed_attachments:
                    continue

                processed_attachments.add(str(file_path))

                # Guess content type
                ctype, encoding = mimetypes.guess_type(str(file_path))
                if ctype is None or encoding is not None:
                    ctype = "application/octet-stream"

                maintype, subtype = ctype.split("/", 1)

                try:
                    with open(file_path, "rb") as fp:
                        file_data = fp.read()
                        if maintype == "image":
                            # For images, use MIMEImage and set Content-ID for inline display
                            if subtype.lower() == "png":
                                attachment = MIMEImage(file_data, "png")
                            elif subtype.lower() in ["jpg", "jpeg"]:
                                attachment = MIMEImage(file_data, "jpeg")
                            elif subtype.lower() == "gif":
                                attachment = MIMEImage(file_data, "gif")
                            else:
                                attachment = MIMEImage(file_data, _subtype=subtype)

                            # Generate a clean content ID from the filename
                            content_id = file_path.stem.replace(" ", "_").lower()

                            # Add Content-ID header with angle brackets
                            attachment.add_header("Content-ID", f"<{content_id}>")

                            # Mark as inline with filename
                            attachment.add_header(
                                "Content-Disposition",
                                "inline",
                                filename=file_path.name,
                            )

                            # Add to the related part for inline images
                            msg_related.attach(attachment)

                            # Log the attachment of inline images
                            logger.debug(
                                f"Attached inline image: "
                                f"{file_path.name} with CID: "
                                f"{content_id}"
                            )

                        elif maintype == "text":
                            attachment = MIMEText(
                                file_data.decode("utf-8"), _subtype=subtype
                            )
                            # Add as regular attachment
                            attachment.add_header(
                                "Content-Disposition",
                                "attachment",
                                filename=file_path.name,
                            )
                            msg.attach(attachment)
                        else:
                            # Handle other file types as regular attachments
                            attachment = MIMEBase(maintype, subtype)
                            attachment.set_payload(file_data)
                            encoders.encode_base64(attachment)
                            attachment.add_header(
                                "Content-Disposition",
                                "attachment",
                                filename=file_path.name,
                            )
                            msg.attach(attachment)

                except Exception as e:
                    logger.error(f"Failed to process {file_path}: {e}", exc_info=True)

        return msg

    def send_email(
        self,
        to_email: Union[str, List[str]],
        subject: str,
        template_name: str = "email_template.html",
        context: Optional[Dict[str, Any]] = None,
        text_content: Optional[str] = None,
        attachments: Optional[List[Union[str, Path]]] = None,
        cc: Optional[Union[str, List[str]]] = None,
        bcc: Optional[Union[str, List[str]]] = None,
        reply_to: Optional[str] = None,
        from_name: Optional[str] = "Stock Analysis Pro",
    ) -> bool:
        """Send an email using a template.

        Args:
            to_email: Recipient email address(es)
            subject: Email subject
            template_name: Name of the template file (in templates/email/)
            context: Dictionary with template variables
            text_content: Plain text alternative
                (auto-generated from HTML if not provided)
            attachments: List of file paths to attach
            cc: CC recipient(s)
            bcc: BCC recipient(s)
            reply_to: Reply-to email address
            from_name: Display name for the sender

        Returns:
            bool: True if email was sent successfully, False otherwise
        """
        try:
            # Prepare context
            context = context or {}
            now = datetime.now()
            context.update(
                {
                    "subject": subject,
                    "date": now.strftime("%Y-%m-%d %H:%M:%S"),
                    "year": now.year,
                    "now": now,  # Add this for direct datetime access in template
                    "recipient": (
                        to_email[0] if isinstance(to_email, list) else to_email
                    ),
                    **context,
                }
            )

            # Load and render template
            template = self.template_env.get_template(template_name)
            html_content = template.render(**context)

            # If no text content provided, create a simple version from HTML
            if not text_content and html_content:
                # Simple HTML to text conversion
                text_content = html2text.html2text(html_content)

            # Create the message
            msg = self._create_message(
                to_email=to_email,
                subject=subject,
                html_content=html_content,
                text_content=text_content,
                attachments=attachments,
                cc=cc,
                bcc=bcc,
                reply_to=reply_to,
                from_name=from_name,
            )

            # Connect to the SMTP server and send the email
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.ehlo()
                server.starttls()
                server.ehlo()
                server.login(self.username, self.password)

                # Prepare recipients list
                recipients = [to_email] if isinstance(to_email, str) else to_email
                if cc:
                    recipients.extend(cc if isinstance(cc, list) else [cc])
                if bcc:
                    recipients.extend(bcc if isinstance(bcc, list) else [bcc])

                # Send the email
                server.send_message(msg, from_addr=self.username, to_addrs=recipients)

                # Log the successful email sending
                logger.info(
                    f"Email sent to {to_email} with {len(attachments or [])} "
                    "attachments"
                )
                return True

        except Exception as e:
            logger.error(f"Failed to send email: {e}", exc_info=True)
            return False

    def send_report(
        self,
        to_email: Union[str, List[str]],
        report_path: Union[str, Path],
        subject: str = "Stock Analysis Report",
        charts: Optional[List[Dict[str, str]]] = None,
        cc: Optional[Union[str, List[str]]] = None,
        bcc: Optional[Union[str, List[str]]] = None,
        from_name: Optional[str] = "Stock Analysis Pro",
    ) -> bool:
        """
        Send a stock analysis report via email.

        Args:
            to_email: Recipient email address(es)
            report_path: Path to the report file to attach
            subject: Email subject
            charts: List of chart information dictionaries with 'path' and 'id' keys
            cc: CC recipient(s)
            bcc: BCC recipient(s)
            from_name: Display name for the sender

        Returns:
            bool: True if email was sent successfully, False otherwise
        """
        try:
            # Prepare attachments
            attachments = [str(report_path)]

            # Process charts for inline display
            chart_context = {}
            if charts:
                for chart in charts:
                    if 'path' in chart and os.path.exists(chart['path']):
                        attachments.append(chart['path'])
                        # Add chart info to context for the template
                        chart_context[chart.get('id', '')] = chart

            # Prepare context for the template
            context = {
                'report_name': os.path.basename(str(report_path)),
                'charts': chart_context,
                'has_charts': bool(charts)
            }

            # Send the email with the report
            return self.send_email(
                to_email=to_email,
                subject=subject,
                template_name="email_template.html",
                context=context,
                attachments=attachments,
                cc=cc,
                bcc=bcc,
                from_name=from_name
            )

        except Exception as e:
            logger.error(f"Failed to send report: {e}", exc_info=True)
            return False

        # Load and render template
        template = self.template_env.get_template(template_name)
        html_content = template.render(**context)

        # If no text content provided, create a simple version from HTML
        if not text_content and html_content:
            # Simple HTML to text conversion
            text_content = html2text.html2text(html_content)

        # Create the message
        msg = self._create_message(
            to_email=to_email,
            subject=subject,
            html_content=html_content,
            text_content=text_content,
            attachments=attachments,
            cc=cc,
            bcc=bcc,
            reply_to=reply_to,
            from_name=from_name,
        )

        # Connect to the SMTP server and send the email
        with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
            server.ehlo()
            server.starttls()
            server.ehlo()
            server.login(self.username, self.password)

            # Prepare recipients list
            recipients = [to_email] if isinstance(to_email, str) else to_email
            if cc:
                recipients.extend(cc if isinstance(cc, list) else [cc])
            if bcc:
                recipients.extend(bcc if isinstance(bcc, list) else [bcc])

            # Send the email
            server.send_message(msg)

            # Log email sending attempt with recipient and attachment count
            attachment_count = len(attachments or [])
            logger.info(
                f"Sending email to {to_email} with {attachment_count} "
                f"attachments"
            )
            return True

        except Exception as e:
            logger.error(f"Failed to send email: {e}", exc_info=True)
            return False

    def send_report(
        self,
        to_email: Union[str, List[str]],
        report_path: Union[str, Path],
        report_type: str = "Stock Analysis Report",
        report_summary: Optional[str] = None,
        key_metrics: Optional[List[Dict[str, Any]]] = None,
        recommendations: Optional[List[str]] = None,
        charts: Optional[List[Dict[str, str]]] = None,
        subject: Optional[str] = None,
        cc: Optional[Union[str, List[str]]] = None,
        bcc: Optional[Union[str, List[str]]] = None,
        from_name: str = "Stock Analysis Pro",
    ) -> bool:
        """Send a report via email with a nicely formatted message.

        Args:
            to_email: Recipient email address(es)
            report_path: Path to the report file to attach
            report_type: Type of report (e.g., 'Stock Analysis', 'Sector Report')
            report_summary: Summary of the report (HTML supported)
            key_metrics: List of key metrics to highlight
            recommendations: List of recommendations
            subject: Email subject (auto-generated if None)
            cc: CC recipient(s)
            bcc: BCC recipient(s)
            from_name: Display name for the sender

        Returns:
            bool: True if email was sent successfully, False otherwise
        """
        # Initialize variables
        template_name = "email_template.html"
        text_content = None
        attachments = [str(report_path)]
        processed_charts = []
        charts = charts or []
        # Get current datetime
        current_time = datetime.now()

        # Create base context with all required fields
        context = {
            "report_type": report_type,
            "report_summary": report_summary or "",
            "key_metrics": key_metrics or [],
            "recommendations": recommendations or [],
            "date": current_time.strftime("%Y-%m-%d"),
            "now": current_time,  # Add current datetime object for template
            "subject": subject
            or f"{report_type} - {current_time.strftime('%Y-%m-%d')}",
            "message": {
                "subject": subject
                or f"{report_type} - {current_time.strftime('%Y-%m-%d')}",
                "symbol": "",  # Will be set if available in charts
                "company_name": "",  # Will be set if available in charts
                "current_price": None,  # Will be set if available in charts
                "price_change_pct": 0.0,  # Default value to prevent template errors
                "charts": [],
            },
        }
        if not subject:
            date_str = datetime.now().strftime("%Y-%m-%d")
            subject = f"{report_type} - {date_str}"

        # Load and render template
        template = self.template_env.get_template(template_name)
        html_content = template.render(**context)

        # Process charts and update context
        if charts:
            for chart in charts:
                if "path" in chart and Path(chart["path"]).exists():
                    chart_path = Path(chart["path"])
                    # Generate a clean content ID from the filename
                    chart_id = chart_path.stem.replace(" ", "_").lower()

                    # Add chart to attachments
                    attachments.append(chart_path)

                    # Add chart info with proper ID for referencing in the email
                    processed_charts.append(
                        {
                            "id": chart_id,  # This must match the Content-ID in the email
                            "type": chart.get("type", "chart"),
                            "title": chart.get("title", "Chart"),
                        }
                    )

        # Update context with processed charts
        context["message"]["charts"] = processed_charts

        # If no text content provided, create a simple version from HTML
        if not text_content and html_content:
            # Simple HTML to text conversion
            text_content = html2text.html2text(html_content)

            try:
                # Send the email with the report and charts attached
                return self.send_email(
                    to_email=to_email,
                    subject=subject,
                    template_name="email_template.html",
                    context=context,
                    attachments=attachments,
                    cc=cc,
                    bcc=bcc,
                    from_name=from_name,
                )
            except Exception as e:
                logger.error(f"Failed to send report email: {e}", exc_info=True)
                return False
