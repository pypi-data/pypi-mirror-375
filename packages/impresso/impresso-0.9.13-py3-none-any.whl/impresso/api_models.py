# generated by datamodel-codegen:
#   filename:  http://localhost:3030/swagger.json

from __future__ import annotations

from datetime import date
from typing import Any, Mapping, Optional, Sequence, Union

from pydantic import AnyUrl, AwareDatetime, BaseModel, ConfigDict, Field, RootModel
from typing_extensions import Annotated, Literal


class AuthenticationCreateRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    strategy: Literal['local', 'jwt-app']
    email: Optional[str] = None
    password: Optional[str] = None
    accessToken: Optional[str] = None


class Authentication(BaseModel):
    strategy: Optional[str] = None
    payload: Optional[Mapping[str, Any]] = None


class User(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: int
    username: str
    firstname: str
    lastname: str
    isStaff: bool
    isActive: bool
    isSuperuser: bool
    uid: str


class AuthenticationCreateResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accessToken: str
    authentication: Authentication
    user: Annotated[User, Field(description='User details', title='User')]


class CollectableItemsUpdatedResponse(BaseModel):
    totalAdded: Annotated[
        int, Field(description='Total number of items added to the collection')
    ]
    totalRemoved: Annotated[
        int, Field(description='Total number of items removed from the collection')
    ]


class Params(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[Optional[str], Field(None, description='The collection id')]
    status: Annotated[
        Optional[Literal['DEL']], Field(None, description='The status of the operation')
    ]


class Task(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    task_id: Annotated[Optional[str], Field(None, description='The ID of the task')]
    creationDate: Annotated[
        Optional[str], Field(None, description='When task was created')
    ]


class CollectionsRemoveResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    params: Params
    task: Annotated[Task, Field(description='Deletion task details')]


class Error(BaseModel):
    type: Annotated[
        AnyUrl,
        Field(
            description='A URI reference [RFC3986] that identifies the problem type.'
        ),
    ]
    title: Annotated[
        str, Field(description='A short, human-readable summary of the problem type.')
    ]
    status: Annotated[
        int, Field(description='The HTTP status code ([RFC7231], Section 6)')
    ]
    detail: Annotated[
        Optional[str],
        Field(
            None,
            description='A human-readable explanation specific to this occurrence of the problem.',
        ),
    ]


class Q(RootModel[str]):
    root: Annotated[str, Field(max_length=500, min_length=2)]


class QItem(RootModel[str]):
    root: Annotated[str, Field(max_length=500, min_length=2)]


class Filter(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Literal['include', 'exclude']] = 'include'
    op: Optional[Literal['AND', 'OR']] = 'OR'
    type: Annotated[
        str,
        Field(
            description="Possible values are in 'search.validators:eachFilterValidator.type.choices'"
        ),
    ]
    precision: Optional[Literal['fuzzy', 'soft', 'exact', 'partial']] = 'exact'
    q: Optional[Union[Q, Sequence[QItem]]] = None
    daterange: Annotated[
        Optional[str],
        Field(
            None,
            pattern='\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z TO \\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z',
        ),
    ]
    uids: Optional[str] = None
    uid: Optional[str] = None


class Offset(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    start: Annotated[int, Field(description='Start offset of the entity in the text')]
    end: Annotated[int, Field(description='End offset of the entity in the text')]


class Confidence(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ner: Annotated[
        Optional[float],
        Field(None, description='Confidence score for the named entity recognition'),
    ]
    nel: Annotated[
        Optional[float],
        Field(None, description='Confidence score for the named entity linking'),
    ]


class Wikidata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='Wikidata ID of the entity')]
    wikipediaPageName: Annotated[
        Optional[str], Field(None, description='Wikipedia page name of the entity')
    ]
    wikipediaPageUrl: Annotated[
        Optional[str], Field(None, description='Wikipedia page URL of the entity')
    ]


class ImpressoNerEntity(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='ID of the entity')]
    type: Annotated[
        Literal[
            'comp.demonym',
            'comp.function',
            'comp.name',
            'comp.qualifier',
            'comp.title',
            'loc',
            'loc.add.elec',
            'loc.add.phys',
            'loc.adm.nat',
            'loc.adm.reg',
            'loc.adm.sup',
            'loc.adm.town',
            'loc.fac',
            'loc.oro',
            'loc.phys.astro',
            'loc.phys.geo',
            'loc.phys.hydro',
            'loc.unk',
            'org',
            'org.adm',
            'org.ent',
            'org.ent.pressagency',
            'org.ent.pressagency.AFP',
            'org.ent.pressagency.ANSA',
            'org.ent.pressagency.AP',
            'org.ent.pressagency.APA',
            'org.ent.pressagency.ATS-SDA',
            'org.ent.pressagency.Belga',
            'org.ent.pressagency.CTK',
            'org.ent.pressagency.DDP-DAPD',
            'org.ent.pressagency.DNB',
            'org.ent.pressagency.DPA',
            'org.ent.pressagency.Domei',
            'org.ent.pressagency.Europapress',
            'org.ent.pressagency.Extel',
            'org.ent.pressagency.Havas',
            'org.ent.pressagency.Kipa',
            'org.ent.pressagency.Reuters',
            'org.ent.pressagency.SPK-SMP',
            'org.ent.pressagency.Stefani',
            'org.ent.pressagency.TASS',
            'org.ent.pressagency.UP-UPI',
            'org.ent.pressagency.Wolff',
            'org.ent.pressagency.Xinhua',
            'org.ent.pressagency.ag',
            'org.ent.pressagency.unk',
            'pers',
            'pers.coll',
            'pers.ind',
            'pers.ind.articleauthor',
            'prod',
            'prod.doctr',
            'prod.media',
            'time',
            'time.date.abs',
            'time.hour.abs',
            'unk',
        ],
        Field(description='Type of the entity'),
    ]
    surfaceForm: Annotated[
        Optional[str], Field(None, description='Surface form of the entity')
    ]
    offset: Optional[Offset] = None
    isTypeNested: Annotated[
        Optional[bool], Field(None, description='Whether the entity type is nested')
    ]
    confidence: Confidence
    wikidata: Optional[Wikidata] = None
    function: Annotated[
        Optional[str], Field(None, description='Function of the entity')
    ]
    name: Annotated[Optional[str], Field(None, description='Name of the entity')]


class ImpressoNerRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    text: Annotated[
        str,
        Field(
            description='Text to be processed for named entity recognition',
            max_length=3999,
            min_length=1,
        ),
    ]
    method: Annotated[
        Optional[Literal['ner', 'ner-nel', 'nel']],
        Field(
            'ner',
            description='NER method to be used: `ner` (default), `ner-nel` (named entity recognition with named entity linking) and `nel` (linking only - enclose entities in [START] [END] tags).',
        ),
    ]


class ImpressoNerResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    modelId: Annotated[
        str, Field(description='ID of the model used for the named entity recognition')
    ]
    text: Annotated[
        str, Field(description='Text processed for named entity recognition')
    ]
    timestamp: Annotated[
        AwareDatetime,
        Field(description='Timestamp of when named entity recognition was performed'),
    ]
    entities: Sequence[ImpressoNerEntity]


class NewCollectionRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[str, Field(max_length=50, min_length=2)]
    description: Annotated[Optional[str], Field(None, max_length=500)]
    accessLevel: Annotated[
        Optional[Literal['public', 'private']],
        Field(None, description='Access level of the collection.'),
    ]


class UpdateCollectableItemsRequest(BaseModel):
    add: Annotated[
        Optional[Sequence[str]],
        Field(None, description='IDs of the items to add to the collection'),
    ]
    remove: Annotated[
        Optional[Sequence[str]],
        Field(None, description='IDs of the items to remove from the collection'),
    ]


class Pagination(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    total: Annotated[
        int, Field(description='The total number of items matching the query')
    ]
    limit: Annotated[
        int, Field(description='The number of items returned in this response')
    ]
    offset: Annotated[
        int,
        Field(
            description='Starting index of the items subset returned in this response'
        ),
    ]


class BaseFind(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: Sequence
    pagination: Pagination


class Collection(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='Unique identifier of the collection.')]
    title: Annotated[Optional[str], Field(None, description='Title of the collection.')]
    description: Annotated[
        Optional[str], Field(None, description='Description of the collection.')
    ]
    accessLevel: Annotated[
        Optional[Literal['public', 'private']],
        Field(None, description='Access level of the collection.'),
    ]
    createdAt: Annotated[
        Optional[AwareDatetime],
        Field(None, description='Creation date of the collection.'),
    ]
    updatedAt: Annotated[
        Optional[AwareDatetime],
        Field(None, description='Last update date of the collection.'),
    ]
    totalItems: Annotated[
        Optional[int],
        Field(None, description='Total number of items in the collection.'),
    ]


class EntityMention(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='Unique identifier of the entity')]
    relevance: Annotated[
        Optional[float],
        Field(None, description='Relevance of the entity in the document'),
    ]


class Freeform(BaseModel):
    pass
    model_config = ConfigDict(
        extra='allow',
    )


class MediaSourceRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='The unique identifier of the media source')]
    name: Annotated[str, Field(description='The name of the media source')]
    type: Annotated[
        Optional[Literal['newspaper']],
        Field(None, description='The type of the media source'),
    ]


class Image(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='The unique identifier of the image')]
    caption: Annotated[Optional[str], Field(None, description='Image caption')]
    issueUid: Annotated[
        str,
        Field(
            description='The unique identifier of the issue that the image belongs to.'
        ),
    ]
    contentItemUid: Annotated[
        Optional[str],
        Field(
            None,
            description='The unique identifier of the content item that the image belongs to.',
        ),
    ]
    previewUrl: Annotated[AnyUrl, Field(description='The URL of the image preview')]
    pageNumbers: Annotated[
        Optional[Sequence[int]],
        Field(
            None, description='The page numbers of the issue that the image belongs to.'
        ),
    ]
    mediaSourceRef: Annotated[
        MediaSourceRef, Field(description='The media source of the image')
    ]
    date: Annotated[
        date,
        Field(
            description='The date of the image or the date of the issue that the image belongs to.'
        ),
    ]


class Totals(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    articles: Annotated[
        Optional[int],
        Field(None, description='The number of articles in the media source.'),
    ]
    issues: Annotated[
        Optional[int],
        Field(None, description='The number of issues in the media source.'),
    ]
    pages: Annotated[
        Optional[int],
        Field(None, description='The number of pages in the media source.'),
    ]


class Property(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='The unique identifier of the property.')]
    label: Annotated[str, Field(description='The name of the property.')]
    value: Annotated[str, Field(description='The value of the property.')]


class MediaSource(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='The unique identifier of the media source.')]
    type: Annotated[
        Literal['newspaper'], Field(description='The type of the media source.')
    ]
    name: Annotated[str, Field(description='A display name of the media source.')]
    languageCodes: Annotated[
        Sequence[str],
        Field(description='ISO 639-2 language codes this media source has content in.'),
    ]
    publishedPeriodYears: Annotated[
        Optional[Sequence[int]],
        Field(
            None,
            description='The range of years this media source has been published for. Impresso may not have data for all this period. Is not defined if there is no information.',
            max_length=2,
            min_length=2,
        ),
    ]
    availableDatesRange: Annotated[
        Optional[Sequence[AwareDatetime]],
        Field(
            None,
            description='The range of dates this media source has content items for. This represents the earliest and the latest dates of the contet items.  Is not defined if there are no content items for this source.',
            max_length=2,
            min_length=2,
        ),
    ]
    totals: Totals
    properties: Optional[Sequence[Property]] = None


class NamedEntity(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='Unique identifier of the entity')]
    count: Annotated[
        Optional[float],
        Field(None, description='How many times it is mentioned in the text'),
    ]


class Newspaper(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='The unique identifier of the newspaper.')]
    title: Annotated[
        Optional[str], Field(None, description='The title of the newspaper.')
    ]
    startYear: Annotated[
        Optional[float],
        Field(
            None,
            description='The year of the first available article in the newspaper.',
            ge=0.0,
        ),
    ]
    endYear: Annotated[
        Optional[float],
        Field(
            None,
            description='The year of the last available article in the newspaper.',
            ge=0.0,
        ),
    ]
    languageCodes: Annotated[
        Optional[Sequence[str]],
        Field(None, description='ISO 639-1 codes of languages used in the newspaper.'),
    ]
    totalArticles: Annotated[
        Optional[float],
        Field(None, description='Total number of articles in the newspaper.', ge=0.0),
    ]
    totalIssues: Annotated[
        Optional[float],
        Field(None, description='Total number of issues in the newspaper.', ge=0.0),
    ]
    totalPages: Annotated[
        Optional[float],
        Field(None, description='Total number of pages in the newspaper.', ge=0.0),
    ]


class SearchFacetBucket(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    count: Annotated[int, Field(description='Number of items in the bucket', ge=0)]
    value: Annotated[
        Union[str, float, int], Field(description='Value that represents the bucket.')
    ]
    label: Annotated[
        Optional[str], Field(None, description='Label of the value, if relevant.')
    ]


class TimeCoverage(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    startDate: Annotated[
        date,
        Field(
            description='Publication date of the earliest content item in the cluster.'
        ),
    ]
    endDate: Annotated[
        date,
        Field(
            description='Publication date of the latest content item in the cluster.'
        ),
    ]


class TextReuseCluster(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='Unique ID of the text reuse cluster.')]
    lexicalOverlap: Annotated[
        Optional[float],
        Field(
            None,
            description='Overlap in percents between the passages in the cluster.',
            ge=0.0,
            le=100.0,
        ),
    ]
    clusterSize: Annotated[
        Optional[int],
        Field(None, description='Number of passages in the cluster.', ge=0),
    ]
    textSample: Annotated[
        Optional[str],
        Field(
            None,
            description='Sample of a text from one of the passages in the cluster.',
        ),
    ]
    timeCoverage: Annotated[
        Optional[TimeCoverage], Field(None, description='Time coverage of the cluster.')
    ]


class Offset1(BaseModel):
    start: Annotated[
        int, Field(description='Start offset of the passage in the content item.')
    ]
    end: Annotated[
        int, Field(description='End offset of the passage in the content item.')
    ]


class TextReusePassage(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='Unique ID of the text reuse passage.')]
    content: Annotated[
        Optional[str], Field(None, description='Textual content of the passage.')
    ]
    contentItemId: Annotated[
        Optional[str],
        Field(
            None,
            description='ID of the content item that the text reuse passage belongs to.',
        ),
    ]
    offset: Annotated[
        Optional[Offset1],
        Field(
            None,
            description='Start and end offsets of the passage in the content item.',
        ),
    ]


class TopicMention(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='Unique identifier of the topic.')]
    relevance: Annotated[
        Optional[float],
        Field(
            None,
            description='Relevance of the topic in the content item.',
            ge=0.0,
            le=1.0,
        ),
    ]


class VersionDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    version: Annotated[str, Field(description='Version of the API.')]


class Coordinates(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    latitude: Annotated[
        Optional[float], Field(None, description='The latitude of the location')
    ]
    longitude: Annotated[
        Optional[float], Field(None, description='The longitude of the location')
    ]


class WikidataLocation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        str,
        Field(
            description='The Q Wikidata ID of the location (https://www.wikidata.org/wiki/Wikidata:Identifiers)'
        ),
    ]
    type: Annotated[Literal['location'], Field(description='The type of the entity')]
    labels: Annotated[
        Optional[Mapping[str, Sequence[str]]],
        Field(None, description='Labels of the location in different languages'),
    ]
    descriptions: Annotated[
        Optional[Mapping[str, Sequence[str]]],
        Field(None, description='Descriptions of the location in different languages'),
    ]
    coordinates: Optional[Coordinates] = None


class WordMatch(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='Unique identifier for the word')]
    languageCode: Annotated[str, Field(description='The language code of the word')]
    word: Annotated[str, Field(description='The word')]


class ContentItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[
        str,
        Field(description='The unique identifier of the content item.', min_length=1),
    ]
    copyrightStatus: Annotated[
        Optional[Literal['pbl', 'und', 'nkn', 'euo', 'unk', 'in_cpy']],
        Field(None, description='Copyright status.'),
    ]
    type: Annotated[
        Optional[str],
        Field(
            None,
            description='The type of the content item, as present in the OLR provided by the data provider. All content items are not characterised by the same set of types.',
        ),
    ]
    sourceMedium: Annotated[
        Optional[Literal['audio', 'print', 'typescript']],
        Field(
            None,
            description='Medium of the source (audio for audio radio broadcasts, print for newspapers, typescript for digitised radio bulletin typescripts).',
        ),
    ]
    title: Annotated[
        Optional[str], Field(None, description='The title of the content item.')
    ]
    transcript: Annotated[
        Optional[str], Field(None, description='Transcript of the content item.')
    ]
    locationEntities: Annotated[
        Optional[Sequence[NamedEntity]],
        Field(
            None, description='Linked location entities mentioned in the content item.'
        ),
    ]
    personEntities: Annotated[
        Optional[Sequence[NamedEntity]],
        Field(
            None, description='Linked person entities mentioned in the content item.'
        ),
    ]
    organisationEntities: Annotated[
        Optional[Sequence[NamedEntity]],
        Field(
            None,
            description='Linked organisation entities mentioned in the content item.',
        ),
    ]
    newsAgenciesEntities: Annotated[
        Optional[Sequence[NamedEntity]],
        Field(
            None,
            description='Linked news agency entities mentioned in the content item.',
        ),
    ]
    topics: Annotated[
        Optional[Sequence[TopicMention]],
        Field(None, description='Topics mentioned in the content item.'),
    ]
    transcriptLength: Annotated[
        Optional[float],
        Field(None, description='The length of the transcript in characters.', ge=0.0),
    ]
    totalPages: Annotated[
        Optional[float],
        Field(None, description='Total number of pages the item covers.', ge=0.0),
    ]
    languageCode: Annotated[
        Optional[str],
        Field(None, description='ISO 639-1 language code of the content item.'),
    ]
    isOnFrontPage: Annotated[
        Optional[bool],
        Field(
            None,
            description='Whether the content item is on the front page of the publication.',
        ),
    ]
    publicationDate: Annotated[
        Optional[AwareDatetime],
        Field(None, description='The publication date of the content item.'),
    ]
    issueUid: Annotated[
        Optional[str], Field(None, description='Unique issue identifier')
    ]
    countryCode: Annotated[
        Optional[str],
        Field(None, description='ISO 3166-1 alpha-2 country code of the content item.'),
    ]
    providerCode: Annotated[
        Optional[str], Field(None, description='The code of the data provider.')
    ]
    mediaUid: Annotated[
        Optional[str],
        Field(
            None,
            description='Media title alias. Usually a 3 letter code of the media title (newspaper, radio station, etc.).',
        ),
    ]
    mediaType: Annotated[
        Optional[
            Literal[
                'newspaper',
                'radio_broadcast',
                'radio_magazine',
                'radio_schedule',
                'monograph',
                'encyclopedia',
            ]
        ],
        Field(None, description='The type of the media the content item belongs to.'),
    ]


class WikidataHuman(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        str,
        Field(
            description='The Q Wikidata ID of the person (https://www.wikidata.org/wiki/Wikidata:Identifiers)'
        ),
    ]
    type: Annotated[Literal['human'], Field(description='The type of the entity')]
    labels: Annotated[
        Optional[Mapping[str, Sequence[str]]],
        Field(None, description='Labels of the person in different languages'),
    ]
    descriptions: Annotated[
        Optional[Mapping[str, Sequence[str]]],
        Field(None, description='Descriptions of the person in different languages'),
    ]
    birthDate: Annotated[
        Optional[AwareDatetime], Field(None, description='The birth date of the person')
    ]
    deathDate: Annotated[
        Optional[AwareDatetime], Field(None, description='The death date of the person')
    ]
    birthPlace: Annotated[
        Optional[WikidataLocation],
        Field(None, description='The birth place of the person'),
    ]
    deathPlace: Annotated[
        Optional[WikidataLocation],
        Field(None, description='The death place of the person'),
    ]


class EntityDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uid: Annotated[str, Field(description='Unique identifier of the entity')]
    label: Annotated[Optional[str], Field(None, description='Entity label')]
    type: Optional[Literal['person', 'location', 'organisation', 'newsagency']] = None
    wikidataId: Annotated[
        Optional[str], Field(None, description='Wikidata identifier of the entity.')
    ]
    totalMentions: Annotated[
        Optional[int],
        Field(None, description='Total number of mentions of the entity.'),
    ]
    totalContentItems: Annotated[
        Optional[int],
        Field(
            None,
            description='Total number of content items the entity is mentioned in.',
        ),
    ]
    wikidataDetails: Optional[Union[WikidataHuman, WikidataLocation]] = None
