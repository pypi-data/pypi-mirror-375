"""
Generated node classes from TOML configuration.
This file is auto-generated. Do not edit manually.
"""

from typing import Any, Dict, List, Optional, Union, Protocol, runtime_checkable
from .node import Node, NodeOutputs


@Node.register_node_type("append_files")
class AppendFilesNode(Node):
    """
    Append files together in successive fashion

    ## Inputs
    ### Common Inputs
        file_type: The type of file to append.
        selected_files: The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.).

    ## Outputs
    ### Common Outputs
        file: A file with all the files appended together.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_type",
            "helper_text": "The type of file to append.",
            "value": "PDF",
            "type": "enum<string>",
        },
        {
            "field": "selected_files",
            "helper_text": "The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.).",
            "value": [""],
            "type": "vec<file>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "A file with all the files appended together."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "PDF",
        selected_files: List[str] = [""],
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="append_files",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if selected_files is not None:
            self.inputs["selected_files"] = selected_files

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AppendFilesNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sticky_note")
class StickyNoteNode(Node):
    """


    ## Inputs
    ### Common Inputs
        text: The text input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sticky_note",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "StickyNoteNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("custom_group")
class CustomGroupNode(Node):
    """


    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="custom_group",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CustomGroupNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("transformation")
class TransformationNode(Node):
    """
    A transformation node that applies a specific transformation to the input data.

    ## Inputs
    ### Common Inputs
        transformation: The ID of the transformation to be used
    ### [transformations._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [transformations._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "transformation",
            "helper_text": "The ID of the transformation to be used",
            "value": {"object_id": "", "object_type": 14},
            "type": "transformation",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[transformations._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["transformation"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        transformation: Any = {"object_id": "", "object_type": 14},
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["transformation"] = transformation

        super().__init__(
            node_type="transformation",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if transformation is not None:
            self.inputs["transformation"] = transformation

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TransformationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chat_file_reader")
class ChatFileReaderNode(Node):
    """
    Allows for document upload within chatbots (often connected to the LLM node).

    ## Inputs
    ### Common Inputs
        chunk_overlap: The number of tokens of overlap between chunks (1 token = 4 characters)
        chunk_size: The number of tokens per chunk (1 token = 4 characters)
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
        max_docs_per_query: Sets the maximum number of chunks to retrieve for each query
        retrieval_unit: Return the most relevant Chunks (text content) or Documents (will return the document metadata)

    ## Outputs
    ### Common Outputs
        documents: The uploaded file (in the chat interface) is processed into text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_overlap",
            "helper_text": "The number of tokens of overlap between chunks (1 token = 4 characters)",
            "value": 200,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The number of tokens per chunk (1 token = 4 characters)",
            "value": 1000,
            "type": "int32",
        },
        {
            "field": "file_parser",
            "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
            "value": "default",
            "type": "enum<string>",
        },
        {
            "field": "max_docs_per_query",
            "helper_text": "Sets the maximum number of chunks to retrieve for each query",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "Return the most relevant Chunks (text content) or Documents (will return the document metadata)",
            "value": "chunks",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "documents",
            "helper_text": "The uploaded file (in the chat interface) is processed into text",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_overlap: int = 200,
        chunk_size: int = 1000,
        file_parser: str = "default",
        max_docs_per_query: int = 10,
        retrieval_unit: str = "chunks",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="chat_file_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if max_docs_per_query is not None:
            self.inputs["max_docs_per_query"] = max_docs_per_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ChatFileReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("pipeline")
class PipelineNode(Node):
    """
    Pipeline

    ## Inputs
    ### Common Inputs
        pipeline: The ID of the pipeline to be used
    ### [pipelines._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [pipelines._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "pipeline",
            "helper_text": "The ID of the pipeline to be used",
            "value": {"object_type": 0, "object_id": ""},
            "type": "pipeline",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[pipelines._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["pipeline"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        pipeline: Any = {"object_type": 0, "object_id": ""},
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["pipeline"] = pipeline

        super().__init__(
            node_type="pipeline",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if pipeline is not None:
            self.inputs["pipeline"] = pipeline

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "PipelineNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("agent")
class AgentNode(Node):
    """
    Agent

    ## Inputs
    ### Common Inputs
        agent: The ID of the agent to be used
    ### [agents._id.<A>]
        [<A>.inputs]: The [<A>.inputs] input

    ## Outputs
    ### [agents._id.<A>]
        [<A>.outputs]: The [<A>.outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "agent",
            "helper_text": "The ID of the agent to be used",
            "value": {"object_id": "", "object_type": 25},
            "type": "agent",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[agents._id.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["agent"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        agent: Any = {"object_id": "", "object_type": 25},
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["agent"] = agent

        super().__init__(
            node_type="agent",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if agent is not None:
            self.inputs["agent"] = agent

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AgentNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chat_memory")
class ChatMemoryNode(Node):
    """
    Give connected nodes access to conversation history.

    ## Inputs
    ### Common Inputs
        memory_type: The type of memory to use
        memory_window: The number of tokens to store in memory

    ## Outputs
    ### Common Outputs
        memory: The conversation history in the format of the selected type
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "memory_type",
            "helper_text": "The type of memory to use",
            "value": "Token Buffer",
            "type": "string",
        },
        {
            "field": "memory_window",
            "helper_text": "The number of tokens to store in memory",
            "value": 2048,
            "type": "int32",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "memory",
            "helper_text": "The conversation history in the format of the selected type",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "Vector Database": {
            "inputs": [
                {"field": "memory_window", "type": "int32", "value": 20},
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Vector Database",
                    "helper_text": "Stores all previous messages in a Vector Database. Will return most similar messages based on the user message",
                },
            ],
            "outputs": [],
        },
        "Message Buffer": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Message Buffer",
                    "helper_text": "Returns a set number of previous consecutive messages",
                },
                {"field": "memory_window", "type": "int32", "value": 10},
            ],
            "outputs": [],
        },
        "Token Buffer": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Token Buffer",
                    "helper_text": "Returns a set number of previous consecutive messages until adding an additional message would cause the total history size to be larger than the Max Tokens",
                },
                {"field": "memory_window", "type": "int32", "value": 2048},
            ],
            "outputs": [],
        },
        "Full - Formatted": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Full - Formatted",
                    "helper_text": "Returns all previous chat history",
                }
            ],
            "outputs": [],
        },
        "Full - Raw": {
            "inputs": [
                {
                    "field": "memory_type",
                    "type": "string",
                    "value": "Full - Raw",
                    "helper_text": 'Returns a Python list with elements in the following format: {"type": type, "message": message}',
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["memory_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        memory_type: str = "Token Buffer",
        memory_window: int = 2048,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["memory_type"] = memory_type

        super().__init__(
            node_type="chat_memory",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if memory_type is not None:
            self.inputs["memory_type"] = memory_type
        if memory_window is not None:
            self.inputs["memory_window"] = memory_window

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ChatMemoryNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm")
class LlmNode(Node):
    """
    LLM

    ## Inputs
    ### Common Inputs
        enable_moderation: Whether to enable moderation
        enable_pii_address: Whether to enable PII address
        enable_pii_cc: Whether to enable PII cc
        enable_pii_email: Whether to enable PII email
        enable_pii_name: Whether to enable PII name
        enable_pii_phone: Whether to enable PII phone
        enable_pii_ssn: Whether to enable PII ssn
        max_tokens: The maximum amount of input + output tokens the model will take in and generate per run (1 token = 4 characters). Note: different models have different token limits and the workflow will error if the max token is reached.
        model: Select the LLM model to be used
        prompt: The data that is sent to the LLM. Add data from other nodes with double curly braces e.g., {{input_0.text}}
        provider: Select the LLM provider to be used
        retry_on_failure: Enable retrying when the node execution fails
        safe_context_token_window: If enabled, the context window will be reduced to fit the model's maximum context window.
        show_confidence: Whether to show the confidence score of the response
        show_sources: Whether to show the sources used to generate the response
        stream: Whether to stream the response
        system: The system prompt to be used
        temperature: The “creativity” of the response - increase the temperature for more creative responses.
        thinking_token_limit: The maximum number of tokens the model can use for thinking
        top_p: The “randomness” of the output - higher Top P values increase the randomness
    ### When use_personal_api_key = True
        api_key: Your personal API key
    ### When provider = 'custom'
        api_key: Your personal API key
        base_url: The base URL of the custom LLM provider
        finetuned_model: Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.
        use_personal_api_key: Whether to use a personal API key
    ### When show_sources = True
        citation_metadata: The metadata of the sources used to generate the response
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'azure' and use_personal_api_key = True
        deployment_id: The deployment ID for the Azure OpenAI model. This is required when using Azure OpenAI services.
        endpoint: The Azure OpenAI endpoint URL (e.g., https://your-resource-name.openai.azure.com)
    ### When provider = 'openai' and use_personal_api_key = True
        finetuned_model: Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.
    ### When provider = 'openai'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'anthropic'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'google'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'cohere'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'together'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When provider = 'bedrock'
        json_response: Whether to return the response as a JSON object
    ### When provider = 'azure'
        json_response: Whether to return the response as a JSON object
        use_personal_api_key: Whether to use a personal API key
    ### When json_response = True
        json_schema: The schema of the JSON response
    ### When retry_on_failure = True
        max_retries: The maximum number of retries
        retry_interval_ms: The interval between retries in milliseconds
    ### When provider = 'perplexity'
        use_personal_api_key: Whether to use a personal API key

    ## Outputs
    ### Common Outputs
        credits_used: The number of credits used
        input_tokens: The number of input tokens
        output_tokens: The number of output tokens
        tokens_used: The number of tokens used
    ### When stream = True
        response: The response as a stream of text
    ### When stream = False
        response: The response as a single string
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "enable_moderation",
            "helper_text": "Whether to enable moderation",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_address",
            "helper_text": "Whether to enable PII address",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_cc",
            "helper_text": "Whether to enable PII cc",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_email",
            "helper_text": "Whether to enable PII email",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_name",
            "helper_text": "Whether to enable PII name",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_phone",
            "helper_text": "Whether to enable PII phone",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_pii_ssn",
            "helper_text": "Whether to enable PII ssn",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum amount of input + output tokens the model will take in and generate per run (1 token = 4 characters). Note: different models have different token limits and the workflow will error if the max token is reached.",
            "value": 128000,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "Select the LLM model to be used",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The data that is sent to the LLM. Add data from other nodes with double curly braces e.g., {{input_0.text}}",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the LLM provider to be used",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "retry_on_failure",
            "helper_text": "Enable retrying when the node execution fails",
            "value": False,
            "type": "bool",
        },
        {
            "field": "safe_context_token_window",
            "helper_text": "If enabled, the context window will be reduced to fit the model's maximum context window.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "show_confidence",
            "helper_text": "Whether to show the confidence score of the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "show_sources",
            "helper_text": "Whether to show the sources used to generate the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "stream",
            "helper_text": "Whether to stream the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "The system prompt to be used",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The “creativity” of the response - increase the temperature for more creative responses.",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "thinking_token_limit",
            "helper_text": "The maximum number of tokens the model can use for thinking",
            "value": 0,
            "type": "int64",
        },
        {
            "field": "top_p",
            "helper_text": "The “randomness” of the output - higher Top P values increase the randomness",
            "value": 0.5,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "credits_used", "helper_text": "The number of credits used"},
        {"field": "input_tokens", "helper_text": "The number of input tokens"},
        {"field": "output_tokens", "helper_text": "The number of output tokens"},
        {"field": "tokens_used", "helper_text": "The number of tokens used"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**true**(*)**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "response",
                    "type": "stream<string>",
                    "helper_text": "The response as a stream of text",
                }
            ],
        },
        "(*)**false**(*)**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response as a single string",
                }
            ],
        },
        "(*)**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Your personal API key",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_schema",
                    "type": "string",
                    "value": "",
                    "helper_text": "The schema of the JSON response",
                    "is_advanced_setting": True,
                    "placeholder": "JSON Schema",
                    "label": "JSON Schema",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "value": [],
                    "helper_text": "The metadata of the sources used to generate the response",
                    "is_advanced_setting": True,
                    "placeholder": "Citation Metadata",
                    "label": "Citation Metadata",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                    "is_advanced_setting": True,
                    "placeholder": "JSON Response",
                    "label": "JSON Response",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                },
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "max_retries",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The maximum number of retries",
                    "placeholder": "Max Retries",
                    "label": "Max Retrie",
                },
                {
                    "field": "retry_interval_ms",
                    "type": "int32",
                    "value": 1000,
                    "helper_text": "The interval between retries in milliseconds",
                    "placeholder": "Retry Interval in ms",
                    "label": "Retry Interval in ms",
                },
            ],
            "outputs": [],
        },
        "custom**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "base_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The base URL of the custom LLM provider",
                },
                {
                    "field": "model",
                    "type": "string",
                    "value": "",
                    "helper_text": "The model to be used",
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Your API key",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                },
                {
                    "field": "finetuned_model",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.",
                },
            ],
            "outputs": [],
            "title": "Custom",
        },
        "openai**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "is_advanced_setting": True,
                    "helper_text": "Whether to return the response as a JSON object",
                    "placeholder": "JSON Response",
                    "label": "JSON Response",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                },
            ],
            "outputs": [],
            "title": "OpenAI",
        },
        "openai**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "finetuned_model",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use your finetuned model for response generation. Make sure to select the matching base model from the dropdown.",
                }
            ],
            "outputs": [],
        },
        "anthropic**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                    "is_advanced_setting": True,
                    "placeholder": "JSON Response",
                    "label": "JSON Response",
                },
            ],
            "outputs": [],
            "title": "Anthropic",
        },
        "perplexity**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                }
            ],
            "outputs": [],
            "title": "Perplexity",
        },
        "google**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                },
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                    "is_advanced_setting": True,
                    "placeholder": "JSON Response",
                    "label": "JSON Response",
                },
            ],
            "outputs": [],
            "title": "Google",
        },
        "cohere**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                    "is_advanced_setting": True,
                    "placeholder": "JSON Response",
                    "label": "JSON Response",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                },
            ],
            "outputs": [],
            "title": "Cohere",
        },
        "together**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                    "is_advanced_setting": True,
                    "placeholder": "JSON Response",
                    "label": "JSON Response",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                },
            ],
            "outputs": [],
            "title": "Open Source",
        },
        "bedrock**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                    "is_advanced_setting": True,
                    "placeholder": "JSON Response",
                    "label": "JSON Response",
                }
            ],
            "outputs": [],
            "title": "Bedrock",
        },
        "azure**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_response",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return the response as a JSON object",
                    "is_advanced_setting": True,
                    "placeholder": "JSON Response",
                    "label": "JSON Response",
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "placeholder": "Use Personal Api Key",
                    "label": "Use Personal Api Key",
                },
            ],
            "outputs": [],
            "title": "Azure",
        },
        "azure**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "endpoint",
                    "type": "string",
                    "value": "",
                    "helper_text": "The Azure OpenAI endpoint URL (e.g., https://your-resource-name.openai.azure.com)",
                },
                {
                    "field": "deployment_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The deployment ID for the Azure OpenAI model. This is required when using Azure OpenAI services.",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "provider",
        "stream",
        "use_personal_api_key",
        "json_response",
        "show_sources",
        "retry_on_failure",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "openai",
        stream: bool = False,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        show_sources: bool = False,
        retry_on_failure: bool = False,
        api_key: str = "",
        base_url: str = "",
        citation_metadata: List[str] = [],
        deployment_id: str = "",
        enable_moderation: bool = False,
        enable_pii_address: bool = False,
        enable_pii_cc: bool = False,
        enable_pii_email: bool = False,
        enable_pii_name: bool = False,
        enable_pii_phone: bool = False,
        enable_pii_ssn: bool = False,
        endpoint: str = "",
        finetuned_model: str = "",
        json_schema: str = "",
        max_retries: int = 1,
        max_tokens: int = 128000,
        model: str = "gpt-4o",
        prompt: str = "",
        retry_interval_ms: int = 1000,
        safe_context_token_window: bool = False,
        show_confidence: bool = False,
        system: str = "",
        temperature: Any = 0.5,
        thinking_token_limit: int = 0,
        top_p: Any = 0.5,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["stream"] = stream
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response
        params["show_sources"] = show_sources
        params["retry_on_failure"] = retry_on_failure

        super().__init__(
            node_type="llm",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if show_sources is not None:
            self.inputs["show_sources"] = show_sources
        if show_confidence is not None:
            self.inputs["show_confidence"] = show_confidence
        if enable_moderation is not None:
            self.inputs["enable_moderation"] = enable_moderation
        if enable_pii_name is not None:
            self.inputs["enable_pii_name"] = enable_pii_name
        if enable_pii_email is not None:
            self.inputs["enable_pii_email"] = enable_pii_email
        if enable_pii_phone is not None:
            self.inputs["enable_pii_phone"] = enable_pii_phone
        if enable_pii_ssn is not None:
            self.inputs["enable_pii_ssn"] = enable_pii_ssn
        if enable_pii_address is not None:
            self.inputs["enable_pii_address"] = enable_pii_address
        if enable_pii_cc is not None:
            self.inputs["enable_pii_cc"] = enable_pii_cc
        if thinking_token_limit is not None:
            self.inputs["thinking_token_limit"] = thinking_token_limit
        if safe_context_token_window is not None:
            self.inputs["safe_context_token_window"] = safe_context_token_window
        if retry_on_failure is not None:
            self.inputs["retry_on_failure"] = retry_on_failure
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema
        if citation_metadata is not None:
            self.inputs["citation_metadata"] = citation_metadata
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if max_retries is not None:
            self.inputs["max_retries"] = max_retries
        if retry_interval_ms is not None:
            self.inputs["retry_interval_ms"] = retry_interval_ms
        if base_url is not None:
            self.inputs["base_url"] = base_url
        if finetuned_model is not None:
            self.inputs["finetuned_model"] = finetuned_model
        if endpoint is not None:
            self.inputs["endpoint"] = endpoint
        if deployment_id is not None:
            self.inputs["deployment_id"] = deployment_id

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "LlmNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("input")
class InputNode(Node):
    """
    Pass data of different types into your workflow.

    ## Inputs
    ### Common Inputs
        description: The description of the input
        input_type: Raw Text
        use_default_value: Set default value to be used if no value is provided
    ### When input_type = 'string' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'file' and use_default_value = True
        default_value: The default value to be used if no value is provided
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'audio' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'image' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'knowledge_base' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'pipeline' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'vec<file>' and use_default_value = True
        default_value: The default value to be used if no value is provided
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'int32' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'float' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'bool' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'timestamp' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'vec<string>' and use_default_value = True
        default_value: The default value to be used if no value is provided
    ### When input_type = 'file' and use_default_value = False
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
    ### When input_type = 'vec<file>' and use_default_value = False
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.

    ## Outputs
    ### When input_type = 'audio' and use_default_value = False
        audio: The audio that was passed in
    ### When input_type = 'audio' and use_default_value = True
        audio: The audio that was passed in
    ### When input_type = 'file' and use_default_value = False
        file: The file that was passed in
        processed_text: The processed text of the file.
    ### When input_type = 'file' and use_default_value = True
        file: The file that was passed in
        processed_text: The processed text of the file.
    ### When input_type = 'vec<file>' and use_default_value = False
        files: The files that were passed in
        processed_texts: The processed text of the files
    ### When input_type = 'vec<file>' and use_default_value = True
        files: The files that were passed in
        processed_texts: The processed text of the files
    ### When input_type = 'image' and use_default_value = False
        image: The image that was passed in
    ### When input_type = 'image' and use_default_value = True
        image: The image that was passed in
    ### When input_type = 'knowledge_base' and use_default_value = False
        knowledge_base: The Knowledge Base that was passed in
    ### When input_type = 'knowledge_base' and use_default_value = True
        knowledge_base: The Knowledge Base that was passed in
    ### When input_type = 'pipeline' and use_default_value = False
        pipeline: The pipeline output
    ### When input_type = 'pipeline' and use_default_value = True
        pipeline: The pipeline output
    ### When input_type = 'string' and use_default_value = False
        text: The text that was passed in
    ### When input_type = 'string' and use_default_value = True
        text: The text that was passed in
    ### When input_type = 'int32' and use_default_value = False
        value: The integer that was passed in
    ### When input_type = 'int32' and use_default_value = True
        value: The integer that was passed in
    ### When input_type = 'float' and use_default_value = False
        value: The float that was passed in
    ### When input_type = 'float' and use_default_value = True
        value: The float that was passed in
    ### When input_type = 'bool' and use_default_value = False
        value: The boolean that was passed in
    ### When input_type = 'bool' and use_default_value = True
        value: The boolean that was passed in
    ### When input_type = 'timestamp' and use_default_value = False
        value: The timestamp that was passed in
    ### When input_type = 'timestamp' and use_default_value = True
        value: The timestamp that was passed in
    ### When input_type = 'vec<string>' and use_default_value = False
        value: The list of strings that was passed in
    ### When input_type = 'vec<string>' and use_default_value = True
        value: The list of strings that was passed in
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "description",
            "helper_text": "The description of the input",
            "value": "",
            "type": "string",
        },
        {
            "field": "input_type",
            "helper_text": "Raw Text",
            "value": "string",
            "type": "enum<string>",
        },
        {
            "field": "use_default_value",
            "helper_text": "Set default value to be used if no value is provided",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "string**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Raw Text",
                }
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text that was passed in",
                }
            ],
        },
        "string**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Raw Text",
                },
                {
                    "field": "default_value",
                    "type": "string",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text that was passed in",
                }
            ],
        },
        "file**false": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "File of any type: PDF, Word, MP3, JPEG, etc.",
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "helper_text": "The processed text of the file.",
                },
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                },
            ],
        },
        "file**true": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "File of any type: PDF, Word, MP3, JPEG, etc.",
                },
                {
                    "field": "default_value",
                    "type": "file",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "helper_text": "The processed text of the file.",
                },
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                },
            ],
        },
        "audio**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Allows you to record audio through the VectorShift platform. To convert the audio to text, connect the input node to a Speech to Text node",
                }
            ],
            "outputs": [
                {
                    "field": "audio",
                    "type": "audio",
                    "helper_text": "The audio that was passed in",
                }
            ],
        },
        "audio**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Allows you to record audio through the VectorShift platform. To convert the audio to text, connect the input node to a Speech to Text node",
                },
                {
                    "field": "default_value",
                    "type": "audio",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "audio",
                    "type": "audio",
                    "helper_text": "The audio that was passed in",
                }
            ],
        },
        "image**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Image of any type: JPEG, PNG, etc.",
                }
            ],
            "outputs": [
                {
                    "field": "image",
                    "type": "image",
                    "helper_text": "The image that was passed in",
                }
            ],
        },
        "image**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Image of any type: JPEG, PNG, etc.",
                },
                {
                    "field": "default_value",
                    "type": "image",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "image",
                    "type": "image",
                    "helper_text": "The image that was passed in",
                }
            ],
        },
        "knowledge_base**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "knowledge_base",
                    "helper_text": "Allows you to pass a Knowledge Base as an input",
                }
            ],
            "outputs": [
                {
                    "field": "knowledge_base",
                    "type": "knowledge_base",
                    "helper_text": "The Knowledge Base that was passed in",
                }
            ],
        },
        "knowledge_base**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "knowledge_base",
                    "helper_text": "Allows you to pass a Knowledge Base as an input",
                },
                {
                    "field": "default_value",
                    "type": "knowledge_base",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "knowledge_base",
                    "type": "knowledge_base",
                    "helper_text": "The Knowledge Base that was passed in",
                }
            ],
        },
        "pipeline**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "pipeline",
                    "helper_text": "Allows you to pass a Pipeline as an input",
                }
            ],
            "outputs": [{"field": "pipeline", "type": "pipeline"}],
        },
        "pipeline**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "pipeline",
                    "helper_text": "Allows you to pass a Pipeline as an input",
                },
                {
                    "field": "default_value",
                    "type": "pipeline",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [{"field": "pipeline", "type": "pipeline"}],
        },
        "vec<file>**false": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Allows you to pass a list of files as an input",
                },
            ],
            "outputs": [
                {
                    "field": "processed_texts",
                    "type": "vec<string>",
                    "helper_text": "The processed text of the files",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files that were passed in",
                },
            ],
        },
        "vec<file>**true": {
            "inputs": [
                {
                    "field": "file_parser",
                    "type": "enum<string>",
                    "value": "default",
                    "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
                },
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Allows you to pass a list of files as an input",
                },
                {
                    "field": "default_value",
                    "type": "vec<file>",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "processed_texts",
                    "type": "vec<string>",
                    "helper_text": "The processed text of the files",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files that were passed in",
                },
            ],
        },
        "int32**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Allows you to pass an integer as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "int32",
                    "helper_text": "The integer that was passed in",
                }
            ],
        },
        "int32**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Allows you to pass an integer as an input",
                },
                {
                    "field": "default_value",
                    "type": "int32",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "int32",
                    "helper_text": "The integer that was passed in",
                }
            ],
        },
        "float**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "float",
                    "helper_text": "Allows you to pass a float as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "float",
                    "helper_text": "The float that was passed in",
                }
            ],
        },
        "float**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "float",
                    "helper_text": "Allows you to pass a float as an input",
                },
                {
                    "field": "default_value",
                    "type": "float",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "float",
                    "helper_text": "The float that was passed in",
                }
            ],
        },
        "bool**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Allows you to pass a boolean as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "bool",
                    "helper_text": "The boolean that was passed in",
                }
            ],
        },
        "bool**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Allows you to pass a boolean as an input",
                },
                {
                    "field": "default_value",
                    "type": "bool",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "bool",
                    "helper_text": "The boolean that was passed in",
                }
            ],
        },
        "timestamp**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Allows you to pass a timestamp as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "timestamp",
                    "helper_text": "The timestamp that was passed in",
                }
            ],
        },
        "timestamp**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Allows you to pass a timestamp as an input",
                },
                {
                    "field": "default_value",
                    "type": "timestamp",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "timestamp",
                    "helper_text": "The timestamp that was passed in",
                }
            ],
        },
        "vec<string>**false": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<string>",
                    "helper_text": "Allows you to pass a list of strings as an input",
                }
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "vec<string>",
                    "helper_text": "The list of strings that was passed in",
                }
            ],
        },
        "vec<string>**true": {
            "inputs": [
                {
                    "field": "input_type",
                    "type": "enum<string>",
                    "value": "vec<string>",
                    "helper_text": "Allows you to pass a list of strings as an input",
                },
                {
                    "field": "default_value",
                    "type": "vec<string>",
                    "helper_text": "The default value to be used if no value is provided",
                },
            ],
            "outputs": [
                {
                    "field": "value",
                    "type": "vec<string>",
                    "helper_text": "The list of strings that was passed in",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["input_type", "use_default_value"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        input_type: str = "string",
        use_default_value: bool = False,
        default_value: Optional[str] = None,
        description: str = "",
        file_parser: str = "default",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["input_type"] = input_type
        params["use_default_value"] = use_default_value

        super().__init__(
            node_type="input",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if input_type is not None:
            self.inputs["input_type"] = input_type
        if description is not None:
            self.inputs["description"] = description
        if use_default_value is not None:
            self.inputs["use_default_value"] = use_default_value
        if default_value is not None:
            self.inputs["default_value"] = default_value
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "InputNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("output")
class OutputNode(Node):
    """
    Output data of different types from your workflow.

    ## Inputs
    ### Common Inputs
        description: The description of the output
        output_type: The output_type input
    ### string
        value: The value input
    ### file
        value: The value input
    ### audio
        value: The value input
    ### json
        value: The value input
    ### image
        value: The value input
    ### stream<string>
        value: The value input
    ### vec<file>
        value: The value input
    ### int32
        value: The value input
    ### float
        value: The value input
    ### bool
        value: The value input
    ### timestamp
        value: The value input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "description",
            "helper_text": "The description of the output",
            "value": "",
            "type": "string",
        },
        {
            "field": "output_type",
            "helper_text": "The output_type input",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "string": {
            "inputs": [
                {"field": "value", "type": "string", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "string",
                    "helper_text": "Output raw text",
                },
            ],
            "outputs": [],
        },
        "file": {
            "inputs": [
                {"field": "value", "type": "file", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "file",
                    "helper_text": "Output file of any type: PDF, Word, Excel, CSV, MP3, JPEG, etc.",
                },
            ],
            "outputs": [],
        },
        "audio": {
            "inputs": [
                {"field": "value", "type": "audio", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "audio",
                    "helper_text": "Output raw audio. Output can be generated with the text to speech node",
                },
            ],
            "outputs": [],
        },
        "json": {
            "inputs": [
                {"field": "value", "type": "string", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "json",
                    "helper_text": "Output JSON (e.g., LLMs can output JSON - input the schema by selecting “JSON Output” in the gear of the LLM)",
                },
            ],
            "outputs": [],
        },
        "image": {
            "inputs": [
                {"field": "value", "type": "image", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "image",
                    "helper_text": "Output Image(s) (images are of file type PNG)",
                },
            ],
            "outputs": [],
        },
        "stream<string>": {
            "inputs": [
                {"field": "value", "type": "stream<string>", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "stream<string>",
                    "helper_text": "Output as a stream of raw text",
                },
            ],
            "outputs": [],
            "banner_text": 'Ensure to check "Stream Response" in gear of the LLM',
        },
        "vec<file>": {
            "inputs": [
                {"field": "value", "type": "vec<file>", "value": []},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "vec<file>",
                    "helper_text": "Output a list of files",
                },
            ],
            "outputs": [],
        },
        "int32": {
            "inputs": [
                {"field": "value", "type": "int32", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "Output an integer",
                },
            ],
            "outputs": [],
        },
        "float": {
            "inputs": [
                {"field": "value", "type": "float", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "float",
                    "helper_text": "Output a float",
                },
            ],
            "outputs": [],
        },
        "bool": {
            "inputs": [
                {"field": "value", "type": "bool", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "Output a boolean",
                },
            ],
            "outputs": [],
        },
        "timestamp": {
            "inputs": [
                {"field": "value", "type": "timestamp", "value": ""},
                {
                    "field": "output_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "Output a timestamp",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["output_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        output_type: str = "string",
        description: str = "",
        value: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["output_type"] = output_type

        super().__init__(
            node_type="output",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if output_type is not None:
            self.inputs["output_type"] = output_type
        if description is not None:
            self.inputs["description"] = description
        if value is not None:
            self.inputs["value"] = value

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "OutputNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("categorizer")
class CategorizerNode(Node):
    """
    Categorize text using AI into custom-defined buckets

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        fields: The fields to be categorized
        justification: Include the AI’s justification for its score
        max_tokens: The maximum number of tokens to generate
        model: The specific model for categorization
        provider: The model provider
        temperature: The temperature of the model
        text: The text that will be categorized
        top_p: The top-p value

    ## Outputs
    ### Common Outputs
        category: The category of the input text
        credits_used: The number of credits used
        input_tokens: The number of input tokens
        output_tokens: The number of output tokens
        tokens_used: The number of tokens used
    ### When justification = True
        justification: The AI justification
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields to be categorized",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "justification",
            "helper_text": "Include the AI’s justification for its score",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum number of tokens to generate",
            "value": 2048,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "The specific model for categorization",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature of the model",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "text",
            "helper_text": "The text that will be categorized",
            "value": "",
            "type": "string",
        },
        {
            "field": "top_p",
            "helper_text": "The top-p value",
            "value": 1.0,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "category", "helper_text": "The category of the input text"},
        {"field": "credits_used", "helper_text": "The number of credits used"},
        {"field": "input_tokens", "helper_text": "The number of input tokens"},
        {"field": "output_tokens", "helper_text": "The number of output tokens"},
        {"field": "tokens_used", "helper_text": "The number of tokens used"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [],
            "outputs": [
                {
                    "field": "justification",
                    "type": "string",
                    "helper_text": "The AI justification",
                }
            ],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["justification"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        justification: bool = False,
        additional_context: str = "",
        fields: List[Any] = [],
        max_tokens: int = 2048,
        model: str = "gpt-4o",
        provider: str = "openai",
        temperature: Any = 0.7,
        text: str = "",
        top_p: Any = 1.0,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["justification"] = justification

        super().__init__(
            node_type="categorizer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if justification is not None:
            self.inputs["justification"] = justification
        if fields is not None:
            self.inputs["fields"] = fields
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if text is not None:
            self.inputs["text"] = text
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if top_p is not None:
            self.inputs["top_p"] = top_p

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CategorizerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("extract_data")
class ExtractDataNode(Node):
    """
    Extract key pieces of information or a list of information from a input text.

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        fields: The fields input
        model: The specific model for data extraction
        processed_outputs: The processed_outputs input
        provider: The model provider
        text: The text that data will be extracted from

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for data extraction",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text that data will be extracted from",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        additional_context: str = "",
        fields: List[Any] = [],
        model: str = "gpt-4o",
        processed_outputs: Dict[str, str] = {},
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="extract_data",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if fields is not None:
            self.inputs["fields"] = fields
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if text is not None:
            self.inputs["text"] = text
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ExtractDataNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("data_collector")
class DataCollectorNode(Node):
    """
    Allows a chatbot to collect information by asking the user to provide specific pieces of information (e.g., name, email, etc.).

    ## Inputs
    ### Common Inputs
        auto_generate: If checked, the node will output questions in successive order until all fields are successfully collected. If unchecked, the node will output the data that is collected (often passed to an LLM with a prompt to ask successive questions to the user, along with specific instructions after all fields are collected) - e.g., {'Field1': 'Collected_Data', 'Field2': 'Collected_Data'}
        data_collector_node_id: The ID of the data collector node
        fields: The fields to be collected
        prompt: Specific instructions of how the LLM should collect the information
        query: The query to be analysed for data collection (passed to the LLM)
    ### When auto_generate = True
        model: The specific model for question generation
        provider: The model provider

    ## Outputs
    ### When auto_generate = False
        collected_data: The data that is collected
    ### When auto_generate = True
        question: The question to be asked to the user
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "auto_generate",
            "helper_text": "If checked, the node will output questions in successive order until all fields are successfully collected. If unchecked, the node will output the data that is collected (often passed to an LLM with a prompt to ask successive questions to the user, along with specific instructions after all fields are collected) - e.g., {'Field1': 'Collected_Data', 'Field2': 'Collected_Data'}",
            "value": True,
            "type": "bool",
        },
        {
            "field": "data_collector_node_id",
            "helper_text": "The ID of the data collector node",
            "value": "",
            "type": "string",
        },
        {
            "field": "fields",
            "helper_text": "The fields to be collected",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "prompt",
            "helper_text": "Specific instructions of how the LLM should collect the information",
            "value": "",
            "type": "string",
        },
        {
            "field": "query",
            "helper_text": "The query to be analysed for data collection (passed to the LLM)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "provider",
                    "type": "enum<string>",
                    "value": "openai",
                    "helper_text": "The model provider",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "gpt-4.1",
                    "helper_text": "The specific model for question generation",
                },
            ],
            "outputs": [
                {
                    "field": "question",
                    "type": "string",
                    "helper_text": "The question to be asked to the user",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "collected_data",
                    "type": "string",
                    "helper_text": "The data that is collected",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["auto_generate"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        auto_generate: bool = True,
        data_collector_node_id: str = "",
        fields: List[Any] = [],
        model: str = "gpt-4.1",
        prompt: str = "",
        provider: str = "openai",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["auto_generate"] = auto_generate

        super().__init__(
            node_type="data_collector",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if auto_generate is not None:
            self.inputs["auto_generate"] = auto_generate
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if fields is not None:
            self.inputs["fields"] = fields
        if data_collector_node_id is not None:
            self.inputs["data_collector_node_id"] = data_collector_node_id
        if query is not None:
            self.inputs["query"] = query
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "DataCollectorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("scorer")
class ScorerNode(Node):
    """
    Score text using AI based on a set of criteria.

    ## Inputs
    ### Common Inputs
        additional_context: Provide any additional context or instructions
        criteria: The criteria that the text will be scored
        justification: Include the AI’s justification for its score
        model: The specific model for scoring
        provider: The model provider
        text: The text that will be scored

    ## Outputs
    ### Common Outputs
        score: The score of the text based on the criteria
    ### When justification = True
        justification: The AI justification
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context or instructions",
            "value": "",
            "type": "string",
        },
        {
            "field": "criteria",
            "helper_text": "The criteria that the text will be scored",
            "value": "",
            "type": "string",
        },
        {
            "field": "justification",
            "helper_text": "Include the AI’s justification for its score",
            "value": False,
            "type": "bool",
        },
        {
            "field": "model",
            "helper_text": "The specific model for scoring",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text that will be scored",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "score", "helper_text": "The score of the text based on the criteria"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [],
            "outputs": [
                {
                    "field": "justification",
                    "type": "string",
                    "helper_text": "The AI justification",
                }
            ],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["justification"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        justification: bool = False,
        additional_context: str = "",
        criteria: str = "",
        model: str = "gpt-4o",
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["justification"] = justification

        super().__init__(
            node_type="scorer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if justification is not None:
            self.inputs["justification"] = justification
        if text is not None:
            self.inputs["text"] = text
        if criteria is not None:
            self.inputs["criteria"] = criteria
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ScorerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("speech_to_text")
class SpeechToTextNode(Node):
    """


    ## Inputs
    ### Common Inputs
        audio: The audio input
        model: The model input
    ### Deepgram
        submodel: The submodel input
        tier: The tier input

    ## Outputs
    ### Common Outputs
        text: The text output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "audio",
            "helper_text": "The audio input",
            "value": "",
            "type": "audio",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "OpenAI Whisper",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The text output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "OpenAI Whisper": {"inputs": [], "outputs": []},
        "Deepgram": {
            "inputs": [
                {"field": "submodel", "type": "enum<string>", "value": "nova-2"},
                {"field": "tier", "type": "enum<string>", "value": "general"},
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["model"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "OpenAI Whisper",
        audio: Any = None,
        submodel: str = "nova-2",
        tier: str = "general",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["model"] = model

        super().__init__(
            node_type="speech_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if audio is not None:
            self.inputs["audio"] = audio
        if submodel is not None:
            self.inputs["submodel"] = submodel
        if tier is not None:
            self.inputs["tier"] = tier

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SpeechToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_save")
class FileSaveNode(Node):
    """
    Save a file on the VectorShift platform (under the 'Files' tab).

    ## Inputs
    ### Common Inputs
        files: The files to be saved
        name: The name of the file

    ## Outputs
    ### Common Outputs
        file_name: The name of the file saved
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "files",
            "helper_text": "The files to be saved",
            "value": [""],
            "type": "vec<file>",
        },
        {
            "field": "name",
            "helper_text": "The name of the file",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file_name", "helper_text": "The name of the file saved"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        files: List[str] = [""],
        name: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="file_save",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if name is not None:
            self.inputs["name"] = name
        if files is not None:
            self.inputs["files"] = files

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "FileSaveNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("image_gen")
class ImageGenNode(Node):
    """


    ## Inputs
    ### Common Inputs
        aspect_ratio: The aspect_ratio input
        image_count: The image_count input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        size: The size input

    ## Outputs
    ### Common Outputs
        images: The images output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "aspect_ratio",
            "helper_text": "The aspect_ratio input",
            "value": "1:1",
            "type": "enum<string>",
        },
        {
            "field": "image_count",
            "helper_text": "The image_count input",
            "value": "1",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gpt-4-1106-preview",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "llmOpenAI",
            "type": "enum<string>",
        },
        {
            "field": "size",
            "helper_text": "The size input",
            "value": "512x512",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "images", "helper_text": "The images output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        aspect_ratio: str = "1:1",
        image_count: str = "1",
        model: str = "gpt-4-1106-preview",
        prompt: str = "",
        provider: str = "llmOpenAI",
        size: str = "512x512",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="image_gen",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if size is not None:
            self.inputs["size"] = size
        if aspect_ratio is not None:
            self.inputs["aspect_ratio"] = aspect_ratio
        if image_count is not None:
            self.inputs["image_count"] = image_count

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ImageGenNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file")
class FileNode(Node):
    """
    Load a static file into the workflow as a raw File or process it into Text.

    ## Inputs
    ### Common Inputs
        file_parser: The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.
        selected_option: Select an existing file from the VectorShift platform
    ### upload
        file: The file that was passed in
    ### name
        file_name: The name of the file from the VectorShift platform (for files on the File tab)

    ## Outputs
    ### Common Outputs
        file: The file that was passed in
        processed_text: The processed text of the file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_parser",
            "helper_text": "The processing model with which the document will be processed. Default processing model includes standard document parsing / OCR. Llamaparse will allow for ability to read documents with complex features (e.g., tables, charts, etc.). Llamaparse will be charged at 0.3 cents per page. Textract for most advanced data extraction and will be charged at 1.5 cents per page.",
            "value": "default",
            "type": "enum<string>",
        },
        {
            "field": "selected_option",
            "helper_text": "Select an existing file from the VectorShift platform",
            "value": "upload",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The file that was passed in"},
        {"field": "processed_text", "helper_text": "The processed text of the file"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "upload": {
            "inputs": [
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The file that was passed in",
                }
            ],
            "outputs": [],
        },
        "name": {
            "inputs": [
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "The name of the file from the VectorShift platform (for files on the File tab)",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected_option"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected_option: str = "upload",
        file: Optional[str] = None,
        file_name: str = "",
        file_parser: str = "default",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected_option"] = selected_option

        super().__init__(
            node_type="file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if selected_option is not None:
            self.inputs["selected_option"] = selected_option
        if file is not None:
            self.inputs["file"] = file
        if file_name is not None:
            self.inputs["file_name"] = file_name

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "FileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("get_list_item")
class GetListItemNode(Node):
    """
    Get a value from a list given an index. The first item in the list is index 0.

    ## Inputs
    ### Common Inputs
        index: The index of the item to retrieve
        type: The type of the list
    ### <T>
        list: The list to retrieve the item from

    ## Outputs
    ### <T>
        output: The item retrieved from the list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "index",
            "helper_text": "The index of the item to retrieve",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to retrieve the item from",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "<T>",
                    "helper_text": "The item retrieved from the list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        index: int = 0,
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="get_list_item",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if index is not None:
            self.inputs["index"] = index
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "GetListItemNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_open_ai_vision")
class LlmOpenAiVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        stream: The stream input
        system: The system input
        temperature: The temperature input
        top_p: The top_p input
        use_personal_api_key: The use_personal_api_key input
    ### When use_personal_api_key = True
        api_key: The api_key input
    ### When json_response = True
        json_schema: The json_schema input

    ## Outputs
    ### Common Outputs
        response: The response output
        tokens_used: The tokens_used output
    ### When stream = True
        response_deltas: The response_deltas output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 128000,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gpt-4-vision-preview",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "openAiImageToText",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "The stream input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "The system input",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "response", "helper_text": "The response output"},
        {"field": "tokens_used", "helper_text": "The tokens_used output"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [{"field": "response_deltas", "type": "Stream<string>"}],
        },
        "(*)**false**(*)**(*)": {"inputs": [], "outputs": []},
        "(*)**(*)**true**(*)": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**(*)**false**(*)": {"inputs": [], "outputs": []},
        "(*)**(*)**(*)**true": {
            "inputs": [{"field": "json_schema", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**(*)**(*)**false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["provider", "stream", "use_personal_api_key", "json_response"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "openAiImageToText",
        stream: bool = False,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        api_key: str = "",
        image: Optional[Any] = None,
        json_schema: str = "",
        max_tokens: int = 128000,
        model: str = "gpt-4-vision-preview",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["stream"] = stream
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response

        super().__init__(
            node_type="llm_open_ai_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if image is not None:
            self.inputs["image"] = image
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "LlmOpenAiVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_google_vision")
class LlmGoogleVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        api_key: The api_key input
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        provider: The provider input
        stream: The stream input
        temperature: The temperature input
        top_p: The top_p input

    ## Outputs
    ### Common Outputs
        response: The response output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "The api_key input",
            "value": "",
            "type": "string",
        },
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 32760,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "gemini-pro-vision",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "The provider input",
            "value": "googleImageToText",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "The stream input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "response", "helper_text": "The response output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        image: Optional[Any] = None,
        json_response: bool = False,
        max_tokens: int = 32760,
        model: str = "gemini-pro-vision",
        prompt: str = "",
        provider: str = "googleImageToText",
        stream: bool = False,
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="llm_google_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if image is not None:
            self.inputs["image"] = image

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "LlmGoogleVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("split_text")
class SplitTextNode(Node):
    """
    Takes input text and separate it into a List of texts based on the delimiter.

    ## Inputs
    ### Common Inputs
        delimiter: The delimiter to split the text on
        text: The text to split
    ### character(s)
        character: The character(s) to split the text on

    ## Outputs
    ### Common Outputs
        processed_text: The text split into a list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "delimiter",
            "helper_text": "The delimiter to split the text on",
            "value": "space",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to split",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "processed_text", "helper_text": "The text split into a list"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "character(s)": {
            "inputs": [
                {
                    "field": "character",
                    "type": "string",
                    "value": "",
                    "helper_text": "The character(s) to split the text on",
                }
            ],
            "outputs": [],
        },
        "space": {"inputs": [], "outputs": []},
        "newline": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["delimiter"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        delimiter: str = "space",
        character: str = "",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["delimiter"] = delimiter

        super().__init__(
            node_type="split_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if delimiter is not None:
            self.inputs["delimiter"] = delimiter
        if text is not None:
            self.inputs["text"] = text
        if character is not None:
            self.inputs["character"] = character

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SplitTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("summarizer")
class SummarizerNode(Node):
    """
    Summarize text with AI

    ## Inputs
    ### Common Inputs
        model: The specific model for summarization
        provider: The model provider
        text: The text to be summarized

    ## Outputs
    ### Common Outputs
        summary: The summary of the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The specific model for summarization",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to be summarized",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "summary", "helper_text": "The summary of the text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="summarizer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SummarizerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text")
class TextNode(Node):
    """
    Accepts Text from upstream nodes and allows you to write additional text / concatenate different texts to pass to downstream nodes.

    ## Inputs
    ### Common Inputs
        text: The text to be processed

    ## Outputs
    ### Common Outputs
        text: The text from the node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text to be processed",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The text from the node"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_to_file")
class TextToFileNode(Node):
    """
    Convert data from type Text to type File

    ## Inputs
    ### Common Inputs
        file_type: The type of file to convert the text to.
        text: The text for conversion.

    ## Outputs
    ### Common Outputs
        file: The text as converted to a file.
        file_type: The type of file that was converted the text to.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file_type",
            "helper_text": "The type of file to convert the text to.",
            "value": "PDF",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text for conversion.",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The text as converted to a file."},
        {
            "field": "file_type",
            "helper_text": "The type of file that was converted the text to.",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "PDF",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text_to_file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TextToFileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("time")
class TimeNode(Node):
    """
    Outputs the current time (often connected to LLM node)

    ## Inputs
    ### Common Inputs
        delta_time_unit: The unit of the delta
        delta_value: The value of the delta
        is_positive: If the time should be positive
        is_positive_delta: If the time should be positive
        output_format: The format of the output time
        time_node_zone: The timezone of the time node

    ## Outputs
    ### Common Outputs
        processed_time: The time from the node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "delta_time_unit",
            "helper_text": "The unit of the delta",
            "value": "Seconds",
            "type": "enum<string>",
        },
        {
            "field": "delta_value",
            "helper_text": "The value of the delta",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "is_positive",
            "helper_text": "If the time should be positive",
            "value": "+",
            "type": "enum<string>",
        },
        {
            "field": "is_positive_delta",
            "helper_text": "If the time should be positive",
            "value": True,
            "type": "bool",
        },
        {
            "field": "output_format",
            "helper_text": "The format of the output time",
            "value": "DD/MM/YYYY",
            "type": "enum<string>",
        },
        {
            "field": "time_node_zone",
            "helper_text": "The timezone of the time node",
            "value": "America/New_York",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "processed_time", "helper_text": "The time from the node"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        delta_time_unit: str = "Seconds",
        delta_value: int = 0,
        is_positive: str = "+",
        is_positive_delta: bool = True,
        output_format: str = "DD/MM/YYYY",
        time_node_zone: str = "America/New_York",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="time",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if is_positive is not None:
            self.inputs["is_positive"] = is_positive
        if is_positive_delta is not None:
            self.inputs["is_positive_delta"] = is_positive_delta
        if delta_value is not None:
            self.inputs["delta_value"] = delta_value
        if delta_time_unit is not None:
            self.inputs["delta_time_unit"] = delta_time_unit
        if output_format is not None:
            self.inputs["output_format"] = output_format
        if time_node_zone is not None:
            self.inputs["time_node_zone"] = time_node_zone

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TimeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("translator")
class TranslatorNode(Node):
    """
    Translate text from one language to another

    ## Inputs
    ### Common Inputs
        model: The specific model for translation
        provider: The model provider
        source_language: The language of the input text
        target_language: The language to translate to
        text: The text to be translated

    ## Outputs
    ### Common Outputs
        translation: The translation of the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The specific model for translation",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "source_language",
            "helper_text": "The language of the input text",
            "value": "Detect Language",
            "type": "enum<string>",
        },
        {
            "field": "target_language",
            "helper_text": "The language to translate to",
            "value": "English",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to be translated",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "translation", "helper_text": "The translation of the text"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        source_language: str = "Detect Language",
        target_language: str = "English",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="translator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if source_language is not None:
            self.inputs["source_language"] = source_language
        if target_language is not None:
            self.inputs["target_language"] = target_language

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TranslatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("tts_eleven_labs")
class TtsElevenLabsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        api_key: The api_key input
        model: The model input
        text: The text input
        voice: The voice input

    ## Outputs
    ### Common Outputs
        audio: The audio output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "The api_key input",
            "value": "",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "eleven_multilingual_v2",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        },
        {
            "field": "voice",
            "helper_text": "The voice input",
            "value": "shimmer",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "audio", "helper_text": "The audio output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        model: str = "eleven_multilingual_v2",
        text: str = "",
        voice: str = "shimmer",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="tts_eleven_labs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TtsElevenLabsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("tts_open_ai")
class TtsOpenAiNode(Node):
    """


    ## Inputs
    ### Common Inputs
        model: The model input
        text: The text input
        use_personal_api_key: The use_personal_api_key input
        voice: The voice input
    ### When use_personal_api_key = True
        api_key: The api_key input

    ## Outputs
    ### Common Outputs
        audio: The audio output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "tts-1",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text input",
            "value": "",
            "type": "string",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "voice",
            "helper_text": "The voice input",
            "value": "alloy",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "audio", "helper_text": "The audio output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false": {"inputs": [], "outputs": []},
        "true": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        api_key: str = "",
        model: str = "tts-1",
        text: str = "",
        voice: str = "alloy",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key

        super().__init__(
            node_type="tts_open_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if text is not None:
            self.inputs["text"] = text
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TtsOpenAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_audio_operations")
class AiAudioOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_audio_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiAudioOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_text_to_speech")
class AiTextToSpeechNode(Node):
    """
    Generate Audio from text using AI

    ## Inputs
    ### Common Inputs
        model: Select the text-to-speech model
        provider: Select the model provider.
        text: The text for conversion.
        use_personal_api_key: Use your personal API key
        voice: Select the voice
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run

    ## Outputs
    ### Common Outputs
        audio: The Text as converted to Audio.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "model",
            "helper_text": "Select the text-to-speech model",
            "value": "tts-1",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text for conversion.",
            "value": "",
            "type": "string",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
        {
            "field": "voice",
            "helper_text": "Select the voice",
            "value": "alloy",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "audio", "helper_text": "The Text as converted to Audio."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "label": "API Key",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "(*)**openai": {"inputs": [], "outputs": [], "title": "OpenAI Text to Speech"},
        "(*)**eleven_labs": {
            "inputs": [],
            "outputs": [],
            "title": "Eleven Labs Text to Speech",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        model: str = "tts-1",
        text: str = "",
        voice: str = "alloy",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_text_to_speech",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if voice is not None:
            self.inputs["voice"] = voice
        if text is not None:
            self.inputs["text"] = text
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiTextToSpeechNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_speech_to_text")
class AiSpeechToTextNode(Node):
    """
    Generate Text from Audio using AI

    ## Inputs
    ### Common Inputs
        audio: The audio for conversion
        model: Select the speech-to-text model
        provider: Select the model provider.
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run
    ### When provider = 'deepgram'
        tier: Select the tier

    ## Outputs
    ### Common Outputs
        text: The Text from the Audio.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "audio",
            "helper_text": "The audio for conversion",
            "value": "",
            "type": "audio",
        },
        {
            "field": "model",
            "helper_text": "Select the speech-to-text model",
            "value": "whisper-1",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "text", "helper_text": "The Text from the Audio."}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "label": "API Key",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "(*)**openai": {"inputs": [], "outputs": [], "title": "OpenAI Speech to Text"},
        "(*)**deepgram": {
            "inputs": [
                {
                    "field": "tier",
                    "type": "enum<string>",
                    "value": "general",
                    "label": "Tier",
                    "helper_text": "Select the tier",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "dropdown",
                        "llm_options": {"field": "tier", "type": "speech_to_text"},
                    },
                }
            ],
            "outputs": [],
            "title": "Deepgram Speech to Text",
        },
        "false**(*)": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        audio: Any = None,
        model: str = "whisper-1",
        tier: str = "general",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_speech_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if audio is not None:
            self.inputs["audio"] = audio
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if tier is not None:
            self.inputs["tier"] = tier

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiSpeechToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_image_operations")
class AiImageOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_image_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiImageOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_image_to_text")
class AiImageToTextNode(Node):
    """
    Generate Text from Image using AI

    ## Inputs
    ### Common Inputs
        image: The image for conversion
        json_response: Return the response as a JSON object
        max_tokens: The maximum number of tokens to generate
        model: Select the image-to-text model
        prompt: The data that is sent to the LLM. Add data from other nodes with double curly braces, e.g., {{input1}}
        provider: Select the model provider.
        stream: Stream the response
        system: Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model on what tone to respond in or how to respond given the information you provide
        temperature: The temperature of the model
        top_p: The top-p value
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run
    ### When json_response = True
        json_schema: The JSON schema to use for the response

    ## Outputs
    ### Common Outputs
        tokens_used: The number of tokens used
    ### When stream = False
        text: The Text from the Image.
    ### When stream = True
        text: Stream of text generated from the Image.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image for conversion",
            "value": "",
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "Return the response as a JSON object",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum number of tokens to generate",
            "value": 128000,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "Select the image-to-text model",
            "value": "chatgpt-4o-latest",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The data that is sent to the LLM. Add data from other nodes with double curly braces, e.g., {{input1}}",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "stream",
            "helper_text": "Stream the response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "system",
            "helper_text": "Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model on what tone to respond in or how to respond given the information you provide",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature of the model",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top-p value",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "tokens_used", "helper_text": "The number of tokens used"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)**(*)**(*)": {"inputs": [], "outputs": []},
        "true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "label": "API Key",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "(*)**false**(*)**(*)": {"inputs": [], "outputs": []},
        "(*)**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "json_schema",
                    "type": "string",
                    "value": "",
                    "label": "JSON Schema",
                    "helper_text": "The JSON schema to use for the response",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**false**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The Text from the Image.",
                }
            ],
        },
        "(*)**(*)**true**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "text",
                    "type": "stream<string>",
                    "helper_text": "Stream of text generated from the Image.",
                }
            ],
        },
        "(*)**(*)**(*)**openai": {
            "inputs": [],
            "outputs": [],
            "title": "OpenAI Image to Text",
        },
        "(*)**(*)**(*)**anthropic": {
            "inputs": [],
            "outputs": [],
            "title": "Anthropic Image to Text",
        },
        "(*)**(*)**(*)**google": {
            "inputs": [],
            "outputs": [],
            "title": "Google Image to Text",
        },
        "(*)**(*)**(*)**xai": {
            "inputs": [],
            "outputs": [],
            "title": "XAI Image to Text",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "json_response", "stream", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        stream: bool = False,
        provider: str = "openai",
        api_key: str = "",
        image: Any = None,
        json_schema: str = "",
        max_tokens: int = 128000,
        model: str = "chatgpt-4o-latest",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response
        params["stream"] = stream
        params["provider"] = provider

        super().__init__(
            node_type="ai_image_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if image is not None:
            self.inputs["image"] = image
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if stream is not None:
            self.inputs["stream"] = stream
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiImageToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_text_to_image")
class AiTextToImageNode(Node):
    """
    Generate Image from Text using AI

    ## Inputs
    ### Common Inputs
        aspect_ratio: Select the aspect ratio.
        model: Select the text-to-image model
        prompt: Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model to use bright colors.
        provider: Select the model provider.
        use_personal_api_key: Use your personal API key
    ### When use_personal_api_key = True
        api_key: Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run
    ### When provider = 'openai'
        size: Select the size.

    ## Outputs
    ### Common Outputs
        image: The Image(s) generated from the Text.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "aspect_ratio",
            "helper_text": "Select the aspect ratio.",
            "value": "1:1",
            "type": "enum<string>",
        },
        {
            "field": "model",
            "helper_text": "Select the text-to-image model",
            "value": "dall-e-2",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "Tell the AI model how you would like it to respond. Be as specific as possible. For example, you can instruct the model to use bright colors.",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the model provider.",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Use your personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "image", "helper_text": "The Image(s) generated from the Text."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "label": "API Key",
                    "helper_text": "Input your personal API key from the model provider. Note: if you do not have access to the selected model, the workflow will not run",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "(*)**openai": {
            "inputs": [
                {
                    "field": "size",
                    "type": "enum<string>",
                    "value": "512x512",
                    "label": "Size",
                    "helper_text": "Select the size.",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "256x256", "value": "256x256"},
                            {"label": "512x512", "value": "512x512"},
                            {"label": "1024x1024", "value": "1024x1024"},
                        ],
                    },
                }
            ],
            "outputs": [],
            "title": "OpenAI Text to Image",
        },
        "(*)**stabilityai": {
            "inputs": [],
            "outputs": [],
            "title": "Stability AI Text to Image",
        },
        "(*)**flux": {"inputs": [], "outputs": [], "title": "Flux Text to Image"},
        "(*)**xai": {"inputs": [], "outputs": [], "title": "XAI Text to Image"},
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "provider"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        provider: str = "openai",
        api_key: str = "",
        aspect_ratio: str = "1:1",
        model: str = "dall-e-2",
        prompt: str = "",
        size: str = "512x512",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["provider"] = provider

        super().__init__(
            node_type="ai_text_to_image",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if aspect_ratio is not None:
            self.inputs["aspect_ratio"] = aspect_ratio
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if size is not None:
            self.inputs["size"] = size

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiTextToImageNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("llm_anthropic_vision")
class LlmAnthropicVisionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        image: The image input
        json_response: The json_response input
        max_tokens: The max_tokens input
        model: The model input
        prompt: The prompt input
        system: The system input
        temperature: The temperature input
        top_p: The top_p input
        use_personal_api_key: The use_personal_api_key input
    ### When use_personal_api_key = True
        api_key: The api_key input
    ### When json_response = True
        json_schema: The json_schema input

    ## Outputs
    ### Common Outputs
        response: The response output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "image",
            "helper_text": "The image input",
            "value": None,
            "type": "image",
        },
        {
            "field": "json_response",
            "helper_text": "The json_response input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_tokens",
            "helper_text": "The max_tokens input",
            "value": 200000,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model input",
            "value": "claude-3-haiku-20240307",
            "type": "enum<string>",
        },
        {
            "field": "prompt",
            "helper_text": "The prompt input",
            "value": "",
            "type": "string",
        },
        {
            "field": "system",
            "helper_text": "The system input",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature input",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top_p input",
            "value": 0.9,
            "type": "float",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "The use_personal_api_key input",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "response", "helper_text": "The response output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {"inputs": [], "outputs": []},
        "true**(*)": {
            "inputs": [{"field": "api_key", "type": "string", "value": ""}],
            "outputs": [],
        },
        "(*)**false": {"inputs": [], "outputs": []},
        "(*)**true": {
            "inputs": [{"field": "json_schema", "type": "string", "value": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["use_personal_api_key", "json_response"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        use_personal_api_key: bool = False,
        json_response: bool = False,
        api_key: str = "",
        image: Optional[Any] = None,
        json_schema: str = "",
        max_tokens: int = 200000,
        model: str = "claude-3-haiku-20240307",
        prompt: str = "",
        system: str = "",
        temperature: Any = 0.7,
        top_p: Any = 0.9,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["use_personal_api_key"] = use_personal_api_key
        params["json_response"] = json_response

        super().__init__(
            node_type="llm_anthropic_vision",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if system is not None:
            self.inputs["system"] = system
        if prompt is not None:
            self.inputs["prompt"] = prompt
        if image is not None:
            self.inputs["image"] = image
        if model is not None:
            self.inputs["model"] = model
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if json_response is not None:
            self.inputs["json_response"] = json_response
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if json_schema is not None:
            self.inputs["json_schema"] = json_schema

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "LlmAnthropicVisionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("semantic_search")
class SemanticSearchNode(Node):
    """
    Generate a temporary vector database at run-time and retrieve the most relevant pieces from the documents based on the query.

    ## Inputs
    ### Common Inputs
        alpha: The alpha value for the retrieval
        analyze_documents: To analyze document contents and enrich them when parsing
        answer_multiple_questions: Extract separate questions from the query and retrieve content separately for each question to improve search performance
        do_advanced_qa: Use additional LLM calls to analyze each document to improve answer correctness
        do_nl_metadata_query: Do a natural language metadata query
        documents: The text for semantic search. Note: you may add multiple upstream nodes to this field.
        enable_context: Additional context passed to advanced search and query analysis
        enable_document_db_filter: Filter the documents returned from the knowledge base
        enable_filter: Filter the content returned from the knowledge base
        expand_query: Expand query to improve semantic search
        expand_query_terms: Expand query terms to improve semantic search
        format_context_for_llm: Format the context for the LLM
        is_hybrid: Whether to create a hybrid knowledge base
        max_docs_per_query: The maximum number of relevant chunks to be returned
        model: The model to use for the embedding
        query: The query will be used to search documents for relevant pieces semantically.
        rerank_documents: Refine the initial ranking of returned chunks based on relevancy
        retrieval_unit: The unit of retrieval
        score_cutoff: The score cutoff
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.
        show_intermediate_steps: Show intermediate steps
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        transform_query: Transform the query for better semantic search
    ### When do_advanced_qa = True
        advanced_search_mode: The mode to use for the advanced search
        qa_model_name: The model to use for the QA
    ### When enable_context = True
        context: Additional context to pass to the query analysis and qa steps
    ### When enable_document_db_filter = True
        document_db_filter: Filter the documents returned from the knowledge base
    ### When enable_filter = True
        filter: Filter the content returned from the knowledge base
    ### When rerank_documents = True
        rerank_model: Refine the initial ranking of returned chunks based on relevancy

    ## Outputs
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False
        chunks: Semantically similar chunks retrieved from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True
        chunks: Semantically similar chunks retrieved from the knowledge base
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When do_advanced_qa = True
        citation_metadata: Citation metadata for semantic search outputs, used for showing sources in LLM responses
        response: The response from the semantic search
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False
        documents: Semantically similar documents retrieved from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True
        documents: Semantically similar documents retrieved from the knowledge base
        formatted_text: Knowledge base outputs formatted for input to a LLM
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "alpha",
            "helper_text": "The alpha value for the retrieval",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "analyze_documents",
            "helper_text": "To analyze document contents and enrich them when parsing",
            "value": False,
            "type": "bool",
        },
        {
            "field": "answer_multiple_questions",
            "helper_text": "Extract separate questions from the query and retrieve content separately for each question to improve search performance",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_advanced_qa",
            "helper_text": "Use additional LLM calls to analyze each document to improve answer correctness",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_nl_metadata_query",
            "helper_text": "Do a natural language metadata query",
            "value": False,
            "type": "bool",
        },
        {
            "field": "documents",
            "helper_text": "The text for semantic search. Note: you may add multiple upstream nodes to this field.",
            "value": [],
            "type": "string",
        },
        {
            "field": "enable_context",
            "helper_text": "Additional context passed to advanced search and query analysis",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_document_db_filter",
            "helper_text": "Filter the documents returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_filter",
            "helper_text": "Filter the content returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query",
            "helper_text": "Expand query to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query_terms",
            "helper_text": "Expand query terms to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "format_context_for_llm",
            "helper_text": "Format the context for the LLM",
            "value": False,
            "type": "bool",
        },
        {
            "field": "is_hybrid",
            "helper_text": "Whether to create a hybrid knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "max_docs_per_query",
            "helper_text": "The maximum number of relevant chunks to be returned",
            "value": 5,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "The model to use for the embedding",
            "value": "openai/text-embedding-3-small",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The query will be used to search documents for relevant pieces semantically.",
            "value": "",
            "type": "string",
        },
        {
            "field": "rerank_documents",
            "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
            "value": False,
            "type": "bool",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "The unit of retrieval",
            "value": "chunks",
            "type": "enum<string>",
        },
        {
            "field": "score_cutoff",
            "helper_text": "The score cutoff",
            "value": 0,
            "type": "float",
        },
        {
            "field": "segmentation_method",
            "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
            "value": "words",
            "type": "enum<string>",
        },
        {
            "field": "show_intermediate_steps",
            "helper_text": "Show intermediate steps",
            "value": False,
            "type": "bool",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "transform_query",
            "helper_text": "Transform the query for better semantic search",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "qa_model_name",
                    "type": "enum<string>",
                    "value": "gpt-4o-mini",
                    "helper_text": "The model to use for the QA",
                },
                {
                    "field": "advanced_search_mode",
                    "type": "enum<string>",
                    "value": "accurate",
                    "helper_text": "The mode to use for the advanced search",
                },
            ],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response from the semantic search",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for semantic search outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "(*)**true**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the content returned from the knowledge base",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**true**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "rerank_model",
                    "type": "enum<string>",
                    "value": "cohere/rerank-english-v3.0",
                    "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
                }
            ],
            "outputs": [],
        },
        "false**(*)**(*)**documents**(*)**false**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base",
                }
            ],
        },
        "false**(*)**(*)**chunks**(*)**false**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base",
                }
            ],
        },
        "false**(*)**(*)**documents**(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**true**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "(*)**(*)**(*)**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "context",
                    "type": "string",
                    "value": "",
                    "helper_text": "Additional context to pass to the query analysis and qa steps",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "document_db_filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the documents returned from the knowledge base",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**(*)**(dynamic)": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "do_advanced_qa",
        "enable_filter",
        "rerank_documents",
        "retrieval_unit",
        "enable_context",
        "format_context_for_llm",
        "enable_document_db_filter",
        "splitter_method",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        do_advanced_qa: bool = False,
        enable_filter: bool = False,
        rerank_documents: bool = False,
        retrieval_unit: str = "chunks",
        enable_context: bool = False,
        format_context_for_llm: bool = False,
        enable_document_db_filter: bool = False,
        splitter_method: str = "markdown",
        advanced_search_mode: str = "accurate",
        alpha: Any = 0.5,
        analyze_documents: bool = False,
        answer_multiple_questions: bool = False,
        context: str = "",
        do_nl_metadata_query: bool = False,
        document_db_filter: str = "",
        documents: str = "[]",
        expand_query: bool = False,
        expand_query_terms: bool = False,
        filter: str = "",
        is_hybrid: bool = False,
        max_docs_per_query: int = 5,
        model: str = "openai/text-embedding-3-small",
        qa_model_name: str = "gpt-4o-mini",
        query: str = "",
        rerank_model: str = "cohere/rerank-english-v3.0",
        score_cutoff: Any = 0,
        segmentation_method: str = "words",
        show_intermediate_steps: bool = False,
        transform_query: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["do_advanced_qa"] = do_advanced_qa
        params["enable_filter"] = enable_filter
        params["rerank_documents"] = rerank_documents
        params["retrieval_unit"] = retrieval_unit
        params["enable_context"] = enable_context
        params["format_context_for_llm"] = format_context_for_llm
        params["enable_document_db_filter"] = enable_document_db_filter
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="semantic_search",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if model is not None:
            self.inputs["model"] = model
        if query is not None:
            self.inputs["query"] = query
        if max_docs_per_query is not None:
            self.inputs["max_docs_per_query"] = max_docs_per_query
        if rerank_documents is not None:
            self.inputs["rerank_documents"] = rerank_documents
        if documents is not None:
            self.inputs["documents"] = documents
        if enable_filter is not None:
            self.inputs["enable_filter"] = enable_filter
        if do_nl_metadata_query is not None:
            self.inputs["do_nl_metadata_query"] = do_nl_metadata_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if alpha is not None:
            self.inputs["alpha"] = alpha
        if transform_query is not None:
            self.inputs["transform_query"] = transform_query
        if answer_multiple_questions is not None:
            self.inputs["answer_multiple_questions"] = answer_multiple_questions
        if expand_query is not None:
            self.inputs["expand_query"] = expand_query
        if expand_query_terms is not None:
            self.inputs["expand_query_terms"] = expand_query_terms
        if do_advanced_qa is not None:
            self.inputs["do_advanced_qa"] = do_advanced_qa
        if show_intermediate_steps is not None:
            self.inputs["show_intermediate_steps"] = show_intermediate_steps
        if score_cutoff is not None:
            self.inputs["score_cutoff"] = score_cutoff
        if enable_context is not None:
            self.inputs["enable_context"] = enable_context
        if format_context_for_llm is not None:
            self.inputs["format_context_for_llm"] = format_context_for_llm
        if enable_document_db_filter is not None:
            self.inputs["enable_document_db_filter"] = enable_document_db_filter
        if analyze_documents is not None:
            self.inputs["analyze_documents"] = analyze_documents
        if is_hybrid is not None:
            self.inputs["is_hybrid"] = is_hybrid
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method
        if qa_model_name is not None:
            self.inputs["qa_model_name"] = qa_model_name
        if advanced_search_mode is not None:
            self.inputs["advanced_search_mode"] = advanced_search_mode
        if filter is not None:
            self.inputs["filter"] = filter
        if rerank_model is not None:
            self.inputs["rerank_model"] = rerank_model
        if context is not None:
            self.inputs["context"] = context
        if document_db_filter is not None:
            self.inputs["document_db_filter"] = document_db_filter

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SemanticSearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base")
class KnowledgeBaseNode(Node):
    """
    Semantically query a knowledge base that can contain files, scraped URLs, and data from synced integrations (e.g., Google Drive). Can optionally generate an LLM response using the retrieved context.

    ## Inputs
    ### Common Inputs
        alpha: The alpha value for the retrieval
        answer_multiple_questions: Extract separate questions from the query and retrieve content separately for each question to improve search performance
        do_advanced_qa: Use additional LLM calls to analyze each document to improve answer correctness
        do_nl_metadata_query: Do a natural language metadata query
        enable_context: Enable context
        enable_document_db_filter: Enable the document DB filter
        enable_filter: Filter the content returned from the knowledge base
        expand_query: Expand query to improve semantic search
        expand_query_terms: Expand query terms to improve semantic search
        format_context_for_llm: Format the context for the LLM
        generate_metadata_filters: Use an LLM to generate metadata filters to refine your query
        knowledge_base: Select an existing knowledge base
        query: The query will be used to search documents for relevant pieces semantically.
        rerank_documents: Rerank the documents returned from the knowledge base
        retrieval_unit: The unit of retrieval
        score_cutoff: The score cutoff
        set_response_format: Generate an LLM response from the retrieved context
        stream_response: Whether to stream the LLM response
        top_k: The number of relevant chunks to be returned
        transform_query: Transform the query for better semantic search
    ### When do_advanced_qa = True
        advanced_search_mode: The mode to use for the advanced search
        qa_model_name: The model to use for the QA
    ### When enable_context = True
        context: Additional context to pass to the query analysis and qa steps
    ### When enable_document_db_filter = True
        document_db_filter: Filter the documents returned from the knowledge base
    ### When enable_filter = True
        filter: Filter the content returned from the knowledge base
    ### When rerank_documents = True
        num_chunks_to_rerank: The number of chunks to rerank
        rerank_model: Refine the initial ranking of returned chunks based on relevancy
    ### When set_response_format = True and stream_response = True
        system_prompt: The system prompt to use for the LLM
    ### When set_response_format = True and stream_response = False
        system_prompt: The system prompt to use for the LLM

    ## Outputs
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = False
        chunks: Semantically similar chunks retrieved from the knowledge base.
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When do_advanced_qa = False and retrieval_unit = 'chunks' and format_context_for_llm = True
        chunks: Semantically similar chunks retrieved from the knowledge base.
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When do_advanced_qa = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        response: The response from the knowledge base
    ### When enable_filter = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = False
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        documents: The documents returned from the knowledge base
    ### When do_advanced_qa = False and retrieval_unit = 'documents' and format_context_for_llm = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        documents: Semantically similar documents retrieved from the knowledge base.
        formatted_text: Knowledge base outputs formatted for input to a LLM
    ### When enable_context = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When enable_document_db_filter = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
    ### When set_response_format = True and stream_response = True
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        response: The response from the knowledge base
    ### When set_response_format = True and stream_response = False
        citation_metadata: Citation metadata for knowledge base outputs, used for showing sources in LLM responses
        response: The response from the knowledge base
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "alpha",
            "helper_text": "The alpha value for the retrieval",
            "value": 0.5,
            "type": "float",
        },
        {
            "field": "answer_multiple_questions",
            "helper_text": "Extract separate questions from the query and retrieve content separately for each question to improve search performance",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_advanced_qa",
            "helper_text": "Use additional LLM calls to analyze each document to improve answer correctness",
            "value": False,
            "type": "bool",
        },
        {
            "field": "do_nl_metadata_query",
            "helper_text": "Do a natural language metadata query",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_context",
            "helper_text": "Enable context",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_document_db_filter",
            "helper_text": "Enable the document DB filter",
            "value": False,
            "type": "bool",
        },
        {
            "field": "enable_filter",
            "helper_text": "Filter the content returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query",
            "helper_text": "Expand query to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "expand_query_terms",
            "helper_text": "Expand query terms to improve semantic search",
            "value": False,
            "type": "bool",
        },
        {
            "field": "format_context_for_llm",
            "helper_text": "Format the context for the LLM",
            "value": True,
            "type": "bool",
        },
        {
            "field": "generate_metadata_filters",
            "helper_text": "Use an LLM to generate metadata filters to refine your query",
            "value": False,
            "type": "bool",
        },
        {
            "field": "knowledge_base",
            "helper_text": "Select an existing knowledge base",
            "value": {"object_type": 1, "object_id": ""},
            "type": "knowledge_base",
        },
        {
            "field": "query",
            "helper_text": "The query will be used to search documents for relevant pieces semantically.",
            "value": "",
            "type": "string",
        },
        {
            "field": "rerank_documents",
            "helper_text": "Rerank the documents returned from the knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "retrieval_unit",
            "helper_text": "The unit of retrieval",
            "value": "chunks",
            "type": "enum<string>",
        },
        {
            "field": "score_cutoff",
            "helper_text": "The score cutoff",
            "value": 0,
            "type": "float",
        },
        {
            "field": "set_response_format",
            "helper_text": "Generate an LLM response from the retrieved context",
            "value": False,
            "type": "bool",
        },
        {
            "field": "stream_response",
            "helper_text": "Whether to stream the LLM response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "top_k",
            "helper_text": "The number of relevant chunks to be returned",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "transform_query",
            "helper_text": "Transform the query for better semantic search",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)**(*)**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "qa_model_name",
                    "label": "QA Model Name",
                    "type": "string",
                    "value": "gpt-4o-mini",
                    "helper_text": "The model to use for the QA",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "qa_models",
                    },
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "advanced_search_mode",
                    "label": "Advanced Search Mode",
                    "type": "string",
                    "value": "accurate",
                    "helper_text": "The mode to use for the advanced search",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Fast", "value": "fast"},
                            {"label": "Accurate", "value": "accurate"},
                        ],
                    },
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response from the knowledge base",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "(*)**true**(*)**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "filter",
                    "label": "Filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the content returned from the knowledge base",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
        "(*)**(*)**true**(*)**(*)**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "rerank_model",
                    "label": "Rerank Model",
                    "type": "string",
                    "value": "cohere/rerank-english-v3.0",
                    "helper_text": "Refine the initial ranking of returned chunks based on relevancy",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "rerank_models",
                    },
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "num_chunks_to_rerank",
                    "label": "Num Chunks to Rerank",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The number of chunks to rerank",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
        },
        "false**(*)**(*)**documents**(*)**false**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "The documents returned from the knowledge base",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**false**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "false**(*)**(*)**documents**(*)**true**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "documents",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar documents retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "false**(*)**(*)**chunks**(*)**true**(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "chunks",
                    "type": "vec<string>",
                    "helper_text": "Semantically similar chunks retrieved from the knowledge base.",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
                {
                    "field": "formatted_text",
                    "type": "string",
                    "helper_text": "Knowledge base outputs formatted for input to a LLM",
                },
            ],
        },
        "(*)**(*)**(*)**(*)**true**(*)**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "context",
                    "label": "Context",
                    "type": "string",
                    "value": "",
                    "helper_text": "Additional context to pass to the query analysis and qa steps",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**true**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "document_db_filter",
                    "label": "Document DB Filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter the documents returned from the knowledge base",
                }
            ],
            "outputs": [
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                }
            ],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**(*)**true**true": {
            "inputs": [
                {
                    "field": "system_prompt",
                    "label": "System Prompt",
                    "type": "string",
                    "value": "",
                    "helper_text": "The system prompt to use for the LLM",
                }
            ],
            "outputs": [
                {
                    "field": "response",
                    "type": "stream<string>",
                    "helper_text": "The response from the knowledge base",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
        "(*)**(*)**(*)**(*)**(*)**(*)**(*)**true**false": {
            "inputs": [
                {
                    "field": "system_prompt",
                    "label": "System Prompt",
                    "type": "string",
                    "value": "",
                    "helper_text": "The system prompt to use for the LLM",
                }
            ],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The response from the knowledge base",
                },
                {
                    "field": "citation_metadata",
                    "type": "vec<string>",
                    "helper_text": "Citation metadata for knowledge base outputs, used for showing sources in LLM responses",
                },
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = [
        "do_advanced_qa",
        "enable_filter",
        "rerank_documents",
        "retrieval_unit",
        "enable_context",
        "format_context_for_llm",
        "enable_document_db_filter",
        "set_response_format",
        "stream_response",
    ]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        do_advanced_qa: bool = False,
        enable_filter: bool = False,
        rerank_documents: bool = False,
        retrieval_unit: str = "chunks",
        enable_context: bool = False,
        format_context_for_llm: bool = True,
        enable_document_db_filter: bool = False,
        set_response_format: bool = False,
        stream_response: bool = False,
        advanced_search_mode: str = "accurate",
        alpha: Any = 0.5,
        answer_multiple_questions: bool = False,
        context: str = "",
        do_nl_metadata_query: bool = False,
        document_db_filter: str = "",
        expand_query: bool = False,
        expand_query_terms: bool = False,
        filter: str = "",
        generate_metadata_filters: bool = False,
        knowledge_base: Any = {"object_type": 1, "object_id": ""},
        num_chunks_to_rerank: int = 10,
        qa_model_name: str = "gpt-4o-mini",
        query: str = "",
        rerank_model: str = "cohere/rerank-english-v3.0",
        score_cutoff: Any = 0,
        system_prompt: str = "",
        top_k: int = 10,
        transform_query: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["do_advanced_qa"] = do_advanced_qa
        params["enable_filter"] = enable_filter
        params["rerank_documents"] = rerank_documents
        params["retrieval_unit"] = retrieval_unit
        params["enable_context"] = enable_context
        params["format_context_for_llm"] = format_context_for_llm
        params["enable_document_db_filter"] = enable_document_db_filter
        params["set_response_format"] = set_response_format
        params["stream_response"] = stream_response

        super().__init__(
            node_type="knowledge_base",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base
        if query is not None:
            self.inputs["query"] = query
        if top_k is not None:
            self.inputs["top_k"] = top_k
        if enable_filter is not None:
            self.inputs["enable_filter"] = enable_filter
        if rerank_documents is not None:
            self.inputs["rerank_documents"] = rerank_documents
        if do_nl_metadata_query is not None:
            self.inputs["do_nl_metadata_query"] = do_nl_metadata_query
        if retrieval_unit is not None:
            self.inputs["retrieval_unit"] = retrieval_unit
        if alpha is not None:
            self.inputs["alpha"] = alpha
        if transform_query is not None:
            self.inputs["transform_query"] = transform_query
        if answer_multiple_questions is not None:
            self.inputs["answer_multiple_questions"] = answer_multiple_questions
        if expand_query is not None:
            self.inputs["expand_query"] = expand_query
        if expand_query_terms is not None:
            self.inputs["expand_query_terms"] = expand_query_terms
        if do_advanced_qa is not None:
            self.inputs["do_advanced_qa"] = do_advanced_qa
        if score_cutoff is not None:
            self.inputs["score_cutoff"] = score_cutoff
        if enable_context is not None:
            self.inputs["enable_context"] = enable_context
        if format_context_for_llm is not None:
            self.inputs["format_context_for_llm"] = format_context_for_llm
        if enable_document_db_filter is not None:
            self.inputs["enable_document_db_filter"] = enable_document_db_filter
        if set_response_format is not None:
            self.inputs["set_response_format"] = set_response_format
        if stream_response is not None:
            self.inputs["stream_response"] = stream_response
        if generate_metadata_filters is not None:
            self.inputs["generate_metadata_filters"] = generate_metadata_filters
        if qa_model_name is not None:
            self.inputs["qa_model_name"] = qa_model_name
        if advanced_search_mode is not None:
            self.inputs["advanced_search_mode"] = advanced_search_mode
        if filter is not None:
            self.inputs["filter"] = filter
        if rerank_model is not None:
            self.inputs["rerank_model"] = rerank_model
        if num_chunks_to_rerank is not None:
            self.inputs["num_chunks_to_rerank"] = num_chunks_to_rerank
        if context is not None:
            self.inputs["context"] = context
        if document_db_filter is not None:
            self.inputs["document_db_filter"] = document_db_filter
        if system_prompt is not None:
            self.inputs["system_prompt"] = system_prompt

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_loader")
class KnowledgeBaseLoaderNode(Node):
    """
    Load data into an existing knowledge base.

    ## Inputs
    ### Common Inputs
        document_type: Scrape sub-pages of the provided link
        knowledge_base: The knowledge base to load data into
        rescrape_frequency: The frequency to rescrape the URL
    ### File
        documents: The file to be added to the selected knowledge base. Note: to convert text to file, use the Text to File node
    ### Recursive URL
        load_sitemap: Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.
        max_depth: The maximum depth of the URL to crawl
        max_recursive_urls: The maximum number of recursive URLs to scrape
        same_domain_only: Whether to only crawl links from the same domain
        url: The raw URL link (e.g., https://vectorshift.ai/)
        use_proxy: Use a proxy to crawl the website
    ### URL
        max_recursive_urls: The maximum number of recursive URLs to scrape
        url: The raw URL link (e.g., https://vectorshift.ai/)
        use_proxy: Use a proxy to crawl the website

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "document_type",
            "helper_text": "Scrape sub-pages of the provided link",
            "value": "File",
            "type": "enum<string>",
        },
        {
            "field": "knowledge_base",
            "helper_text": "The knowledge base to load data into",
            "value": {},
            "type": "knowledge_base",
        },
        {
            "field": "rescrape_frequency",
            "helper_text": "The frequency to rescrape the URL",
            "value": "Never",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "URL": {
            "inputs": [
                {
                    "field": "max_recursive_urls",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of recursive URLs to scrape",
                },
                {
                    "field": "url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw URL link (e.g., https://vectorshift.ai/)",
                },
                {
                    "field": "use_proxy",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Use a proxy to crawl the website",
                    "label": "Use proxy",
                },
            ],
            "outputs": [],
        },
        "File": {
            "inputs": [
                {
                    "field": "documents",
                    "type": "vec<file>",
                    "value": [""],
                    "helper_text": "The file to be added to the selected knowledge base. Note: to convert text to file, use the Text to File node",
                }
            ],
            "outputs": [],
        },
        "Recursive URL": {
            "inputs": [
                {
                    "field": "max_recursive_urls",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of recursive URLs to scrape",
                    "label": "Max urls to crawl (max 800)",
                },
                {
                    "field": "url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw URL link (e.g., https://vectorshift.ai/)",
                },
                {
                    "field": "max_depth",
                    "type": "int32",
                    "value": 5,
                    "helper_text": "The maximum depth of the URL to crawl",
                    "label": "Max depth to crawl",
                },
                {
                    "field": "same_domain_only",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to only crawl links from the same domain",
                    "label": "Same domain only",
                },
                {
                    "field": "load_sitemap",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.",
                    "label": "Load sitemap",
                },
                {
                    "field": "use_proxy",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Use a proxy to crawl the website",
                    "label": "Use proxy",
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["document_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        document_type: str = "File",
        documents: List[str] = [""],
        knowledge_base: Any = {},
        load_sitemap: bool = False,
        max_depth: int = 5,
        max_recursive_urls: int = 10,
        rescrape_frequency: str = "Never",
        same_domain_only: bool = False,
        url: str = "",
        use_proxy: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["document_type"] = document_type

        super().__init__(
            node_type="knowledge_base_loader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base
        if document_type is not None:
            self.inputs["document_type"] = document_type
        if rescrape_frequency is not None:
            self.inputs["rescrape_frequency"] = rescrape_frequency
        if max_recursive_urls is not None:
            self.inputs["max_recursive_urls"] = max_recursive_urls
        if url is not None:
            self.inputs["url"] = url
        if use_proxy is not None:
            self.inputs["use_proxy"] = use_proxy
        if documents is not None:
            self.inputs["documents"] = documents
        if max_depth is not None:
            self.inputs["max_depth"] = max_depth
        if same_domain_only is not None:
            self.inputs["same_domain_only"] = same_domain_only
        if load_sitemap is not None:
            self.inputs["load_sitemap"] = load_sitemap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseLoaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("map")
class MapNode(Node):
    """


    ## Inputs
    ### Common Inputs
        function: The function input
        inputs: The inputs input

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "function",
            "helper_text": "The function input",
            "value": "",
            "type": "string",
        },
        {
            "field": "inputs",
            "helper_text": "The inputs input",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        function: str = "",
        inputs: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="map",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if inputs is not None:
            self.inputs["inputs"] = inputs
        if function is not None:
            self.inputs["function"] = function

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "MapNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("merge")
class MergeNode(Node):
    """
    Recombine paths created by a condition node. Note: if you are not using a condition node, you shouldn’t use a merge node

    ## Inputs
    ### Common Inputs
        function: The function to apply to the input fields
        type: The expected type of the input and output fields
    ### When function = 'first' and type = '<T>'
        fields: The fields input
    ### When function = 'join' and type = '<T>'
        fields: The fields input

    ## Outputs
    ### When function = 'first' and type = '<T>'
        output: The Text from the path based on the condition node
    ### When function = 'join' and type = '<T>'
        output: The Text from the path based on the condition node
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "function",
            "helper_text": "The function to apply to the input fields",
            "value": "first",
            "type": "enum<string>",
        },
        {
            "field": "type",
            "helper_text": "The expected type of the input and output fields",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "first**<T>": {
            "inputs": [
                {"field": "fields", "type": "vec<<T>>", "value": [""]},
                {
                    "field": "function",
                    "type": "enum<string>",
                    "value": "first",
                    "helper_text": "The function to apply to the input fields",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "<T>",
                    "helper_text": "The Text from the path based on the condition node",
                }
            ],
        },
        "join**<T>": {
            "inputs": [
                {"field": "fields", "type": "vec<<T>>", "value": [""]},
                {
                    "field": "function",
                    "type": "enum<string>",
                    "value": "join",
                    "helper_text": "The function to apply to the output fields",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The Text from the path based on the condition node",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["function", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        function: str = "first",
        type: str = "string",
        fields: List[Any] = [""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["function"] = function
        params["type"] = type

        super().__init__(
            node_type="merge",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if function is not None:
            self.inputs["function"] = function
        if fields is not None:
            self.inputs["fields"] = fields

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "MergeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("condition")
class ConditionNode(Node):
    """
    Specify a series of conditions and execute different paths based on the value of the conditions.

    ## Inputs
    ### Common Inputs
        conditions: The conditions input
        outputs: The outputs input

    ## Outputs
    ### Common Outputs
        [outputs]: The [outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "conditions",
            "helper_text": "The conditions input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "outputs",
            "helper_text": "The outputs input",
            "value": {},
            "type": "map<string, string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "[outputs]", "helper_text": "The [outputs] output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        conditions: List[Any] = [],
        outputs: Dict[str, str] = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="condition",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if conditions is not None:
            self.inputs["conditions"] = conditions
        if outputs is not None:
            self.inputs["outputs"] = outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ConditionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("nl_to_sql")
class NlToSqlNode(Node):
    """
    Convert natural language queries to SQL queries.

    ## Inputs
    ### Common Inputs
        db_dialect: The database dialect to use
        model: The model to use for the conversion
        schema: The schema of the database
        text: The natural language query to convert to SQL

    ## Outputs
    ### Common Outputs
        sql_query: The SQL query generated from the natural language query
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "db_dialect",
            "helper_text": "The database dialect to use",
            "value": "PostgreSQL",
            "type": "enum<string>",
        },
        {
            "field": "model",
            "helper_text": "The model to use for the conversion",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "schema",
            "helper_text": "The schema of the database",
            "value": "",
            "type": "string",
        },
        {
            "field": "text",
            "helper_text": "The natural language query to convert to SQL",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "sql_query",
            "helper_text": "The SQL query generated from the natural language query",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        db_dialect: str = "PostgreSQL",
        model: str = "gpt-4o",
        schema: str = "",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="nl_to_sql",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if db_dialect is not None:
            self.inputs["db_dialect"] = db_dialect
        if schema is not None:
            self.inputs["schema"] = schema
        if text is not None:
            self.inputs["text"] = text
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "NlToSqlNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("read_json_values")
class ReadJsonValuesNode(Node):
    """
    Read values from a JSON object based on a provided key(s).

    ## Inputs
    ### Common Inputs
        json_string: The JSON you want to read from
        keys: Define the name(s) of the JSON keys from the JSON that you want to read
        processed_outputs: The processed_outputs input

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
        json_values: The JSON Value
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "json_string",
            "helper_text": "The JSON you want to read from",
            "value": "",
            "type": "string",
        },
        {
            "field": "keys",
            "helper_text": "Define the name(s) of the JSON keys from the JSON that you want to read",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        },
        {"field": "json_values", "helper_text": "The JSON Value"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        json_string: str = "",
        keys: List[Any] = [],
        processed_outputs: Dict[str, str] = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="read_json_values",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if json_string is not None:
            self.inputs["json_string"] = json_string
        if keys is not None:
            self.inputs["keys"] = keys
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ReadJsonValuesNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("write_json_value")
class WriteJsonValueNode(Node):
    """
    Update a specific value in a JSON.

    ## Inputs
    ### Common Inputs
        fields: The fields input
        selected: Whether to update the JSON value or create a new JSON
    ### old
        json_string: The JSON to update

    ## Outputs
    ### Common Outputs
        updated_json: The updated JSON
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "fields",
            "helper_text": "The fields input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "selected",
            "helper_text": "Whether to update the JSON value or create a new JSON",
            "value": "new",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "updated_json", "helper_text": "The updated JSON"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "old": {
            "inputs": [
                {
                    "field": "json_string",
                    "type": "string",
                    "value": "",
                    "helper_text": "The JSON to update",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected: str = "new",
        fields: List[Any] = [],
        json_string: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected"] = selected

        super().__init__(
            node_type="write_json_value",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected is not None:
            self.inputs["selected"] = selected
        if fields is not None:
            self.inputs["fields"] = fields
        if json_string is not None:
            self.inputs["json_string"] = json_string

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "WriteJsonValueNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("api")
class ApiNode(Node):
    """
    Make an API request to a given URL.

    ## Inputs
    ### Common Inputs
        files: Files to include in the API request
        headers: Headers to include in the API request
        is_raw_json: Whether to return the raw JSON response from the API
        method: Choose the API Method desired (GET, POST, PUT, DELETE, PATCH)
        query_params: Query parameters to include in the API request
        url: Target URL for the API Request
    ### When is_raw_json = False
        body_params: The body parameters to include in the API request
    ### When is_raw_json = True
        raw_json: The raw JSON request to the API

    ## Outputs
    ### Common Outputs
        output: The response from the API
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "files",
            "helper_text": "Files to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "headers",
            "helper_text": "Headers to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "is_raw_json",
            "helper_text": "Whether to return the raw JSON response from the API",
            "value": False,
            "type": "bool",
        },
        {
            "field": "method",
            "helper_text": "Choose the API Method desired (GET, POST, PUT, DELETE, PATCH)",
            "value": "GET",
            "type": "enum<string>",
        },
        {
            "field": "query_params",
            "helper_text": "Query parameters to include in the API request",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "url",
            "helper_text": "Target URL for the API Request",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The response from the API"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "raw_json",
                    "type": "string",
                    "value": "",
                    "helper_text": "The raw JSON request to the API",
                    "label": "Raw JSON",
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "false": {
            "inputs": [
                {
                    "field": "body_params",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The body parameters to include in the API request",
                    "label": "Body Parameters",
                    "component": {"type": "table"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["is_raw_json"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        is_raw_json: bool = False,
        body_params: List[Any] = [],
        files: List[Any] = [],
        headers: List[Any] = [],
        method: str = "GET",
        query_params: List[Any] = [],
        raw_json: str = "",
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["is_raw_json"] = is_raw_json

        super().__init__(
            node_type="api",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if method is not None:
            self.inputs["method"] = method
        if url is not None:
            self.inputs["url"] = url
        if headers is not None:
            self.inputs["headers"] = headers
        if query_params is not None:
            self.inputs["query_params"] = query_params
        if files is not None:
            self.inputs["files"] = files
        if is_raw_json is not None:
            self.inputs["is_raw_json"] = is_raw_json
        if raw_json is not None:
            self.inputs["raw_json"] = raw_json
        if body_params is not None:
            self.inputs["body_params"] = body_params

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ApiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("url_loader")
class UrlLoaderNode(Node):
    """
    Scrape content from a URL.

    ## Inputs
    ### Common Inputs
        provider: The provider to use for the URL loader
        url: The URL to load
    ### When provider = 'modal' and use_actions = True
        actions: The browser actions to perform on the URL
    ### When provider = 'modal'
        ai_enhance_content: Whether to enhance the content
        recursive: Whether to recursively load the URL
        use_actions: Perform browser actions to interact with the input website
        use_personal_api_key: Whether to use a personal API key
        use_proxy: Use a proxy to crawl the website
    ### When provider = 'apify'
        api_key: The API key to use
        recursive: Whether to recursively load the URL
    ### When provider = 'jina' and use_personal_api_key = True
        api_key: The API key to use
    ### When provider = 'modal' and use_personal_api_key = True
        apify_key: The API key to use
    ### When provider = 'modal' and recursive = True
        load_sitemap: Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.
        url_limit: The maximum number of URLs to load
    ### When provider = 'apify' and recursive = True
        url_limit: The maximum number of URLs to load
    ### When provider = 'jina'
        use_personal_api_key: Whether to use a personal API key

    ## Outputs
    ### Common Outputs
        content: The content of the URL
        links: The sub-links present on the webpage of the provided URL
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "provider",
            "helper_text": "The provider to use for the URL loader",
            "value": "modal",
            "type": "enum<string>",
        },
        {
            "field": "url",
            "helper_text": "The URL to load",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "content", "helper_text": "The content of the URL"},
        {
            "field": "links",
            "helper_text": "The sub-links present on the webpage of the provided URL",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "jina**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "label": "Use personal API key",
                    "component": {"type": "bool"},
                }
            ],
            "outputs": [],
            "inputs_sort_order": ["provider", "url", "use_personal_api_key", "api_key"],
        },
        "apify**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "helper_text": "Whether to recursively load the URL",
                    "label": "Recursive",
                    "component": {"type": "bool"},
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "inputs_sort_order": [
                "provider",
                "url",
                "recursive",
                "url_limit",
                "api_key",
            ],
        },
        "modal**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "helper_text": "Whether to recursively load the URL",
                    "label": "Recursive",
                    "component": {"type": "bool"},
                },
                {
                    "field": "use_personal_api_key",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to use a personal API key",
                    "label": "Use personal API key",
                    "component": {"type": "bool"},
                },
                {
                    "field": "ai_enhance_content",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to enhance the content",
                    "label": "AI enhance content",
                    "component": {"type": "bool"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "is_advanced_setting": True,
                },
                {
                    "field": "use_actions",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Perform browser actions to interact with the input website",
                    "label": "Use browser actions",
                    "component": {"type": "bool"},
                    "banner_text": "This feature is only supported for the default provider and with recursive disabled",
                    "agent_field_type": "dynamic",
                    "is_hidden_in_agent": True,
                    "disable_conversion": True,
                },
                {
                    "field": "use_proxy",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Use a proxy to crawl the website",
                    "label": "Use proxy",
                    "component": {"type": "bool"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "is_advanced_setting": True,
                },
            ],
            "outputs": [],
            "inputs_sort_order": [
                "provider",
                "url",
                "use_actions",
                "actions",
                "recursive",
                "url_limit",
                "load_sitemap",
                "use_personal_api_key",
                "apify_key",
                "ai_enhance_content",
                "use_proxy",
            ],
        },
        "modal**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "apify_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "modal**(*)**true**(*)": {
            "inputs": [
                {
                    "field": "actions",
                    "type": "vec<any>",
                    "value": [],
                    "helper_text": "The browser actions to perform on the URL",
                    "label": "Actions",
                    "agent_field_type": "dynamic",
                    "is_hidden_in_agent": True,
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "modal**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "url_limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of URLs to load",
                    "label": "URL limit",
                    "component": {"type": "int32"},
                },
                {
                    "field": "load_sitemap",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Load URLs to crawl from a sitemap. If the URL is a sitemap, it will be used directly. If the URL is not a sitemap, the sitemap will be fetched automatically.",
                    "label": "Load sitemap",
                    "component": {"type": "bool"},
                    "agent_field_type": "dynamic",
                },
            ],
            "outputs": [],
        },
        "jina**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                    "label": "API key",
                    "component": {"type": "password"},
                    "agent_field_type": "static",
                    "disable_conversion": True,
                }
            ],
            "outputs": [],
        },
        "apify**(*)**(*)**true": {
            "inputs": [
                {
                    "field": "url_limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "The maximum number of URLs to load",
                    "label": "URL limit",
                    "component": {"type": "int32"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["provider", "use_personal_api_key", "use_actions", "recursive"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "modal",
        use_personal_api_key: bool = False,
        use_actions: bool = False,
        recursive: bool = False,
        actions: List[Any] = [],
        ai_enhance_content: bool = False,
        api_key: str = "",
        apify_key: str = "",
        load_sitemap: bool = False,
        url: str = "",
        url_limit: int = 10,
        use_proxy: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["use_personal_api_key"] = use_personal_api_key
        params["use_actions"] = use_actions
        params["recursive"] = recursive

        super().__init__(
            node_type="url_loader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if url is not None:
            self.inputs["url"] = url
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if recursive is not None:
            self.inputs["recursive"] = recursive
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if ai_enhance_content is not None:
            self.inputs["ai_enhance_content"] = ai_enhance_content
        if use_actions is not None:
            self.inputs["use_actions"] = use_actions
        if use_proxy is not None:
            self.inputs["use_proxy"] = use_proxy
        if apify_key is not None:
            self.inputs["apify_key"] = apify_key
        if actions is not None:
            self.inputs["actions"] = actions
        if url_limit is not None:
            self.inputs["url_limit"] = url_limit
        if load_sitemap is not None:
            self.inputs["load_sitemap"] = load_sitemap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "UrlLoaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("wikipedia")
class WikipediaNode(Node):
    """
    Query Wikipedia to return relevant articles

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        query: The Wikipedia query
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the Wikipedia article
    ### When chunk_text = False
        output: The raw text from the Wikipedia article
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "query",
            "helper_text": "The Wikipedia query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                    "label": "Chunk Size",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 1,
                        "max": 4096,
                        "step": 1,
                    },
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                    "label": "Chunk Overlap",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 0,
                        "max": 4095,
                        "step": 1,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the Wikipedia article",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the Wikipedia article",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="wikipedia",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "WikipediaNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("youtube")
class YoutubeNode(Node):
    """
    Get the transcript of a youtube video.

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        url: The YouTube URL to get the transcript of
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the YouTube transcript
    ### When chunk_text = False
        output: The raw text from the YouTube transcript
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "url",
            "helper_text": "The YouTube URL to get the transcript of",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                    "label": "Chunk Size",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 1,
                        "max": 4096,
                        "step": 1,
                    },
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                    "label": "Chunk Overlap",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 0,
                        "max": 4095,
                        "step": 1,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the YouTube transcript",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the YouTube transcript",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="youtube",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if url is not None:
            self.inputs["url"] = url
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "YoutubeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("arxiv")
class ArxivNode(Node):
    """
    Query ARXIV to return relevant articles

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text
        query: The ARXIV query
    ### When chunk_text = True
        chunk_overlap: The overlap of the chunks
        chunk_size: The size of the chunks to create

    ## Outputs
    ### When chunk_text = True
        output: List of raw text from the ARXIV article
    ### When chunk_text = False
        output: The raw text from the ARXIV article
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text",
            "value": False,
            "type": "bool",
        },
        {
            "field": "query",
            "helper_text": "The ARXIV query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 512,
                    "helper_text": "The size of the chunks to create",
                    "label": "Chunk Size",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 1,
                        "max": 4096,
                        "step": 1,
                    },
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The overlap of the chunks",
                    "label": "Chunk Overlap",
                    "is_advanced_setting": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 0,
                        "max": 4095,
                        "step": 1,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<string>",
                    "helper_text": "List of raw text from the ARXIV article",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "The raw text from the ARXIV article",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="arxiv",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ArxivNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("serp_api")
class SerpApiNode(Node):
    """
    Query the SERPAPI Google search API

    ## Inputs
    ### Common Inputs
        api_key: SERP API key
        query: The web search query

    ## Outputs
    ### Common Outputs
        output: Results of the SERP query
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "SERP API key",
            "value": "",
            "type": "string",
        },
        {
            "field": "query",
            "helper_text": "The web search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "Results of the SERP query"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        api_key: str = "",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="serp_api",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SerpApiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("you_dot_com")
class YouDotComNode(Node):
    """
    Query the You.com search API

    ## Inputs
    ### Common Inputs
        api_key: You.com API key
        loader_type: Select the loader type: General or News
        query: The search query

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "api_key",
            "helper_text": "You.com API key",
            "value": "",
            "type": "string",
        },
        {
            "field": "loader_type",
            "helper_text": "Select the loader type: General or News",
            "value": "YOU_DOT_COM",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "YOU_DOT_COM": {"inputs": [], "outputs": [], "title": "You.com Web Search"},
        "YOU_DOT_COM_NEWS": {
            "inputs": [],
            "outputs": [],
            "title": "You.com Search News",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["loader_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        loader_type: str = "YOU_DOT_COM",
        api_key: str = "",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["loader_type"] = loader_type

        super().__init__(
            node_type="you_dot_com",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if loader_type is not None:
            self.inputs["loader_type"] = loader_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "YouDotComNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("exa_ai")
class ExaAiNode(Node):
    """
    Query the Exa search API

    ## Inputs
    ### Common Inputs
        loader_type: Select the loader type: General, Companies, or Research Papers
        query: The search query

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "loader_type",
            "helper_text": "Select the loader type: General, Companies, or Research Papers",
            "value": "EXA_AI_SEARCH",
            "type": "enum<string>",
        },
        {
            "field": "query",
            "helper_text": "The search query",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "EXA_AI_SEARCH": {"inputs": [], "outputs": [], "title": "Exa AI Web Search"},
        "EXA_AI_SEARCH_COMPANIES": {
            "inputs": [],
            "outputs": [],
            "title": "Exa AI Companies",
        },
        "EXA_AI_SEARCH_RESEARCH_PAPERS": {
            "inputs": [],
            "outputs": [],
            "title": "Exa AI Research Papers",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["loader_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        loader_type: str = "EXA_AI_SEARCH",
        query: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["loader_type"] = loader_type

        super().__init__(
            node_type="exa_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if loader_type is not None:
            self.inputs["loader_type"] = loader_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ExaAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("google_search")
class GoogleSearchNode(Node):
    """
    Query the Google Search search API

    ## Inputs
    ### Common Inputs
        location: The location of the search
        num_results: The number of results to return
        query: The Google search query
        search_type: Select the search type: Web, Image, Hotels, Events, or News

    ## Outputs
    ### Common Outputs
        snippets: The snippets of the Google search results
        urls: The URLs of the Google search results
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "location",
            "helper_text": "The location of the search",
            "value": "us",
            "type": "string",
        },
        {
            "field": "num_results",
            "helper_text": "The number of results to return",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "query",
            "helper_text": "The Google search query",
            "value": "",
            "type": "string",
        },
        {
            "field": "search_type",
            "helper_text": "Select the search type: Web, Image, Hotels, Events, or News",
            "value": "web",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "snippets",
            "helper_text": "The snippets of the Google search results",
        },
        {"field": "urls", "helper_text": "The URLs of the Google search results"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        location: str = "us",
        num_results: int = 10,
        query: str = "",
        search_type: str = "web",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="google_search",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if query is not None:
            self.inputs["query"] = query
        if num_results is not None:
            self.inputs["num_results"] = num_results
        if search_type is not None:
            self.inputs["search_type"] = search_type
        if location is not None:
            self.inputs["location"] = location

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "GoogleSearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("google_alert_rss_reader")
class GoogleAlertRssReaderNode(Node):
    """
    Read the contents from a Google Alert RSS feed

    ## Inputs
    ### Common Inputs
        feed_link: The link of the Google Alert RSS feed you want to read
        timeframe: The publish dates of the items in the feed to read

    ## Outputs
    ### Common Outputs
        dates: The publish dates of the Google Alert RSS feed items
        links: The links of the Google Alert RSS feed items
        snippets: The snippets of the Google Alert RSS feed items
        titles: The titles of the Google Alert RSS feed items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "feed_link",
            "helper_text": "The link of the Google Alert RSS feed you want to read",
            "value": "",
            "type": "string",
        },
        {
            "field": "timeframe",
            "helper_text": "The publish dates of the items in the feed to read",
            "value": "all",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "dates",
            "helper_text": "The publish dates of the Google Alert RSS feed items",
        },
        {
            "field": "links",
            "helper_text": "The links of the Google Alert RSS feed items",
        },
        {
            "field": "snippets",
            "helper_text": "The snippets of the Google Alert RSS feed items",
        },
        {
            "field": "titles",
            "helper_text": "The titles of the Google Alert RSS feed items",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        feed_link: str = "",
        timeframe: str = "all",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="google_alert_rss_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if feed_link is not None:
            self.inputs["feed_link"] = feed_link
        if timeframe is not None:
            self.inputs["timeframe"] = timeframe

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "GoogleAlertRssReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("rss_feed_reader")
class RssFeedReaderNode(Node):
    """
    Read the contents from an RSS feed

    ## Inputs
    ### Common Inputs
        entries: The number of entries you want to fetch
        timeframe: The publish dates of the items in the feed to read
        url: The link of the RSS feed you want to read

    ## Outputs
    ### Common Outputs
        authors: The authors of the RSS feed items
        contents: The contents of the RSS feed items
        links: The links of the RSS feed items
        published_dates: The publish dates of the RSS feed items
        summaries: The summaries of the RSS feed items
        titles: The titles of the RSS feed items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "entries",
            "helper_text": "The number of entries you want to fetch",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "timeframe",
            "helper_text": "The publish dates of the items in the feed to read",
            "value": "all",
            "type": "enum<string>",
        },
        {
            "field": "url",
            "helper_text": "The link of the RSS feed you want to read",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "authors", "helper_text": "The authors of the RSS feed items"},
        {"field": "contents", "helper_text": "The contents of the RSS feed items"},
        {"field": "links", "helper_text": "The links of the RSS feed items"},
        {
            "field": "published_dates",
            "helper_text": "The publish dates of the RSS feed items",
        },
        {"field": "summaries", "helper_text": "The summaries of the RSS feed items"},
        {"field": "titles", "helper_text": "The titles of the RSS feed items"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        entries: int = 10,
        timeframe: str = "all",
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="rss_feed_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if url is not None:
            self.inputs["url"] = url
        if timeframe is not None:
            self.inputs["timeframe"] = timeframe
        if entries is not None:
            self.inputs["entries"] = entries

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "RssFeedReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_query")
class CsvQueryNode(Node):
    """
    Utilizes an LLM agent to query CSV(s). Delimeter for the CSV must be commas.

    ## Inputs
    ### Common Inputs
        csv: The CSV to be queried (file must be a CSV). Note: Ensure connecting node is of type File not text
        query: The question you want to be answered by the CSV
        stream: Whether to stream the results of the query

    ## Outputs
    ### Common Outputs
        output: The answer to the Query based on the CSV
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "csv",
            "helper_text": "The CSV to be queried (file must be a CSV). Note: Ensure connecting node is of type File not text",
            "value": None,
            "type": "file",
        },
        {
            "field": "query",
            "helper_text": "The question you want to be answered by the CSV",
            "value": "",
            "type": "string",
        },
        {
            "field": "stream",
            "helper_text": "Whether to stream the results of the query",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "The answer to the Query based on the CSV"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        csv: Optional[str] = None,
        query: str = "",
        stream: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="csv_query",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if csv is not None:
            self.inputs["csv"] = csv
        if query is not None:
            self.inputs["query"] = query
        if stream is not None:
            self.inputs["stream"] = stream

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CsvQueryNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_reader")
class CsvReaderNode(Node):
    """
    Read the contents from a CSV file and output a list of the data for each column.

    ## Inputs
    ### Common Inputs
        columns: Define the name(s) of the columns that you want to read
        file_type: The type of file to read.
        processed_outputs: The processed_outputs input
        selected_file: The file to read.
    ### EXCEL
        sheet: The sheet input
        sheets: The sheets input

    ## Outputs
    ### Common Outputs
        [processed_outputs]: The [processed_outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "columns",
            "helper_text": "Define the name(s) of the columns that you want to read",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "file_type",
            "helper_text": "The type of file to read.",
            "value": "CSV",
            "type": "enum<string>",
        },
        {
            "field": "processed_outputs",
            "helper_text": "The processed_outputs input",
            "value": {},
            "type": "map<string, string>",
        },
        {
            "field": "selected_file",
            "helper_text": "The file to read.",
            "value": None,
            "type": "file",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "[processed_outputs]",
            "helper_text": "The [processed_outputs] output",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "CSV": {"inputs": [], "outputs": []},
        "EXCEL": {
            "inputs": [
                {"field": "sheet", "type": "enum<string>"},
                {"field": "sheets", "type": "vec<string>", "value": []},
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["file_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file_type: str = "CSV",
        columns: List[Any] = [],
        processed_outputs: Dict[str, str] = {},
        selected_file: Optional[str] = None,
        sheet: Optional[str] = None,
        sheets: List[str] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["file_type"] = file_type

        super().__init__(
            node_type="csv_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file_type is not None:
            self.inputs["file_type"] = file_type
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if columns is not None:
            self.inputs["columns"] = columns
        if sheet is not None:
            self.inputs["sheet"] = sheet
        if sheets is not None:
            self.inputs["sheets"] = sheets

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CsvReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_writer")
class CsvWriterNode(Node):
    """
    Create a CSV from data

    ## Inputs
    ### Common Inputs
        load_option: Whether to load the CSV from a file or a string.
        selected_option: Whether to create a new CSV or update an existing one.
    ### When selected_option = 'new'
        columns: The columns to write to the CSV.
    ### When selected_option = 'old' and load_option = 'file'
        columns: The columns to write to the CSV.
        selected_file: The file to update.
    ### When selected_option = 'old' and load_option = 'text'
        csv_string: The CSV string to write.

    ## Outputs
    ### Common Outputs
        file: The CSV file created or updated.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "load_option",
            "helper_text": "Whether to load the CSV from a file or a string.",
            "value": "file",
            "type": "enum<string>",
        },
        {
            "field": "selected_option",
            "helper_text": "Whether to create a new CSV or update an existing one.",
            "value": "new",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "file", "helper_text": "The CSV file created or updated."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new**(*)": {
            "inputs": [
                {
                    "field": "columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The columns to write to the CSV.",
                    "table": {
                        "name": {"helper_text": "The name of the column"},
                        "value": {"helper_text": "The value of the column"},
                    },
                }
            ],
            "outputs": [],
        },
        "old**file": {
            "inputs": [
                {
                    "field": "selected_file",
                    "type": "file",
                    "helper_text": "The file to update.",
                },
                {
                    "field": "columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "helper_text": "The columns to write to the CSV.",
                    "table": {
                        "name": {"helper_text": "The name of the column"},
                        "value": {"helper_text": "The value of the column"},
                    },
                },
            ],
            "outputs": [],
        },
        "old**text": {
            "inputs": [
                {
                    "field": "csv_string",
                    "type": "string",
                    "value": "",
                    "helper_text": "The CSV string to write.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["selected_option", "load_option"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        selected_option: str = "new",
        load_option: str = "file",
        columns: List[Any] = [],
        csv_string: str = "",
        selected_file: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["selected_option"] = selected_option
        params["load_option"] = load_option

        super().__init__(
            node_type="csv_writer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected_option is not None:
            self.inputs["selected_option"] = selected_option
        if load_option is not None:
            self.inputs["load_option"] = load_option
        if columns is not None:
            self.inputs["columns"] = columns
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if csv_string is not None:
            self.inputs["csv_string"] = csv_string

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CsvWriterNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("create_list")
class CreateListNode(Node):
    """
    Create a list from input texts. Final list is ordered in the order of the inputs.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: Value to be added to the list

    ## Outputs
    ### <T>
        output: The created list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": ["", ""],
                    "helper_text": "Value to be added to the list",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The created list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[Any] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="create_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CreateListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("combine_list")
class CombineListNode(Node):
    """
    Combine multiple lists into one list. Final list is ordered in the order of the input lists.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: List to be combined

    ## Outputs
    ### <T>
        output: The combined list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<vec<<T>>>",
                    "value": ["", ""],
                    "helper_text": "List to be combined",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The combined list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[List[Any]] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="combine_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CombineListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_trimmer")
class ListTrimmerNode(Node):
    """
    Trim a list to just the sections you want. Enter enter the number of items or specify the section of the list that you want to keep.

    ## Inputs
    ### Common Inputs
        specify_section: Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items from the start.
        type: The type of the list
    ### When specify_section = True and type = '<T>'
        end_index: The ending index of the section to keep (exclusive).
        list: The list to trim
        start_index: The starting index of the section to keep (inclusive). The first item of the list is index 0.
    ### When specify_section = False and type = '<T>'
        item_to_keep: Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items.
        list: The list to trim

    ## Outputs
    ### When specify_section = False and type = '<T>'
        output: The trimmed list
    ### When specify_section = True and type = '<T>'
        output: The trimmed list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "specify_section",
            "helper_text": "Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items from the start.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**<T>": {
            "inputs": [
                {
                    "field": "item_to_keep",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Check this to specify a section of the list to keep. Leave unchecked to keep a specified number of items.",
                },
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to trim",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The trimmed list",
                }
            ],
        },
        "true**<T>": {
            "inputs": [
                {
                    "field": "start_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The starting index of the section to keep (inclusive). The first item of the list is index 0.",
                },
                {
                    "field": "end_index",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The ending index of the section to keep (exclusive).",
                },
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to trim",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The trimmed list",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["specify_section", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        specify_section: bool = False,
        type: str = "string",
        end_index: int = 1,
        item_to_keep: int = 0,
        list: List[Any] = [],
        start_index: int = 0,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["specify_section"] = specify_section
        params["type"] = type

        super().__init__(
            node_type="list_trimmer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if specify_section is not None:
            self.inputs["specify_section"] = specify_section
        if item_to_keep is not None:
            self.inputs["item_to_keep"] = item_to_keep
        if list is not None:
            self.inputs["list"] = list
        if start_index is not None:
            self.inputs["start_index"] = start_index
        if end_index is not None:
            self.inputs["end_index"] = end_index

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ListTrimmerNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("duplicate_list")
class DuplicateListNode(Node):
    """
    Create a new list by duplicating a single item with the size of the new list either matching the size of another list, or a specified size.

    ## Inputs
    ### Common Inputs
        specify_list_size: Check this box if you want to manually specify the list size. In this case 'Match List Size' will not be used.
        type: The type of the list
    ### When specify_list_size = True and type = '<T>'
        input_field: Item to duplicate
        list_size: The size of the new list
    ### When specify_list_size = False and type = '<T>'
        input_field: Item to duplicate
        list_size_to_match: The size of the list you want to match

    ## Outputs
    ### When specify_list_size = True and type = '<T>'
        output: The duplicated list
    ### When specify_list_size = False and type = '<T>'
        output: The duplicated list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "specify_list_size",
            "helper_text": "Check this box if you want to manually specify the list size. In this case 'Match List Size' will not be used.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**<T>": {
            "inputs": [
                {
                    "field": "list_size",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "The size of the new list",
                },
                {
                    "field": "input_field",
                    "type": "<T>",
                    "value": "",
                    "helper_text": "Item to duplicate",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The duplicated list",
                }
            ],
        },
        "false**<T>": {
            "inputs": [
                {
                    "field": "list_size_to_match",
                    "type": "vec<string>",
                    "value": "",
                    "helper_text": "The size of the list you want to match",
                },
                {
                    "field": "input_field",
                    "type": "<T>",
                    "value": "",
                    "helper_text": "Item to duplicate",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The duplicated list",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["specify_list_size", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        specify_list_size: bool = False,
        type: str = "string",
        list_size: int = 1,
        list_size_to_match: List[str] = [],
        input_field: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["specify_list_size"] = specify_list_size
        params["type"] = type

        super().__init__(
            node_type="duplicate_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if specify_list_size is not None:
            self.inputs["specify_list_size"] = specify_list_size
        if list_size is not None:
            self.inputs["list_size"] = list_size
        if input_field is not None:
            self.inputs["input_field"] = input_field
        if list_size_to_match is not None:
            self.inputs["list_size_to_match"] = list_size_to_match
        if input_field is not None:
            self.inputs["input_field"] = input_field

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "DuplicateListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("flatten_list")
class FlattenListNode(Node):
    """
    Flatten list of lists into a single list. For example, [[a, b], [c, d]] becomes [a,b,c,d].

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list_of_lists: List of lists to be flattened

    ## Outputs
    ### <T>
        flattened_list: The flattened list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list_of_lists",
                    "type": "vec<vec<<T>>>",
                    "value": "",
                    "helper_text": "List of lists to be flattened",
                }
            ],
            "outputs": [
                {
                    "field": "flattened_list",
                    "type": "vec<<T>>",
                    "helper_text": "The flattened list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list_of_lists: List[List[Any]] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="flatten_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list_of_lists is not None:
            self.inputs["list_of_lists"] = list_of_lists

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "FlattenListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("join_list_item")
class JoinListItemNode(Node):
    """
    Join a list of items into a single string. If join_by_newline is true, the items are joined by a newline character.

    ## Inputs
    ### Common Inputs
        join_by_newline: Separate each line in the final output with a new line
        type: The type of the list
    ### When join_by_newline = False
        join_characters: Use a specified character to join list items into a single string
    ### When type = '<T>'
        list: List of items to be joined

    ## Outputs
    ### Common Outputs
        joined_text: The joined string
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "join_by_newline",
            "helper_text": "Separate each line in the final output with a new line",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "joined_text", "helper_text": "The joined string"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "false**(*)": {
            "inputs": [
                {
                    "field": "join_characters",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use a specified character to join list items into a single string",
                }
            ],
            "outputs": [],
        },
        "(*)**<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "List of items to be joined",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["join_by_newline", "type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        join_by_newline: bool = False,
        type: str = "string",
        join_characters: str = "",
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["join_by_newline"] = join_by_newline
        params["type"] = type

        super().__init__(
            node_type="join_list_item",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if join_by_newline is not None:
            self.inputs["join_by_newline"] = join_by_newline
        if join_characters is not None:
            self.inputs["join_characters"] = join_characters
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "JoinListItemNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("csv_to_excel")
class CsvToExcelNode(Node):
    """
    Convert a CSV file into XLSX

    ## Inputs
    ### Common Inputs
        csv_file: The CSV file to convert.
        horizontal_alignment: The horizontal alignment of the text
        max_column_width: The maximum width of the columns
        vertical_alignment: The vertical alignment of the text
        wrap_text: Enable text wrapping

    ## Outputs
    ### Common Outputs
        xlsx_file: The Excel file created.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "csv_file",
            "helper_text": "The CSV file to convert.",
            "value": None,
            "type": "file",
        },
        {
            "field": "horizontal_alignment",
            "helper_text": "The horizontal alignment of the text",
            "value": "left",
            "type": "enum<string>",
        },
        {
            "field": "max_column_width",
            "helper_text": "The maximum width of the columns",
            "value": 100,
            "type": "int32",
        },
        {
            "field": "vertical_alignment",
            "helper_text": "The vertical alignment of the text",
            "value": "top",
            "type": "enum<string>",
        },
        {
            "field": "wrap_text",
            "helper_text": "Enable text wrapping",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "xlsx_file", "helper_text": "The Excel file created."}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        csv_file: Optional[str] = None,
        horizontal_alignment: str = "left",
        max_column_width: int = 100,
        vertical_alignment: str = "top",
        wrap_text: bool = True,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="csv_to_excel",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if csv_file is not None:
            self.inputs["csv_file"] = csv_file
        if wrap_text is not None:
            self.inputs["wrap_text"] = wrap_text
        if max_column_width is not None:
            self.inputs["max_column_width"] = max_column_width
        if horizontal_alignment is not None:
            self.inputs["horizontal_alignment"] = horizontal_alignment
        if vertical_alignment is not None:
            self.inputs["vertical_alignment"] = vertical_alignment

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CsvToExcelNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_formatter")
class TextFormatterNode(Node):
    """
    Format text based off a specified formatter

    ## Inputs
    ### Common Inputs
        formatter: The formatter to apply to the text
        text: The text to format
    ### Truncate
        max_num_token: The maximum number of tokens to truncate the text to

    ## Outputs
    ### Common Outputs
        output: The formatted text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "formatter",
            "helper_text": "The formatter to apply to the text",
            "value": "To Uppercase",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to format",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The formatted text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "Truncate": {
            "inputs": [
                {
                    "field": "max_num_token",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The maximum number of tokens to truncate the text to",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["formatter"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        formatter: str = "To Uppercase",
        max_num_token: int = 0,
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["formatter"] = formatter

        super().__init__(
            node_type="text_formatter",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if formatter is not None:
            self.inputs["formatter"] = formatter
        if max_num_token is not None:
            self.inputs["max_num_token"] = max_num_token

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TextFormatterNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("json_operations")
class JsonOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="json_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "JsonOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_operations")
class ListOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="list_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ListOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_gmail")
class IntegrationGmailNode(Node):
    """
    Gmail

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'send_email'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        subject: The subject of the email
    ### When action = 'send_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
    ### When action = 'create_draft'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        subject: The subject of the email
    ### When action = 'draft_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
    ### When action = 'reply_to_thread'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        thread_id: The ID of the thread to read
    ### When action = 'list_messages'
        bcc: Emails BCC'd to this address
        body: The body of the email
        category: Filter by tab (e.g. Primary, Social)
        cc: Emails CC'd to this address
        custom_params: Extra filters as raw query
        filename: Find attachments by name or type
        from: Emails sent by this address
        has: Filter by feature (e.g. attachment, drive)
        has_attachment: Only emails with attachments
        has_images: Emails containing images
        has_links: Emails containing links
        has_starred: Only starred emails
        has_unread: Only unread emails
        has_user_labels: Emails with custom labels
        in: Search within a folder (e.g. sent, spam)
        include_spam_trash: Include spam and trash emails
        is: Filter by status (e.g. read, unread, starred)
        label: Search emails with this label
        label_ids: Emails with all listed label IDs
        larger: Emails larger than this size (e.g. 5M)
        list: Emails from this mailing list
        msg_id: Search by message ID (ignores other filters)
        newer_than: Emails newer than a time (e.g. 7d, 2m)
        older_than: Emails older than a time (e.g. 7d, 2m)
        page_token: Use to fetch next page of results
        projection: Select which fields to return
        query: Raw query string to use directly. If provided, overrides all other query parameters.
        smaller: Emails smaller than this size (e.g. 5M)
        subject: The subject of the email
        to: Emails sent to this address
        use_date: Toggle to use dates
    ### When action = 'get_drafts'
        bcc: Emails BCC'd to this address
        body: The body of the email
        category: Filter by tab (e.g. Primary, Social)
        cc: Emails CC'd to this address
        detailed_view: Include full draft details in the response
        filename: Find attachments by name or type
        from: Emails sent by this address
        has: Filter by feature (e.g. attachment, drive)
        has_attachment: Only emails with attachments
        has_images: Emails containing images
        has_links: Emails containing links
        has_starred: Only starred emails
        has_unread: Only unread emails
        has_user_labels: Emails with custom labels
        in: Search within a folder (e.g. sent, spam)
        include_spam_trash: Include spam and trash emails
        is: Filter by status (e.g. read, unread, starred)
        label: Search emails with this label
        label_ids: Emails with all listed label IDs
        larger: Emails larger than this size (e.g. 5M)
        list: Emails from this mailing list
        newer_than: Emails newer than a time (e.g. 7d, 2m)
        older_than: Emails older than a time (e.g. 7d, 2m)
        page_token: Use to fetch next page of results
        query: Raw query string to use directly. If provided, overrides all other query parameters.
        smaller: Emails smaller than this size (e.g. 5M)
        subject: The subject of the email
        to: Emails sent to this address
        use_date: Toggle to use dates
    ### When action = 'get_threads'
        bcc: Emails BCC'd to this address
        body: The body of the email
        category: Filter by tab (e.g. Primary, Social)
        cc: Emails CC'd to this address
        filename: Find attachments by name or type
        from: Emails sent by this address
        has: Filter by feature (e.g. attachment, drive)
        has_attachment: Only emails with attachments
        has_chat: Only chat threads
        has_images: Emails containing images
        has_important: Only important threads
        has_links: Emails containing links
        has_starred: Only starred emails
        has_unread: Only unread emails
        has_user_labels: Emails with custom labels
        in: Search within a folder (e.g. sent, spam)
        include_spam_trash: Include spam and trash emails
        is: Filter by status (e.g. read, unread, starred)
        label: Search emails with this label
        label_ids: Emails with all listed label IDs
        larger: Emails larger than this size (e.g. 5M)
        list: Emails from this mailing list
        newer_than: Emails newer than a time (e.g. 7d, 2m)
        older_than: Emails older than a time (e.g. 7d, 2m)
        page_token: Use to fetch next page of results
        query: Raw query string to use directly. If provided, overrides all other query parameters.
        read_status: Filter by read status
        received_after: RFC3339 timestamp (e.g. 2023-01-01T00:00:00Z)
        received_before: RFC3339 timestamp (e.g. 2023-12-31T23:59:59Z)
        smaller: Emails smaller than this size (e.g. 5M)
        subject: The subject of the email
        to: Emails sent to this address
        use_date: Toggle to use dates
    ### When action = 'list_messages' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'get_drafts' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'get_threads' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'read_draft'
        draft_id: The ID of the draft to read
        format: Either html (to allow html content) or text (for plaintext content - default)
    ### When action = 'delete_draft'
        draft_id: The ID of the draft to read
    ### When action = 'trash_draft'
        draft_message_id: The ID of the draft message to trash
    ### When action = 'list_messages' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'get_drafts' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'get_threads' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'read_message'
        format: Either html (to allow html content) or text (for plaintext content - default)
        message_id: The ID of the message to read
    ### When action = 'read_thread'
        format: Either html (to allow html content) or text (for plaintext content - default)
        thread_id: The ID of the thread to read
    ### When action = 'read_label'
        label_id: The ID of the label to read
    ### When action = 'delete_label'
        label_id: The ID of the label to read
    ### When action = 'add_label_to_message'
        label_ids: Emails with all listed label IDs
        message_id: The ID of the message to read
    ### When action = 'remove_label_from_message'
        label_ids: Emails with all listed label IDs
        message_id: The ID of the message to read
    ### When action = 'add_label_to_thread'
        label_ids: Emails with all listed label IDs
        thread_id: The ID of the thread to read
    ### When action = 'remove_label_from_thread'
        label_ids: Emails with all listed label IDs
        thread_id: The ID of the thread to read
    ### When action = 'create_label'
        label_list_visibility: The visibility of the label in the label list
        message_list_visibility: The visibility of messages with this label
        name: The name of the label to create
    ### When action = 'mark_as_read'
        message_id: The ID of the message to read
    ### When action = 'mark_as_unread'
        message_id: The ID of the message to read
    ### When action = 'trash_message'
        message_id: The ID of the message to read
    ### When action = 'delete_message'
        message_id: The ID of the message to read
    ### When action = 'list_messages' and use_date = False
        num_messages: Specify the last n number of emails
    ### When action = 'get_drafts' and use_date = False
        num_messages: Specify the last n number of emails
    ### When action = 'get_threads' and use_date = False
        num_messages: Specify the last n number of emails
    ### When action = 'trash_thread'
        thread_id: The ID of the thread to read
    ### When action = 'delete_thread'
        thread_id: The ID of the thread to read
    ### When action = 'untrash_thread'
        thread_id: The ID of the thread to read
    ### When action = 'list_messages' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_drafts' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_threads' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_message'
        attachments: The attachments of the message
        body: The body of the message
        date: The date the message was sent
        from: The sender of the message
        has_attachments: Whether the message has attachments
        labels: The labels applied to the message
        message_id: The ID of the message
        raw_data: Raw data of the message
        snippet: A short snippet of the message
        subject: The subject of the message
        thread_id: The ID of the thread this message belongs to
        to: The recipients of the message
    ### When action = 'list_messages'
        attachments: The attachments of the retrieved emails
        email_bodies: The content of the retrieved emails
        email_dates: The sent dates of the retrieved emails
        email_display_names: The display names of the senders
        email_ids: The IDs of the retrieved emails
        email_subjects: The subjects of the retrieved emails
        raw_data: Raw data of the retrieved emails
        recipient_addresses: The email addresses of the recipients
        sender_addresses: The email addresses of the senders
    ### When action = 'read_draft'
        attachments: The attachments of the draft
        body: The body of the draft
        date: The date the draft was created
        draft_id: The ID of the draft
        from: The sender of the draft
        has_attachments: Whether the draft has attachments
        labels: The labels applied to the draft
        message_id: The ID of the draft message
        raw_data: Raw data of the draft
        snippet: A short snippet of the draft
        subject: The subject of the draft
        thread_id: The ID of the thread this draft belongs to
        to: The recipients of the draft
    ### When action = 'get_drafts'
        attachments: The attachments of the drafts
        draft_bodies: The bodies of the drafts
        draft_ids: The IDs of the drafts
        draft_message_ids: The IDs of the draft messages
        draft_recipients: The recipients of the drafts
        draft_subjects: The subjects of the drafts
        draft_thread_ids: The IDs of the draft threads
        raw_data: Raw data of the drafts
        total_results: Total number of drafts found
    ### When action = 'create_draft'
        draft_id: The ID of the created draft
        labels: The labels applied to the draft
        message_id: The ID of the created draft message
        raw_data: Raw data of the created draft
        thread_id: The ID of the thread this draft belongs to
    ### When action = 'draft_reply'
        draft_id: The ID of the created draft
        labels: The labels applied to the draft
        message_id: The ID of the created draft message
        raw_data: Raw data of the draft reply
        thread_id: The ID of the thread this draft belongs to
    ### When action = 'trash_draft'
        draft_message_id: The ID of the trashed draft message
        message: Success message
        raw_data: Raw data of the trashed draft
        success: Whether the trash operation was successful
    ### When action = 'read_thread'
        history_id: The history ID of the thread
        message_bodies: The bodies of messages in the thread
        message_count: Number of messages in the thread
        message_dates: The dates of messages in the thread
        message_senders: The senders of messages in the thread
        message_subjects: The subjects of messages in the thread
        messages: The messages in the thread
        raw_data: Raw data of the thread
        thread_id: The ID of the thread
    ### When action = 'create_label'
        label_id: The ID of the created label
        label_list_visibility: The visibility of the label in the label list
        label_name: The name of the created label
        label_type: The type of the label
        message: Success message
        message_list_visibility: The visibility of messages with this label
        raw_data: Raw data of the created label
        success: Whether the label was created successfully
    ### When action = 'read_label'
        label_id: The ID of the label
        label_list_visibility: The visibility of the label in the label list
        label_name: The name of the label
        label_type: The type of the label
        message_list_visibility: The visibility of messages with this label
        raw_data: Raw data of the label
    ### When action = 'get_labels'
        label_ids: The IDs of all labels
        label_names: The names of all labels
        label_types: The types of all labels
        raw_data: Raw data of the labels
        system_labels: System labels
        total_labels: Total number of labels
        user_labels: User-created labels
    ### When action = 'send_email'
        labels: The labels applied to the message
        message_id: The ID of the sent message
        raw_data: Raw data of the sent message
        thread_id: The ID of the thread this message belongs to
    ### When action = 'send_reply'
        labels: The labels applied to the message
        message_id: The ID of the sent reply
        raw_data: Raw data of the sent reply
        thread_id: The ID of the thread this message belongs to
    ### When action = 'mark_as_read'
        labels: The updated labels of the message
        message_id: The ID of the modified message
        raw_data: Raw data of the modified message
        success: Whether the operation was successful
    ### When action = 'mark_as_unread'
        labels: The updated labels of the message
        message_id: The ID of the modified message
        raw_data: Raw data of the modified message
        success: Whether the operation was successful
    ### When action = 'add_label_to_message'
        labels: The updated labels of the message
        message_id: The ID of the modified message
        raw_data: Raw data of the modified message
        success: Whether the operation was successful
    ### When action = 'remove_label_from_message'
        labels: The updated labels of the message
        message_id: The ID of the modified message
        raw_data: Raw data of the modified message
        success: Whether the operation was successful
    ### When action = 'reply_to_thread'
        labels: The labels applied to the reply
        message_id: The ID of the created reply message
        raw_data: Raw data of the reply
        thread_id: The ID of the thread this reply belongs to
    ### When action = 'trash_message'
        message: Success message
        message_id: The ID of the trashed message
        raw_data: Raw data of the trashed message
        success: Whether the trash operation was successful
    ### When action = 'delete_message'
        message: Success message
        raw_data: Raw data of the deleted message
        success: Whether the deletion was successful
    ### When action = 'delete_draft'
        message: Success message
        raw_data: Raw data of the deleted draft
        success: Whether the deletion was successful
    ### When action = 'delete_thread'
        message: Success message
        success: Whether the deletion was successful
    ### When action = 'delete_label'
        message: Success message
        success: Whether the deletion was successful
    ### When action = 'add_label_to_thread'
        raw_data: Raw data of the modified thread
        success: Whether the operation was successful
        thread_id: The ID of the modified thread
    ### When action = 'remove_label_from_thread'
        raw_data: Raw data of the modified thread
        success: Whether the operation was successful
        thread_id: The ID of the modified thread
    ### When action = 'get_threads'
        raw_data: Raw data of the threads
        thread_history_ids: History IDs of the threads
        thread_ids: The IDs of the threads
        thread_snippets: Snippets of the threads
        total_results: Total number of threads found
    ### When action = 'trash_thread'
        raw_data: Raw data of the modified thread
        success: Whether the operation was successful
        thread_id: The ID of the modified thread
    ### When action = 'untrash_thread'
        raw_data: Raw data of the modified thread
        success: Whether the operation was successful
        thread_id: The ID of the modified thread
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Gmail>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "send_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the sent message",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the thread this message belongs to",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The labels applied to the message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the sent message",
                },
            ],
            "name": "send_email",
            "task_name": "tasks.gmail.send_email",
            "description": "Create and send a new email",
            "label": "Send Email",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "subject",
                "body",
                "attachments",
            ],
        },
        "read_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the message to read",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "full",
                    "label": "Format",
                    "placeholder": "Full",
                    "helper_text": "The format to return the message in",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Full", "value": "full"},
                            {"label": "Minimal", "value": "minimal"},
                            {"label": "Raw", "value": "raw"},
                            {"label": "Metadata", "value": "metadata"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the message",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the thread this message belongs to",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "helper_text": "The subject of the message",
                },
                {
                    "field": "from",
                    "type": "string",
                    "helper_text": "The sender of the message",
                },
                {
                    "field": "to",
                    "type": "string",
                    "helper_text": "The recipients of the message",
                },
                {
                    "field": "date",
                    "type": "timestamp",
                    "helper_text": "The date the message was sent",
                },
                {
                    "field": "snippet",
                    "type": "string",
                    "helper_text": "A short snippet of the message",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The labels applied to the message",
                },
                {
                    "field": "has_attachments",
                    "type": "bool",
                    "helper_text": "Whether the message has attachments",
                },
                {
                    "field": "body",
                    "type": "string",
                    "helper_text": "The body of the message",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments of the message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the message",
                },
            ],
            "name": "read_message",
            "hidden": True,
            "task_name": "tasks.gmail.read_message",
            "description": "Read details of a specific message",
            "label": "Read Message",
            "inputs_sort_order": ["integration", "action", "message_id", "format"],
        },
        "send_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the sent reply",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the thread this message belongs to",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The labels applied to the message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the sent reply",
                },
            ],
            "name": "send_reply",
            "task_name": "tasks.gmail.send_reply",
            "description": "Create and send a new reply to an existing email",
            "label": "Send Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "body",
                "email_id",
                "attachments",
            ],
        },
        "list_messages**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Raw Query",
                    "placeholder": "from:john@company.com subject:urgent",
                    "helper_text": "Raw query string to use directly. If provided, overrides all other query parameters.",
                },
                {
                    "field": "from",
                    "type": "string",
                    "value": "",
                    "label": "From",
                    "placeholder": "john@company.com",
                    "helper_text": "Emails sent by this address",
                },
                {
                    "field": "to",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "alex@company.com",
                    "helper_text": "Emails sent to this address",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "urgent meeting",
                    "helper_text": "Search keywords in the subject",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "project update",
                    "helper_text": "Search text in the email body",
                },
                {
                    "field": "has_attachment",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only emails with attachments",
                    "label": "Has Attachment",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Attachments", "value": "True"},
                            {"label": "Emails Without Attachments", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_images",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails containing images",
                    "label": "Has Images",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Images", "value": "True"},
                            {"label": "Emails Without Images", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_links",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails containing links",
                    "label": "Has Links",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With Links", "value": "True"},
                            {"label": "Emails Without Links", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_starred",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only starred emails",
                    "label": "Has Starred",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Starred Emails", "value": "True"},
                            {"label": "Exclude Starred Emails", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_unread",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only unread emails",
                    "label": "Has Unread",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Unread Emails", "value": "True"},
                            {"label": "Exclude Unread Emails", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "label",
                    "type": "string",
                    "value": "",
                    "label": "Label",
                    "placeholder": "important",
                    "helper_text": "Search emails with this label",
                },
                {
                    "field": "in",
                    "type": "string",
                    "value": "",
                    "label": "Inside Folder",
                    "placeholder": "sent",
                    "helper_text": "Search within a folder (e.g. sent, spam)",
                },
                {
                    "field": "is",
                    "type": "string",
                    "value": "",
                    "label": "Is",
                    "placeholder": "unread",
                    "helper_text": "Filter by status (e.g. read, unread, starred)",
                },
                {
                    "field": "has",
                    "type": "string",
                    "value": "",
                    "label": "Has",
                    "placeholder": "attachment",
                    "helper_text": "Filter by feature (e.g. attachment, drive)",
                },
                {
                    "field": "filename",
                    "type": "string",
                    "value": "",
                    "label": "Filename",
                    "placeholder": "report.pdf",
                    "helper_text": "Find attachments by name or type",
                },
                {
                    "field": "newer_than",
                    "type": "string",
                    "value": "",
                    "label": "Newer Than",
                    "placeholder": "7d",
                    "helper_text": "Emails newer than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "older_than",
                    "type": "string",
                    "value": "",
                    "label": "Older Than",
                    "placeholder": "1m",
                    "helper_text": "Emails older than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "cc",
                    "type": "string",
                    "value": "",
                    "label": "CC",
                    "placeholder": "manager@company.com",
                    "helper_text": "Emails CC'd to this address",
                },
                {
                    "field": "bcc",
                    "type": "string",
                    "value": "",
                    "label": "BCC",
                    "placeholder": "admin@company.com",
                    "helper_text": "Emails BCC'd to this address",
                },
                {
                    "field": "list",
                    "type": "string",
                    "value": "",
                    "label": "List",
                    "placeholder": "newsletter@company.com",
                    "helper_text": "Emails from this mailing list",
                },
                {
                    "field": "category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "primary",
                    "helper_text": "Filter by tab (e.g. Primary, Social)",
                },
                {
                    "field": "larger",
                    "type": "string",
                    "value": "",
                    "label": "Larger",
                    "placeholder": "5M",
                    "helper_text": "Emails larger than this size (e.g. 5M)",
                },
                {
                    "field": "smaller",
                    "type": "string",
                    "value": "",
                    "label": "Smaller",
                    "placeholder": "1M",
                    "helper_text": "Emails smaller than this size (e.g. 5M)",
                },
                {
                    "field": "custom_params",
                    "type": "string",
                    "value": "",
                    "label": "Custom Parameters",
                    "placeholder": "has:nouserlabels",
                    "helper_text": "Extra filters as raw query",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "value": "",
                    "label": "Projection",
                    "placeholder": "id,threadId,snippet",
                    "helper_text": "Select which fields to return",
                },
                {
                    "field": "page_token",
                    "type": "string",
                    "value": "",
                    "label": "Page Token",
                    "placeholder": "abc123nextpage",
                    "helper_text": "Use to fetch next page of results",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "placeholder": "Label_1,Label_2",
                    "helper_text": "Emails with all listed label IDs",
                },
                {
                    "field": "has_user_labels",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Emails with custom labels",
                    "label": "Has User Labels",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Emails With User Labels", "value": "True"},
                            {"label": "Emails Without User Labels", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "include_spam_trash",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Include spam and trash emails",
                    "label": "Include Spam Trash",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Spam and Trash Emails", "value": "True"},
                            {
                                "label": "Exclude Spam and Trash Emails",
                                "value": "False",
                            },
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "msg_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "Search by message ID (ignores other filters)",
                },
            ],
            "outputs": [
                {
                    "field": "email_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the retrieved emails",
                },
                {
                    "field": "email_subjects",
                    "type": "vec<string>",
                    "helper_text": "The subjects of the retrieved emails",
                },
                {
                    "field": "email_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "The sent dates of the retrieved emails",
                },
                {
                    "field": "email_bodies",
                    "type": "vec<string>",
                    "helper_text": "The content of the retrieved emails",
                },
                {
                    "field": "sender_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the senders",
                },
                {
                    "field": "email_display_names",
                    "type": "vec<string>",
                    "helper_text": "The display names of the senders",
                },
                {
                    "field": "recipient_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the recipients",
                },
                {
                    "field": "attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "The attachments of the retrieved emails",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the retrieved emails",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "list_messages",
            "task_name": "tasks.gmail.list_messages",
            "description": "Get emails from Gmail",
            "label": "Get Emails",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
                "from",
                "to",
                "subject",
                "body",
                "has_attachment",
                "has_images",
                "has_links",
                "has_starred",
                "has_unread",
                "has_user_labels",
                "label",
                "in",
                "is",
                "has",
                "filename",
                "newer_than",
                "older_than",
                "cc",
                "bcc",
                "list",
                "category",
                "larger",
                "smaller",
                "custom_params",
                "projection",
                "page_token",
                "label_ids",
                "include_spam_trash",
                "msg_id",
            ],
        },
        "list_messages**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Emails",
                    "helper_text": "Specify the last n number of emails",
                }
            ],
            "outputs": [],
        },
        "list_messages**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "list_messages**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "label": "Date Range",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "list_messages**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "label": "Exact date",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "mark_as_read**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the message to mark as read",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the modified message",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The updated labels of the message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the modified message",
                },
            ],
            "name": "mark_as_read",
            "hidden": True,
            "task_name": "tasks.gmail.mark_as_read",
            "description": "Mark a message as read",
            "label": "Mark as Read",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "message_id"],
        },
        "mark_as_unread**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the message to mark as unread",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the modified message",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The updated labels of the message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the modified message",
                },
            ],
            "name": "mark_as_unread",
            "hidden": True,
            "task_name": "tasks.gmail.mark_as_unread",
            "description": "Mark a message as unread",
            "label": "Mark as Unread",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "message_id"],
        },
        "add_label_to_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the message to add labels to",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "placeholder": "Label_1,Label_2",
                    "helper_text": "Comma-separated list of label IDs to add",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the modified message",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The updated labels of the message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the modified message",
                },
            ],
            "name": "add_label_to_message",
            "hidden": True,
            "task_name": "tasks.gmail.add_label_to_message",
            "description": "Add labels to a message",
            "label": "Add Label to Message",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "message_id", "label_ids"],
        },
        "remove_label_from_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the message to remove labels from",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "placeholder": "Label_1,Label_2",
                    "helper_text": "Comma-separated list of label IDs to remove",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the modified message",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The updated labels of the message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the modified message",
                },
            ],
            "name": "remove_label_from_message",
            "hidden": True,
            "task_name": "tasks.gmail.remove_label_from_message",
            "description": "Remove labels from a message",
            "label": "Remove Label from Message",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "message_id", "label_ids"],
        },
        "trash_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the message to trash",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the trash operation was successful",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the trashed message",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the trashed message",
                },
            ],
            "name": "trash_message",
            "hidden": True,
            "task_name": "tasks.gmail.trash_message",
            "description": "Move a message to the trash",
            "label": "Trash Message",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "message_id"],
        },
        "delete_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the message to delete",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the deleted message",
                },
            ],
            "name": "delete_message",
            "hidden": True,
            "task_name": "tasks.gmail.delete_message",
            "description": "Permanently delete a message",
            "label": "Delete Message",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "message_id"],
            "banner_text": "This action will permanently delete the message and cannot be undone.",
        },
        "create_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients’ emails",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [
                {
                    "field": "draft_id",
                    "type": "string",
                    "helper_text": "The ID of the created draft",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the created draft message",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the thread this draft belongs to",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The labels applied to the draft",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the created draft",
                },
            ],
            "name": "create_draft",
            "task_name": "tasks.gmail.create_email_draft",
            "description": "Create (but do not send) a new email",
            "label": "Create Email Draft",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "subject",
                "body",
                "attachments",
            ],
        },
        "read_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "draft_id",
                    "type": "string",
                    "value": "",
                    "label": "Draft ID",
                    "placeholder": "r-123456789abcdef",
                    "helper_text": "The ID of the draft to read",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "full",
                    "label": "Format",
                    "placeholder": "Full",
                    "helper_text": "The format to return the draft in",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Full", "value": "full"},
                            {"label": "Minimal", "value": "minimal"},
                            {"label": "Raw", "value": "raw"},
                            {"label": "Metadata", "value": "metadata"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "draft_id",
                    "type": "string",
                    "helper_text": "The ID of the draft",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the draft message",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the thread this draft belongs to",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "helper_text": "The subject of the draft",
                },
                {
                    "field": "from",
                    "type": "string",
                    "helper_text": "The sender of the draft",
                },
                {
                    "field": "to",
                    "type": "string",
                    "helper_text": "The recipients of the draft",
                },
                {
                    "field": "date",
                    "type": "timestamp",
                    "helper_text": "The date the draft was created",
                },
                {
                    "field": "snippet",
                    "type": "string",
                    "helper_text": "A short snippet of the draft",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The labels applied to the draft",
                },
                {
                    "field": "has_attachments",
                    "type": "bool",
                    "helper_text": "Whether the draft has attachments",
                },
                {
                    "field": "body",
                    "type": "string",
                    "helper_text": "The body of the draft",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments of the draft",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the draft",
                },
            ],
            "name": "read_draft",
            "hidden": True,
            "task_name": "tasks.gmail.read_draft",
            "description": "Read details of a specific draft",
            "label": "Read Draft",
            "inputs_sort_order": ["integration", "action", "draft_id", "format"],
        },
        "draft_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "email_id",
                    "type": "string",
                    "value": "",
                    "label": "Email Id",
                    "placeholder": "r-123456789abcdef",
                    "helper_text": "The ID of the email (often used in conjunction with a trigger where the email ID is received from the trigger)",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [
                {
                    "field": "draft_id",
                    "type": "string",
                    "helper_text": "The ID of the created draft",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the created draft message",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the thread this draft belongs to",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The labels applied to the draft",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the draft reply",
                },
            ],
            "name": "draft_reply",
            "task_name": "tasks.gmail.draft_reply",
            "description": "Create (but do not send) a draft of a reply to an existing email",
            "label": "Draft Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "format",
                "recipients",
                "body",
                "email_id",
                "attachments",
            ],
        },
        "get_drafts**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Raw Query",
                    "placeholder": "from:john@company.com subject:urgent",
                    "helper_text": "Raw query string to use directly. If provided, overrides all other query parameters.",
                },
                {
                    "field": "from",
                    "type": "string",
                    "value": "",
                    "label": "From",
                    "placeholder": "john@company.com",
                    "helper_text": "Drafts created by this address",
                },
                {
                    "field": "to",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "alex@company.com",
                    "helper_text": "Drafts sent to this address",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "draft meeting",
                    "helper_text": "Search keywords in the subject",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "project update",
                    "helper_text": "Search text in the draft body",
                },
                {
                    "field": "has_attachment",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only drafts with attachments",
                    "label": "Has Attachment",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Drafts With Attachments", "value": "True"},
                            {"label": "Drafts Without Attachments", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_images",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Drafts containing images",
                    "label": "Has Images",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Drafts With Images", "value": "True"},
                            {"label": "Drafts Without Images", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_links",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Drafts containing links",
                    "label": "Has Links",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Drafts With Links", "value": "True"},
                            {"label": "Drafts Without Links", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_starred",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only starred drafts",
                    "label": "Has Starred",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Starred Drafts", "value": "True"},
                            {"label": "Exclude Starred Drafts", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_unread",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only unread drafts",
                    "label": "Has Unread",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Unread Drafts", "value": "True"},
                            {"label": "Exclude Unread Drafts", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "label",
                    "type": "string",
                    "value": "",
                    "label": "Label",
                    "placeholder": "important",
                    "helper_text": "Search drafts with this label",
                },
                {
                    "field": "in",
                    "type": "string",
                    "value": "",
                    "label": "Inside Folder",
                    "placeholder": "drafts",
                    "helper_text": "Search within a folder (e.g. drafts, spam)",
                },
                {
                    "field": "is",
                    "type": "string",
                    "value": "",
                    "label": "Is",
                    "placeholder": "unread",
                    "helper_text": "Filter by status (e.g. read, unread, starred)",
                },
                {
                    "field": "has",
                    "type": "string",
                    "value": "",
                    "label": "Has",
                    "placeholder": "attachment",
                    "helper_text": "Filter by feature (e.g. attachment, drive)",
                },
                {
                    "field": "filename",
                    "type": "string",
                    "value": "",
                    "label": "Filename",
                    "placeholder": "report.pdf",
                    "helper_text": "Find attachments by name or type",
                },
                {
                    "field": "newer_than",
                    "type": "string",
                    "value": "",
                    "label": "Newer Than",
                    "placeholder": "7d",
                    "helper_text": "Drafts newer than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "older_than",
                    "type": "string",
                    "value": "",
                    "label": "Older Than",
                    "placeholder": "1m",
                    "helper_text": "Drafts older than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "cc",
                    "type": "string",
                    "value": "",
                    "label": "CC",
                    "placeholder": "manager@company.com",
                    "helper_text": "Drafts CC'd to this address",
                },
                {
                    "field": "bcc",
                    "type": "string",
                    "value": "",
                    "label": "BCC",
                    "placeholder": "admin@company.com",
                    "helper_text": "Drafts BCC'd to this address",
                },
                {
                    "field": "list",
                    "type": "string",
                    "value": "",
                    "label": "List",
                    "placeholder": "newsletter@company.com",
                    "helper_text": "Drafts from this mailing list",
                },
                {
                    "field": "category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "primary",
                    "helper_text": "Filter by tab (e.g. Primary, Social)",
                },
                {
                    "field": "larger",
                    "type": "string",
                    "value": "",
                    "label": "Larger",
                    "placeholder": "5M",
                    "helper_text": "Drafts larger than this size (e.g. 5M)",
                },
                {
                    "field": "smaller",
                    "type": "string",
                    "value": "",
                    "label": "Smaller",
                    "placeholder": "1M",
                    "helper_text": "Drafts smaller than this size (e.g. 5M)",
                },
                {
                    "field": "detailed_view",
                    "type": "bool",
                    "value": False,
                    "label": "Detailed View",
                    "placeholder": "false",
                    "helper_text": "Include full draft details in the response",
                },
                {
                    "field": "page_token",
                    "type": "string",
                    "value": "",
                    "label": "Page Token",
                    "placeholder": "abc123nextpage",
                    "helper_text": "Use to fetch next page of results",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "placeholder": "Label_1,Label_2",
                    "helper_text": "Drafts with all listed label IDs",
                },
                {
                    "field": "has_user_labels",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Drafts with custom labels",
                    "label": "Has User Labels",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Drafts With User Labels", "value": "True"},
                            {"label": "Drafts Without User Labels", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "include_spam_trash",
                    "type": "bool",
                    "value": False,
                    "label": "Include Spam/Trash",
                    "helper_text": "Include drafts in spam and trash",
                },
            ],
            "outputs": [
                {
                    "field": "draft_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the drafts",
                },
                {
                    "field": "draft_message_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the draft messages",
                },
                {
                    "field": "draft_thread_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the draft threads",
                },
                {
                    "field": "draft_subjects",
                    "type": "vec<string>",
                    "helper_text": "The subjects of the drafts",
                },
                {
                    "field": "draft_bodies",
                    "type": "vec<string>",
                    "helper_text": "The bodies of the drafts",
                },
                {
                    "field": "draft_recipients",
                    "type": "vec<string>",
                    "helper_text": "The recipients of the drafts",
                },
                {
                    "field": "attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "The attachments of the drafts",
                },
                {
                    "field": "total_results",
                    "type": "int32",
                    "helper_text": "Total number of drafts found",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the drafts",
                },
            ],
            "name": "get_drafts",
            "hidden": True,
            "task_name": "tasks.gmail.get_drafts",
            "description": "Get email drafts from Gmail",
            "label": "Get Drafts",
            "variant": "get_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
                "from",
                "to",
                "subject",
                "body",
                "has_attachment",
                "has_images",
                "has_links",
                "has_starred",
                "has_unread",
                "has_user_labels",
                "label",
                "in",
                "is",
                "has",
                "filename",
                "newer_than",
                "older_than",
                "cc",
                "bcc",
                "list",
                "category",
                "larger",
                "smaller",
                "detailed_view",
                "page_token",
                "label_ids",
                "include_spam_trash",
            ],
        },
        "get_drafts**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Drafts",
                    "helper_text": "Specify the number of drafts to fetch",
                }
            ],
            "outputs": [],
        },
        "get_drafts**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_drafts**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_drafts**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "trash_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "draft_message_id",
                    "type": "string",
                    "value": "",
                    "label": "Draft Message ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the draft message to trash",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the trash operation was successful",
                },
                {
                    "field": "draft_message_id",
                    "type": "string",
                    "helper_text": "The ID of the trashed draft message",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the trashed draft",
                },
            ],
            "name": "trash_draft",
            "hidden": True,
            "task_name": "tasks.gmail.trash_draft",
            "description": "Move a draft to the trash",
            "label": "Trash Draft",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "draft_message_id"],
        },
        "delete_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "draft_id",
                    "type": "string",
                    "value": "",
                    "label": "Draft ID",
                    "placeholder": "r-123456789abcdef",
                    "helper_text": "The ID of the draft to delete",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the deleted draft",
                },
            ],
            "name": "delete_draft",
            "hidden": True,
            "task_name": "tasks.gmail.delete_draft",
            "description": "Permanently delete a draft",
            "label": "Delete Draft",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "draft_id"],
            "banner_text": "This action will permanently delete the draft and cannot be undone.",
        },
        "read_thread**(*)**(*)": {
            "inputs": [
                {
                    "field": "thread_id",
                    "type": "string",
                    "value": "",
                    "label": "Thread ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the thread to read",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "full",
                    "label": "Format",
                    "placeholder": "full",
                    "helper_text": "The format to return the thread in",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Full", "value": "full"},
                            {"label": "Minimal", "value": "minimal"},
                            {"label": "Metadata", "value": "metadata"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the thread",
                },
                {
                    "field": "history_id",
                    "type": "string",
                    "helper_text": "The history ID of the thread",
                },
                {
                    "field": "messages",
                    "type": "vec<string>",
                    "helper_text": "The messages in the thread",
                },
                {
                    "field": "message_subjects",
                    "type": "vec<string>",
                    "helper_text": "The subjects of messages in the thread",
                },
                {
                    "field": "message_senders",
                    "type": "vec<string>",
                    "helper_text": "The senders of messages in the thread",
                },
                {
                    "field": "message_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "The dates of messages in the thread",
                },
                {
                    "field": "message_bodies",
                    "type": "vec<string>",
                    "helper_text": "The bodies of messages in the thread",
                },
                {
                    "field": "message_count",
                    "type": "int32",
                    "helper_text": "Number of messages in the thread",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the thread",
                },
            ],
            "name": "read_thread",
            "hidden": True,
            "task_name": "tasks.gmail.read_thread",
            "description": "Read details of a specific thread",
            "label": "Read Thread",
            "inputs_sort_order": ["integration", "action", "thread_id", "format"],
        },
        "add_label_to_thread**(*)**(*)": {
            "inputs": [
                {
                    "field": "thread_id",
                    "type": "string",
                    "value": "",
                    "label": "Thread ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the thread to add labels to",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "placeholder": "Label_1,Label_2",
                    "helper_text": "Comma-separated list of label IDs to add",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the modified thread",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the modified thread",
                },
            ],
            "name": "add_label_to_thread",
            "hidden": True,
            "task_name": "tasks.gmail.add_label_to_thread",
            "description": "Add labels to a thread",
            "label": "Add Label to Thread",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "thread_id", "label_ids"],
        },
        "remove_label_from_thread**(*)**(*)": {
            "inputs": [
                {
                    "field": "thread_id",
                    "type": "string",
                    "value": "",
                    "label": "Thread ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the thread to remove labels from",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "placeholder": "Label_1,Label_2",
                    "helper_text": "Comma-separated list of label IDs to remove",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the modified thread",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the modified thread",
                },
            ],
            "name": "remove_label_from_thread",
            "hidden": True,
            "task_name": "tasks.gmail.remove_label_from_thread",
            "description": "Remove labels from a thread",
            "label": "Remove Label from Thread",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "thread_id", "label_ids"],
        },
        "reply_to_thread**(*)**(*)": {
            "inputs": [
                {
                    "field": "thread_id",
                    "type": "string",
                    "value": "",
                    "label": "Thread ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the thread to reply to",
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the reply",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the created reply message",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the thread this reply belongs to",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "The labels applied to the reply",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the reply",
                },
            ],
            "name": "reply_to_thread",
            "hidden": True,
            "task_name": "tasks.gmail.reply_to_thread",
            "description": "Reply to a thread",
            "label": "Reply to Thread",
            "inputs_sort_order": [
                "integration",
                "action",
                "thread_id",
                "format",
                "recipients",
                "body",
                "attachments",
            ],
        },
        "get_threads**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Raw Query",
                    "placeholder": "from:john@company.com subject:urgent",
                    "helper_text": "Raw query string to use directly. If provided, overrides all other query parameters.",
                },
                {
                    "field": "from",
                    "type": "string",
                    "value": "",
                    "label": "From",
                    "placeholder": "john@company.com",
                    "helper_text": "Threads with emails from this address",
                },
                {
                    "field": "to",
                    "type": "string",
                    "value": "",
                    "label": "To",
                    "placeholder": "alex@company.com",
                    "helper_text": "Threads with emails to this address",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "urgent meeting",
                    "helper_text": "Search keywords in the subject",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "project update",
                    "helper_text": "Search text in the thread body",
                },
                {
                    "field": "has_attachment",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only threads with attachments",
                    "label": "Has Attachment",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Threads With Attachments", "value": "True"},
                            {"label": "Threads Without Attachments", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_images",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Threads containing images",
                    "label": "Has Images",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Threads With Images", "value": "True"},
                            {"label": "Threads Without Images", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_links",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Threads containing links",
                    "label": "Has Links",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Threads With Links", "value": "True"},
                            {"label": "Threads Without Links", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_starred",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only starred threads",
                    "label": "Has Starred",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Starred Threads", "value": "True"},
                            {"label": "Exclude Starred Threads", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_unread",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only unread threads",
                    "label": "Has Unread",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Unread Threads", "value": "True"},
                            {"label": "Exclude Unread Threads", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_important",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only important threads",
                    "label": "Has Important",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Important Threads", "value": "True"},
                            {"label": "Exclude Important Threads", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "has_chat",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Only chat threads",
                    "label": "Has Chat",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Include Chat Threads", "value": "True"},
                            {"label": "Exclude Chat Threads", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "label",
                    "type": "string",
                    "value": "",
                    "label": "Label",
                    "placeholder": "important",
                    "helper_text": "Search threads with this label",
                },
                {
                    "field": "in",
                    "type": "string",
                    "value": "",
                    "label": "Inside Folder",
                    "placeholder": "sent",
                    "helper_text": "Search within a folder (e.g. sent, spam)",
                },
                {
                    "field": "is",
                    "type": "string",
                    "value": "",
                    "label": "Is",
                    "placeholder": "unread",
                    "helper_text": "Filter by status (e.g. read, unread, starred)",
                },
                {
                    "field": "has",
                    "type": "string",
                    "value": "",
                    "label": "Has",
                    "placeholder": "attachment",
                    "helper_text": "Filter by feature (e.g. attachment, drive)",
                },
                {
                    "field": "filename",
                    "type": "string",
                    "value": "",
                    "label": "Filename",
                    "placeholder": "report.pdf",
                    "helper_text": "Find attachments by name or type",
                },
                {
                    "field": "newer_than",
                    "type": "string",
                    "value": "",
                    "label": "Newer Than",
                    "placeholder": "7d",
                    "helper_text": "Threads newer than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "older_than",
                    "type": "string",
                    "value": "",
                    "label": "Older Than",
                    "placeholder": "1m",
                    "helper_text": "Threads older than a time (e.g. 7d, 2m)",
                },
                {
                    "field": "cc",
                    "type": "string",
                    "value": "",
                    "label": "CC",
                    "placeholder": "manager@company.com",
                    "helper_text": "Threads with emails CC'd to this address",
                },
                {
                    "field": "bcc",
                    "type": "string",
                    "value": "",
                    "label": "BCC",
                    "placeholder": "admin@company.com",
                    "helper_text": "Threads with emails BCC'd to this address",
                },
                {
                    "field": "list",
                    "type": "string",
                    "value": "",
                    "label": "List",
                    "placeholder": "newsletter@company.com",
                    "helper_text": "Threads from this mailing list",
                },
                {
                    "field": "category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "primary",
                    "helper_text": "Filter by tab (e.g. Primary, Social)",
                },
                {
                    "field": "larger",
                    "type": "string",
                    "value": "",
                    "label": "Larger",
                    "placeholder": "5M",
                    "helper_text": "Threads larger than this size (e.g. 5M)",
                },
                {
                    "field": "smaller",
                    "type": "string",
                    "value": "",
                    "label": "Smaller",
                    "placeholder": "1M",
                    "helper_text": "Threads smaller than this size (e.g. 5M)",
                },
                {
                    "field": "read_status",
                    "type": "string",
                    "value": "all",
                    "hidden": True,
                    "helper_text": "Filter by read status",
                    "label": "Read Status",
                    "placeholder": "All",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "All", "value": "all"},
                            {"label": "Unread", "value": "unread"},
                            {"label": "Read", "value": "read"},
                        ],
                    },
                },
                {
                    "field": "received_after",
                    "type": "timestamp",
                    "value": "",
                    "hidden": True,
                    "label": "Received After",
                    "placeholder": "2023-01-01T00:00:00Z",
                    "helper_text": "RFC3339 timestamp (e.g. 2023-01-01T00:00:00Z)",
                },
                {
                    "field": "received_before",
                    "type": "timestamp",
                    "value": "",
                    "hidden": True,
                    "label": "Received Before",
                    "placeholder": "2023-12-31T23:59:59Z",
                    "helper_text": "RFC3339 timestamp (e.g. 2023-12-31T23:59:59Z)",
                },
                {
                    "field": "page_token",
                    "type": "string",
                    "value": "",
                    "label": "Page Token",
                    "placeholder": "abc123nextpage",
                    "helper_text": "Use to fetch next page of results",
                },
                {
                    "field": "label_ids",
                    "type": "string",
                    "value": "",
                    "label": "Label IDs",
                    "placeholder": "Label_1,Label_2",
                    "helper_text": "Filter by label IDs (comma-separated)",
                },
                {
                    "field": "has_user_labels",
                    "type": "string",
                    "value": "Ignore",
                    "hidden": True,
                    "helper_text": "Threads with custom labels",
                    "label": "Has User Labels",
                    "placeholder": "Ignore",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Threads With User Labels", "value": "True"},
                            {"label": "Threads Without User Labels", "value": "False"},
                            {"label": "Ignore", "value": "Ignore"},
                        ],
                    },
                },
                {
                    "field": "include_spam_trash",
                    "type": "bool",
                    "value": False,
                    "label": "Include Spam/Trash",
                    "helper_text": "Include threads in spam and trash",
                },
            ],
            "outputs": [
                {
                    "field": "thread_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the threads",
                },
                {
                    "field": "thread_snippets",
                    "type": "vec<string>",
                    "helper_text": "Snippets of the threads",
                },
                {
                    "field": "thread_history_ids",
                    "type": "vec<string>",
                    "helper_text": "History IDs of the threads",
                },
                {
                    "field": "total_results",
                    "type": "int32",
                    "helper_text": "Total number of threads found",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the threads",
                },
            ],
            "name": "get_threads",
            "hidden": True,
            "task_name": "tasks.gmail.get_threads",
            "description": "Get email threads from Gmail",
            "label": "Get Threads",
            "variant": "get_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
                "from",
                "to",
                "subject",
                "body",
                "has_attachment",
                "has_images",
                "has_links",
                "has_starred",
                "has_unread",
                "has_user_labels",
                "has_important",
                "has_chat",
                "label",
                "in",
                "is",
                "has",
                "filename",
                "newer_than",
                "older_than",
                "cc",
                "bcc",
                "list",
                "category",
                "larger",
                "smaller",
                "read_status",
                "received_after",
                "received_before",
                "page_token",
                "label_ids",
                "include_spam_trash",
            ],
        },
        "get_threads**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Threads",
                    "helper_text": "Specify the number of threads to fetch",
                }
            ],
            "outputs": [],
        },
        "get_threads**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_threads**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_threads**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "trash_thread**(*)**(*)": {
            "inputs": [
                {
                    "field": "thread_id",
                    "type": "string",
                    "value": "",
                    "label": "Thread ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the thread to move to trash",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the modified thread",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the modified thread",
                },
            ],
            "name": "trash_thread",
            "hidden": True,
            "task_name": "tasks.gmail.trash_thread",
            "description": "Move a thread to trash",
            "label": "Trash Thread",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "thread_id"],
        },
        "delete_thread**(*)**(*)": {
            "inputs": [
                {
                    "field": "thread_id",
                    "type": "string",
                    "value": "",
                    "label": "Thread ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the thread to delete",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
            ],
            "name": "delete_thread",
            "hidden": True,
            "task_name": "tasks.gmail.delete_thread",
            "description": "Permanently delete a thread",
            "label": "Delete Thread",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "thread_id"],
            "banner_text": "This action will permanently delete the thread and cannot be undone.",
        },
        "untrash_thread**(*)**(*)": {
            "inputs": [
                {
                    "field": "thread_id",
                    "type": "string",
                    "value": "",
                    "label": "Thread ID",
                    "placeholder": "123456789abcdef",
                    "helper_text": "The ID of the thread to remove from trash",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "thread_id",
                    "type": "string",
                    "helper_text": "The ID of the modified thread",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the modified thread",
                },
            ],
            "name": "untrash_thread",
            "hidden": True,
            "task_name": "tasks.gmail.untrash_thread",
            "description": "Remove a thread from trash",
            "label": "Untrash Thread",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "thread_id"],
        },
        "create_label**(*)**(*)": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Label Name",
                    "placeholder": "My Custom Label",
                    "helper_text": "The name of the label to create",
                },
                {
                    "field": "label_list_visibility",
                    "type": "string",
                    "value": "",
                    "label": "Label List Visibility",
                    "placeholder": "labelShow",
                    "helper_text": "The visibility of the label in the label list",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Show", "value": "labelShow"},
                            {"label": "Show If Unread", "value": "labelShowIfUnread"},
                            {"label": "Hide", "value": "labelHide"},
                        ],
                    },
                },
                {
                    "field": "message_list_visibility",
                    "type": "string",
                    "value": "show",
                    "label": "Message List Visibility",
                    "placeholder": "show",
                    "helper_text": "The visibility of messages with this label",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Show", "value": "show"},
                            {"label": "Hide", "value": "hide"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the label was created successfully",
                },
                {
                    "field": "label_id",
                    "type": "string",
                    "helper_text": "The ID of the created label",
                },
                {
                    "field": "label_name",
                    "type": "string",
                    "helper_text": "The name of the created label",
                },
                {
                    "field": "label_type",
                    "type": "string",
                    "helper_text": "The type of the label",
                },
                {
                    "field": "message_list_visibility",
                    "type": "string",
                    "helper_text": "The visibility of messages with this label",
                },
                {
                    "field": "label_list_visibility",
                    "type": "string",
                    "helper_text": "The visibility of the label in the label list",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the created label",
                },
            ],
            "name": "create_label",
            "hidden": True,
            "task_name": "tasks.gmail.create_label",
            "description": "Create a new label",
            "label": "Create Label",
            "inputs_sort_order": [
                "integration",
                "action",
                "name",
                "label_list_visibility",
                "message_list_visibility",
            ],
        },
        "read_label**(*)**(*)": {
            "inputs": [
                {
                    "field": "label_id",
                    "type": "string",
                    "value": "",
                    "label": "Label ID",
                    "placeholder": "Label_123456789",
                    "helper_text": "The ID of the label to read",
                }
            ],
            "outputs": [
                {
                    "field": "label_id",
                    "type": "string",
                    "helper_text": "The ID of the label",
                },
                {
                    "field": "label_name",
                    "type": "string",
                    "helper_text": "The name of the label",
                },
                {
                    "field": "label_type",
                    "type": "string",
                    "helper_text": "The type of the label",
                },
                {
                    "field": "message_list_visibility",
                    "type": "string",
                    "helper_text": "The visibility of messages with this label",
                },
                {
                    "field": "label_list_visibility",
                    "type": "string",
                    "helper_text": "The visibility of the label in the label list",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the label",
                },
            ],
            "name": "read_label",
            "hidden": True,
            "task_name": "tasks.gmail.read_label",
            "description": "Read details of a specific label",
            "label": "Read Label",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "label_id"],
        },
        "get_labels**(*)**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "label_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of all labels",
                },
                {
                    "field": "label_names",
                    "type": "vec<string>",
                    "helper_text": "The names of all labels",
                },
                {
                    "field": "label_types",
                    "type": "vec<string>",
                    "helper_text": "The types of all labels",
                },
                {
                    "field": "system_labels",
                    "type": "vec<string>",
                    "helper_text": "System labels",
                },
                {
                    "field": "user_labels",
                    "type": "vec<string>",
                    "helper_text": "User-created labels",
                },
                {
                    "field": "total_labels",
                    "type": "int32",
                    "helper_text": "Total number of labels",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the labels",
                },
            ],
            "name": "get_labels",
            "hidden": True,
            "task_name": "tasks.gmail.get_labels",
            "description": "Get all labels",
            "label": "Get Labels",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action"],
        },
        "delete_label**(*)**(*)": {
            "inputs": [
                {
                    "field": "label_id",
                    "type": "string",
                    "value": "",
                    "label": "Label ID",
                    "placeholder": "Label_123456789",
                    "helper_text": "The ID of the label to delete",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
            ],
            "name": "delete_label",
            "hidden": True,
            "task_name": "tasks.gmail.delete_label",
            "description": "Delete a label",
            "label": "Delete Label",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "label_id"],
            "banner_text": "This action will permanently delete the label and cannot be undone.",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        attachments: List[str] = [],
        bcc: str = "",
        body: str = "",
        category: str = "",
        cc: str = "",
        custom_params: str = "",
        detailed_view: bool = False,
        draft_id: str = "",
        draft_message_id: str = "",
        email_id: str = "",
        exact_date: Any = {"start": "", "end": ""},
        filename: str = "",
        format: str = "text",
        from_: str = "",
        has: str = "",
        has_attachment: str = "Ignore",
        has_chat: str = "Ignore",
        has_images: str = "Ignore",
        has_important: str = "Ignore",
        has_links: str = "Ignore",
        has_starred: str = "Ignore",
        has_unread: str = "Ignore",
        has_user_labels: str = "Ignore",
        in_: str = "",
        include_spam_trash: str = "Ignore",
        is_: str = "",
        label: str = "",
        label_id: str = "",
        label_ids: str = "",
        label_list_visibility: str = "",
        larger: str = "",
        list: str = "",
        message_id: str = "",
        message_list_visibility: str = "show",
        msg_id: str = "",
        name: str = "",
        newer_than: str = "",
        num_messages: int = 10,
        older_than: str = "",
        page_token: str = "",
        projection: str = "",
        query: str = "",
        read_status: str = "all",
        received_after: Any = None,
        received_before: Any = None,
        recipients: str = "",
        smaller: str = "",
        subject: str = "",
        thread_id: str = "",
        to: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_gmail",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if format is not None:
            self.inputs["format"] = format
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if message_id is not None:
            self.inputs["message_id"] = message_id
        if email_id is not None:
            self.inputs["email_id"] = email_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if query is not None:
            self.inputs["query"] = query
        if from_ is not None:
            self.inputs["from"] = from_
        if to is not None:
            self.inputs["to"] = to
        if has_attachment is not None:
            self.inputs["has_attachment"] = has_attachment
        if has_images is not None:
            self.inputs["has_images"] = has_images
        if has_links is not None:
            self.inputs["has_links"] = has_links
        if has_starred is not None:
            self.inputs["has_starred"] = has_starred
        if has_unread is not None:
            self.inputs["has_unread"] = has_unread
        if label is not None:
            self.inputs["label"] = label
        if in_ is not None:
            self.inputs["in"] = in_
        if is_ is not None:
            self.inputs["is"] = is_
        if has is not None:
            self.inputs["has"] = has
        if filename is not None:
            self.inputs["filename"] = filename
        if newer_than is not None:
            self.inputs["newer_than"] = newer_than
        if older_than is not None:
            self.inputs["older_than"] = older_than
        if cc is not None:
            self.inputs["cc"] = cc
        if bcc is not None:
            self.inputs["bcc"] = bcc
        if list is not None:
            self.inputs["list"] = list
        if category is not None:
            self.inputs["category"] = category
        if larger is not None:
            self.inputs["larger"] = larger
        if smaller is not None:
            self.inputs["smaller"] = smaller
        if custom_params is not None:
            self.inputs["custom_params"] = custom_params
        if projection is not None:
            self.inputs["projection"] = projection
        if page_token is not None:
            self.inputs["page_token"] = page_token
        if label_ids is not None:
            self.inputs["label_ids"] = label_ids
        if has_user_labels is not None:
            self.inputs["has_user_labels"] = has_user_labels
        if include_spam_trash is not None:
            self.inputs["include_spam_trash"] = include_spam_trash
        if msg_id is not None:
            self.inputs["msg_id"] = msg_id
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if draft_id is not None:
            self.inputs["draft_id"] = draft_id
        if detailed_view is not None:
            self.inputs["detailed_view"] = detailed_view
        if draft_message_id is not None:
            self.inputs["draft_message_id"] = draft_message_id
        if thread_id is not None:
            self.inputs["thread_id"] = thread_id
        if has_important is not None:
            self.inputs["has_important"] = has_important
        if has_chat is not None:
            self.inputs["has_chat"] = has_chat
        if read_status is not None:
            self.inputs["read_status"] = read_status
        if received_after is not None:
            self.inputs["received_after"] = received_after
        if received_before is not None:
            self.inputs["received_before"] = received_before
        if name is not None:
            self.inputs["name"] = name
        if label_list_visibility is not None:
            self.inputs["label_list_visibility"] = label_list_visibility
        if message_list_visibility is not None:
            self.inputs["message_list_visibility"] = message_list_visibility
        if label_id is not None:
            self.inputs["label_id"] = label_id
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if from_ is not None:
            self.inputs["from"] = from_
        if in_ is not None:
            self.inputs["in"] = in_
        if integration is not None:
            self.inputs["integration"] = integration
        if is_ is not None:
            self.inputs["is"] = is_

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGmailNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_copper")
class IntegrationCopperNode(Node):
    """
    Copper

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_lead
        email: The email of the lead
        name: The name of the lead

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Copper>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_lead": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "John Smith",
                    "helper_text": "The name of the lead",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@company.com",
                    "helper_text": "The email of the lead",
                },
            ],
            "outputs": [],
            "name": "create_lead",
            "task_name": "tasks.copper.create_lead",
            "description": "Create a new lead",
            "label": "Create Lead",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        email: str = "",
        name: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_copper",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if name is not None:
            self.inputs["name"] = name
        if email is not None:
            self.inputs["email"] = email
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationCopperNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_discord")
class IntegrationDiscordNode(Node):
    """
    Discord

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_message
        channel_name: The name of the Discord channel
        message: The message you want to send

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Discord>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "send_message": {
            "inputs": [
                {
                    "field": "channel_name",
                    "type": "string",
                    "value": "",
                    "label": "Channel Name",
                    "placeholder": "General",
                    "helper_text": "The name of the Discord channel",
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message you want to send",
                },
            ],
            "outputs": [],
            "name": "send_message",
            "task_name": "tasks.discord.send_message",
            "description": "Send a message to a specific channel",
            "label": "Send Message",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        channel_name: str = "",
        message: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_discord",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if channel_name is not None:
            self.inputs["channel_name"] = channel_name
        if message is not None:
            self.inputs["message"] = message
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDiscordNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_telegram")
class IntegrationTelegramNode(Node):
    """
    Telegram

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_animation
        animation: Animation to send (file_id, HTTP URL, or file path)
        caption: Animation caption (0-1024 characters, optional)
        chat_id: ID of the chat to get information about
        parse_mode: Mode for parsing entities in the message text
    ### send_audio
        audio: Audio file to send (file_id, HTTP URL, or file path)
        caption: Animation caption (0-1024 characters, optional)
        chat_id: ID of the chat to get information about
        duration: Duration of the audio in seconds (optional)
        performer: Performer of the audio (optional)
        title: New title for the chat (1-255 characters)
    ### send_document
        caption: Animation caption (0-1024 characters, optional)
        chat_id: ID of the chat to get information about
        document: Document to send (file_id, HTTP URL, or file path)
        parse_mode: Mode for parsing entities in the message text
    ### send_photo
        caption: Animation caption (0-1024 characters, optional)
        chat_id: ID of the chat to get information about
        parse_mode: Mode for parsing entities in the message text
        photo: Photo to send (file_id, HTTP URL, or file path)
    ### send_video
        caption: Animation caption (0-1024 characters, optional)
        chat_id: ID of the chat to get information about
        duration: Duration of the audio in seconds (optional)
        height: Video height (optional)
        video: Video to send (file_id, HTTP URL, or file path)
        width: Video width (optional)
    ### get_chat
        chat_id: ID of the chat to get information about
    ### get_updates
        chat_id: ID of the chat to get information about
        limit: Number of updates to retrieve (1-100, default: 10)
        offset: Offset for pagination (default: 0)
    ### list_administrators
        chat_id: ID of the chat to get information about
    ### get_member
        chat_id: ID of the chat to get information about
        user_id: ID of the user to get member details for
    ### leave_chat
        chat_id: ID of the chat to get information about
    ### update_description
        chat_id: ID of the chat to get information about
        description: New description for the chat (0-255 characters)
    ### update_title
        chat_id: ID of the chat to get information about
        title: New title for the chat (1-255 characters)
    ### delete_message
        chat_id: ID of the chat to get information about
        message_id: ID of the message to delete
    ### edit_message_text
        chat_id: ID of the chat to get information about
        message_id: ID of the message to delete
        parse_mode: Mode for parsing entities in the message text
        text: New text of the message (1-4096 characters)
    ### pin_message
        chat_id: ID of the chat to get information about
        disable_notification: Pass true if it is not necessary to send a notification to all chat members about the new pinned message
        message_id: ID of the message to delete
    ### send_location
        chat_id: ID of the chat to get information about
        heading: Direction in which the user is moving (1-360 degrees, optional)
        latitude: Latitude of the location
        live_period: Period in seconds for which the location will be updated (60-86400, optional)
        longitude: Longitude of the location
    ### send_media_group
        chat_id: ID of the chat to get information about
        media: JSON array of InputMedia objects (2-10 items). Send with type(type of media) and value(url) keys.
    ### send_message
        chat_id: ID of the chat to get information about
        disable_notification: Pass true if it is not necessary to send a notification to all chat members about the new pinned message
        disable_web_page_preview: Disables link previews for links in this message
        parse_mode: Mode for parsing entities in the message text
        text: New text of the message (1-4096 characters)
    ### send_sticker
        chat_id: ID of the chat to get information about
        sticker: Sticker to send (file_id, HTTP URL, or file path)
    ### unpin_message
        chat_id: ID of the chat to get information about
        message_id: ID of the message to delete
    ### get_file
        telegram_file_id: File identifier to get info about

    ## Outputs
    ### get_chat
        accent_color_id: Accent color ID
        active_usernames: Array of active usernames in JSON format
        can_send_gift: Whether the user can send gifts (for private chats)
        chat_description: Description of the chat
        chat_id: ID of the chat
        chat_title: Title of the chat
        chat_type: Type of the chat (private, group, supergroup, channel)
        first_name: First name of the user (for private chats)
        last_name: Last name of the user (for private chats)
        max_reaction_count: Maximum number of reactions allowed
        raw_data: Raw API response data
        username: Username of the user (for private chats)
    ### list_administrators
        admin_count: Number of administrators
        admin_ids: Array of administrator user IDs in JSON format
        admin_names: Array of administrator names in JSON format
        admin_statuses: Array of administrator statuses in JSON format
        admin_usernames: Array of administrator usernames in JSON format
        administrators: List of chat administrators in JSON format
        raw_data: Raw API response data
    ### get_file
        file: The actual file content downloaded from Telegram
        file_id: Identifier for this file
        file_path: File path on Telegram servers
        file_size: File size, if known
        file_unique_id: Unique identifier for this file
        file_url: Direct download URL for the file
        raw_data: Raw API response data
    ### get_updates
        message_count: Number of messages retrieved
        message_dates: Array of message timestamps in JSON format
        message_ids: Array of message IDs in JSON format
        message_texts: Array of message texts in JSON format
        messages: Array of messages in JSON format
        raw_data: Raw API response data
        sender_names: Array of sender names in JSON format
        sender_usernames: Array of sender usernames in JSON format
        updates: Array of updates in JSON format
    ### edit_message_text
        message_id: ID of the edited message
        raw_data: Raw API response data
        success: Whether the message was edited successfully
    ### send_animation
        message_id: ID of the sent message
        raw_data: Raw API response data
        success: Whether the animation was sent successfully
    ### send_audio
        message_id: ID of the sent message
        raw_data: Raw API response data
        success: Whether the audio was sent successfully
    ### send_document
        message_id: ID of the sent message
        raw_data: Raw API response data
        success: Whether the document was sent successfully
    ### send_location
        message_id: ID of the sent message
        raw_data: Raw API response data
        success: Whether the location was sent successfully
    ### send_message
        message_id: ID of the sent message
        message_text: Text of the sent message
        raw_data: Raw API response data
        success: Whether the message was sent successfully
    ### send_photo
        message_id: ID of the sent message
        raw_data: Raw API response data
        success: Whether the photo was sent successfully
    ### send_sticker
        message_id: ID of the sent message
        raw_data: Raw API response data
        success: Whether the sticker was sent successfully
    ### send_video
        message_id: ID of the sent message
        raw_data: Raw API response data
        success: Whether the video was sent successfully
    ### send_media_group
        message_ids: Array of message IDs in JSON format
        raw_data: Raw API response data
        success: Whether the media group was sent successfully
    ### get_member
        raw_data: Raw API response data
        status: Member status (creator, administrator, member, restricted, left, kicked)
        user_id: ID of the user
        user_name: Name of the user
        user_username: Username of the user
    ### leave_chat
        raw_data: Raw API response data
        success: Whether the bot left the chat successfully
    ### update_description
        raw_data: Raw API response data
        success: Whether the description was updated successfully
    ### update_title
        raw_data: Raw API response data
        success: Whether the title was updated successfully
    ### delete_message
        raw_data: Raw API response data
        success: Whether the message was deleted successfully
    ### pin_message
        raw_data: Raw API response data
        success: Whether the message was pinned successfully
    ### unpin_message
        raw_data: Raw API response data
        success: Whether the message was unpinned successfully
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Telegram>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "get_chat": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to get information about",
                }
            ],
            "outputs": [
                {"field": "chat_id", "type": "string", "helper_text": "ID of the chat"},
                {
                    "field": "chat_title",
                    "type": "string",
                    "helper_text": "Title of the chat",
                },
                {
                    "field": "chat_type",
                    "type": "string",
                    "helper_text": "Type of the chat (private, group, supergroup, channel)",
                },
                {
                    "field": "chat_description",
                    "type": "string",
                    "helper_text": "Description of the chat",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "First name of the user (for private chats)",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "Last name of the user (for private chats)",
                },
                {
                    "field": "username",
                    "type": "string",
                    "helper_text": "Username of the user (for private chats)",
                },
                {
                    "field": "can_send_gift",
                    "type": "bool",
                    "helper_text": "Whether the user can send gifts (for private chats)",
                },
                {
                    "field": "active_usernames",
                    "type": "string",
                    "helper_text": "Array of active usernames in JSON format",
                },
                {
                    "field": "max_reaction_count",
                    "type": "int32",
                    "helper_text": "Maximum number of reactions allowed",
                },
                {
                    "field": "accent_color_id",
                    "type": "int32",
                    "helper_text": "Accent color ID",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_chat",
            "task_name": "tasks.telegram.get_chat",
            "description": "Get up-to-date information about a chat",
            "label": "Get Chat",
            "variant": "common_integration_nodes",
            "required": ["chat_id"],
        },
        "get_updates": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to filter updates from (optional)",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Number of updates to retrieve (1-100, default: 10)",
                },
                {
                    "field": "offset",
                    "type": "int32",
                    "value": 0,
                    "label": "Offset",
                    "helper_text": "Offset for pagination (default: 0)",
                },
            ],
            "outputs": [
                {
                    "field": "updates",
                    "type": "string",
                    "helper_text": "Array of updates in JSON format",
                },
                {
                    "field": "messages",
                    "type": "string",
                    "helper_text": "Array of messages in JSON format",
                },
                {
                    "field": "message_count",
                    "type": "int32",
                    "helper_text": "Number of messages retrieved",
                },
                {
                    "field": "message_ids",
                    "type": "string",
                    "helper_text": "Array of message IDs in JSON format",
                },
                {
                    "field": "message_texts",
                    "type": "string",
                    "helper_text": "Array of message texts in JSON format",
                },
                {
                    "field": "sender_names",
                    "type": "string",
                    "helper_text": "Array of sender names in JSON format",
                },
                {
                    "field": "sender_usernames",
                    "type": "string",
                    "helper_text": "Array of sender usernames in JSON format",
                },
                {
                    "field": "message_dates",
                    "type": "string",
                    "helper_text": "Array of message timestamps in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_updates",
            "task_name": "tasks.telegram.get_updates",
            "description": "Get updates from Telegram bot",
            "label": "Get Updates",
            "variant": "common_integration_nodes",
            "required": [],
        },
        "list_administrators": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to list administrators from",
                }
            ],
            "outputs": [
                {
                    "field": "administrators",
                    "type": "string",
                    "helper_text": "List of chat administrators in JSON format",
                },
                {
                    "field": "admin_count",
                    "type": "int32",
                    "helper_text": "Number of administrators",
                },
                {
                    "field": "admin_ids",
                    "type": "string",
                    "helper_text": "Array of administrator user IDs in JSON format",
                },
                {
                    "field": "admin_names",
                    "type": "string",
                    "helper_text": "Array of administrator names in JSON format",
                },
                {
                    "field": "admin_usernames",
                    "type": "string",
                    "helper_text": "Array of administrator usernames in JSON format",
                },
                {
                    "field": "admin_statuses",
                    "type": "string",
                    "helper_text": "Array of administrator statuses in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "list_administrators",
            "task_name": "tasks.telegram.list_administrators",
            "description": "List all administrators in a chat",
            "label": "List Administrators",
            "variant": "common_integration_nodes",
            "required": ["chat_id"],
        },
        "get_member": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "label": "User ID",
                    "placeholder": "123456789",
                    "helper_text": "ID of the user to get member details for",
                },
            ],
            "outputs": [
                {"field": "user_id", "type": "string", "helper_text": "ID of the user"},
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Name of the user",
                },
                {
                    "field": "user_username",
                    "type": "string",
                    "helper_text": "Username of the user",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Member status (creator, administrator, member, restricted, left, kicked)",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_member",
            "task_name": "tasks.telegram.get_member",
            "description": "Get the details of a chat member",
            "label": "Get Member",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "user_id"],
        },
        "leave_chat": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to leave",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the bot left the chat successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "leave_chat",
            "task_name": "tasks.telegram.leave_chat",
            "description": "Leave a chat",
            "label": "Leave Chat",
            "variant": "common_integration_nodes",
            "required": ["chat_id"],
        },
        "update_description": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to update description for",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "New chat description",
                    "helper_text": "New description for the chat (0-255 characters)",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the description was updated successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "update_description",
            "task_name": "tasks.telegram.update_description",
            "description": "Update description of a chat",
            "label": "Update Description",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "description"],
        },
        "update_title": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to update title for",
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "New chat title",
                    "helper_text": "New title for the chat (1-255 characters)",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the title was updated successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "update_title",
            "task_name": "tasks.telegram.update_title",
            "description": "Update title of a chat",
            "label": "Update Title",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "title"],
        },
        "get_file": {
            "inputs": [
                {
                    "field": "telegram_file_id",
                    "type": "string",
                    "value": "",
                    "label": "Telegram File ID",
                    "placeholder": "BAADBAADrwADBREAAYdaWKoKI4kCAg",
                    "helper_text": "File identifier to get info about",
                }
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "Identifier for this file",
                },
                {
                    "field": "file_unique_id",
                    "type": "string",
                    "helper_text": "Unique identifier for this file",
                },
                {
                    "field": "file_size",
                    "type": "int32",
                    "helper_text": "File size, if known",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "File path on Telegram servers",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "Direct download URL for the file",
                },
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The actual file content downloaded from Telegram",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_file",
            "task_name": "tasks.telegram.get_file",
            "description": "Get file from Telegram",
            "label": "Get File",
            "variant": "common_integration_nodes",
            "required": ["file_id"],
        },
        "delete_message": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat containing the message",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123",
                    "helper_text": "ID of the message to delete",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was deleted successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "delete_message",
            "task_name": "tasks.telegram.delete_message",
            "description": "Delete chat message",
            "label": "Delete Message",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "message_id"],
        },
        "edit_message_text": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat containing the message",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123",
                    "helper_text": "ID of the message to edit",
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "New Text",
                    "placeholder": "Updated message text",
                    "helper_text": "New text of the message (1-4096 characters)",
                },
                {
                    "field": "parse_mode",
                    "type": "string",
                    "value": "",
                    "label": "Parse Mode",
                    "helper_text": "Mode for parsing entities in the message text",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Markdown", "value": "Markdown"},
                            {"label": "MarkdownV2", "value": "MarkdownV2"},
                            {"label": "HTML", "value": "HTML"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the edited message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was edited successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "edit_message_text",
            "task_name": "tasks.telegram.edit_message_text",
            "description": "Edit the text of an existing message",
            "label": "Edit Message Text",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "message_id", "text"],
        },
        "pin_message": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat containing the message",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123",
                    "helper_text": "ID of the message to pin",
                },
                {
                    "field": "disable_notification",
                    "type": "bool",
                    "value": False,
                    "label": "Disable Notification",
                    "helper_text": "Pass true if it is not necessary to send a notification to all chat members about the new pinned message",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was pinned successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "pin_message",
            "task_name": "tasks.telegram.pin_message",
            "description": "Pin message in the chat",
            "label": "Pin Message",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "message_id"],
        },
        "send_animation": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send animation to",
                },
                {
                    "field": "animation",
                    "type": "string",
                    "value": "",
                    "label": "Animation",
                    "placeholder": "https://example.com/animation.gif",
                    "helper_text": "Animation to send (file_id, HTTP URL, or file path)",
                },
                {
                    "field": "caption",
                    "type": "string",
                    "value": "",
                    "label": "Caption",
                    "placeholder": "Animation caption",
                    "helper_text": "Animation caption (0-1024 characters, optional)",
                },
                {
                    "field": "parse_mode",
                    "type": "string",
                    "value": "",
                    "label": "Parse Mode",
                    "helper_text": "Mode for parsing entities in the caption",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Markdown", "value": "Markdown"},
                            {"label": "MarkdownV2", "value": "MarkdownV2"},
                            {"label": "HTML", "value": "HTML"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the sent message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the animation was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_animation",
            "task_name": "tasks.telegram.send_animation",
            "description": "Send animation to the chat",
            "label": "Send Animation",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "animation"],
        },
        "send_audio": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send audio to",
                },
                {
                    "field": "audio",
                    "type": "string",
                    "value": "",
                    "label": "Audio",
                    "placeholder": "https://example.com/audio.mp3",
                    "helper_text": "Audio file to send (file_id, HTTP URL, or file path)",
                },
                {
                    "field": "caption",
                    "type": "string",
                    "value": "",
                    "label": "Caption",
                    "placeholder": "Audio caption",
                    "helper_text": "Audio caption (0-1024 characters, optional)",
                },
                {
                    "field": "duration",
                    "type": "int32",
                    "value": 0,
                    "label": "Duration",
                    "helper_text": "Duration of the audio in seconds (optional)",
                },
                {
                    "field": "performer",
                    "type": "string",
                    "value": "",
                    "label": "Performer",
                    "placeholder": "Artist name",
                    "helper_text": "Performer of the audio (optional)",
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Track title",
                    "helper_text": "Track name of the audio (optional)",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the sent message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the audio was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_audio",
            "task_name": "tasks.telegram.send_audio",
            "description": "Send audio file to the chat and display it in the music player",
            "label": "Send Audio",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "audio"],
        },
        "send_document": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send document to",
                },
                {
                    "field": "document",
                    "type": "string",
                    "value": "",
                    "label": "Document",
                    "placeholder": "https://example.com/document.pdf",
                    "helper_text": "Document to send (file_id, HTTP URL, or file path)",
                },
                {
                    "field": "caption",
                    "type": "string",
                    "value": "",
                    "label": "Caption",
                    "placeholder": "Document caption",
                    "helper_text": "Document caption (0-1024 characters, optional)",
                },
                {
                    "field": "parse_mode",
                    "type": "string",
                    "value": "",
                    "label": "Parse Mode",
                    "helper_text": "Mode for parsing entities in the caption",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Markdown", "value": "Markdown"},
                            {"label": "MarkdownV2", "value": "MarkdownV2"},
                            {"label": "HTML", "value": "HTML"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the sent message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the document was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_document",
            "task_name": "tasks.telegram.send_document",
            "description": "Send document to the chat",
            "label": "Send Document",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "document"],
        },
        "send_location": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send location to",
                },
                {
                    "field": "latitude",
                    "type": "string",
                    "value": "",
                    "label": "Latitude",
                    "placeholder": "40.7128",
                    "helper_text": "Latitude of the location",
                },
                {
                    "field": "longitude",
                    "type": "string",
                    "value": "",
                    "label": "Longitude",
                    "placeholder": "-74.0060",
                    "helper_text": "Longitude of the location",
                },
                {
                    "field": "live_period",
                    "type": "int32",
                    "value": 0,
                    "label": "Live Period",
                    "helper_text": "Period in seconds for which the location will be updated (60-86400, optional)",
                },
                {
                    "field": "heading",
                    "type": "int32",
                    "value": 0,
                    "label": "Heading",
                    "helper_text": "Direction in which the user is moving (1-360 degrees, optional)",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the sent message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the location was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_location",
            "task_name": "tasks.telegram.send_location",
            "description": "Send a geolocation to the chat",
            "label": "Send Location",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "latitude", "longitude"],
        },
        "send_media_group": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send media group to",
                },
                {
                    "field": "media",
                    "type": "string",
                    "value": "[]",
                    "label": "Media",
                    "placeholder": '[{"type":"photo","media":"https://example.com/photo.jpg"}]',
                    "helper_text": "JSON array of InputMedia objects (2-10 items). Send with type(type of media) and value(url) keys.",
                },
            ],
            "outputs": [
                {
                    "field": "message_ids",
                    "type": "string",
                    "helper_text": "Array of message IDs in JSON format",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the media group was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_media_group",
            "task_name": "tasks.telegram.send_media_group",
            "description": "Send a group of photos and/or videos",
            "label": "Send Media Group",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "media"],
        },
        "send_message": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send message to",
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "Text of the message to be sent (1-4096 characters)",
                },
                {
                    "field": "parse_mode",
                    "type": "string",
                    "value": "",
                    "label": "Parse Mode",
                    "helper_text": "Mode for parsing entities in the message text",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Markdown", "value": "Markdown"},
                            {"label": "MarkdownV2", "value": "MarkdownV2"},
                            {"label": "HTML", "value": "HTML"},
                        ],
                    },
                },
                {
                    "field": "disable_web_page_preview",
                    "type": "bool",
                    "value": False,
                    "label": "Disable Web Page Preview",
                    "helper_text": "Disables link previews for links in this message",
                },
                {
                    "field": "disable_notification",
                    "type": "bool",
                    "value": False,
                    "label": "Disable Notification",
                    "helper_text": "Sends the message silently",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the sent message",
                },
                {
                    "field": "message_text",
                    "type": "string",
                    "helper_text": "Text of the sent message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_message",
            "task_name": "tasks.telegram.send_message",
            "description": "Send message to the chat",
            "label": "Send Message",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "text"],
        },
        "send_photo": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send photo to",
                },
                {
                    "field": "photo",
                    "type": "string",
                    "value": "",
                    "label": "Photo",
                    "placeholder": "https://example.com/photo.jpg",
                    "helper_text": "Photo to send (file_id, HTTP URL, or file path)",
                },
                {
                    "field": "caption",
                    "type": "string",
                    "value": "",
                    "label": "Caption",
                    "placeholder": "Photo caption",
                    "helper_text": "Photo caption (0-1024 characters, optional)",
                },
                {
                    "field": "parse_mode",
                    "type": "string",
                    "value": "",
                    "label": "Parse Mode",
                    "helper_text": "Mode for parsing entities in the caption",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Markdown", "value": "Markdown"},
                            {"label": "MarkdownV2", "value": "MarkdownV2"},
                            {"label": "HTML", "value": "HTML"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the sent message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the photo was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_photo",
            "task_name": "tasks.telegram.send_photo",
            "description": "Send photo to the chat",
            "label": "Send Photo",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "photo"],
        },
        "send_sticker": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send sticker to",
                },
                {
                    "field": "sticker",
                    "type": "string",
                    "value": "",
                    "label": "Sticker",
                    "placeholder": "CAACAgIAAxkBAAICGmG...",
                    "helper_text": "Sticker to send (file_id, HTTP URL, or file path)",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the sent message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the sticker was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_sticker",
            "task_name": "tasks.telegram.send_sticker",
            "description": "Send sticker to the chat",
            "label": "Send Sticker",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "sticker"],
        },
        "send_video": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat to send video to",
                },
                {
                    "field": "video",
                    "type": "string",
                    "value": "",
                    "label": "Video",
                    "placeholder": "https://example.com/video.mp4",
                    "helper_text": "Video to send (file_id, HTTP URL, or file path)",
                },
                {
                    "field": "caption",
                    "type": "string",
                    "value": "",
                    "label": "Caption",
                    "placeholder": "Video caption",
                    "helper_text": "Video caption (0-1024 characters, optional)",
                },
                {
                    "field": "duration",
                    "type": "int32",
                    "value": 0,
                    "label": "Duration",
                    "helper_text": "Duration of the video in seconds (optional)",
                },
                {
                    "field": "width",
                    "type": "int32",
                    "value": 0,
                    "label": "Width",
                    "helper_text": "Video width (optional)",
                },
                {
                    "field": "height",
                    "type": "int32",
                    "value": 0,
                    "label": "Height",
                    "helper_text": "Video height (optional)",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the sent message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the video was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_video",
            "task_name": "tasks.telegram.send_video",
            "description": "Send video to the chat",
            "label": "Send Video",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "video"],
        },
        "unpin_message": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "-1001234567890",
                    "helper_text": "ID of the chat containing the message",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "123",
                    "helper_text": "ID of the message to unpin (optional, if not specified, the most recent pinned message will be unpinned)",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was unpinned successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "unpin_message",
            "task_name": "tasks.telegram.unpin_message",
            "description": "Unpin message from the chat",
            "label": "Unpin Message",
            "variant": "common_integration_nodes",
            "required": ["chat_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        animation: str = "",
        audio: str = "",
        caption: str = "",
        chat_id: str = "",
        description: str = "",
        disable_notification: bool = False,
        disable_web_page_preview: bool = False,
        document: str = "",
        duration: int = 0,
        heading: int = 0,
        height: int = 0,
        latitude: str = "",
        limit: int = 10,
        live_period: int = 0,
        longitude: str = "",
        media: str = "[]",
        message_id: str = "",
        offset: int = 0,
        parse_mode: str = "",
        performer: str = "",
        photo: str = "",
        sticker: str = "",
        telegram_file_id: str = "",
        text: str = "",
        title: str = "",
        user_id: str = "",
        video: str = "",
        width: int = 0,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_telegram",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if chat_id is not None:
            self.inputs["chat_id"] = chat_id
        if limit is not None:
            self.inputs["limit"] = limit
        if offset is not None:
            self.inputs["offset"] = offset
        if user_id is not None:
            self.inputs["user_id"] = user_id
        if description is not None:
            self.inputs["description"] = description
        if title is not None:
            self.inputs["title"] = title
        if telegram_file_id is not None:
            self.inputs["telegram_file_id"] = telegram_file_id
        if message_id is not None:
            self.inputs["message_id"] = message_id
        if text is not None:
            self.inputs["text"] = text
        if parse_mode is not None:
            self.inputs["parse_mode"] = parse_mode
        if disable_notification is not None:
            self.inputs["disable_notification"] = disable_notification
        if animation is not None:
            self.inputs["animation"] = animation
        if caption is not None:
            self.inputs["caption"] = caption
        if audio is not None:
            self.inputs["audio"] = audio
        if duration is not None:
            self.inputs["duration"] = duration
        if performer is not None:
            self.inputs["performer"] = performer
        if document is not None:
            self.inputs["document"] = document
        if latitude is not None:
            self.inputs["latitude"] = latitude
        if longitude is not None:
            self.inputs["longitude"] = longitude
        if live_period is not None:
            self.inputs["live_period"] = live_period
        if heading is not None:
            self.inputs["heading"] = heading
        if media is not None:
            self.inputs["media"] = media
        if disable_web_page_preview is not None:
            self.inputs["disable_web_page_preview"] = disable_web_page_preview
        if photo is not None:
            self.inputs["photo"] = photo
        if sticker is not None:
            self.inputs["sticker"] = sticker
        if video is not None:
            self.inputs["video"] = video
        if width is not None:
            self.inputs["width"] = width
        if height is not None:
            self.inputs["height"] = height
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationTelegramNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_linear")
class IntegrationLinearNode(Node):
    """
    Linear

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'create_issue'
        assignee_id: Assign the issue to a user
        description: The description of the ticket
        priority: Issue priority
        state_id: Set the workflow state
        team_id: The team within Linear
        title: The title of the issue
    ### When action = 'update_issue'
        assignee_id: Assign the issue to a user
        description: The description of the ticket
        issue_id: The ID of the issue to update
        priority: Issue priority
        state_id: Set the workflow state
        team_id: The team within Linear
        title: The title of the issue
        update_team_id: Move to a different team
    ### When action = 'list_issues'
        assignee_id: Assign the issue to a user
        priority: Issue priority
        return_all: Return all matching issues regardless of count
        state_id: Set the workflow state
        team_id: The team within Linear
        use_date: Toggle to use dates
    ### When action = 'create_comment'
        comment: The comment text
        issue_id: The ID of the issue to update
        parent_id: ID of parent comment for replies (optional)
        team_id: The team within Linear
    ### When action = 'list_issues' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'list_issues' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'delete_issue'
        issue_id: The ID of the issue to update
        team_id: The team within Linear
    ### When action = 'get_issue'
        issue_id: The ID of the issue to update
        team_id: The team within Linear
    ### When action = 'add_link'
        issue_id: The ID of the issue to update
        link: The URL to attach to the issue
        team_id: The team within Linear
    ### When action = 'list_issues' and use_date = False
        num_messages: Specify the number of issues to fetch
    ### When action = 'list_issues' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'create_issue'
        assignee_email: Email of the assigned user
        assignee_name: Name of the assigned user
        created_at: When the issue was created
        description: Description of the created issue
        issue_id: Unique identifier of the created issue
        issue_identifier: Human-readable identifier (e.g., ABC-123)
        priority: Priority level of the issue
        raw_data: Raw API response data
        state: Current workflow state of the issue
        team_key: Key/abbreviation of the team
        team_name: Name of the team the issue belongs to
        title: Title of the created issue
    ### When action = 'update_issue'
        assignee_email: Email of the assigned user
        assignee_name: Name of the assigned user
        description: Updated description of the issue
        issue_id: Unique identifier of the updated issue
        issue_identifier: Human-readable identifier (e.g., ABC-123)
        priority: Updated priority level of the issue
        raw_data: Raw API response data
        state: Current workflow state of the issue
        team_key: Key/abbreviation of the team
        team_name: Name of the team the issue belongs to
        title: Updated title of the issue
        updated_at: When the issue was last updated
    ### When action = 'get_issue'
        assignee_email: Email of the assigned user
        assignee_id: ID of the assigned user
        assignee_name: Name of the assigned user
        comment_count: Number of comments on the issue
        comments: Comments on the issue
        created_at: When the issue was created
        creator_email: Email of the user who created the issue
        creator_id: ID of the user who created the issue
        creator_name: Name of the user who created the issue
        description: Description of the issue
        due_date: Due date of the issue
        issue_id: Unique identifier of the issue
        issue_identifier: Human-readable identifier (e.g., ABC-123)
        priority: Priority level of the issue
        project_id: ID of the project the issue belongs to
        project_name: Name of the project the issue belongs to
        raw_data: Raw API response data
        state: Current workflow state of the issue
        state_type: Type of the workflow state
        team_id: ID of the team the issue belongs to
        team_key: Key/abbreviation of the team
        team_name: Name of the team the issue belongs to
        title: Title of the issue
        updated_at: When the issue was last updated
    ### When action = 'list_issues'
        assignee_emails: List of assigned user emails
        assignee_ids: List of assigned user IDs
        assignee_names: List of assigned user names
        created_at: List of creation timestamps for all issues
        creator_emails: List of issue creator emails
        creator_ids: List of issue creator IDs
        creator_names: List of issue creator names
        descriptions: List of issue descriptions
        due_dates: List of due dates for all issues
        issue_count: Total number of issues returned
        issue_identifiers: List of human-readable identifiers (e.g., ABC-123)
        issue_identifiers_str: List of issue identifiers as strings
        issue_ids: List of unique identifiers for all issues
        issue_titles: List of issue titles (duplicate of titles)
        priorities: List of priority levels for all issues
        project_ids: List of project IDs for all issues
        project_names: List of project names for all issues
        raw_data: Raw API response data
        state_types: List of workflow state types
        states: List of workflow states for all issues
        team_ids: List of team IDs for all issues
        team_keys: List of team keys/abbreviations
        team_names: List of team names for all issues
        titles: List of issue titles
        updated_at: List of last update timestamps for all issues
    ### When action = 'add_link'
        attachment_id: ID of the added attachment
        issue_id: ID of the issue the link was added to
        link: URL of the added link
        raw_data: Raw API response data
        success: Whether the link was successfully added
        title: Title of the added attachment
    ### When action = 'create_comment'
        comment_body: Content of the created comment
        comment_id: Unique identifier of the created comment
        created_at: When the comment was created
        raw_data: Raw API response data
        user_email: Email of the user who created the comment
        user_name: Name of the user who created the comment
    ### When action = 'delete_issue'
        issue_id: ID of the deleted issue
        raw_data: Raw API response data
        success: Whether the issue was successfully deleted
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Linear>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "label": "Select Team",
                    "helper_text": "The team within Linear",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Bug on submit button",
                    "helper_text": "The title of the issue",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Clicking on submit button leads to wrong page",
                    "helper_text": "The description of the ticket",
                },
                {
                    "field": "assignee_id",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "helper_text": "Assign the issue to a user",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "state_id",
                    "type": "string",
                    "value": "",
                    "label": "State",
                    "helper_text": "Set the workflow state",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=state_id&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "priority",
                    "type": "string",
                    "value": "",
                    "placeholder": "None",
                    "label": "Select Priority",
                    "helper_text": "Issue priority",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"value": "0", "label": "None"},
                            {"value": "1", "label": "Urgent"},
                            {"value": "2", "label": "High"},
                            {"value": "3", "label": "Medium"},
                            {"value": "4", "label": "Low"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the created issue",
                },
                {
                    "field": "issue_identifier",
                    "type": "string",
                    "helper_text": "Human-readable identifier (e.g., ABC-123)",
                },
                {
                    "field": "title",
                    "type": "string",
                    "helper_text": "Title of the created issue",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Description of the created issue",
                },
                {
                    "field": "state",
                    "type": "string",
                    "helper_text": "Current workflow state of the issue",
                },
                {
                    "field": "priority",
                    "type": "int32",
                    "helper_text": "Priority level of the issue",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the issue was created",
                },
                {
                    "field": "assignee_name",
                    "type": "string",
                    "helper_text": "Name of the assigned user",
                },
                {
                    "field": "assignee_email",
                    "type": "string",
                    "helper_text": "Email of the assigned user",
                },
                {
                    "field": "team_name",
                    "type": "string",
                    "helper_text": "Name of the team the issue belongs to",
                },
                {
                    "field": "team_key",
                    "type": "string",
                    "helper_text": "Key/abbreviation of the team",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "create_issue",
            "task_name": "tasks.linear.create_new_issue",
            "description": "Create a new issue",
            "label": "Create Issue",
            "variant": "common_integration_nodes",
            "input_sort_order": [
                "action",
                "integration",
                "team_id",
                "title",
                "description",
                "assignee_id",
                "state_id",
                "priority",
            ],
            "required": ["team_id", "title"],
        },
        "update_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "label": "Select Team",
                    "helper_text": "The team within Linear",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "value": "",
                    "label": "Select Issue",
                    "helper_text": "The ID of the issue to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_id&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "placeholder": "Updated bug title",
                    "helper_text": "New title for the issue",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Updated description",
                    "helper_text": "New description for the issue",
                },
                {
                    "field": "update_team_id",
                    "type": "string",
                    "value": "",
                    "label": "Update Team",
                    "helper_text": "Move to a different team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "assignee_id",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "helper_text": "Change assignee",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "state_id",
                    "type": "string",
                    "value": "",
                    "label": "State",
                    "helper_text": "Change workflow state",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=state_id&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "priority",
                    "type": "string",
                    "value": "",
                    "placeholder": "None",
                    "label": "Change Priority",
                    "helper_text": "Change priority",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"value": "0", "label": "None"},
                            {"value": "1", "label": "Urgent"},
                            {"value": "2", "label": "High"},
                            {"value": "3", "label": "Medium"},
                            {"value": "4", "label": "Low"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the updated issue",
                },
                {
                    "field": "issue_identifier",
                    "type": "string",
                    "helper_text": "Human-readable identifier (e.g., ABC-123)",
                },
                {
                    "field": "title",
                    "type": "string",
                    "helper_text": "Updated title of the issue",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Updated description of the issue",
                },
                {
                    "field": "state",
                    "type": "string",
                    "helper_text": "Current workflow state of the issue",
                },
                {
                    "field": "priority",
                    "type": "int32",
                    "helper_text": "Updated priority level of the issue",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "When the issue was last updated",
                },
                {
                    "field": "assignee_name",
                    "type": "string",
                    "helper_text": "Name of the assigned user",
                },
                {
                    "field": "assignee_email",
                    "type": "string",
                    "helper_text": "Email of the assigned user",
                },
                {
                    "field": "team_name",
                    "type": "string",
                    "helper_text": "Name of the team the issue belongs to",
                },
                {
                    "field": "team_key",
                    "type": "string",
                    "helper_text": "Key/abbreviation of the team",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "update_issue",
            "task_name": "tasks.linear.update_issue",
            "description": "Update an existing issue",
            "label": "Update Issue",
            "variant": "common_integration_nodes",
            "input_sort_order": [
                "action",
                "integration",
                "team_id",
                "issue_id",
                "title",
                "description",
                "update_team_id",
                "assignee_id",
                "state_id",
                "priority",
            ],
            "required": ["team_id", "issue_id"],
        },
        "delete_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "label": "Select Team",
                    "helper_text": "The team within Linear",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "value": "",
                    "label": "Select Issue",
                    "helper_text": "The ID of the issue to delete",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_id&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the issue was successfully deleted",
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "ID of the deleted issue",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "delete_issue",
            "task_name": "tasks.linear.delete_issue",
            "description": "Delete an issue",
            "label": "Delete Issue",
            "variant": "common_integration_nodes",
            "input_sort_order": ["action", "integration", "team_id", "issue_id"],
            "required": ["team_id", "issue_id"],
        },
        "get_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "label": "Select Team",
                    "helper_text": "The team within Linear",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "value": "",
                    "label": "Select Issue",
                    "helper_text": "The ID of the issue to retrieve",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_id&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the issue",
                },
                {
                    "field": "issue_identifier",
                    "type": "string",
                    "helper_text": "Human-readable identifier (e.g., ABC-123)",
                },
                {
                    "field": "title",
                    "type": "string",
                    "helper_text": "Title of the issue",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Description of the issue",
                },
                {
                    "field": "state",
                    "type": "string",
                    "helper_text": "Current workflow state of the issue",
                },
                {
                    "field": "state_type",
                    "type": "string",
                    "helper_text": "Type of the workflow state",
                },
                {
                    "field": "priority",
                    "type": "int32",
                    "helper_text": "Priority level of the issue",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the issue was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "When the issue was last updated",
                },
                {
                    "field": "assignee_name",
                    "type": "string",
                    "helper_text": "Name of the assigned user",
                },
                {
                    "field": "assignee_email",
                    "type": "string",
                    "helper_text": "Email of the assigned user",
                },
                {
                    "field": "assignee_id",
                    "type": "string",
                    "helper_text": "ID of the assigned user",
                },
                {
                    "field": "creator_name",
                    "type": "string",
                    "helper_text": "Name of the user who created the issue",
                },
                {
                    "field": "creator_email",
                    "type": "string",
                    "helper_text": "Email of the user who created the issue",
                },
                {
                    "field": "creator_id",
                    "type": "string",
                    "helper_text": "ID of the user who created the issue",
                },
                {
                    "field": "team_name",
                    "type": "string",
                    "helper_text": "Name of the team the issue belongs to",
                },
                {
                    "field": "team_key",
                    "type": "string",
                    "helper_text": "Key/abbreviation of the team",
                },
                {
                    "field": "team_id",
                    "type": "string",
                    "helper_text": "ID of the team the issue belongs to",
                },
                {
                    "field": "project_name",
                    "type": "string",
                    "helper_text": "Name of the project the issue belongs to",
                },
                {
                    "field": "project_id",
                    "type": "string",
                    "helper_text": "ID of the project the issue belongs to",
                },
                {
                    "field": "due_date",
                    "type": "timestamp",
                    "helper_text": "Due date of the issue",
                },
                {
                    "field": "comment_count",
                    "type": "int32",
                    "helper_text": "Number of comments on the issue",
                },
                {
                    "field": "comments",
                    "type": "string",
                    "helper_text": "Comments on the issue",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_issue",
            "task_name": "tasks.linear.get_issue",
            "description": "Get a single issue",
            "label": "Get Issue",
            "variant": "common_integration_nodes",
            "input_sort_order": ["action", "integration", "team_id", "issue_id"],
            "required": ["team_id", "issue_id"],
        },
        "list_issues**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                },
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Select Team",
                    "helper_text": "Filter by team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "state_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Select State",
                    "helper_text": "Filter by workflow state",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=state_id&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "assignee_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Select Assignee",
                    "helper_text": "Filter by assignee",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "priority",
                    "type": "string",
                    "value": "",
                    "placeholder": "None",
                    "hidden": True,
                    "label": "Select Priority",
                    "helper_text": "Filter by priority",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"value": "0", "label": "None"},
                            {"value": "1", "label": "Urgent"},
                            {"value": "2", "label": "High"},
                            {"value": "3", "label": "Medium"},
                            {"value": "4", "label": "Low"},
                        ],
                    },
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "label": "Return All",
                    "helper_text": "Return all matching issues regardless of count",
                },
            ],
            "outputs": [
                {
                    "field": "issue_count",
                    "type": "int32",
                    "helper_text": "Total number of issues returned",
                },
                {
                    "field": "issue_ids",
                    "type": "vec<string>",
                    "helper_text": "List of unique identifiers for all issues",
                },
                {
                    "field": "issue_identifiers",
                    "type": "vec<string>",
                    "helper_text": "List of human-readable identifiers (e.g., ABC-123)",
                },
                {
                    "field": "titles",
                    "type": "vec<string>",
                    "helper_text": "List of issue titles",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of issue descriptions",
                },
                {
                    "field": "states",
                    "type": "vec<string>",
                    "helper_text": "List of workflow states for all issues",
                },
                {
                    "field": "state_types",
                    "type": "vec<string>",
                    "helper_text": "List of workflow state types",
                },
                {
                    "field": "priorities",
                    "type": "vec<int32>",
                    "helper_text": "List of priority levels for all issues",
                },
                {
                    "field": "created_at",
                    "type": "vec<timestamp>",
                    "helper_text": "List of creation timestamps for all issues",
                },
                {
                    "field": "updated_at",
                    "type": "vec<timestamp>",
                    "helper_text": "List of last update timestamps for all issues",
                },
                {
                    "field": "assignee_names",
                    "type": "vec<string>",
                    "helper_text": "List of assigned user names",
                },
                {
                    "field": "assignee_emails",
                    "type": "vec<string>",
                    "helper_text": "List of assigned user emails",
                },
                {
                    "field": "assignee_ids",
                    "type": "vec<string>",
                    "helper_text": "List of assigned user IDs",
                },
                {
                    "field": "creator_names",
                    "type": "vec<string>",
                    "helper_text": "List of issue creator names",
                },
                {
                    "field": "creator_emails",
                    "type": "vec<string>",
                    "helper_text": "List of issue creator emails",
                },
                {
                    "field": "creator_ids",
                    "type": "vec<string>",
                    "helper_text": "List of issue creator IDs",
                },
                {
                    "field": "team_names",
                    "type": "vec<string>",
                    "helper_text": "List of team names for all issues",
                },
                {
                    "field": "team_keys",
                    "type": "vec<string>",
                    "helper_text": "List of team keys/abbreviations",
                },
                {
                    "field": "team_ids",
                    "type": "vec<string>",
                    "helper_text": "List of team IDs for all issues",
                },
                {
                    "field": "project_names",
                    "type": "vec<string>",
                    "helper_text": "List of project names for all issues",
                },
                {
                    "field": "project_ids",
                    "type": "vec<string>",
                    "helper_text": "List of project IDs for all issues",
                },
                {
                    "field": "due_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of due dates for all issues",
                },
                {
                    "field": "issue_titles",
                    "type": "vec<string>",
                    "helper_text": "List of issue titles (duplicate of titles)",
                },
                {
                    "field": "issue_identifiers_str",
                    "type": "vec<string>",
                    "helper_text": "List of issue identifiers as strings",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "list_issues",
            "task_name": "tasks.linear.list_issues",
            "description": "List issues with filters",
            "label": "List Issues",
            "variant": "get_integration_nodes",
            "input_sort_order": [
                "action",
                "integration",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "team_id",
                "state_id",
                "assignee_id",
                "priority",
                "return_all",
            ],
            "required": [],
        },
        "list_issues**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "label": "Number of Issues",
                    "helper_text": "Specify the number of issues to fetch",
                }
            ],
            "outputs": [],
        },
        "list_issues**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "list_issues**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "list_issues**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "add_link**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "label": "Select Team",
                    "helper_text": "The team within Linear",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "value": "",
                    "label": "Select Issue",
                    "helper_text": "The ID of the issue to add a link to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_id&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "link",
                    "type": "string",
                    "value": "",
                    "label": "Link URL",
                    "placeholder": "https://example.com/document",
                    "helper_text": "The URL to attach to the issue",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the link was successfully added",
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "ID of the issue the link was added to",
                },
                {
                    "field": "link",
                    "type": "string",
                    "helper_text": "URL of the added link",
                },
                {
                    "field": "attachment_id",
                    "type": "string",
                    "helper_text": "ID of the added attachment",
                },
                {
                    "field": "title",
                    "type": "string",
                    "helper_text": "Title of the added attachment",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "add_link",
            "task_name": "tasks.linear.add_link",
            "description": "Add a link to an issue",
            "label": "Add Link",
            "variant": "common_integration_nodes",
            "input_sort_order": [
                "action",
                "integration",
                "team_id",
                "issue_id",
                "link",
            ],
            "required": ["team_id", "issue_id", "link"],
        },
        "create_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "label": "Select Team",
                    "helper_text": "The team within Linear",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_id",
                    "type": "string",
                    "value": "",
                    "label": "Select Issue",
                    "helper_text": "The ID of the issue to add a comment to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_id&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "placeholder": "More users are facing this issue",
                    "helper_text": "The comment text",
                },
                {
                    "field": "parent_id",
                    "type": "string",
                    "value": "",
                    "label": "Parent Comment ID",
                    "helper_text": "ID of parent comment for replies (optional)",
                    "placeholder": "4fc4-aa4b-1234567890",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the created comment",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "helper_text": "Content of the created comment",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the comment was created",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Name of the user who created the comment",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "helper_text": "Email of the user who created the comment",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "create_comment",
            "task_name": "tasks.linear.create_new_comment",
            "description": "Add a comment to an issue",
            "label": "Add Comment",
            "variant": "common_integration_nodes",
            "input_sort_order": [
                "action",
                "integration",
                "team_id",
                "issue_id",
                "comment",
                "parent_id",
            ],
            "required": ["team_id", "issue_id", "comment"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        assignee_id: str = "",
        comment: str = "",
        description: str = "",
        exact_date: Any = {"start": "", "end": ""},
        issue_id: str = "",
        link: str = "",
        num_messages: int = 10,
        parent_id: str = "",
        priority: str = "",
        return_all: bool = False,
        state_id: str = "",
        team_id: Optional[str] = None,
        title: str = "",
        update_team_id: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_linear",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team_id is not None:
            self.inputs["team_id"] = team_id
        if title is not None:
            self.inputs["title"] = title
        if description is not None:
            self.inputs["description"] = description
        if assignee_id is not None:
            self.inputs["assignee_id"] = assignee_id
        if state_id is not None:
            self.inputs["state_id"] = state_id
        if priority is not None:
            self.inputs["priority"] = priority
        if issue_id is not None:
            self.inputs["issue_id"] = issue_id
        if update_team_id is not None:
            self.inputs["update_team_id"] = update_team_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if return_all is not None:
            self.inputs["return_all"] = return_all
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if link is not None:
            self.inputs["link"] = link
        if comment is not None:
            self.inputs["comment"] = comment
        if parent_id is not None:
            self.inputs["parent_id"] = parent_id
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationLinearNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_outlook")
class IntegrationOutlookNode(Node):
    """
    Outlook

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'add_message_attachment'
        attachment: The file to attach to the message
        message_id: Select the message to get
    ### When action = 'get_message_attachment'
        attachment_id: The ID of the attachment to retrieve
        fields: Comma-separated list of additional fields to return
        message_id: Select the message to get
    ### When action = 'download_message_attachment'
        attachment_id: The ID of the attachment to retrieve
        message_id: Select the message to get
    ### When action = 'send_email'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        subject: The subject of the email
    ### When action = 'send_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: Select the message to reply to
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
    ### When action = 'create_draft'
        attachments: Attachments to be appended.
        body: The body of the email
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
        subject: The subject of the email
    ### When action = 'draft_reply'
        attachments: Attachments to be appended.
        body: The body of the email
        email_id: Select the message to reply to
        format: Either html (to allow html content) or text (for plaintext content - default)
        recipients: A single email or a comma-separated list of the recipients' emails
    ### When action = 'update_draft'
        bcc_recipients: Comma-separated list of BCC recipient emails
        body: The body of the email
        body_content_type: Content type for the body
        cc_recipients: Comma-separated list of CC recipient emails
        importance: Change the message importance level
        is_read: Mark the message as read or unread
        is_read_receipt_requested: Request a read receipt for this message
        message_id: Select the message to get
        subject: The subject of the email
        to_recipients: Comma-separated list of recipient emails
    ### When action = 'read_email' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'update_message'
        destination_folder_id: ID of the folder to move the message to (leave empty to keep in current folder)
        importance: Change the message importance level
        is_read: Mark the message as read or unread
        message_id: Select the message to get
    ### When action = 'move_message'
        destination_folder_id: ID of the folder to move the message to (leave empty to keep in current folder)
        message_id: Select the message to get
    ### When action = 'create_folder'
        display_name: The name of the folder to create
        parent_folder_id: ID of the parent folder (optional, creates in root if not provided)
    ### When action = 'update_folder'
        display_name: The name of the folder to create
        folder_id: Select a mailbox to read
    ### When action = 'read_email' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_folder'
        fields: Comma-separated list of additional fields to return
        folder_id: Select a mailbox to read
    ### When action = 'list_folders'
        fields: Comma-separated list of additional fields to return
        filter: OData filter expression
        limit: Maximum number of folders to return (0 for no limit)
        parent_folder_id: ID of the parent folder (optional, creates in root if not provided)
        return_all: Whether to return all folders (ignores limit)
    ### When action = 'list_folder_messages'
        fields: Comma-separated list of additional fields to return
        filter: OData filter expression
        folder_id: Select a mailbox to read
        limit: Maximum number of folders to return (0 for no limit)
        output: Output format for the message data
        return_all: Whether to return all folders (ignores limit)
        search: Search term to filter messages
    ### When action = 'list_message_attachments'
        fields: Comma-separated list of additional fields to return
        limit: Maximum number of folders to return (0 for no limit)
        message_id: Select the message to get
        return_all: Whether to return all folders (ignores limit)
    ### When action = 'delete_folder'
        folder_id: Select a mailbox to read
    ### When action = 'read_email'
        item_id: Select a mailbox to read emails from
        use_date: Toggle to use dates
    ### When action = 'get_message'
        message_id: Select the message to get
        output: Output format for the message data
    ### When action = 'delete_message'
        message_id: Select the message to get
    ### When action = 'get_draft'
        message_id: Select the message to get
        output: Output format for the message data
    ### When action = 'send_draft'
        message_id: Select the message to get
        to: Optional: Update recipients before sending
    ### When action = 'delete_draft'
        message_id: Select the message to get
    ### When action = 'read_email' and use_date = False
        num_messages: Specify the last n number of emails
    ### When action = 'read_email' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'add_message_attachment'
        attachment_id: The ID of the added attachment
        name: The name of the attachment
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### When action = 'get_message_attachment'
        attachment_id: The ID of the attachment
        content_type: The MIME type of the attachment
        is_inline: Whether the attachment is inline
        last_modified_date_time: Last modified date and time
        name: The name of the attachment
        raw_data: Raw API response data
        size: The size of the attachment in bytes
    ### When action = 'download_message_attachment'
        attachment_id: The ID of the downloaded attachment
        content_size: The size of the downloaded content in bytes
        content_type: The MIME type of the file
        file_data: The downloaded file data
        file_name: The name of the downloaded file
        raw_data: Raw API response data
        success: Whether the download was successful
    ### When action = 'list_message_attachments'
        attachment_ids: List of attachment IDs
        attachment_names: List of attachment names
        attachments_count: Total number of attachments returned
        content_types: List of attachment MIME types
        is_inline_list: List indicating which attachments are inline
        last_modified_date_times: List of last modified date times
        raw_data: Raw API response data
        sizes: List of attachment sizes in bytes
    ### When action = 'read_email'
        attachments: The attachments for each email
        email_bodies: The content of the retrieved emails
        email_dates: The sent dates of the retrieved emails
        email_display_names: The display names of the senders
        email_ids: The IDs of the retrieved emails
        email_subjects: The subjects of the retrieved emails
        raw_data: Raw API response data
        recipient_addresses: The email addresses of the recipients
        sender_addresses: The email addresses of the senders
    ### When action = 'get_message'
        attachments: The attachments for the message (Full output only)
        body_preview: Preview of the body content
        categories: List of categories assigned to the message
        conversation_id: The conversation ID
        from_email: Sender email address
        from_name: Sender display name
        has_attachments: Whether the message has attachments
        message_id: The ID of the message
        raw_data: Raw API response data
        subject: The subject of the message
        to_emails: List of recipient email addresses
        to_names: List of recipient display names
    ### When action = 'get_draft'
        attachments: The attachments for the draft (Full output only)
        body_preview: Preview of the body content
        from_email: Sender email address
        from_name: Sender display name
        has_attachments: Whether the draft has attachments
        message_id: The ID of the draft
        raw_data: Raw API response data
        subject: The subject of the draft
        to_emails: List of recipient email addresses
        to_names: List of recipient display names
    ### When action = 'get_folder'
        child_folder_count: Number of child folders
        display_name: The display name of the folder
        folder_id: The ID of the folder
        parent_folder_id: The ID of the parent folder
        raw_data: Raw API response data
        total_item_count: Total number of items in the folder
        unread_item_count: Number of unread items in the folder
    ### When action = 'list_folders'
        child_folder_counts: List of child folder counts
        folder_ids: List of folder IDs
        folder_names: List of folder display names
        folders_count: Total number of folders returned
        parent_folder_ids: List of parent folder IDs
        raw_data: Raw API response data
        total_item_counts: List of total item counts
        unread_item_counts: List of unread item counts
    ### When action = 'create_folder'
        display_name: The display name of the created folder
        folder_id: The ID of the created folder
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### When action = 'update_folder'
        display_name: The updated display name of the folder
        folder_id: The ID of the updated folder
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### When action = 'create_draft'
        draft_id: The ID of the created draft
        output: Success message
        raw_data: Raw API response data
    ### When action = 'draft_reply'
        draft_id: The ID of the created draft reply
        output: Success message
        raw_data: Raw API response data
    ### When action = 'update_draft'
        draft_id: The ID of the updated draft
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### When action = 'list_folder_messages'
        from_emails: List of sender email addresses
        from_names: List of sender display names
        has_attachments: List indicating which messages have attachments
        message_ids: List of message IDs
        messages_count: Total number of messages returned
        raw_data: Raw API response data
        subjects: List of message subjects
    ### When action = 'update_message'
        message_id: The ID of the updated message
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### When action = 'send_email'
        output: Success message
        raw_data: Raw API response data
    ### When action = 'send_reply'
        output: Success message
        raw_data: Raw API response data
    ### When action = 'move_message'
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### When action = 'delete_message'
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### When action = 'send_draft'
        raw_data: Raw API response data
        success: Whether the draft was sent successfully
    ### When action = 'delete_draft'
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### When action = 'delete_folder'
        raw_data: Raw API response data
        success: Whether the operation was successful
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Outlook>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "send_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [
                {"field": "output", "type": "string", "helper_text": "Success message"},
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "send_email",
            "task_name": "tasks.outlook.send_email",
            "description": "Create and send a new email",
            "label": "Send Email",
            "inputs_sort_order": [
                "integration",
                "action",
                "recipients",
                "subject",
                "format",
                "body",
                "attachments",
            ],
            "required": ["recipients", "subject", "body"],
        },
        "send_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "email_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to reply to",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [
                {"field": "output", "type": "string", "helper_text": "Success message"},
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "send_reply",
            "task_name": "tasks.outlook.send_reply",
            "description": "Create and send a new reply to an existing email",
            "label": "Send Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "email_id",
                "recipients",
                "format",
                "body",
                "attachments",
            ],
            "required": ["email_id", "recipients", "body"],
        },
        "read_email**(*)**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "label": "Mailbox",
                    "helper_text": "Select a mailbox to read emails from",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "order": 1,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                    "order": 2,
                },
            ],
            "outputs": [
                {
                    "field": "email_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of the retrieved emails",
                },
                {
                    "field": "email_subjects",
                    "type": "vec<string>",
                    "helper_text": "The subjects of the retrieved emails",
                },
                {
                    "field": "email_dates",
                    "type": "vec<string>",
                    "helper_text": "The sent dates of the retrieved emails",
                },
                {
                    "field": "email_bodies",
                    "type": "vec<string>",
                    "helper_text": "The content of the retrieved emails",
                },
                {
                    "field": "sender_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the senders",
                },
                {
                    "field": "email_display_names",
                    "type": "vec<string>",
                    "helper_text": "The display names of the senders",
                },
                {
                    "field": "recipient_addresses",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the recipients",
                },
                {
                    "field": "attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "The attachments for each email",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "read_email",
            "task_name": "tasks.outlook.read_email",
            "description": "Read emails from Outlook",
            "label": "Read Emails",
            "inputs_sort_order": [
                "integration",
                "action",
                "item_id",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "read_email**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Emails",
                    "helper_text": "Specify the last n number of emails",
                    "hidden": True,
                    "order": 5,
                }
            ],
            "outputs": [],
        },
        "read_email**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "hidden": True,
                    "order": 3,
                }
            ],
            "outputs": [],
        },
        "read_email**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                    "order": 4,
                }
            ],
            "outputs": [],
        },
        "read_email**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                    "order": 4,
                }
            ],
            "outputs": [],
        },
        "get_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to get",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "output",
                    "type": "string",
                    "value": "simple",
                    "label": "Output Format",
                    "helper_text": "Output format for the message data",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Simple", "value": "simple"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the message",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "helper_text": "The subject of the message",
                },
                {
                    "field": "body_preview",
                    "type": "string",
                    "helper_text": "Preview of the body content",
                },
                {
                    "field": "conversation_id",
                    "type": "string",
                    "helper_text": "The conversation ID",
                },
                {
                    "field": "from_email",
                    "type": "string",
                    "helper_text": "Sender email address",
                },
                {
                    "field": "from_name",
                    "type": "string",
                    "helper_text": "Sender display name",
                },
                {
                    "field": "to_emails",
                    "type": "vec<string>",
                    "helper_text": "List of recipient email addresses",
                },
                {
                    "field": "to_names",
                    "type": "vec<string>",
                    "helper_text": "List of recipient display names",
                },
                {
                    "field": "has_attachments",
                    "type": "bool",
                    "helper_text": "Whether the message has attachments",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments for the message (Full output only)",
                },
                {
                    "field": "categories",
                    "type": "vec<string>",
                    "helper_text": "List of categories assigned to the message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "get_message",
            "task_name": "tasks.outlook.get_message",
            "description": "Retrieve a specific message",
            "label": "Get Message",
            "inputs_sort_order": ["integration", "action", "message_id", "output"],
            "required": ["message_id", "output"],
        },
        "update_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to update",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "importance",
                    "type": "string",
                    "value": "",
                    "label": "Importance",
                    "helper_text": "Change the message importance level",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "low"},
                            {"label": "Normal", "value": "normal"},
                            {"label": "High", "value": "high"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "is_read",
                    "type": "bool",
                    "value": False,
                    "label": "Mark as Read",
                    "helper_text": "Mark the message as read or unread",
                },
                {
                    "field": "destination_folder_id",
                    "type": "string",
                    "value": "",
                    "label": "Move to Folder",
                    "placeholder": "Optional folder ID",
                    "helper_text": "ID of the folder to move the message to (leave empty to keep in current folder)",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the updated message",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "update_message",
            "task_name": "tasks.outlook.update_message",
            "description": "Update message properties",
            "label": "Update Message Properties",
            "inputs_sort_order": [
                "integration",
                "action",
                "message_id",
                "importance",
                "is_read",
                "destination_folder_id",
            ],
            "required": ["message_id"],
        },
        "move_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "destination_folder_id",
                    "type": "string",
                    "label": "Destination Folder ID",
                    "helper_text": "Select the destination folder",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to move",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "move_message",
            "task_name": "tasks.outlook.move_message",
            "description": "Move a message to a different folder",
            "label": "Move Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "message_id",
                "destination_folder_id",
            ],
            "required": ["message_id", "destination_folder_id"],
        },
        "delete_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to delete",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "delete_message",
            "task_name": "tasks.outlook.delete_message",
            "description": "Delete a message",
            "label": "Delete Message",
            "inputs_sort_order": ["integration", "action", "message_id"],
            "required": ["message_id"],
        },
        "create_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Introduction to John",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [
                {"field": "output", "type": "string", "helper_text": "Success message"},
                {
                    "field": "draft_id",
                    "type": "string",
                    "helper_text": "The ID of the created draft",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "create_draft",
            "task_name": "tasks.outlook.create_email_draft",
            "description": "Create (but do not send) a new email draft",
            "label": "Create Email Draft",
            "inputs_sort_order": [
                "integration",
                "action",
                "recipients",
                "subject",
                "format",
                "body",
                "attachments",
            ],
            "required": ["recipients", "subject", "body"],
        },
        "draft_reply**(*)**(*)": {
            "inputs": [
                {
                    "field": "email_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the email to reply to (often used in conjunction with a trigger where the email ID is received from the trigger)",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "A single email or a comma-separated list of the recipients' emails",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Hi John, …",
                    "helper_text": "The body of the email",
                },
                {
                    "field": "format",
                    "type": "string",
                    "value": "text",
                    "label": "Format",
                    "placeholder": "html / text (default)",
                    "helper_text": "Either html (to allow html content) or text (for plaintext content - default)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                },
            ],
            "outputs": [
                {"field": "output", "type": "string", "helper_text": "Success message"},
                {
                    "field": "draft_id",
                    "type": "string",
                    "helper_text": "The ID of the created draft reply",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "draft_reply",
            "task_name": "tasks.outlook.draft_reply",
            "description": "Create (but do not send) a draft of a reply to an existing email",
            "label": "Draft Reply",
            "inputs_sort_order": [
                "integration",
                "action",
                "email_id",
                "recipients",
                "format",
                "body",
                "attachments",
            ],
            "required": ["email_id", "recipients", "body"],
        },
        "get_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the draft message to get",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "output",
                    "type": "string",
                    "value": "simple",
                    "label": "Output Format",
                    "helper_text": "Output format for the draft data",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Simple", "value": "simple"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "The ID of the draft",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "helper_text": "The subject of the draft",
                },
                {
                    "field": "body_preview",
                    "type": "string",
                    "helper_text": "Preview of the body content",
                },
                {
                    "field": "from_email",
                    "type": "string",
                    "helper_text": "Sender email address",
                },
                {
                    "field": "from_name",
                    "type": "string",
                    "helper_text": "Sender display name",
                },
                {
                    "field": "to_emails",
                    "type": "vec<string>",
                    "helper_text": "List of recipient email addresses",
                },
                {
                    "field": "to_names",
                    "type": "vec<string>",
                    "helper_text": "List of recipient display names",
                },
                {
                    "field": "has_attachments",
                    "type": "bool",
                    "helper_text": "Whether the draft has attachments",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments for the draft (Full output only)",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "get_draft",
            "task_name": "tasks.outlook.get_draft",
            "description": "Retrieve a specific draft message",
            "label": "Get Draft",
            "inputs_sort_order": ["integration", "action", "message_id", "output"],
            "required": ["message_id", "output"],
        },
        "update_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the draft message to update",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Updated subject",
                    "helper_text": "New subject for the draft",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Updated body content",
                    "helper_text": "New body content for the draft",
                },
                {
                    "field": "body_content_type",
                    "type": "string",
                    "value": "html",
                    "label": "Body Content Type",
                    "helper_text": "Content type for the body",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "HTML", "value": "html"},
                            {"label": "Text", "value": "text"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "to_recipients",
                    "type": "string",
                    "value": "",
                    "label": "To Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "Comma-separated list of recipient emails",
                },
                {
                    "field": "cc_recipients",
                    "type": "string",
                    "value": "",
                    "label": "CC Recipients",
                    "placeholder": "cc@company.com",
                    "helper_text": "Comma-separated list of CC recipient emails",
                },
                {
                    "field": "bcc_recipients",
                    "type": "string",
                    "value": "",
                    "label": "BCC Recipients",
                    "placeholder": "bcc@company.com",
                    "helper_text": "Comma-separated list of BCC recipient emails",
                },
                {
                    "field": "importance",
                    "type": "string",
                    "value": "",
                    "label": "Importance",
                    "helper_text": "Message importance level",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "low"},
                            {"label": "Normal", "value": "normal"},
                            {"label": "High", "value": "high"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "is_read",
                    "type": "bool",
                    "value": False,
                    "label": "Is Read",
                    "helper_text": "Mark the draft as read/unread",
                },
                {
                    "field": "is_read_receipt_requested",
                    "type": "bool",
                    "value": False,
                    "label": "Request Read Receipt",
                    "helper_text": "Request a read receipt for this message",
                },
            ],
            "outputs": [
                {
                    "field": "draft_id",
                    "type": "string",
                    "helper_text": "The ID of the updated draft",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "update_draft",
            "task_name": "tasks.outlook.update_draft",
            "description": "Update an existing draft message",
            "label": "Update Draft",
            "inputs_sort_order": [
                "integration",
                "action",
                "message_id",
                "subject",
                "body",
                "body_content_type",
                "to_recipients",
                "cc_recipients",
                "bcc_recipients",
                "importance",
                "is_read",
                "is_read_receipt_requested",
            ],
            "required": ["message_id"],
        },
        "send_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the draft message to send",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "to",
                    "type": "string",
                    "value": "",
                    "label": "To Recipients",
                    "placeholder": "john@company.com, alex@company.com",
                    "helper_text": "Optional: Update recipients before sending",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the draft was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "send_draft",
            "task_name": "tasks.outlook.send_draft",
            "description": "Send an existing draft message",
            "label": "Send Draft",
            "inputs_sort_order": ["integration", "action", "message_id", "to"],
            "required": ["message_id"],
        },
        "delete_draft**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the draft message to delete",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "delete_draft",
            "task_name": "tasks.outlook.delete_draft",
            "description": "Delete a draft message",
            "label": "Delete Draft",
            "inputs_sort_order": ["integration", "action", "message_id"],
            "required": ["message_id"],
        },
        "create_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "display_name",
                    "type": "string",
                    "value": "",
                    "label": "Display Name",
                    "placeholder": "My New Folder",
                    "helper_text": "The name of the folder to create",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "label": "Parent Folder ID",
                    "placeholder": "Optional parent folder ID",
                    "helper_text": "ID of the parent folder (optional, creates in root if not provided)",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "The ID of the created folder",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "The display name of the created folder",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "create_folder",
            "task_name": "tasks.outlook.create_folder",
            "description": "Create a new mail folder",
            "label": "Create Folder",
            "inputs_sort_order": [
                "integration",
                "action",
                "display_name",
                "parent_folder_id",
            ],
            "required": ["display_name"],
        },
        "get_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "label": "Mailbox",
                    "helper_text": "Select a mailbox to read",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "order": 1,
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Additional Fields",
                    "placeholder": "Additional fields to return",
                    "helper_text": "Comma-separated list of additional fields to return",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "The ID of the folder",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "The display name of the folder",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "helper_text": "The ID of the parent folder",
                },
                {
                    "field": "child_folder_count",
                    "type": "int32",
                    "helper_text": "Number of child folders",
                },
                {
                    "field": "unread_item_count",
                    "type": "int32",
                    "helper_text": "Number of unread items in the folder",
                },
                {
                    "field": "total_item_count",
                    "type": "int32",
                    "helper_text": "Total number of items in the folder",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "get_folder",
            "task_name": "tasks.outlook.get_folder",
            "description": "Retrieve a specific mail folder",
            "label": "Get Folder",
            "inputs_sort_order": ["integration", "action", "folder_id", "fields"],
            "required": ["folder_id"],
        },
        "list_folders**(*)**(*)": {
            "inputs": [
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "label": "Parent Folder ID",
                    "placeholder": "Optional parent folder ID",
                    "helper_text": "ID of the parent folder to list children from (optional, lists root folders if not provided)",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Additional Fields",
                    "placeholder": "Additional fields to return",
                    "helper_text": "Comma-separated list of additional fields to return",
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": "displayName eq 'Inbox'",
                    "helper_text": "OData filter expression",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of folders to return (0 for no limit)",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "Whether to return all folders (ignores limit)",
                },
            ],
            "outputs": [
                {
                    "field": "folder_ids",
                    "type": "vec<string>",
                    "helper_text": "List of folder IDs",
                },
                {
                    "field": "folder_names",
                    "type": "vec<string>",
                    "helper_text": "List of folder display names",
                },
                {
                    "field": "parent_folder_ids",
                    "type": "vec<string>",
                    "helper_text": "List of parent folder IDs",
                },
                {
                    "field": "child_folder_counts",
                    "type": "vec<int32>",
                    "helper_text": "List of child folder counts",
                },
                {
                    "field": "unread_item_counts",
                    "type": "vec<int32>",
                    "helper_text": "List of unread item counts",
                },
                {
                    "field": "total_item_counts",
                    "type": "vec<int32>",
                    "helper_text": "List of total item counts",
                },
                {
                    "field": "folders_count",
                    "type": "int32",
                    "helper_text": "Total number of folders returned",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "list_folders",
            "task_name": "tasks.outlook.list_folders",
            "description": "List mail folders",
            "label": "List Folders",
            "inputs_sort_order": [
                "integration",
                "action",
                "parent_folder_id",
                "fields",
                "filter",
                "limit",
                "return_all",
            ],
        },
        "list_folder_messages**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "label": "Mailbox",
                    "helper_text": "Select a mailbox to read messages from",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "order": 1,
                },
                {
                    "field": "output",
                    "type": "string",
                    "value": "simple",
                    "label": "Output Format",
                    "helper_text": "Output format for the message data",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Simple", "value": "simple"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Additional Fields",
                    "placeholder": "Additional fields to return",
                    "helper_text": "Comma-separated list of additional fields to return (when output is 'full')",
                },
                {
                    "field": "search",
                    "type": "string",
                    "value": "",
                    "label": "Search",
                    "placeholder": "search term",
                    "helper_text": "Search term to filter messages",
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": "isRead eq false",
                    "helper_text": "OData filter expression",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of messages to return (0 for no limit)",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "Whether to return all messages (ignores limit)",
                },
            ],
            "outputs": [
                {
                    "field": "message_ids",
                    "type": "vec<string>",
                    "helper_text": "List of message IDs",
                },
                {
                    "field": "subjects",
                    "type": "vec<string>",
                    "helper_text": "List of message subjects",
                },
                {
                    "field": "from_emails",
                    "type": "vec<string>",
                    "helper_text": "List of sender email addresses",
                },
                {
                    "field": "from_names",
                    "type": "vec<string>",
                    "helper_text": "List of sender display names",
                },
                {
                    "field": "has_attachments",
                    "type": "vec<bool>",
                    "helper_text": "List indicating which messages have attachments",
                },
                {
                    "field": "messages_count",
                    "type": "int32",
                    "helper_text": "Total number of messages returned",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "list_folder_messages",
            "task_name": "tasks.outlook.list_folder_messages",
            "description": "List messages in a specific folder",
            "label": "List Folder Messages",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "output",
                "fields",
                "search",
                "filter",
                "limit",
                "return_all",
            ],
            "required": ["folder_id"],
        },
        "update_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "label": "Mailbox",
                    "helper_text": "Select a mailbox to update",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "order": 1,
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "value": "",
                    "label": "Display Name",
                    "placeholder": "New folder name",
                    "helper_text": "The new name for the folder",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "The ID of the updated folder",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "The updated display name of the folder",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "update_folder",
            "task_name": "tasks.outlook.update_folder",
            "description": "Update a mail folder",
            "label": "Update Folder",
            "inputs_sort_order": ["integration", "action", "folder_id", "display_name"],
            "required": ["folder_id", "display_name"],
        },
        "delete_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "label": "Mailbox",
                    "helper_text": "Select a mailbox to delete",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "order": 1,
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "delete_folder",
            "task_name": "tasks.outlook.delete_folder",
            "description": "Delete a mail folder",
            "label": "Delete Folder",
            "inputs_sort_order": ["integration", "action", "folder_id"],
            "required": ["folder_id"],
        },
        "add_message_attachment**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to add attachment to",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "attachment",
                    "type": "file",
                    "value": "",
                    "label": "Attachment",
                    "helper_text": "The file to attach to the message",
                },
            ],
            "outputs": [
                {
                    "field": "attachment_id",
                    "type": "string",
                    "helper_text": "The ID of the added attachment",
                },
                {
                    "field": "name",
                    "type": "string",
                    "helper_text": "The name of the attachment",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "add_message_attachment",
            "task_name": "tasks.outlook.add_message_attachment",
            "description": "Add an attachment to a message",
            "label": "Add Message Attachment",
            "inputs_sort_order": ["integration", "action", "message_id", "attachment"],
            "required": ["message_id", "attachment"],
        },
        "get_message_attachment**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to get attachment from",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "attachment_id",
                    "type": "string",
                    "value": "",
                    "label": "Attachment ID",
                    "placeholder": "Attachment ID",
                    "helper_text": "The ID of the attachment to retrieve",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Fields",
                    "placeholder": "id,name,contentType",
                    "helper_text": "Comma-separated list of specific fields to return",
                },
            ],
            "outputs": [
                {
                    "field": "attachment_id",
                    "type": "string",
                    "helper_text": "The ID of the attachment",
                },
                {
                    "field": "name",
                    "type": "string",
                    "helper_text": "The name of the attachment",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "The MIME type of the attachment",
                },
                {
                    "field": "size",
                    "type": "int32",
                    "helper_text": "The size of the attachment in bytes",
                },
                {
                    "field": "is_inline",
                    "type": "bool",
                    "helper_text": "Whether the attachment is inline",
                },
                {
                    "field": "last_modified_date_time",
                    "type": "string",
                    "helper_text": "Last modified date and time",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "get_message_attachment",
            "task_name": "tasks.outlook.get_message_attachment",
            "description": "Retrieve metadata about a specific message attachment",
            "label": "Get Message Attachment",
            "inputs_sort_order": [
                "integration",
                "action",
                "message_id",
                "attachment_id",
                "fields",
            ],
            "required": ["message_id", "attachment_id"],
        },
        "list_message_attachments**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to get attachments from",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Fields",
                    "placeholder": "id,name,contentType",
                    "helper_text": "Comma-separated list of specific fields to return",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of attachments to return (0 for no limit)",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "Whether to return all attachments (ignores limit)",
                },
            ],
            "outputs": [
                {
                    "field": "attachment_ids",
                    "type": "vec<string>",
                    "helper_text": "List of attachment IDs",
                },
                {
                    "field": "attachment_names",
                    "type": "vec<string>",
                    "helper_text": "List of attachment names",
                },
                {
                    "field": "content_types",
                    "type": "vec<string>",
                    "helper_text": "List of attachment MIME types",
                },
                {
                    "field": "sizes",
                    "type": "vec<int32>",
                    "helper_text": "List of attachment sizes in bytes",
                },
                {
                    "field": "is_inline_list",
                    "type": "vec<bool>",
                    "helper_text": "List indicating which attachments are inline",
                },
                {
                    "field": "last_modified_date_times",
                    "type": "vec<string>",
                    "helper_text": "List of last modified date times",
                },
                {
                    "field": "attachments_count",
                    "type": "int32",
                    "helper_text": "Total number of attachments returned",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "list_message_attachments",
            "task_name": "tasks.outlook.list_message_attachments",
            "description": "List all attachments for a message",
            "label": "List Message Attachments",
            "inputs_sort_order": [
                "integration",
                "action",
                "message_id",
                "fields",
                "limit",
                "return_all",
            ],
            "required": ["message_id"],
        },
        "download_message_attachment**(*)**(*)": {
            "inputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "label": "Message",
                    "helper_text": "Select the message to download attachment from",
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "attachment_id",
                    "type": "string",
                    "value": "",
                    "label": "Attachment ID",
                    "placeholder": "Attachment ID",
                    "helper_text": "The ID of the attachment to download",
                },
            ],
            "outputs": [
                {
                    "field": "attachment_id",
                    "type": "string",
                    "helper_text": "The ID of the downloaded attachment",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "The name of the downloaded file",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "The MIME type of the file",
                },
                {
                    "field": "file_data",
                    "type": "file",
                    "helper_text": "The downloaded file data",
                },
                {
                    "field": "content_size",
                    "type": "int32",
                    "helper_text": "The size of the downloaded content in bytes",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the download was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "download_message_attachment",
            "task_name": "tasks.outlook.download_message_attachment",
            "description": "Download an attachment from a message",
            "label": "Download Message Attachment",
            "inputs_sort_order": [
                "integration",
                "action",
                "message_id",
                "attachment_id",
            ],
            "required": ["message_id", "attachment_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        attachment: str = "",
        attachment_id: str = "",
        attachments: List[str] = [],
        bcc_recipients: str = "",
        body: str = "",
        body_content_type: str = "html",
        cc_recipients: str = "",
        destination_folder_id: str = "",
        display_name: str = "",
        email_id: Optional[str] = None,
        exact_date: Any = {"start": "", "end": ""},
        fields: str = "",
        filter: str = "",
        folder_id: Optional[str] = None,
        format: str = "text",
        importance: str = "",
        is_read: bool = False,
        is_read_receipt_requested: bool = False,
        item_id: Optional[str] = None,
        limit: int = 10,
        message_id: Optional[str] = None,
        num_messages: int = 10,
        output: str = "simple",
        parent_folder_id: str = "",
        recipients: str = "",
        return_all: bool = False,
        search: str = "",
        subject: str = "",
        to: str = "",
        to_recipients: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_outlook",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if format is not None:
            self.inputs["format"] = format
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if email_id is not None:
            self.inputs["email_id"] = email_id
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if message_id is not None:
            self.inputs["message_id"] = message_id
        if output is not None:
            self.inputs["output"] = output
        if importance is not None:
            self.inputs["importance"] = importance
        if is_read is not None:
            self.inputs["is_read"] = is_read
        if destination_folder_id is not None:
            self.inputs["destination_folder_id"] = destination_folder_id
        if body_content_type is not None:
            self.inputs["body_content_type"] = body_content_type
        if to_recipients is not None:
            self.inputs["to_recipients"] = to_recipients
        if cc_recipients is not None:
            self.inputs["cc_recipients"] = cc_recipients
        if bcc_recipients is not None:
            self.inputs["bcc_recipients"] = bcc_recipients
        if is_read_receipt_requested is not None:
            self.inputs["is_read_receipt_requested"] = is_read_receipt_requested
        if to is not None:
            self.inputs["to"] = to
        if display_name is not None:
            self.inputs["display_name"] = display_name
        if parent_folder_id is not None:
            self.inputs["parent_folder_id"] = parent_folder_id
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if fields is not None:
            self.inputs["fields"] = fields
        if filter is not None:
            self.inputs["filter"] = filter
        if limit is not None:
            self.inputs["limit"] = limit
        if return_all is not None:
            self.inputs["return_all"] = return_all
        if search is not None:
            self.inputs["search"] = search
        if attachment is not None:
            self.inputs["attachment"] = attachment
        if attachment_id is not None:
            self.inputs["attachment_id"] = attachment_id
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationOutlookNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_salesforce")
class IntegrationSalesforceNode(Node):
    """
    Salesforce

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'run_sql_query'
        sql_query: SQL Query in Salesforce Object Query Language

    ## Outputs
    ### When action = 'run_sql_query'
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Salesforce>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "run_sql_query**(*)**(*)": {
            "inputs": [
                {
                    "field": "sql_query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT Id, Name, AccountNumber FROM Account",
                    "helper_text": "SQL Query in Salesforce Object Query Language",
                }
            ],
            "outputs": [{"field": "output", "type": "string"}],
            "name": "run_sql_query",
            "task_name": "tasks.salesforce.run_sql_query",
            "description": "Run a SQL query to query data",
            "label": "Run SQL Query",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        sql_query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_salesforce",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if sql_query is not None:
            self.inputs["sql_query"] = sql_query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSalesforceNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_slack")
class IntegrationSlackNode(Node):
    """
    Slack

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'update_message'
        as_user: Update as user
        blocks: Block kit blocks (JSON)
        channel: The channel to kick user from
        message: The message text to send
        team: The team workspace
        timestamp: Timestamp of the message to update(ISO 8601 or timestamp)
    ### When action = 'delete_message'
        as_user: Update as user
        channel: The channel to kick user from
        team: The team workspace
        timestamp: Timestamp of the message to update(ISO 8601 or timestamp)
    ### When action = 'send_message'
        attachments: Attachments to be appended.
        channel: The channel to kick user from
        message: The message text to send
        team: The team workspace
    ### When action = 'kick_from_channel'
        channel: The channel to kick user from
        team: The team workspace
        user: The user to kick from the channel
    ### When action = 'join_channel'
        channel: The channel to kick user from
        team: The team workspace
    ### When action = 'read_channel'
        channel: The channel to kick user from
        team: The team workspace
    ### When action = 'get_channel_history'
        channel: The channel to kick user from
        team: The team workspace
        use_date: Toggle to use dates
    ### When action = 'invite_to_channel'
        channel: The channel to kick user from
        team: The team workspace
        users: Comma-separated list of user IDs to invite
    ### When action = 'leave_channel'
        channel: The channel to kick user from
        team: The team workspace
    ### When action = 'get_channel_members'
        channel: The channel to kick user from
        limit: Maximum number of channels to return
        team: The team workspace
    ### When action = 'close_dm'
        channel: The channel to kick user from
        team: The team workspace
    ### When action = 'rename_channel'
        channel: The channel to kick user from
        name: Name of the channel to create
        team: The team workspace
    ### When action = 'get_channel_replies'
        channel: The channel to kick user from
        team: The team workspace
        thread_ts: Timestamp of the parent message(ISO 8601 or Unix timestamp)
        use_date: Toggle to use dates
    ### When action = 'set_channel_purpose'
        channel: The channel to kick user from
        purpose: Purpose for the channel
        team: The team workspace
    ### When action = 'set_channel_topic'
        channel: The channel to kick user from
        team: The team workspace
        topic: Topic for the channel
    ### When action = 'archive_channel'
        channel: The channel to kick user from
        team: The team workspace
    ### When action = 'unarchive_channel'
        channel: The channel to kick user from
        team: The team workspace
    ### When action = 'read_message'
        channel: The channel to kick user from
        team: The team workspace
        use_date: Toggle to use dates
    ### When action = 'get_message_permalink'
        channel: The channel to kick user from
        team: The team workspace
        timestamp: Timestamp of the message to update(ISO 8601 or timestamp)
    ### When action = 'add_reaction'
        channel: The channel to kick user from
        name: Name of the channel to create
        team: The team workspace
        timestamp: Timestamp of the message to update(ISO 8601 or timestamp)
    ### When action = 'remove_reaction'
        channel: The channel to kick user from
        name: Name of the channel to create
        team: The team workspace
        timestamp: Timestamp of the message to update(ISO 8601 or timestamp)
    ### When action = 'read_reactions'
        channel: The channel to kick user from
        full: Get full reaction details
        team: The team workspace
        timestamp: Timestamp of the message to update(ISO 8601 or timestamp)
    ### When action = 'add_star'
        channel: The channel to kick user from
        file: File ID (if target is file)
        file_comment: File comment ID
        team: The team workspace
        timestamp: Timestamp of the message to update(ISO 8601 or timestamp)
    ### When action = 'remove_star'
        channel: The channel to kick user from
        file: File ID (if target is file)
        file_comment: File comment ID
        team: The team workspace
        timestamp: Timestamp of the message to update(ISO 8601 or timestamp)
    ### When action = 'get_files'
        channel: The channel to kick user from
        show_files_hidden_by_limit: Show files hidden by limit
        team: The team workspace
        ts_from: Files created after this timestamp(ISO 8601 or Unix timestamp)
        ts_to: Files created before this timestamp(ISO 8601 or Unix timestamp)
        types: Types of channels to include (comma-separated)
        use_date: Toggle to use dates
        user: The user to kick from the channel
    ### When action = 'create_user_group'
        channel: The channel to kick user from
        description: Description of the user group
        handle: Handle for the user group
        include_count: Include member count
        name: Name of the channel to create
        team: The team workspace
    ### When action = 'update_user_group'
        channel: The channel to kick user from
        description: Description of the user group
        handle: Handle for the user group
        include_count: Include member count
        name: Name of the channel to create
        team: The team workspace
        usergroup: User group ID to enable
    ### When action = 'read_file'
        count: Number of comments to include
        file: File ID (if target is file)
        page: Page of comments
    ### When action = 'get_channel_history' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_channel_replies' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'read_message' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'search_messages' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_files' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_channel_history' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_channel_replies' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_message' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'search_messages' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_files' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_channels'
        exclude_archived: Exclude archived channels
        limit: Maximum number of channels to return
        types: Types of channels to include (comma-separated)
    ### When action = 'upload_file'
        filename: Name for the uploaded file
        files: File to upload
        initial_comment: Initial comment for the file
        select_team: The team workspace
        share_file_with_channels: Comma separated list of channel IDs to share with
        thread_ts: Timestamp of the parent message(ISO 8601 or Unix timestamp)
        title: Title for the file
    ### When action = 'search_messages'
        highlight: Highlight search terms
        query: Search query
        sort: Sort by (score or timestamp)
        sort_dir: Sort direction (asc or desc)
        use_date: Toggle to use dates
    ### When action = 'enable_user_group'
        include_count: Include member count
        usergroup: User group ID to enable
    ### When action = 'disable_user_group'
        include_count: Include member count
        usergroup: User group ID to enable
    ### When action = 'get_user_groups'
        include_count: Include member count
        include_disabled: Include disabled user groups
        include_users: Include user list
    ### When action = 'get_user_profile'
        include_labels: Include field labels
        team: The team workspace
        user: The user to kick from the channel
    ### When action = 'get_users'
        include_locale: Include locale information for users
        limit: Maximum number of channels to return
        team_id: Team ID to filter users
    ### When action = 'create_channel'
        is_private: Whether the channel should be private
        name: Name of the channel to create
        team: The team workspace
    ### When action = 'get_stars'
        limit: Maximum number of channels to return
    ### When action = 'update_user_profile'
        name: Name of the channel to create
        profile: Profile fields to update (JSON)
        team: The team workspace
        user: The user to kick from the channel
        value: Value for single field update
    ### When action = 'get_channel_history' and use_date = False
        num_messages: Specify the number of messages to fetch
    ### When action = 'get_channel_replies' and use_date = False
        num_messages: Specify the number of messages to fetch
    ### When action = 'read_message' and use_date = False
        num_messages: Specify the number of messages to fetch
    ### When action = 'search_messages' and use_date = False
        num_messages: Specify the number of messages to fetch
    ### When action = 'get_files' and use_date = False
        num_messages: Specify the number of messages to fetch
    ### When action = 'open_dm'
        return_im: Return IM channel
        users: Comma-separated list of user IDs to invite
    ### When action = 'read_user'
        team: The team workspace
        user: The user to kick from the channel
    ### When action = 'get_channel_history' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_channel_replies' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'read_message' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'search_messages' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_files' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_message'
        attachment_names: List of attachment names
        message: List of message texts
        message_details: List of detailed message objects
        sender_id: List of sender IDs
        thread_id: List of thread IDs
        thread_link: List of thread links
        total: Total number of messages
    ### When action = 'get_user_profile'
        avatar_hash: User avatar hash
        display_name: Display name
        email: Email address
        fields: Fields
        phone: Phone number
        raw_data: Raw API response data
        real_name: Real name
        skype: Skype
        status_emoji: Status emoji
        status_expiration: Status expiration
        status_text: Status text
        title: Job title
    ### When action = 'update_message'
        channel: Channel ID
        raw_data: Raw API response data
        text: Updated message text
        timestamp: Timestamp of the updated message
    ### When action = 'delete_message'
        channel: Channel ID
        raw_data: Raw API response data
        success: Whether the message was successfully deleted
        timestamp: Timestamp of the deleted message
    ### When action = 'get_message_permalink'
        channel: Channel ID
        permalink: Permalink to the message
        raw_data: Raw API response data
    ### When action = 'create_channel'
        channel_id: ID of the created channel
        channel_name: Name of the created channel
        raw_data: Raw API response data
    ### When action = 'join_channel'
        channel_id: ID of the joined channel
        channel_name: Name of the joined channel
        raw_data: Raw API response data
    ### When action = 'read_channel'
        channel_id: ID of the channel
        channel_name: Name of the channel
        created: When the channel was created
        creator: Who created the channel
        is_archived: Whether the channel is archived
        is_channel: Whether this is a channel
        is_general: Whether this is the general channel
        is_member: Whether you are a member
        is_private: Whether the channel is private
        purpose: Channel purpose
        raw_data: Raw API response data
        topic: Channel topic
    ### When action = 'invite_to_channel'
        channel_id: ID of the channel
        channel_name: Name of the channel
        raw_data: Raw API response data
    ### When action = 'open_dm'
        channel_id: ID of the opened DM channel
        raw_data: Raw API response data
    ### When action = 'rename_channel'
        channel_id: ID of the renamed channel
        channel_name: New name of the channel
        raw_data: Raw API response data
    ### When action = 'set_channel_purpose'
        channel_id: ID of the channel
        purpose: Purpose that was set
        raw_data: Raw API response data
    ### When action = 'set_channel_topic'
        channel_id: ID of the channel
        raw_data: Raw API response data
        topic: Topic that was set
    ### When action = 'search_messages'
        channel_id: List of matching channel IDs
        channel_name: List of matching channel names
        message_details: List of matching message details
        messages: List of matching messages
        permalink: List of matching permalinks
        query: Query that was searched
        timestamp: List of matching timestamps
        total: Total number of results
        user_id: List of matching user IDs
    ### When action = 'get_channels'
        channel_ids: List of channel IDs
        channel_names: List of channel names
        channels: List of channel objects
        raw_data: Raw API response data
        total: Total number of channels
    ### When action = 'get_stars'
        channels: List of channels
        item_types: List of item types
        items: List of starred items
        raw_data: Raw API response data
        total: Total number of starred items
    ### When action = 'read_file'
        channels: Channels the file is shared in
        comments_count: Number of comments on the file
        created: When the file was created
        file_id: ID of the file
        file_name: Name of the file
        file_size: Size of the file
        file_type: Type of the file
        permalink: Permalink to the file
        raw_data: Raw API response data
        url_private: Private URL for the file
        url_private_download: Private download URL for the file
        user: User who uploaded the file
    ### When action = 'get_files'
        created: When the file was created
        download_urls: Download URL for the file
        file_ids: List of file IDs
        file_names: List of file names
        file_types: List of file types
        files: List of file objects
        permalinks: Permalink to the file
        preview_urls: Preview URL for the file
        raw_files: List of raw file objects
        total: Total number of files
    ### When action = 'update_user_group'
        description: Description of the updated user group
        handle: Handle of the updated user group
        raw_data: Raw API response data
        usergroup_id: ID of the updated user group
        usergroup_name: Name of the updated user group
    ### When action = 'read_user'
        email: Email of the user
        is_admin: Whether the user is an admin
        is_bot: Whether the user is a bot
        is_deleted: Whether the user is deleted
        profile: User profile information
        raw_data: Raw API response data
        real_name: Real name of the user
        user_id: ID of the user
        user_name: Name of the user
    ### When action = 'get_users'
        emails: List of user emails
        is_admin: List of admin status
        is_bot: List of bot status
        is_owner: List of owner status
        raw_data: Raw API response data
        real_names: List of real names
        total: Total number of users
        user_ids: List of user IDs
        user_names: List of user names
        users: List of user objects
    ### When action = 'upload_file'
        file_ids: ID of the uploaded file
        file_names: Name of the uploaded file
        file_sizes: Size of the uploaded file
        file_types: Type of the uploaded file
        permalinks: Permalink to the file
        raw_data: Raw API response data
        url_private: Private URL for the file
        url_private_download: Private download URL for the file
    ### When action = 'enable_user_group'
        is_active: Whether the user group is active
        raw_data: Raw API response data
        usergroup_id: ID of the enabled user group
        usergroup_name: Name of the enabled user group
    ### When action = 'disable_user_group'
        is_active: Whether the user group is active
        raw_data: Raw API response data
        usergroup_id: ID of the disabled user group
        usergroup_name: Name of the disabled user group
    ### When action = 'get_channel_members'
        member_count: Number of members returned
        members: List of member IDs
        raw_data: Raw API response data
    ### When action = 'read_reactions'
        message: Message object
        message_text: Message text
        raw_data: Raw API response data
        reaction_counts: List of reaction counts
        reaction_names: List of reaction names
        reactions: List of reactions
    ### When action = 'get_channel_history'
        message_texts: List of message texts
        message_timestamps: List of message timestamps
        messages: List of message objects
        raw_data: Raw API response data
        total: Total number of messages
    ### When action = 'get_channel_replies'
        message_texts: List of reply message texts
        messages: List of reply messages
        raw_data: Raw API response data
        total: Total number of replies
    ### When action = 'update_user_profile'
        profile: Updated profile information
        raw_data: Raw API response data
        success: Whether the update was successful
    ### When action = 'kick_from_channel'
        raw_data: Raw API response data
        success: Whether the user was successfully kicked
    ### When action = 'leave_channel'
        raw_data: Raw API response data
        success: Whether you successfully left the channel
    ### When action = 'close_dm'
        raw_data: Raw API response data
        success: Whether the DM was successfully closed
    ### When action = 'archive_channel'
        raw_data: Raw API response data
        success: Whether the channel was successfully archived
    ### When action = 'unarchive_channel'
        raw_data: Raw API response data
        success: Whether the channel was successfully unarchived
    ### When action = 'send_message'
        raw_data: Raw API response data
        timestamp: Timestamp of the sent message
    ### When action = 'add_reaction'
        raw_data: Raw API response data
        success: Whether the reaction was successfully added
    ### When action = 'remove_reaction'
        raw_data: Raw API response data
        success: Whether the reaction was successfully removed
    ### When action = 'add_star'
        raw_data: Raw API response data
        success: Whether the star was successfully added
    ### When action = 'remove_star'
        raw_data: Raw API response data
        success: Whether the star was successfully removed
    ### When action = 'create_user_group'
        raw_data: Raw API response data
        user_group_description: Description of the created user group
        user_group_handle: Handle of the created user group
        user_group_id: ID of the created user group
        user_group_name: Name of the created user group
        user_group_user_count: Count of the created user group
        user_group_users: List of user IDs in the user group
    ### When action = 'get_user_groups'
        raw_data: Raw API response data
        usergroup_handles: List of user group handles
        usergroup_ids: List of user group IDs
        usergroup_names: List of user group names
        usergroups: List of user group objects
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Slack>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the channel to create",
                    "label": "Channel Name",
                    "placeholder": "my-new-channel",
                    "order": 4,
                },
                {
                    "field": "is_private",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the channel should be private",
                    "label": "Private Channel",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the created channel",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the created channel",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "create_channel",
            "task_name": "tasks.slack.create_channel",
            "description": "Create a new Slack channel",
            "label": "Create Channel",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "name",
                "is_private",
            ],
        },
        "kick_from_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to kick user from",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "user",
                    "type": "string",
                    "value": "",
                    "helper_text": "The user to kick from the channel",
                    "label": "User",
                    "placeholder": "Select user",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the user was successfully kicked",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "kick_from_channel",
            "task_name": "tasks.slack.kick_from_channel",
            "description": "Kick a user from a Slack channel",
            "label": "Kick From Channel",
            "inputs_sort_order": ["integration", "action", "team", "channel", "user"],
        },
        "join_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to join",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the joined channel",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the joined channel",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "join_channel",
            "task_name": "tasks.slack.join_channel",
            "description": "Join a Slack channel",
            "label": "Join Channel",
            "inputs_sort_order": ["integration", "action", "team", "channel"],
        },
        "read_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to read information about",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the channel",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the channel",
                },
                {
                    "field": "created",
                    "type": "string",
                    "helper_text": "When the channel was created",
                },
                {
                    "field": "creator",
                    "type": "string",
                    "helper_text": "Who created the channel",
                },
                {
                    "field": "is_archived",
                    "type": "bool",
                    "helper_text": "Whether the channel is archived",
                },
                {
                    "field": "is_channel",
                    "type": "bool",
                    "helper_text": "Whether this is a channel",
                },
                {
                    "field": "is_general",
                    "type": "bool",
                    "helper_text": "Whether this is the general channel",
                },
                {
                    "field": "is_member",
                    "type": "bool",
                    "helper_text": "Whether you are a member",
                },
                {
                    "field": "is_private",
                    "type": "bool",
                    "helper_text": "Whether the channel is private",
                },
                {"field": "topic", "type": "string", "helper_text": "Channel topic"},
                {
                    "field": "purpose",
                    "type": "string",
                    "helper_text": "Channel purpose",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_channel",
            "task_name": "tasks.slack.read_channel",
            "description": "Read information about a Slack channel",
            "label": "Read Channel",
            "inputs_sort_order": ["integration", "action", "team", "channel"],
        },
        "get_channels**(*)**(*)": {
            "inputs": [
                {
                    "field": "types",
                    "type": "string",
                    "value": "public_channel",
                    "helper_text": "Types of channels to include (comma-separated)",
                    "label": "Channel Types",
                    "placeholder": "public_channel,private_channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Public Channel", "value": "public_channel"},
                            {"label": "Private Channel", "value": "private_channel"},
                            {"label": "All Types", "value": "all_types"},
                        ],
                    },
                },
                {
                    "field": "exclude_archived",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Exclude archived channels",
                    "label": "Exclude Archived",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of channels to return",
                    "label": "Limit",
                    "placeholder": "10",
                },
            ],
            "outputs": [
                {
                    "field": "channels",
                    "type": "vec<string>",
                    "helper_text": "List of channel objects",
                },
                {
                    "field": "channel_ids",
                    "type": "vec<string>",
                    "helper_text": "List of channel IDs",
                },
                {
                    "field": "channel_names",
                    "type": "vec<string>",
                    "helper_text": "List of channel names",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of channels",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_channels",
            "task_name": "tasks.slack.get_channels",
            "description": "Get a list of Slack channels",
            "label": "Get Channels",
            "inputs_sort_order": [
                "integration",
                "action",
                "types",
                "exclude_archived",
                "limit",
            ],
        },
        "get_channel_history**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to get history from",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "messages",
                    "type": "vec<string>",
                    "helper_text": "List of message objects",
                },
                {
                    "field": "message_texts",
                    "type": "vec<string>",
                    "helper_text": "List of message texts",
                },
                {
                    "field": "message_timestamps",
                    "type": "vec<timestamp>",
                    "helper_text": "List of message timestamps",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of messages",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_channel_history",
            "task_name": "tasks.slack.get_channel_history",
            "description": "Get message history from a Slack channel",
            "label": "Get Channel History",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "get_channel_history**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Messages",
                    "helper_text": "Specify the number of messages to fetch",
                    "hidden": True,
                    "order": 8,
                }
            ],
            "outputs": [],
        },
        "get_channel_history**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "hidden": True,
                    "order": 6,
                }
            ],
            "outputs": [],
        },
        "get_channel_history**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "get_channel_history**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "invite_to_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to invite users to",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "users",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of user IDs to invite",
                    "label": "Users",
                    "placeholder": "user1, user2, user3",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the channel",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the channel",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "invite_to_channel",
            "task_name": "tasks.slack.invite_to_channel",
            "description": "Invite users to a Slack channel",
            "label": "Invite To Channel",
            "inputs_sort_order": ["integration", "action", "team", "channel", "users"],
        },
        "leave_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to leave",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether you successfully left the channel",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "leave_channel",
            "task_name": "tasks.slack.leave_channel",
            "description": "Leave a Slack channel",
            "label": "Leave Channel",
            "inputs_sort_order": ["integration", "action", "team", "channel"],
        },
        "get_channel_members**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to get members from",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of members to return",
                    "label": "Limit",
                    "placeholder": "10",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "members",
                    "type": "vec<string>",
                    "helper_text": "List of member IDs",
                },
                {
                    "field": "member_count",
                    "type": "string",
                    "helper_text": "Number of members returned",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_channel_members",
            "task_name": "tasks.slack.get_channel_members",
            "description": "Get members of a Slack channel",
            "label": "Get Channel Members",
            "inputs_sort_order": ["integration", "action", "team", "channel", "limit"],
        },
        "open_dm**(*)**(*)": {
            "inputs": [
                {
                    "field": "users",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of user IDs to open DM with",
                    "label": "Users",
                    "placeholder": "user1,user2",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "return_im",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Return IM channel",
                    "label": "Return IM",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the opened DM channel",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "open_dm",
            "task_name": "tasks.slack.open_dm",
            "description": "Open a direct message with users",
            "label": "Open DM",
            "inputs_sort_order": ["integration", "action", "users", "return_im"],
        },
        "close_dm**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "Channel ID of the DM to close",
                    "label": "Channel",
                    "placeholder": "C0666666666",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the DM was successfully closed",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "close_dm",
            "task_name": "tasks.slack.close_dm",
            "description": "Close a direct message with users",
            "label": "Close DM",
            "inputs_sort_order": ["integration", "action", "team", "channel"],
        },
        "rename_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to rename",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the channel",
                    "label": "New Name",
                    "placeholder": "my-renamed-channel",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the renamed channel",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "New name of the channel",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "rename_channel",
            "task_name": "tasks.slack.rename_channel",
            "description": "Rename a Slack channel",
            "label": "Rename Channel",
            "inputs_sort_order": ["integration", "action", "team", "channel", "name"],
        },
        "get_channel_replies**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the thread",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "thread_ts",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the parent message(ISO 8601 or Unix timestamp)",
                    "label": "Thread Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "messages",
                    "type": "vec<string>",
                    "helper_text": "List of reply messages",
                },
                {
                    "field": "message_texts",
                    "type": "vec<string>",
                    "helper_text": "List of reply message texts",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of replies",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_channel_replies",
            "task_name": "tasks.slack.get_channel_replies",
            "description": "Get replies to a message thread in a Slack channel",
            "label": "Get Channel Replies",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "thread_ts",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "get_channel_replies**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Channels",
                    "helper_text": "Specify the number of channels to fetch",
                    "hidden": True,
                    "order": 9,
                }
            ],
            "outputs": [],
        },
        "get_channel_replies**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "get_channel_replies**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                    "order": 8,
                }
            ],
            "outputs": [],
        },
        "get_channel_replies**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                    "order": 8,
                }
            ],
            "outputs": [],
        },
        "set_channel_purpose**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to set purpose for",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "purpose",
                    "type": "string",
                    "value": "",
                    "helper_text": "Purpose for the channel",
                    "label": "Purpose",
                    "placeholder": "This channel is for discussing project updates",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the channel",
                },
                {
                    "field": "purpose",
                    "type": "string",
                    "helper_text": "Purpose that was set",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "set_channel_purpose",
            "task_name": "tasks.slack.set_channel_purpose",
            "description": "Set the purpose of a Slack channel",
            "label": "Set Channel Purpose",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "purpose",
            ],
        },
        "set_channel_topic**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to set topic for",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "topic",
                    "type": "string",
                    "value": "",
                    "helper_text": "Topic for the channel",
                    "label": "Topic",
                    "placeholder": "Weekly standup meetings",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the channel",
                },
                {
                    "field": "topic",
                    "type": "string",
                    "helper_text": "Topic that was set",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "set_channel_topic",
            "task_name": "tasks.slack.set_channel_topic",
            "description": "Set the topic of a Slack channel",
            "label": "Set Channel Topic",
            "inputs_sort_order": ["integration", "action", "team", "channel", "topic"],
        },
        "archive_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to archive",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the channel was successfully archived",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "archive_channel",
            "task_name": "tasks.slack.archive_channel",
            "description": "Archive a Slack channel",
            "label": "Archive Channel",
            "inputs_sort_order": ["integration", "action", "team", "channel"],
        },
        "unarchive_channel**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to unarchive",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the channel was successfully unarchived",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "unarchive_channel",
            "task_name": "tasks.slack.unarchive_channel",
            "description": "Unarchive a Slack channel",
            "label": "Unarchive Channel",
            "inputs_sort_order": ["integration", "action", "team", "channel"],
        },
        "send_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to send message to",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "helper_text": "The message text to send",
                    "label": "Message",
                    "placeholder": "Hello, world!",
                    "order": 5,
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "value": [],
                    "label": "Attachments",
                    "placeholder": "Attachments!",
                    "helper_text": "Attachments to be appended.",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "timestamp",
                    "type": "timestamp",
                    "helper_text": "Timestamp of the sent message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "send_message",
            "task_name": "tasks.slack.create_message",
            "description": "Send a message to a Slack channel",
            "label": "Send Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "message",
                "attachments",
            ],
        },
        "read_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel to read messages from",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "message",
                    "type": "vec<string>",
                    "helper_text": "List of message texts",
                },
                {
                    "field": "thread_id",
                    "type": "vec<string>",
                    "helper_text": "List of thread IDs",
                },
                {
                    "field": "attachment_names",
                    "type": "vec<string>",
                    "helper_text": "List of attachment names",
                },
                {
                    "field": "sender_id",
                    "type": "vec<string>",
                    "helper_text": "List of sender IDs",
                },
                {
                    "field": "thread_link",
                    "type": "vec<string>",
                    "helper_text": "List of thread links",
                },
                {
                    "field": "message_details",
                    "type": "vec<string>",
                    "helper_text": "List of detailed message objects",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of messages",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_message",
            "task_name": "tasks.slack.read_messages",
            "description": "Read messages from a Slack channel",
            "label": "Read Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "read_message**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Messages",
                    "helper_text": "Specify the number of messages to fetch",
                    "hidden": True,
                    "order": 8,
                }
            ],
            "outputs": [],
        },
        "read_message**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "order": 6,
                }
            ],
            "outputs": [],
        },
        "read_message**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "read_message**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "update_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the message",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the message to update(ISO 8601 or timestamp)",
                    "label": "Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "helper_text": "New message text",
                    "label": "Message",
                    "placeholder": "Updated message text",
                    "order": 6,
                },
                {
                    "field": "blocks",
                    "type": "string",
                    "value": "",
                    "helper_text": "Block kit blocks (JSON)",
                    "label": "Blocks",
                    "placeholder": "Blocks",
                    "order": 7,
                },
                {
                    "field": "as_user",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update as user",
                    "label": "As User",
                    "order": 9,
                },
            ],
            "outputs": [
                {
                    "field": "timestamp",
                    "type": "timestamp",
                    "helper_text": "Timestamp of the updated message",
                },
                {"field": "channel", "type": "string", "helper_text": "Channel ID"},
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "Updated message text",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_message",
            "task_name": "tasks.slack.update_message",
            "description": "Update a message in Slack",
            "label": "Update Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "timestamp",
                "message",
                "blocks",
                "as_user",
            ],
        },
        "delete_message**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the message",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the message to delete(ISO 8601 or Unix timestamp)",
                    "label": "Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
                {
                    "field": "as_user",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Delete as user",
                    "label": "As User",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was successfully deleted",
                },
                {"field": "channel", "type": "string", "helper_text": "Channel ID"},
                {
                    "field": "timestamp",
                    "type": "timestamp",
                    "helper_text": "Timestamp of the deleted message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "delete_message",
            "task_name": "tasks.slack.delete_message",
            "description": "Delete a message in Slack",
            "label": "Delete Message",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "timestamp",
                "as_user",
            ],
        },
        "get_message_permalink**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the message",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the message(ISO 8601 or Unix timestamp)",
                    "label": "Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "permalink",
                    "type": "string",
                    "helper_text": "Permalink to the message",
                },
                {"field": "channel", "type": "string", "helper_text": "Channel ID"},
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_message_permalink",
            "task_name": "tasks.slack.get_message_permalink",
            "description": "Get a permalink to a Slack message",
            "label": "Get Message Permalink",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "timestamp",
            ],
        },
        "search_messages**(*)**(*)": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "helper_text": "Search query",
                    "label": "Query",
                    "placeholder": "hello world",
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                    "order": 5,
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "score",
                    "helper_text": "Sort by (score or timestamp)",
                    "label": "Sort",
                    "placeholder": "score",
                    "order": 4,
                },
                {
                    "field": "sort_dir",
                    "type": "string",
                    "value": "desc",
                    "helper_text": "Sort direction (asc or desc)",
                    "label": "Sort Direction",
                    "placeholder": "desc",
                    "order": 5,
                },
                {
                    "field": "highlight",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Highlight search terms",
                    "label": "Highlight",
                    "order": 8,
                },
            ],
            "outputs": [
                {
                    "field": "messages",
                    "type": "vec<string>",
                    "helper_text": "List of matching messages",
                },
                {
                    "field": "channel_id",
                    "type": "vec<string>",
                    "helper_text": "List of matching channel IDs",
                },
                {
                    "field": "channel_name",
                    "type": "vec<string>",
                    "helper_text": "List of matching channel names",
                },
                {
                    "field": "user_id",
                    "type": "vec<string>",
                    "helper_text": "List of matching user IDs",
                },
                {
                    "field": "timestamp",
                    "type": "vec<string>",
                    "helper_text": "List of matching timestamps",
                },
                {
                    "field": "permalink",
                    "type": "vec<string>",
                    "helper_text": "List of matching permalinks",
                },
                {
                    "field": "message_details",
                    "type": "vec<string>",
                    "helper_text": "List of matching message details",
                },
                {
                    "field": "total",
                    "type": "string",
                    "helper_text": "Total number of results",
                },
                {
                    "field": "query",
                    "type": "string",
                    "helper_text": "Query that was searched",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "search_messages",
            "task_name": "tasks.slack.search_messages",
            "description": "Search for messages in Slack",
            "label": "Search Messages",
            "inputs_sort_order": [
                "integration",
                "action",
                "query",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "sort",
                "sort_dir",
                "highlight",
            ],
        },
        "search_messages**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Messages",
                    "helper_text": "Specify the number of messages to fetch",
                    "hidden": True,
                    "order": 8,
                }
            ],
            "outputs": [],
        },
        "search_messages**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "order": 6,
                }
            ],
            "outputs": [],
        },
        "search_messages**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "search_messages**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "add_reaction**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the message",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the message(ISO 8601 or Unix timestamp)",
                    "label": "Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the emoji reaction",
                    "label": "Emoji Name",
                    "placeholder": "Select emoji",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=emoji&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the reaction was successfully added",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "add_reaction",
            "task_name": "tasks.slack.add_reaction",
            "description": "Add a reaction to a Slack message",
            "label": "Add Reaction",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "timestamp",
                "name",
            ],
        },
        "remove_reaction**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the message",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the message(ISO 8601 or Unix timestamp)",
                    "label": "Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the emoji reaction",
                    "label": "Emoji Name",
                    "placeholder": "Select emoji",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=emoji&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the reaction was successfully removed",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "remove_reaction",
            "task_name": "tasks.slack.remove_reaction",
            "description": "Remove a reaction from a Slack message",
            "label": "Remove Reaction",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "timestamp",
                "name",
            ],
        },
        "read_reactions**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the message",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the message(ISO 8601 or Unix timestamp)",
                    "label": "Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
                {
                    "field": "full",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Get full reaction details",
                    "label": "Full Details",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "reactions",
                    "type": "vec<string>",
                    "helper_text": "List of reactions",
                },
                {
                    "field": "reaction_names",
                    "type": "vec<string>",
                    "helper_text": "List of reaction names",
                },
                {
                    "field": "reaction_counts",
                    "type": "vec<string>",
                    "helper_text": "List of reaction counts",
                },
                {"field": "message", "type": "string", "helper_text": "Message object"},
                {
                    "field": "message_text",
                    "type": "string",
                    "helper_text": "Message text",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_reactions",
            "task_name": "tasks.slack.read_reactions",
            "description": "Read reactions from a Slack message",
            "label": "Read Reactions",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "timestamp",
                "full",
            ],
        },
        "add_star**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the item",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the message (if target is message)(ISO 8601 or Unix timestamp)",
                    "label": "Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
                {
                    "field": "file",
                    "type": "string",
                    "value": "",
                    "helper_text": "File ID (if target is file)",
                    "label": "File",
                    "placeholder": "F1234567890",
                    "order": 6,
                },
                {
                    "field": "file_comment",
                    "type": "string",
                    "value": "",
                    "helper_text": "File comment ID",
                    "label": "File Comment",
                    "placeholder": "Optional file comment ID",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the star was successfully added",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "add_star",
            "task_name": "tasks.slack.add_star",
            "description": "Add a star to a Slack item",
            "label": "Add Star",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "timestamp",
                "file",
                "file_comment",
            ],
        },
        "remove_star**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "The channel containing the item",
                    "label": "Channel",
                    "placeholder": "General",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timestamp of the message(ISO 8601 or Unix timestamp)",
                    "label": "Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 5,
                },
                {
                    "field": "file",
                    "type": "string",
                    "value": "",
                    "helper_text": "File ID",
                    "label": "File",
                    "placeholder": "F1234567890",
                    "order": 6,
                },
                {
                    "field": "file_comment",
                    "type": "string",
                    "value": "",
                    "helper_text": "File comment ID",
                    "label": "File Comment",
                    "placeholder": "Optional file comment ID",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the star was successfully removed",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "remove_star",
            "task_name": "tasks.slack.remove_star",
            "description": "Remove a star from a Slack item",
            "label": "Remove Star",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "timestamp",
                "file",
                "file_comment",
            ],
        },
        "get_stars**(*)**(*)": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of stars to return",
                    "label": "Limit",
                    "placeholder": "10",
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "items",
                    "type": "vec<string>",
                    "helper_text": "List of starred items",
                },
                {
                    "field": "item_types",
                    "type": "vec<string>",
                    "helper_text": "List of item types",
                },
                {
                    "field": "channels",
                    "type": "vec<string>",
                    "helper_text": "List of channels",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of starred items",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_stars",
            "task_name": "tasks.slack.get_stars",
            "description": "Get starred items in Slack",
            "label": "Get Stars",
            "inputs_sort_order": ["integration", "action", "limit"],
        },
        "upload_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "files",
                    "type": "vec<file>",
                    "value": [],
                    "helper_text": "File to upload",
                    "label": "File",
                    "placeholder": "Select file to upload",
                    "order": 3,
                },
                {
                    "field": "filename",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name for the uploaded file",
                    "label": "Filename",
                    "placeholder": "document.txt",
                    "order": 4,
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Title for the file",
                    "label": "Title",
                    "placeholder": "My Document",
                    "order": 5,
                },
                {
                    "field": "select_team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "share_file_with_channels",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma separated list of channel IDs to share with",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.select_team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "initial_comment",
                    "type": "string",
                    "value": "",
                    "helper_text": "Initial comment for the file",
                    "label": "Initial Comment",
                    "placeholder": "Here's the file you requested",
                    "order": 8,
                },
                {
                    "field": "thread_ts",
                    "type": "string",
                    "value": "",
                    "helper_text": "Thread timestamp to reply to(ISO 8601 or Unix timestamp)",
                    "label": "Thread Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 9,
                },
            ],
            "outputs": [
                {
                    "field": "file_ids",
                    "type": "vec<string>",
                    "helper_text": "ID of the uploaded file",
                },
                {
                    "field": "file_names",
                    "type": "vec<string>",
                    "helper_text": "Name of the uploaded file",
                },
                {
                    "field": "file_types",
                    "type": "vec<string>",
                    "helper_text": "Type of the uploaded file",
                },
                {
                    "field": "file_sizes",
                    "type": "vec<string>",
                    "helper_text": "Size of the uploaded file",
                },
                {
                    "field": "url_private",
                    "type": "string",
                    "helper_text": "Private URL for the file",
                },
                {
                    "field": "url_private_download",
                    "type": "string",
                    "helper_text": "Private download URL for the file",
                },
                {
                    "field": "permalinks",
                    "type": "vec<string>",
                    "helper_text": "Permalink to the file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "upload_file",
            "task_name": "tasks.slack.upload_file",
            "description": "Upload a file to Slack",
            "label": "Upload File",
            "inputs_sort_order": [
                "integration",
                "action",
                "files",
                "filename",
                "title",
                "select_team",
                "share_file_with_channels",
                "initial_comment",
                "thread_ts",
            ],
        },
        "read_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "file",
                    "type": "string",
                    "value": "",
                    "helper_text": "File ID to read",
                    "label": "File",
                    "placeholder": "F1234567890",
                    "order": 3,
                },
                {
                    "field": "count",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Number of comments to include",
                    "label": "Comment Count",
                    "placeholder": "10",
                    "order": 4,
                },
                {
                    "field": "page",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "Page of comments",
                    "label": "Comment Page",
                    "placeholder": "1",
                    "order": 5,
                },
            ],
            "outputs": [
                {"field": "file_id", "type": "string", "helper_text": "ID of the file"},
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the file",
                },
                {
                    "field": "file_type",
                    "type": "string",
                    "helper_text": "Type of the file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the file",
                },
                {
                    "field": "created",
                    "type": "timestamp",
                    "helper_text": "When the file was created",
                },
                {
                    "field": "user",
                    "type": "string",
                    "helper_text": "User who uploaded the file",
                },
                {
                    "field": "url_private",
                    "type": "string",
                    "helper_text": "Private URL for the file",
                },
                {
                    "field": "url_private_download",
                    "type": "string",
                    "helper_text": "Private download URL for the file",
                },
                {
                    "field": "permalink",
                    "type": "string",
                    "helper_text": "Permalink to the file",
                },
                {
                    "field": "channels",
                    "type": "vec<string>",
                    "helper_text": "Channels the file is shared in",
                },
                {
                    "field": "comments_count",
                    "type": "string",
                    "helper_text": "Number of comments on the file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_file",
            "task_name": "tasks.slack.read_file",
            "description": "Read information about a Slack file",
            "label": "Read File",
            "inputs_sort_order": ["integration", "action", "file", "count", "page"],
            "required": ["file", "count"],
        },
        "get_files**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by channel",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "user",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by user",
                    "label": "User",
                    "placeholder": "Select user",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "types",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by file types (comma-separated)",
                    "label": "Types",
                    "placeholder": "images,docs",
                    "order": 6,
                },
                {
                    "field": "ts_from",
                    "type": "string",
                    "value": "",
                    "helper_text": "Files created after this timestamp(ISO 8601 or Unix timestamp)",
                    "label": "From Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 7,
                },
                {
                    "field": "ts_to",
                    "type": "string",
                    "value": "",
                    "helper_text": "Files created before this timestamp(ISO 8601 or Unix timestamp)",
                    "label": "To Timestamp",
                    "placeholder": "2006-01-02T15:04:05.999999999-07:00",
                    "order": 8,
                },
                {
                    "field": "show_files_hidden_by_limit",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Show files hidden by limit",
                    "label": "Show Hidden Files",
                    "order": 9,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "List of file objects",
                },
                {
                    "field": "file_ids",
                    "type": "vec<string>",
                    "helper_text": "List of file IDs",
                },
                {
                    "field": "file_names",
                    "type": "vec<string>",
                    "helper_text": "List of file names",
                },
                {
                    "field": "file_types",
                    "type": "vec<string>",
                    "helper_text": "List of file types",
                },
                {
                    "field": "created",
                    "type": "vec<timestamp>",
                    "helper_text": "When the file was created",
                },
                {
                    "field": "preview_urls",
                    "type": "vec<string>",
                    "helper_text": "Preview URL for the file",
                },
                {
                    "field": "download_urls",
                    "type": "vec<string>",
                    "helper_text": "Download URL for the file",
                },
                {
                    "field": "permalinks",
                    "type": "vec<string>",
                    "helper_text": "Permalink to the file",
                },
                {
                    "field": "raw_files",
                    "type": "vec<string>",
                    "helper_text": "List of raw file objects",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of files",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_files",
            "task_name": "tasks.slack.get_files",
            "description": "Get files from Slack",
            "label": "Get Files",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "channel",
                "user",
                "types",
                "ts_from",
                "ts_to",
                "show_files_hidden_by_limit",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "get_files**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Files",
                    "helper_text": "Specify the number of files to fetch",
                    "hidden": True,
                    "order": 8,
                }
            ],
            "outputs": [],
        },
        "get_files**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "order": 6,
                }
            ],
            "outputs": [],
        },
        "get_files**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "get_files**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "read_user**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "user",
                    "type": "string",
                    "value": "",
                    "helper_text": "User ID to read",
                    "label": "User",
                    "placeholder": "Select user",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {"field": "user_id", "type": "string", "helper_text": "ID of the user"},
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Name of the user",
                },
                {
                    "field": "real_name",
                    "type": "string",
                    "helper_text": "Real name of the user",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "Email of the user",
                },
                {
                    "field": "is_admin",
                    "type": "bool",
                    "helper_text": "Whether the user is an admin",
                },
                {
                    "field": "is_bot",
                    "type": "bool",
                    "helper_text": "Whether the user is a bot",
                },
                {
                    "field": "is_deleted",
                    "type": "bool",
                    "helper_text": "Whether the user is deleted",
                },
                {
                    "field": "profile",
                    "type": "string",
                    "helper_text": "User profile information",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_user",
            "task_name": "tasks.slack.read_user",
            "description": "Read information about a Slack user",
            "label": "Read User",
            "inputs_sort_order": ["integration", "action", "team", "user"],
        },
        "get_users**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Team ID to filter users",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of users to return",
                    "label": "Limit",
                    "placeholder": "10",
                    "order": 4,
                },
                {
                    "field": "include_locale",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include locale information for users",
                    "label": "Include Locale",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "users",
                    "type": "vec<string>",
                    "helper_text": "List of user objects",
                },
                {
                    "field": "user_ids",
                    "type": "vec<string>",
                    "helper_text": "List of user IDs",
                },
                {
                    "field": "user_names",
                    "type": "vec<string>",
                    "helper_text": "List of user names",
                },
                {
                    "field": "real_names",
                    "type": "vec<string>",
                    "helper_text": "List of real names",
                },
                {
                    "field": "emails",
                    "type": "vec<string>",
                    "helper_text": "List of user emails",
                },
                {
                    "field": "is_admin",
                    "type": "vec<bool>",
                    "helper_text": "List of admin status",
                },
                {
                    "field": "is_owner",
                    "type": "vec<bool>",
                    "helper_text": "List of owner status",
                },
                {
                    "field": "is_bot",
                    "type": "vec<bool>",
                    "helper_text": "List of bot status",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of users",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_users",
            "task_name": "tasks.slack.get_users",
            "description": "Get users from Slack",
            "label": "Get Users",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "limit",
                "include_locale",
            ],
        },
        "get_user_profile**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "user",
                    "type": "string",
                    "value": "",
                    "helper_text": "User ID to get profile for",
                    "label": "User",
                    "placeholder": "Select user",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "include_labels",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include field labels",
                    "label": "Include Labels",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "avatar_hash",
                    "type": "string",
                    "helper_text": "User avatar hash",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "Display name",
                },
                {"field": "real_name", "type": "string", "helper_text": "Real name"},
                {"field": "email", "type": "string", "helper_text": "Email address"},
                {"field": "phone", "type": "string", "helper_text": "Phone number"},
                {"field": "title", "type": "string", "helper_text": "Job title"},
                {
                    "field": "status_text",
                    "type": "string",
                    "helper_text": "Status text",
                },
                {
                    "field": "status_emoji",
                    "type": "string",
                    "helper_text": "Status emoji",
                },
                {
                    "field": "status_expiration",
                    "type": "string",
                    "helper_text": "Status expiration",
                },
                {"field": "skype", "type": "string", "helper_text": "Skype"},
                {"field": "fields", "type": "string", "helper_text": "Fields"},
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_user_profile",
            "task_name": "tasks.slack.get_user_profile",
            "description": "Get profile information for a Slack user",
            "label": "Get User Profile",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "user",
                "include_labels",
            ],
        },
        "update_user_profile**(*)**(*)": {
            "inputs": [
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "user",
                    "type": "string",
                    "value": "",
                    "helper_text": "User ID to update profile for",
                    "label": "User",
                    "placeholder": "Select user",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "profile",
                    "type": "string",
                    "value": "",
                    "helper_text": "Profile fields to update (JSON)",
                    "label": "Profile",
                    "placeholder": '{"display_name": "New Name"}',
                    "order": 5,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Single field name to update",
                    "label": "Field Name",
                    "placeholder": "display_name",
                    "order": 6,
                },
                {
                    "field": "value",
                    "type": "string",
                    "value": "",
                    "helper_text": "Value for single field update",
                    "label": "Field Value",
                    "placeholder": "New Name",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "profile",
                    "type": "string",
                    "helper_text": "Updated profile information",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the update was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_user_profile",
            "task_name": "tasks.slack.update_user_profile",
            "description": "Update profile information for a Slack user",
            "label": "Update User Profile",
            "inputs_sort_order": [
                "integration",
                "action",
                "team",
                "user",
                "profile",
                "name",
                "value",
            ],
        },
        "create_user_group**(*)**(*)": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the user group",
                    "label": "Name",
                    "placeholder": "engineering-team",
                    "order": 3,
                },
                {
                    "field": "handle",
                    "type": "string",
                    "value": "",
                    "helper_text": "Handle for the user group",
                    "label": "Handle",
                    "placeholder": "engineering",
                    "order": 4,
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the user group",
                    "label": "Description",
                    "placeholder": "Engineering team members",
                    "order": 5,
                },
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma separated list of channel IDs",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "include_count",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Include member count",
                    "label": "Include Count",
                    "order": 8,
                },
            ],
            "outputs": [
                {
                    "field": "user_group_id",
                    "type": "string",
                    "helper_text": "ID of the created user group",
                },
                {
                    "field": "user_group_name",
                    "type": "string",
                    "helper_text": "Name of the created user group",
                },
                {
                    "field": "user_group_users",
                    "type": "vec<string>",
                    "helper_text": "List of user IDs in the user group",
                },
                {
                    "field": "user_group_user_count",
                    "type": "int32",
                    "helper_text": "Count of the created user group",
                },
                {
                    "field": "user_group_handle",
                    "type": "string",
                    "helper_text": "Handle of the created user group",
                },
                {
                    "field": "user_group_description",
                    "type": "string",
                    "helper_text": "Description of the created user group",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_user_group",
            "task_name": "tasks.slack.create_user_group",
            "description": "Create a new user group in Slack",
            "label": "Create User Group",
            "inputs_sort_order": [
                "integration",
                "action",
                "name",
                "handle",
                "description",
                "team",
                "channel",
                "include_count",
            ],
        },
        "enable_user_group**(*)**(*)": {
            "inputs": [
                {
                    "field": "usergroup",
                    "type": "string",
                    "value": "",
                    "helper_text": "User group ID to enable",
                    "label": "User Group",
                    "placeholder": "Select user group",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_group&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "include_count",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include member count",
                    "label": "Include Count",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "usergroup_id",
                    "type": "string",
                    "helper_text": "ID of the enabled user group",
                },
                {
                    "field": "usergroup_name",
                    "type": "string",
                    "helper_text": "Name of the enabled user group",
                },
                {
                    "field": "is_active",
                    "type": "bool",
                    "helper_text": "Whether the user group is active",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "enable_user_group",
            "task_name": "tasks.slack.enable_user_group",
            "description": "Enable a user group in Slack",
            "label": "Enable User Group",
            "inputs_sort_order": [
                "integration",
                "action",
                "usergroup",
                "include_count",
            ],
        },
        "disable_user_group**(*)**(*)": {
            "inputs": [
                {
                    "field": "usergroup",
                    "type": "string",
                    "value": "",
                    "helper_text": "User group ID to disable",
                    "label": "User Group",
                    "placeholder": "Select user group",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_group&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "include_count",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include member count",
                    "label": "Include Count",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "usergroup_id",
                    "type": "string",
                    "helper_text": "ID of the disabled user group",
                },
                {
                    "field": "usergroup_name",
                    "type": "string",
                    "helper_text": "Name of the disabled user group",
                },
                {
                    "field": "is_active",
                    "type": "bool",
                    "helper_text": "Whether the user group is active",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "disable_user_group",
            "task_name": "tasks.slack.disable_user_group",
            "description": "Disable a user group in Slack",
            "label": "Disable User Group",
            "inputs_sort_order": [
                "integration",
                "action",
                "usergroup",
                "include_count",
            ],
        },
        "get_user_groups**(*)**(*)": {
            "inputs": [
                {
                    "field": "include_disabled",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include disabled user groups",
                    "label": "Include Disabled",
                    "order": 3,
                },
                {
                    "field": "include_count",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include member count",
                    "label": "Include Count",
                    "order": 4,
                },
                {
                    "field": "include_users",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include user list",
                    "label": "Include Users",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "usergroups",
                    "type": "vec<string>",
                    "helper_text": "List of user group objects",
                },
                {
                    "field": "usergroup_ids",
                    "type": "vec<string>",
                    "helper_text": "List of user group IDs",
                },
                {
                    "field": "usergroup_names",
                    "type": "vec<string>",
                    "helper_text": "List of user group names",
                },
                {
                    "field": "usergroup_handles",
                    "type": "vec<string>",
                    "helper_text": "List of user group handles",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_user_groups",
            "task_name": "tasks.slack.get_user_groups",
            "description": "Get user groups from Slack",
            "label": "Get User Groups",
            "inputs_sort_order": [
                "integration",
                "action",
                "include_disabled",
                "include_count",
                "include_users",
            ],
        },
        "update_user_group**(*)**(*)": {
            "inputs": [
                {
                    "field": "usergroup",
                    "type": "string",
                    "value": "",
                    "helper_text": "User group ID to update",
                    "label": "User Group",
                    "placeholder": "Select user group",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_group&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the user group",
                    "label": "Name",
                    "placeholder": "new-engineering-team",
                    "order": 4,
                },
                {
                    "field": "handle",
                    "type": "string",
                    "value": "",
                    "helper_text": "New handle for the user group",
                    "label": "Handle",
                    "placeholder": "new-engineering",
                    "order": 5,
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the user group",
                    "label": "Description",
                    "placeholder": "Updated engineering team",
                    "order": 6,
                },
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "helper_text": "The team workspace",
                    "label": "Team",
                    "placeholder": "Vectorshift",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "channel",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma separated list of channel IDs",
                    "label": "Channel",
                    "placeholder": "Select channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel_name&team={inputs.team}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 8,
                },
                {
                    "field": "include_count",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include member count",
                    "label": "Include Count",
                    "order": 9,
                },
            ],
            "outputs": [
                {
                    "field": "usergroup_id",
                    "type": "string",
                    "helper_text": "ID of the updated user group",
                },
                {
                    "field": "usergroup_name",
                    "type": "string",
                    "helper_text": "Name of the updated user group",
                },
                {
                    "field": "handle",
                    "type": "string",
                    "helper_text": "Handle of the updated user group",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Description of the updated user group",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_user_group",
            "task_name": "tasks.slack.update_user_group",
            "description": "Update a user group in Slack",
            "label": "Update User Group",
            "inputs_sort_order": [
                "integration",
                "action",
                "usergroup",
                "name",
                "handle",
                "description",
                "team",
                "channel",
                "include_count",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        as_user: bool = False,
        attachments: List[str] = [],
        blocks: str = "",
        channel: str = "",
        count: int = 10,
        description: str = "",
        exact_date: Any = {"start": "", "end": ""},
        exclude_archived: bool = True,
        file: str = "",
        file_comment: str = "",
        filename: str = "",
        files: List[str] = [],
        full: bool = False,
        handle: str = "",
        highlight: bool = True,
        include_count: bool = True,
        include_disabled: bool = False,
        include_labels: bool = False,
        include_locale: bool = False,
        include_users: bool = False,
        initial_comment: str = "",
        is_private: bool = False,
        limit: int = 10,
        message: str = "",
        name: str = "",
        num_messages: int = 10,
        page: int = 1,
        profile: str = "",
        purpose: str = "",
        query: str = "",
        return_im: bool = True,
        select_team: str = "",
        share_file_with_channels: str = "",
        show_files_hidden_by_limit: bool = False,
        sort: str = "score",
        sort_dir: str = "desc",
        team: str = "",
        team_id: str = "",
        thread_ts: str = "",
        timestamp: str = "",
        title: str = "",
        topic: str = "",
        ts_from: str = "",
        ts_to: str = "",
        types: str = "public_channel",
        user: str = "",
        usergroup: str = "",
        users: str = "",
        value: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_slack",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team is not None:
            self.inputs["team"] = team
        if name is not None:
            self.inputs["name"] = name
        if is_private is not None:
            self.inputs["is_private"] = is_private
        if channel is not None:
            self.inputs["channel"] = channel
        if user is not None:
            self.inputs["user"] = user
        if types is not None:
            self.inputs["types"] = types
        if exclude_archived is not None:
            self.inputs["exclude_archived"] = exclude_archived
        if limit is not None:
            self.inputs["limit"] = limit
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if users is not None:
            self.inputs["users"] = users
        if return_im is not None:
            self.inputs["return_im"] = return_im
        if thread_ts is not None:
            self.inputs["thread_ts"] = thread_ts
        if purpose is not None:
            self.inputs["purpose"] = purpose
        if topic is not None:
            self.inputs["topic"] = topic
        if message is not None:
            self.inputs["message"] = message
        if attachments is not None:
            self.inputs["attachments"] = attachments
        if timestamp is not None:
            self.inputs["timestamp"] = timestamp
        if blocks is not None:
            self.inputs["blocks"] = blocks
        if as_user is not None:
            self.inputs["as_user"] = as_user
        if query is not None:
            self.inputs["query"] = query
        if sort is not None:
            self.inputs["sort"] = sort
        if sort_dir is not None:
            self.inputs["sort_dir"] = sort_dir
        if highlight is not None:
            self.inputs["highlight"] = highlight
        if full is not None:
            self.inputs["full"] = full
        if file is not None:
            self.inputs["file"] = file
        if file_comment is not None:
            self.inputs["file_comment"] = file_comment
        if files is not None:
            self.inputs["files"] = files
        if filename is not None:
            self.inputs["filename"] = filename
        if title is not None:
            self.inputs["title"] = title
        if select_team is not None:
            self.inputs["select_team"] = select_team
        if share_file_with_channels is not None:
            self.inputs["share_file_with_channels"] = share_file_with_channels
        if initial_comment is not None:
            self.inputs["initial_comment"] = initial_comment
        if count is not None:
            self.inputs["count"] = count
        if page is not None:
            self.inputs["page"] = page
        if ts_from is not None:
            self.inputs["ts_from"] = ts_from
        if ts_to is not None:
            self.inputs["ts_to"] = ts_to
        if show_files_hidden_by_limit is not None:
            self.inputs["show_files_hidden_by_limit"] = show_files_hidden_by_limit
        if team_id is not None:
            self.inputs["team_id"] = team_id
        if include_locale is not None:
            self.inputs["include_locale"] = include_locale
        if include_labels is not None:
            self.inputs["include_labels"] = include_labels
        if profile is not None:
            self.inputs["profile"] = profile
        if value is not None:
            self.inputs["value"] = value
        if handle is not None:
            self.inputs["handle"] = handle
        if description is not None:
            self.inputs["description"] = description
        if include_count is not None:
            self.inputs["include_count"] = include_count
        if usergroup is not None:
            self.inputs["usergroup"] = usergroup
        if include_disabled is not None:
            self.inputs["include_disabled"] = include_disabled
        if include_users is not None:
            self.inputs["include_users"] = include_users
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSlackNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_asana")
class IntegrationAsanaNode(Node):
    """
    Asana

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your Asana account
    ### get_projects
        archived: Whether to include archived projects in the results
        limit: Maximum number of projects to return (1-100)
        team: The team to create the project in
        workspace: The Asana workspace
    ### create_task
        assignee: Email of the person to assign the task to
        due_on: Due date for the task (YYYY-MM-DD format)
        name: The name of the project to create
        notes: Notes or description for the project
        project: The project to create the task in
        section: The section to create the task in
        workspace: The Asana workspace
    ### get_tasks
        assignee: Email of the person to assign the task to
        completed_since: Only return tasks completed after this time (optional)
        project: The project to create the task in
        workspace: The Asana workspace
    ### update_task
        assignee: Email of the person to assign the task to
        completed: Whether to mark the task as completed
        due_on: Due date for the task (YYYY-MM-DD format)
        name: The name of the project to create
        notes: Notes or description for the project
        project: The project to create the task in
        section: The section to create the task in
        task: The task to get details from
        workspace: The Asana workspace
    ### search_tasks
        assignee: Email of the person to assign the task to
        project: The project to create the task in
        text: Text to search for in task names and descriptions
        workspace: The Asana workspace
    ### create_subtask
        assignee: Email of the person to assign the task to
        name: The name of the project to create
        notes: Notes or description for the project
        parent: The task to create the subtask in
        project: The project to create the task in
        section: The section to create the task in
        workspace: The Asana workspace
    ### remove_task_comment
        comment_gid: The global ID of the comment to remove
    ### get_subtasks
        limit: Maximum number of projects to return (1-100)
        parent: The task to create the subtask in
        project: The project to create the task in
        section: The section to create the task in
        workspace: The Asana workspace
    ### create_project
        name: The name of the project to create
        notes: Notes or description for the project
        public: Whether the project should be public
        team: The team to create the project in
        workspace: The Asana workspace
    ### update_project
        name: The name of the project to create
        notes: Notes or description for the project
        project: The project to create the task in
        public: Whether the project should be public
        workspace: The Asana workspace
    ### add_task_comment
        parent: The task to create the subtask in
        project: The project to create the task in
        section: The section to create the task in
        text: Text to search for in task names and descriptions
        workspace: The Asana workspace
    ### read_project
        project: The project to create the task in
        workspace: The Asana workspace
    ### delete_project
        project: The project to create the task in
        workspace: The Asana workspace
    ### read_task
        project: The project to create the task in
        section: The section to create the task in
        task: The task to get details from
        workspace: The Asana workspace
    ### delete_task
        project: The project to create the task in
        section: The section to create the task in
        task: The task to get details from
        workspace: The Asana workspace
    ### move_task
        project: The project to create the task in
        section: The section to create the task in
        target_project: The project to move the task to
        target_section: The section within the project to move the task to (optional)
        target_workspace: The Asana workspace to move the task to
        task: The task to get details from
        workspace: The Asana workspace
    ### add_task_tag
        project: The project to create the task in
        tag: The tag to add
        task: The task to get details from
        workspace: The Asana workspace
    ### add_task_project
        project: The project to create the task in
        section: The section to create the task in
        task: The task to get details from
    ### remove_task_project
        project: The project to create the task in
        task: The task to get details from
    ### remove_task_tag
        tag: The tag to add
        task: The task to get details from
    ### read_user
        user_gid: The global ID of the user to retrieve (optional, defaults to current user)
    ### get_users
        workspace: The Asana workspace

    ## Outputs
    ### read_task
        assignee_name: The name of the assignee
        completed: Whether the task is completed
        created_at: When the task was created
        data: The full response data from Asana API
        due_on: The due date of the task
        modified_at: When the task was last modified
        task_gid: The global ID of the task
        task_name: The name of the task
        task_notes: The notes/description of the task
    ### add_task_comment
        author_name: The name of the comment author
        comment_gid: The global ID of the created comment
        comment_text: The text of the comment
        created_at: When the comment was created
        data: The full response data from Asana API
    ### read_project
        created_at: When the project was created
        data: The full response data from Asana API
        modified_at: When the project was last modified
        project_gid: The global ID of the project
        project_name: The name of the project
        project_notes: The notes/description of the project
    ### create_project
        data: The full response data from Asana API
        project_gid: The global ID of the created project
        project_name: The name of the created project
        project_url: The URL of the created project
    ### get_projects
        data: The full response data from Asana API
        project_gids: The global IDs of all projects
        project_names: The names of all projects
    ### update_project
        data: The full response data from Asana API
        project_gid: The global ID of the updated project
        project_name: The updated name of the project
    ### create_task
        data: The full response data from Asana API
        task_gid: The global ID of the created task
        task_name: The name of the created task
        task_url: The URL of the created task
    ### get_tasks
        data: The full response data from Asana API
        task_gids: The global IDs of all tasks
        task_names: The names of all tasks
    ### update_task
        data: The full response data from Asana API
        task_gid: The global ID of the updated task
        task_name: The updated name of the task
    ### search_tasks
        data: The full response data from Asana API
        task_gids: The global IDs of matching tasks
        task_names: The names of matching tasks
    ### move_task
        data: The full response data from Asana API
        success: Whether the move was successful
        task_gid: The global ID of the moved task
    ### create_subtask
        data: The full response data from Asana API
        parent_task_gid: The global ID of the parent task
        subtask_gid: The global ID of the created subtask
        subtask_name: The name of the created subtask
    ### get_subtasks
        data: The full response data from Asana API
        subtask_gids: The global IDs of all subtasks
        subtask_names: The names of all subtasks
    ### add_task_tag
        data: The full response data from Asana API
        success: Whether the tag addition was successful
        tag_gid: The global ID of the added tag
        task_gid: The global ID of the task
    ### remove_task_tag
        data: The full response data from Asana API
        success: Whether the tag removal was successful
        tag_gid: The global ID of the removed tag
        task_gid: The global ID of the task
    ### add_task_project
        data: The full response data from Asana API
        project_gid: The global ID of the project
        success: Whether the addition was successful
        task_gid: The global ID of the task
    ### remove_task_project
        data: The full response data from Asana API
        project_gid: The global ID of the project
        success: Whether the removal was successful
        task_gid: The global ID of the task
    ### read_user
        data: The full response data from Asana API
        user_email: The email of the user
        user_gid: The global ID of the user
        user_name: The name of the user
        workspaces: List of workspace names the user belongs to
    ### get_users
        data: The full response data from Asana API
        user_emails: The emails of all users
        user_gids: The global IDs of all users
        user_names: The names of all users
    ### delete_project
        status_code: The HTTP status code of the response
        success: Whether the deletion was successful
    ### delete_task
        status_code: The HTTP status code of the response
        success: Whether the deletion was successful
    ### remove_task_comment
        status_code: The HTTP status code of the response
        success: Whether the comment removal was successful
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your Asana account",
            "value": None,
            "type": "integration<Asana>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "create_project": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "placeholder": "Development Team",
                    "helper_text": "The team to create the project in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Project Name",
                    "placeholder": "My New Project",
                    "helper_text": "The name of the project to create",
                    "order": 5,
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "label": "Project Notes",
                    "placeholder": "Project description",
                    "helper_text": "Notes or description for the project",
                    "order": 6,
                },
                {
                    "field": "public",
                    "type": "bool",
                    "value": False,
                    "label": "Public Project",
                    "helper_text": "Whether the project should be public",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "project_gid",
                    "type": "string",
                    "helper_text": "The global ID of the created project",
                },
                {
                    "field": "project_name",
                    "type": "string",
                    "helper_text": "The name of the created project",
                },
                {
                    "field": "project_url",
                    "type": "string",
                    "helper_text": "The URL of the created project",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "create_project",
            "task_name": "tasks.asana.create_project",
            "description": "Create a new project in Asana",
            "label": "Create Project",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "team",
                "name",
                "notes",
                "public",
            ],
            "required": ["workspace", "name"],
        },
        "read_project": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "project_gid",
                    "type": "string",
                    "helper_text": "The global ID of the project",
                },
                {
                    "field": "project_name",
                    "type": "string",
                    "helper_text": "The name of the project",
                },
                {
                    "field": "project_notes",
                    "type": "string",
                    "helper_text": "The notes/description of the project",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the project was created",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "When the project was last modified",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "read_project",
            "task_name": "tasks.asana.read_project",
            "description": "Get details of a specific project",
            "label": "Read Project",
            "inputs_sort_order": ["integration", "action", "workspace", "project"],
            "required": ["workspace", "project"],
        },
        "get_projects": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace to get projects from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "team",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "placeholder": "Development Team",
                    "helper_text": "The team to get projects from (optional)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "archived",
                    "type": "bool",
                    "value": False,
                    "label": "Include Archived",
                    "placeholder": "false",
                    "helper_text": "Whether to include archived projects in the results",
                    "agent_field_type": "static",
                    "component": {"type": "checkbox"},
                    "order": 5,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 50,
                    "label": "Limit",
                    "placeholder": "50",
                    "helper_text": "Maximum number of projects to return (1-100)",
                    "agent_field_type": "static",
                    "component": {"type": "number", "min": 1, "max": 100},
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "project_gids",
                    "type": "vec<string>",
                    "helper_text": "The global IDs of all projects",
                },
                {
                    "field": "project_names",
                    "type": "vec<string>",
                    "helper_text": "The names of all projects",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "get_projects",
            "task_name": "tasks.asana.get_projects",
            "description": "Get all projects from workspace or team",
            "label": "Get Projects",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "team",
                "archived",
                "limit",
            ],
            "required": ["workspace"],
        },
        "update_project": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Project Name",
                    "placeholder": "Updated Project Name",
                    "helper_text": "The new name for the project",
                    "order": 4,
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "label": "Project Notes",
                    "placeholder": "Updated description",
                    "helper_text": "Updated notes or description for the project",
                    "order": 5,
                },
                {
                    "field": "public",
                    "type": "bool",
                    "value": False,
                    "label": "Public Project",
                    "helper_text": "Whether the project should be public",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "project_gid",
                    "type": "string",
                    "helper_text": "The global ID of the updated project",
                },
                {
                    "field": "project_name",
                    "type": "string",
                    "helper_text": "The updated name of the project",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "update_project",
            "task_name": "tasks.asana.update_project",
            "description": "Update an existing project",
            "label": "Update Project",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "project",
                "name",
                "notes",
                "public",
            ],
            "required": ["workspace", "project"],
        },
        "delete_project": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to delete",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "status_code",
                    "type": "string",
                    "helper_text": "The HTTP status code of the response",
                },
            ],
            "name": "delete_project",
            "task_name": "tasks.asana.delete_project",
            "description": "Delete a project",
            "label": "Delete Project",
            "inputs_sort_order": ["integration", "action", "workspace", "project"],
            "required": ["workspace", "project"],
        },
        "create_task": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Section",
                    "placeholder": "My Section",
                    "helper_text": "The section to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Task Name",
                    "placeholder": "Complete feature implementation",
                    "helper_text": "The name of the task to create",
                    "order": 6,
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "label": "Task Description",
                    "placeholder": "Detailed task description",
                    "helper_text": "Notes or description for the task",
                    "order": 7,
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "placeholder": "john@example.com",
                    "helper_text": "Email of the person to assign the task to",
                    "order": 8,
                },
                {
                    "field": "due_on",
                    "type": "string",
                    "value": "",
                    "label": "Due Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Due date for the task (YYYY-MM-DD format)",
                    "order": 9,
                },
            ],
            "outputs": [
                {
                    "field": "task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the created task",
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "The name of the created task",
                },
                {
                    "field": "task_url",
                    "type": "string",
                    "helper_text": "The URL of the created task",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "create_task",
            "task_name": "tasks.asana.create_task",
            "description": "Create a new task in Asana",
            "label": "Create Task",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "project",
                "name",
                "notes",
                "assignee",
                "due_on",
            ],
            "required": ["workspace", "projects", "name"],
        },
        "read_task": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace to get projects from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to get tasks from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Section",
                    "placeholder": "My Section",
                    "helper_text": "The section to get tasks from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task",
                    "placeholder": "My Task",
                    "helper_text": "The task to get details from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&workspace={inputs.workspace}&project={inputs.project}&section={inputs.section}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the task",
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "The name of the task",
                },
                {
                    "field": "task_notes",
                    "type": "string",
                    "helper_text": "The notes/description of the task",
                },
                {
                    "field": "completed",
                    "type": "bool",
                    "helper_text": "Whether the task is completed",
                },
                {
                    "field": "assignee_name",
                    "type": "string",
                    "helper_text": "The name of the assignee",
                },
                {
                    "field": "due_on",
                    "type": "string",
                    "helper_text": "The due date of the task",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the task was created",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "When the task was last modified",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "read_task",
            "task_name": "tasks.asana.read_task",
            "description": "Get details of a specific task",
            "label": "Read Task",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "project",
                "task",
            ],
            "required": ["workspace", "project", "task"],
        },
        "get_tasks": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to get tasks from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "label": "Assignee Filter",
                    "placeholder": "john@example.com",
                    "helper_text": "Filter tasks by assignee email (optional)",
                    "order": 5,
                },
                {
                    "field": "completed_since",
                    "type": "timestamp",
                    "value": -1,
                    "label": "Completed Since",
                    "placeholder": "2024-01-01T00:00:00Z",
                    "helper_text": "Only return tasks completed after this time (optional)",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "task_gids",
                    "type": "vec<string>",
                    "helper_text": "The global IDs of all tasks",
                },
                {
                    "field": "task_names",
                    "type": "vec<string>",
                    "helper_text": "The names of all tasks",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "get_tasks",
            "task_name": "tasks.asana.get_tasks",
            "description": "Get all tasks from a project or workspace",
            "label": "Get Tasks",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "project",
                "assignee",
                "completed_since",
            ],
            "required": ["workspace", "project"],
        },
        "update_task": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to update the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Section",
                    "placeholder": "My Section",
                    "helper_text": "The section to update the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task",
                    "placeholder": "My Task",
                    "helper_text": "The task to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&workspace={inputs.workspace}&project={inputs.project}&section={inputs.section}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Task Name",
                    "placeholder": "Updated task name",
                    "helper_text": "The new name for the task",
                    "order": 4,
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "label": "Task Description",
                    "placeholder": "Updated description",
                    "helper_text": "Updated notes or description for the task",
                    "order": 5,
                },
                {
                    "field": "completed",
                    "type": "bool",
                    "value": False,
                    "label": "Mark Completed",
                    "helper_text": "Whether to mark the task as completed",
                    "order": 6,
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "placeholder": "john@example.com",
                    "helper_text": "Email of the person to assign the task to",
                    "order": 7,
                },
                {
                    "field": "due_on",
                    "type": "string",
                    "value": "",
                    "label": "Due Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Due date for the task (YYYY-MM-DD format)",
                    "order": 8,
                },
            ],
            "outputs": [
                {
                    "field": "task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the updated task",
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "The updated name of the task",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "update_task",
            "task_name": "tasks.asana.update_task",
            "description": "Update an existing task",
            "label": "Update Task",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "project",
                "section",
                "task",
                "name",
                "notes",
                "completed",
                "assignee",
                "due_on",
            ],
            "required": ["workspace", "project", "section", "task"],
        },
        "delete_task": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to delete the task from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Section",
                    "placeholder": "My Section",
                    "helper_text": "The section to delete the task from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task",
                    "placeholder": "My Task",
                    "helper_text": "The task to delete",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&workspace={inputs.workspace}&project={inputs.project}&section={inputs.section}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "status_code",
                    "type": "string",
                    "helper_text": "The HTTP status code of the response",
                },
            ],
            "name": "delete_task",
            "task_name": "tasks.asana.delete_task",
            "description": "Delete a task",
            "label": "Delete Task",
            "inputs_sort_order": ["integration", "action", "task_gid"],
            "required": ["task_gid"],
        },
        "search_tasks": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace to search in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Search Text",
                    "placeholder": "bug fix",
                    "helper_text": "Text to search for in task names and descriptions",
                    "order": 4,
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "placeholder": "john@example.com",
                    "helper_text": "Filter by assignee email (optional)",
                    "order": 5,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "Filter by specific project (optional)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "task_gids",
                    "type": "vec<string>",
                    "helper_text": "The global IDs of matching tasks",
                },
                {
                    "field": "task_names",
                    "type": "vec<string>",
                    "helper_text": "The names of matching tasks",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "search_tasks",
            "task_name": "tasks.asana.search_tasks",
            "description": "Search for tasks in workspace",
            "label": "Search Tasks",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "text",
                "assignee",
                "project",
            ],
            "required": ["workspace", "text"],
        },
        "move_task": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Source Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Source Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to update the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Source Section",
                    "placeholder": "My Section",
                    "helper_text": "The section to update the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Source Task",
                    "placeholder": "My Task",
                    "helper_text": "The task to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&workspace={inputs.workspace}&project={inputs.project}&section={inputs.section}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "target_workspace",
                    "type": "string",
                    "value": "",
                    "label": "Target Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace to move the task to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "target_project",
                    "type": "string",
                    "value": "",
                    "label": "Target Project",
                    "placeholder": "New Project",
                    "helper_text": "The project to move the task to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.target_workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 8,
                },
                {
                    "field": "target_section",
                    "type": "string",
                    "value": "",
                    "label": "Target Section",
                    "placeholder": "In Progress",
                    "helper_text": "The section within the project to move the task to (optional)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.target_workspace}&project={inputs.target_project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 9,
                },
            ],
            "outputs": [
                {
                    "field": "task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the moved task",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the move was successful",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "move_task",
            "task_name": "tasks.asana.move_task",
            "description": "Move a task to a different project or section",
            "label": "Move Task",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_gid",
                "project",
                "section",
            ],
            "required": ["task_gid", "project"],
        },
        "create_subtask": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to create the subtask in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Section",
                    "placeholder": "My Section",
                    "helper_text": "The section to create the subtask in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "parent",
                    "type": "string",
                    "value": "",
                    "label": "Parent Task ID",
                    "placeholder": "My Task",
                    "helper_text": "The task to create the subtask in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&workspace={inputs.workspace}&project={inputs.project}&section={inputs.section}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Subtask Name",
                    "placeholder": "Complete subtask",
                    "helper_text": "The name of the subtask to create",
                    "order": 4,
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "label": "Subtask Description",
                    "placeholder": "Detailed subtask description",
                    "helper_text": "Notes or description for the subtask",
                    "order": 5,
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "placeholder": "john@example.com",
                    "helper_text": "Email of the person to assign the subtask to",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "subtask_gid",
                    "type": "string",
                    "helper_text": "The global ID of the created subtask",
                },
                {
                    "field": "subtask_name",
                    "type": "string",
                    "helper_text": "The name of the created subtask",
                },
                {
                    "field": "parent_task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the parent task",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "create_subtask",
            "task_name": "tasks.asana.create_subtask",
            "description": "Create a new subtask under a parent task",
            "label": "Create Subtask",
            "inputs_sort_order": [
                "integration",
                "action",
                "parent",
                "name",
                "notes",
                "assignee",
            ],
            "required": ["workspace", "project", "section", "parent", "name"],
        },
        "get_subtasks": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to get subtasks from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Section",
                    "placeholder": "My Section",
                    "helper_text": "The section to get subtasks from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "parent",
                    "type": "string",
                    "value": "",
                    "label": "Parent Task",
                    "placeholder": "My Task",
                    "helper_text": "The task to get subtasks from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&workspace={inputs.workspace}&project={inputs.project}&section={inputs.section}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 50,
                    "label": "Limit",
                    "placeholder": "50",
                    "helper_text": "Maximum number of subtasks to return (1-100)",
                    "agent_field_type": "static",
                    "component": {"type": "number", "min": 1, "max": 100},
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "subtask_gids",
                    "type": "vec<string>",
                    "helper_text": "The global IDs of all subtasks",
                },
                {
                    "field": "subtask_names",
                    "type": "vec<string>",
                    "helper_text": "The names of all subtasks",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "get_subtasks",
            "task_name": "tasks.asana.get_subtasks",
            "description": "Get all subtasks of a parent task",
            "label": "Get Subtasks",
            "inputs_sort_order": ["integration", "action", "parent", "limit"],
            "required": ["parent"],
        },
        "add_task_comment": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to add comment to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Section",
                    "placeholder": "My Section",
                    "helper_text": "The section to add comment to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=section&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "parent",
                    "type": "string",
                    "value": "",
                    "label": "Task",
                    "placeholder": "My Task",
                    "helper_text": "The task to add comment to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&workspace={inputs.workspace}&project={inputs.project}&section={inputs.section}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Comment Text",
                    "placeholder": "This task is ready for review",
                    "helper_text": "The comment text to add",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "comment_gid",
                    "type": "string",
                    "helper_text": "The global ID of the created comment",
                },
                {
                    "field": "comment_text",
                    "type": "string",
                    "helper_text": "The text of the comment",
                },
                {
                    "field": "author_name",
                    "type": "string",
                    "helper_text": "The name of the comment author",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the comment was created",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "add_task_comment",
            "task_name": "tasks.asana.add_task_comment",
            "description": "Add a comment to a task",
            "label": "Add Task Comment",
            "inputs_sort_order": ["integration", "action", "parent", "text"],
            "required": ["workspace", "project", "section", "parent", "text"],
        },
        "remove_task_comment": {
            "inputs": [
                {
                    "field": "comment_gid",
                    "type": "string",
                    "value": "",
                    "label": "Comment ID",
                    "placeholder": "1234567890",
                    "helper_text": "The global ID of the comment to remove",
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the comment removal was successful",
                },
                {
                    "field": "status_code",
                    "type": "string",
                    "helper_text": "The HTTP status code of the response",
                },
            ],
            "name": "remove_task_comment",
            "task_name": "tasks.asana.remove_task_comment",
            "description": "Remove a comment from a task",
            "label": "Remove Task Comment",
            "inputs_sort_order": ["integration", "action", "comment_gid"],
            "required": ["comment_gid"],
        },
        "add_task_tag": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "My Project",
                    "helper_text": "The project to add tag to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&workspace={inputs.workspace}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task",
                    "placeholder": "My Task",
                    "helper_text": "The task to add tag to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&workspace={inputs.workspace}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "tag",
                    "type": "string",
                    "value": "",
                    "label": "Tag",
                    "placeholder": "My Tag",
                    "helper_text": "The tag to add",
                    "agent_field_type": "static",
                    "component": {"type": "dropdown"},
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the task",
                },
                {
                    "field": "tag_gid",
                    "type": "string",
                    "helper_text": "The global ID of the added tag",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag addition was successful",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "add_task_tag",
            "task_name": "tasks.asana.add_task_tag",
            "description": "Add a tag to a task",
            "label": "Add Task Tag",
            "inputs_sort_order": [
                "integration",
                "action",
                "workspace",
                "project",
                "task",
                "tag",
            ],
            "required": ["workspace", "project", "task", "tag"],
        },
        "remove_task_tag": {
            "inputs": [
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task ID",
                    "placeholder": "1234567890",
                    "helper_text": "The global ID of the task to remove tag from",
                    "order": 3,
                },
                {
                    "field": "tag",
                    "type": "string",
                    "value": "",
                    "label": "Tag ID",
                    "placeholder": "0987654321",
                    "helper_text": "The global ID of the tag to remove",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the task",
                },
                {
                    "field": "tag_gid",
                    "type": "string",
                    "helper_text": "The global ID of the removed tag",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag removal was successful",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "remove_task_tag",
            "task_name": "tasks.asana.remove_task_tag",
            "description": "Remove a tag from a task",
            "label": "Remove Task Tag",
            "inputs_sort_order": ["integration", "action", "task", "tag"],
            "required": ["task", "tag"],
        },
        "add_task_project": {
            "inputs": [
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task ID",
                    "placeholder": "1234567890",
                    "helper_text": "The global ID of the task to add to project",
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "0987654321",
                    "helper_text": "The global ID of the project to add task to",
                    "order": 4,
                },
                {
                    "field": "section",
                    "type": "string",
                    "value": "",
                    "label": "Section ID",
                    "placeholder": "1122334455",
                    "helper_text": "The global ID of the section within the project (optional)",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the task",
                },
                {
                    "field": "project_gid",
                    "type": "string",
                    "helper_text": "The global ID of the project",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the addition was successful",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "add_task_project",
            "task_name": "tasks.asana.add_task_project",
            "description": "Add a task to a project",
            "label": "Add Task to Project",
            "inputs_sort_order": [
                "integration",
                "action",
                "task",
                "project",
                "section",
            ],
            "required": ["task", "project"],
        },
        "remove_task_project": {
            "inputs": [
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task ID",
                    "placeholder": "1234567890",
                    "helper_text": "The global ID of the task to remove from project",
                    "order": 3,
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "0987654321",
                    "helper_text": "The global ID of the project to remove task from",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "task_gid",
                    "type": "string",
                    "helper_text": "The global ID of the task",
                },
                {
                    "field": "project_gid",
                    "type": "string",
                    "helper_text": "The global ID of the project",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the removal was successful",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "remove_task_project",
            "task_name": "tasks.asana.remove_task_project",
            "description": "Remove a task from a project",
            "label": "Remove Task from Project",
            "inputs_sort_order": ["integration", "action", "task", "project"],
            "required": ["task", "project"],
        },
        "read_user": {
            "inputs": [
                {
                    "field": "user_gid",
                    "type": "string",
                    "value": "",
                    "label": "User ID",
                    "placeholder": "1234567890",
                    "helper_text": "The global ID of the user to retrieve (optional, defaults to current user)",
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "user_gid",
                    "type": "string",
                    "helper_text": "The global ID of the user",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "The name of the user",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "helper_text": "The email of the user",
                },
                {
                    "field": "workspaces",
                    "type": "vec<string>",
                    "helper_text": "List of workspace names the user belongs to",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "read_user",
            "task_name": "tasks.asana.read_user",
            "description": "Get details of a specific user",
            "label": "Read User",
            "inputs_sort_order": ["integration", "action", "user_gid"],
            "required": ["user_gid"],
        },
        "get_users": {
            "inputs": [
                {
                    "field": "workspace",
                    "type": "string",
                    "value": "",
                    "label": "Workspace",
                    "placeholder": "My Workspace",
                    "helper_text": "The Asana workspace to get users from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=workspace&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "user_gids",
                    "type": "vec<string>",
                    "helper_text": "The global IDs of all users",
                },
                {
                    "field": "user_names",
                    "type": "vec<string>",
                    "helper_text": "The names of all users",
                },
                {
                    "field": "user_emails",
                    "type": "vec<string>",
                    "helper_text": "The emails of all users",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The full response data from Asana API",
                },
            ],
            "name": "get_users",
            "task_name": "tasks.asana.get_users",
            "description": "Get all users from a workspace",
            "label": "Get Users",
            "inputs_sort_order": ["integration", "action", "workspace"],
            "required": ["workspace"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        archived: bool = False,
        assignee: str = "",
        comment_gid: str = "",
        completed: bool = False,
        completed_since: Any = -1,
        due_on: str = "",
        limit: int = 50,
        name: str = "",
        notes: str = "",
        parent: str = "",
        project: str = "",
        public: bool = False,
        section: str = "",
        tag: str = "",
        target_project: str = "",
        target_section: str = "",
        target_workspace: str = "",
        task: str = "",
        team: str = "",
        text: str = "",
        user_gid: str = "",
        workspace: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_asana",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if workspace is not None:
            self.inputs["workspace"] = workspace
        if team is not None:
            self.inputs["team"] = team
        if name is not None:
            self.inputs["name"] = name
        if notes is not None:
            self.inputs["notes"] = notes
        if public is not None:
            self.inputs["public"] = public
        if project is not None:
            self.inputs["project"] = project
        if archived is not None:
            self.inputs["archived"] = archived
        if limit is not None:
            self.inputs["limit"] = limit
        if section is not None:
            self.inputs["section"] = section
        if assignee is not None:
            self.inputs["assignee"] = assignee
        if due_on is not None:
            self.inputs["due_on"] = due_on
        if task is not None:
            self.inputs["task"] = task
        if completed_since is not None:
            self.inputs["completed_since"] = completed_since
        if completed is not None:
            self.inputs["completed"] = completed
        if text is not None:
            self.inputs["text"] = text
        if target_workspace is not None:
            self.inputs["target_workspace"] = target_workspace
        if target_project is not None:
            self.inputs["target_project"] = target_project
        if target_section is not None:
            self.inputs["target_section"] = target_section
        if parent is not None:
            self.inputs["parent"] = parent
        if comment_gid is not None:
            self.inputs["comment_gid"] = comment_gid
        if tag is not None:
            self.inputs["tag"] = tag
        if user_gid is not None:
            self.inputs["user_gid"] = user_gid
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationAsanaNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_jira")
class IntegrationJiraNode(Node):
    """
    Jira

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: The integration input
    ### When action = 'read_user'
        account_id: The account ID of the user to retrieve
        expand: Additional information to include
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues'
        affected_version: Filter by affected version
        assignee_name: Account Name of the user to assign the issue to
        comment: Search in issue comments
        comment_exact: Match comment exactly
        component: Filter by issue component
        created: Issue creation (YYYY-MM-DD)
        description: Detailed description of the issue
        description_exact: Match description exactly
        due: Due (YYYY-MM-DD)
        fix_version: Filter by fix version
        issue_summary: Search by issue summary
        issue_type: Type of issue (e.g. Task, Bug, Story)
        labels: Filter by issue labels
        project: The name of the project
        query: The query to filter issues
        reporter_name: Account Name of the user who reported the issue
        resolution: Filter by resolution status
        resolved: Resolution (YYYY-MM-DD)
        site: The name of the Jira site
        status: The status of the issue (e.g. Open, Closed, In Progress)
        summary_exact: Match summary exactly
        text: Search in all text fields
        text_exact: Match text exactly across fields
        updated: Last update (YYYY-MM-DD)
        use_date: Toggle to use dates
    ### When action = 'create_issue'
        assignee_name: Account Name of the user to assign the issue to
        description: Detailed description of the issue
        issue_type: Type of issue (e.g. Task, Bug, Story)
        project: The name of the project
        site: The name of the Jira site
        summary: A brief title or summary of the issue
    ### When action = 'read_attachment'
        attachment_id: The ID of the attachment to retrieve
        download: Whether to download the attachment content
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'remove_attachment'
        attachment_id: The ID of the attachment to retrieve
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'add_issue_comment'
        comment: Search in issue comments
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
        visibility_role: Restrict comment visibility to a project role (leave empty for public comment)
    ### When action = 'update_comment'
        comment: Search in issue comments
        comment_id: The ID of the comment to remove
        expand: Additional information to include
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
        use_wiki_markup: Enable wiki markup parsing
    ### When action = 'remove_comment'
        comment_id: The ID of the comment to remove
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'delete_issue'
        delete_subtasks: Whether to delete subtasks along with the issue
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_attachments'
        download: Whether to download the attachment content
        issue_key: The key of the issue to get changelog for
        limit: Maximum number of changelog entries to return
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'status_transitions'
        expand: Additional information to include
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
        skip_remote_only_condition: Include transitions with remote-only conditions
        transition_id: ID of specific transition to get
    ### When action = 'add_attachment'
        file: File to attach to the issue
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'notify_issue'
        group_names: Comma-separated list of group names to notify
        html_body: HTML body of the notification
        issue_key: The key of the issue to get changelog for
        notify_assignee: Send notification to the issue assignee
        notify_reporter: Send notification to the issue reporter
        notify_voters: Send notification to issue voters
        notify_watchers: Send notification to issue watchers
        project: The name of the project
        site: The name of the Jira site
        subject: Subject of the email notification
        text_body: Plain text body of the notification
        user_account_ids: Comma-separated list of user account IDs to notify
    ### When action = 'changelog'
        issue_key: The key of the issue to get changelog for
        limit: Maximum number of changelog entries to return
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'update_issue'
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
        update_assignee_name: Account Name of the user to assign the issue to
        update_description: The new description for the issue
        update_issue_type: Type of issue (e.g. Task, Bug, Story)
        update_summary: The new summary for the issue
    ### When action = 'read_issue'
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'read_issue_comments'
        issue_key: The key of the issue to get changelog for
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = False
        num_messages: Specify the number of issues to fetch
    ### When action = 'get_users'
        project: The name of the project
        site: The name of the Jira site
    ### When action = 'get_issues' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_user'
        account_id: The account ID of the user
        account_type: The account type of the user
        active: Whether the user is active
        application_roles: The application roles of the user (when expanded)
        display_name: The display name of the user
        email_address: The email address of the user
        groups: The groups the user belongs to (when expanded)
        locale: The locale of the user
        raw_data: The raw response data from Jira API
        timezone: The timezone of the user
    ### When action = 'get_users'
        account_id: The account IDs of the users in the project
        active: The active status of the users in the project
        display_name: The display names of the users in the project
        email: The email addresses of the users in the project
        raw_data: The raw response data from Jira API
    ### When action = 'read_issue'
        assignee_email: The email address of the assignees
        assignee_id: The account ID of the assignees
        assignee_name: The display name of the assignees
        browser_url: The URL to view the issues in browser
        comments: The comments of the issues
        created_date: The date and time when the issues was created
        description: The description of the issues
        issue_attachments: The attachments of the issues
        issue_id: The unique identifier of the issues
        issue_key: The key of the issues (e.g. PROJ-123)
        issue_type: The type of the issues
        raw_data: The raw response data from Jira API
        reporter_email: The email address of the reporters
        reporter_id: The account ID of the reporters
        reporter_name: The display name of the reporters
        status: The current status of the issues
        summary: The summary/title of the issues
        updated_date: The date and time when the issues was last updated
    ### When action = 'get_issues'
        assignee_emails: The email address of the assignee
        assignee_ids: The account ID of the assignee
        assignee_names: The display name of the assignee
        browser_urls: The URL to view the issue in browser
        comments: The comments of the issue
        created_dates: The date and time when the issue was created
        descriptions: The description of the issue
        issue_attachments: The attachments of the issue
        issue_ids: The unique identifier of the issue
        issue_keys: The key of the issue (e.g. PROJ-123)
        issue_types: The type of the issue
        raw_data: The raw response data from Jira API
        reporter_emails: The email address of the reporter
        reporter_ids: The account ID of the reporter
        reporter_names: The display name of the reporter
        statuses: The current status of the issue
        summaries: The summary/title of the issue
        updated_dates: The date and time when the issue was last updated
    ### When action = 'read_attachment'
        attachment_id: The ID of the attachment
        author: The author of the attachment
        created_date: The creation date of the attachment
        file: The downloaded file content (when download=true)
        filename: The filename of the attachment
        mime_type: The MIME type of the attachment
        raw_data: The raw response data from Jira API
        size: The size of the attachment
    ### When action = 'remove_attachment'
        attachment_id: The ID of the removed attachment
        message: Success message
        raw_data: The raw response data from Jira API
    ### When action = 'add_attachment'
        attachment_ids: List of attachment IDs
        attachment_names: List of attachment names
        attachment_sizes: List of attachment sizes
        attachment_urls: List of attachment URLs
        issue_key: The key of the issue
        message: Success message
        raw_data: The raw response data from Jira API
    ### When action = 'get_attachments'
        attachment_ids: List of attachment IDs
        attachment_names: List of attachment names
        attachment_sizes: List of attachment sizes
        attachment_urls: List of attachment URLs
        authors: List of attachment authors
        created_dates: List of attachment creation dates
        files: List of downloaded files (when download=true)
        issue_key: The key of the issue
        mime_types: List of attachment MIME types
        raw_data: The raw response data from Jira API
        total: Total number of attachments
    ### When action = 'update_comment'
        author: The author of the comment
        comment_id: The ID of the updated comment
        comment_text: The updated comment text
        created_date: The creation date of the comment
        issue_key: The key of the issue
        message: Success message
        raw_data: The raw response data from Jira API
        updated_date: The update date of the comment
    ### When action = 'read_issue_comments'
        author_email: List of comment author email addresses
        author_id: List of comment author account IDs
        author_name: List of comment author display names
        body: List of comment bodies
        comment_id: List of comment IDs
        created_date: List of comment creation dates
        raw_data: The raw response data from Jira API
        total: Total number of comments
        updated_date: List of comment update dates
    ### When action = 'changelog'
        author_emails: List of change author email addresses
        author_ids: List of change author account IDs
        author_names: List of change author display names
        change_descriptions: List of change descriptions
        change_ids: List of change IDs
        changelog_entries: List of complete changelog entries (for detailed access)
        created_dates: List of change creation dates
        issue_key: The key of the issue
        raw_data: The raw response data from Jira API
        total: Total number of changelog entries
    ### When action = 'add_issue_comment'
        comment_id: ID of the newly created comment
        created_date: Creation date of the comment
        message: Success message
        raw_data: The raw response data from Jira API
        updated_date: Last update date of the comment
    ### When action = 'remove_comment'
        comment_id: The ID of the removed comment
        issue_key: The key of the issue
        message: Success message
        raw_data: The raw response data from Jira API
    ### When action = 'delete_issue'
        deleted_subtasks: Whether subtasks were deleted
        issue_key: The key of the deleted issue
        message: Success message
        raw_data: The raw response data from Jira API
    ### When action = 'create_issue'
        issue_id: The ID of the created issue
        issue_key: The key of the created issue
        raw_data: The raw response data from Jira API
        url: The URL of the created issue
    ### When action = 'update_issue'
        issue_key: The key of the updated issue
        message: Success message confirming the update
        raw_data: The raw response data from Jira API
    ### When action = 'notify_issue'
        issue_key: The key of the issue
        message: Success message
        raw_data: The raw response data from Jira API
    ### When action = 'status_transitions'
        issue_key: The key of the issue
        raw_data: The raw response data from Jira API
        to_status_ids: List of target status IDs
        to_status_names: List of target status names
        total: Total number of transitions
        transition_ids: List of transition IDs
        transition_names: List of transition names
        transitions: List of complete transition objects (for detailed access)
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Jira>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "changelog**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to get changelog for",
                },
                {
                    "field": "limit",
                    "label": "Limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of changelog entries to return",
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "changelog_entries",
                    "type": "vec<string>",
                    "helper_text": "List of complete changelog entries (for detailed access)",
                },
                {
                    "field": "change_ids",
                    "type": "vec<string>",
                    "helper_text": "List of change IDs",
                },
                {
                    "field": "change_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of change descriptions",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of change creation dates",
                },
                {
                    "field": "author_ids",
                    "type": "vec<string>",
                    "helper_text": "List of change author account IDs",
                },
                {
                    "field": "author_names",
                    "type": "vec<string>",
                    "helper_text": "List of change author display names",
                },
                {
                    "field": "author_emails",
                    "type": "vec<string>",
                    "helper_text": "List of change author email addresses",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of changelog entries",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "changelog",
            "task_name": "tasks.jira.changelog",
            "description": "Get issue changelog",
            "label": "Get Issue Changelog",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "limit",
            ],
        },
        "create_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "summary",
                    "label": "Summary",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue summary",
                    "helper_text": "A brief title or summary of the issue",
                },
                {
                    "field": "description",
                    "label": "Description",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter detailed description",
                    "helper_text": "Detailed description of the issue",
                },
                {
                    "field": "issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "The ID of the created issue",
                },
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the created issue",
                },
                {
                    "field": "url",
                    "type": "string",
                    "helper_text": "The URL of the created issue",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_issue",
            "task_name": "tasks.jira.create_issue",
            "description": "Create a issue",
            "label": "Create Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_type",
                "assignee_name",
                "summary",
                "description",
            ],
        },
        "update_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to update (e.g. PROJ-123)",
                },
                {
                    "field": "update_summary",
                    "label": "Summary",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter new summary",
                    "helper_text": "The new summary for the issue",
                },
                {
                    "field": "update_description",
                    "label": "Description",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter new description",
                    "helper_text": "The new description for the issue",
                },
                {
                    "field": "update_issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "update_assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the updated issue",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message confirming the update",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_issue",
            "task_name": "tasks.jira.update_issue",
            "description": "Update an existing Jira issue",
            "label": "Update Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "update_issue_type",
                "update_assignee_name",
                "issue_key",
                "update_summary",
                "update_description",
            ],
        },
        "read_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to retrieve (e.g. PROJ-123)",
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the issues",
                },
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issues (e.g. PROJ-123)",
                },
                {
                    "field": "summary",
                    "type": "string",
                    "helper_text": "The summary/title of the issues",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "The description of the issues",
                },
                {
                    "field": "comments",
                    "type": "vec<string>",
                    "helper_text": "The comments of the issues",
                },
                {
                    "field": "issue_attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments of the issues",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "helper_text": "The date and time when the issues was created",
                },
                {
                    "field": "updated_date",
                    "type": "string",
                    "helper_text": "The date and time when the issues was last updated",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "The current status of the issues",
                },
                {
                    "field": "browser_url",
                    "type": "string",
                    "helper_text": "The URL to view the issues in browser",
                },
                {
                    "field": "issue_type",
                    "type": "string",
                    "helper_text": "The type of the issues",
                },
                {
                    "field": "assignee_id",
                    "type": "string",
                    "helper_text": "The account ID of the assignees",
                },
                {
                    "field": "assignee_name",
                    "type": "string",
                    "helper_text": "The display name of the assignees",
                },
                {
                    "field": "assignee_email",
                    "type": "string",
                    "helper_text": "The email address of the assignees",
                },
                {
                    "field": "reporter_id",
                    "type": "string",
                    "helper_text": "The account ID of the reporters",
                },
                {
                    "field": "reporter_name",
                    "type": "string",
                    "helper_text": "The display name of the reporters",
                },
                {
                    "field": "reporter_email",
                    "type": "string",
                    "helper_text": "The email address of the reporters",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_issue",
            "task_name": "tasks.jira.read_issue",
            "description": "Retrieve details of an existing Jira issue",
            "label": "Read Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
            ],
        },
        "get_issues**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_type",
                    "label": "Issue Type",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "placeholder": "Select issue type",
                    "helper_text": "Type of issue (e.g. Task, Bug, Story)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=issue_type&project={inputs.project}&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "assignee_name",
                    "label": "Assignee Name",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "placeholder": "Select assignee",
                    "helper_text": "Account Name of the user to assign the issue to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee_name&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "",
                    "label": "Status",
                    "placeholder": "Open",
                    "helper_text": "The status of the issue (e.g. Open, Closed, In Progress)",
                },
                {
                    "field": "reporter_name",
                    "label": "Reporter Name",
                    "type": "string",
                    "value": "",
                    "placeholder": "Select reporter",
                    "helper_text": "Account Name of the user who reported the issue",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "Query",
                    "helper_text": "The query to filter issues",
                },
                {
                    "field": "issue_summary",
                    "type": "string",
                    "value": "",
                    "label": "Summary",
                    "placeholder": "Summary",
                    "helper_text": "Search by issue summary",
                },
                {
                    "field": "summary_exact",
                    "type": "string",
                    "value": "",
                    "label": "Summary Exact",
                    "placeholder": "Summary Exact",
                    "helper_text": "Match summary exactly",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Description",
                    "helper_text": "Search in issue description",
                },
                {
                    "field": "description_exact",
                    "type": "string",
                    "value": "",
                    "label": "Description Exact",
                    "placeholder": "Description Exact",
                    "helper_text": "Match description exactly",
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "placeholder": "Comment",
                    "helper_text": "Search in issue comments",
                },
                {
                    "field": "comment_exact",
                    "type": "string",
                    "value": "",
                    "label": "Comment Exact",
                    "placeholder": "Comment Exact",
                    "helper_text": "Match comment exactly",
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Text",
                    "helper_text": "Search in all text fields",
                },
                {
                    "field": "text_exact",
                    "type": "string",
                    "value": "",
                    "label": "Text Exact",
                    "placeholder": "Text Exact",
                    "helper_text": "Match text exactly across fields",
                },
                {
                    "field": "labels",
                    "type": "string",
                    "value": "",
                    "label": "Labels",
                    "placeholder": "Labels",
                    "helper_text": "Filter by issue labels",
                },
                {
                    "field": "fix_version",
                    "type": "string",
                    "value": "",
                    "label": "Fix Version",
                    "placeholder": "Fix Version",
                    "helper_text": "Filter by fix version",
                },
                {
                    "field": "affected_version",
                    "type": "string",
                    "value": "",
                    "label": "Affected Version",
                    "placeholder": "Affected Version",
                    "helper_text": "Filter by affected version",
                },
                {
                    "field": "component",
                    "type": "string",
                    "value": "",
                    "label": "Component",
                    "placeholder": "Component",
                    "helper_text": "Filter by issue component",
                },
                {
                    "field": "resolution",
                    "type": "string",
                    "value": "",
                    "label": "Resolution",
                    "placeholder": "Resolution",
                    "helper_text": "Filter by resolution status",
                },
                {
                    "field": "created",
                    "type": "string",
                    "value": "",
                    "label": "Created",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Issue creation (YYYY-MM-DD)",
                },
                {
                    "field": "updated",
                    "type": "string",
                    "value": "",
                    "label": "Updated",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Last update (YYYY-MM-DD)",
                },
                {
                    "field": "resolved",
                    "type": "string",
                    "value": "",
                    "label": "Resolved",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Resolution (YYYY-MM-DD)",
                },
                {
                    "field": "due",
                    "type": "string",
                    "value": "",
                    "label": "Due",
                    "placeholder": "YYYY-MM-DD",
                    "helper_text": "Due (YYYY-MM-DD)",
                },
            ],
            "outputs": [
                {
                    "field": "issue_ids",
                    "type": "vec<string>",
                    "helper_text": "The unique identifier of the issue",
                },
                {
                    "field": "issue_keys",
                    "type": "vec<string>",
                    "helper_text": "The key of the issue (e.g. PROJ-123)",
                },
                {
                    "field": "summaries",
                    "type": "vec<string>",
                    "helper_text": "The summary/title of the issue",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "The description of the issue",
                },
                {
                    "field": "comments",
                    "type": "vec<vec<string>>",
                    "helper_text": "The comments of the issue",
                },
                {
                    "field": "issue_attachments",
                    "type": "vec<file>",
                    "helper_text": "The attachments of the issue",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "The date and time when the issue was created",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "The date and time when the issue was last updated",
                },
                {
                    "field": "statuses",
                    "type": "vec<string>",
                    "helper_text": "The current status of the issue",
                },
                {
                    "field": "browser_urls",
                    "type": "vec<string>",
                    "helper_text": "The URL to view the issue in browser",
                },
                {
                    "field": "issue_types",
                    "type": "vec<string>",
                    "helper_text": "The type of the issue",
                },
                {
                    "field": "assignee_ids",
                    "type": "vec<string>",
                    "helper_text": "The account ID of the assignee",
                },
                {
                    "field": "assignee_names",
                    "type": "vec<string>",
                    "helper_text": "The display name of the assignee",
                },
                {
                    "field": "assignee_emails",
                    "type": "vec<string>",
                    "helper_text": "The email address of the assignee",
                },
                {
                    "field": "reporter_ids",
                    "type": "vec<string>",
                    "helper_text": "The account ID of the reporter",
                },
                {
                    "field": "reporter_names",
                    "type": "vec<string>",
                    "helper_text": "The display name of the reporter",
                },
                {
                    "field": "reporter_emails",
                    "type": "vec<string>",
                    "helper_text": "The email address of the reporter",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_issues",
            "task_name": "tasks.jira.get_issues",
            "description": "Get all issues for a Jira project",
            "label": "Get Issues",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_type",
                "status",
                "assignee_name",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "reporter_name",
                "query",
                "issue_summary",
                "summary_exact",
                "description",
                "description_exact",
                "comment",
                "comment_exact",
                "text",
                "text_exact",
                "labels",
                "fix_version",
                "affected_version",
                "component",
                "resolution",
                "created",
                "updated",
                "resolved",
                "due",
            ],
        },
        "get_issues**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Issues",
                    "helper_text": "Specify the number of issues to fetch",
                }
            ],
            "outputs": [],
        },
        "get_issues**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_issues**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "label": "Date Range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                }
            ],
            "outputs": [],
        },
        "get_issues**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "label": "Exact date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                }
            ],
            "outputs": [],
        },
        "delete_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to delete",
                },
                {
                    "field": "delete_subtasks",
                    "label": "Delete Subtasks",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to delete subtasks along with the issue",
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the deleted issue",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "deleted_subtasks",
                    "type": "bool",
                    "helper_text": "Whether subtasks were deleted",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "delete_issue",
            "task_name": "tasks.jira.delete_issue",
            "description": "Delete an issue",
            "label": "Delete Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "delete_subtasks",
            ],
        },
        "notify_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to notify about",
                },
                {
                    "field": "text_body",
                    "label": "Text Body",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter notification text",
                    "helper_text": "Plain text body of the notification",
                },
                {
                    "field": "html_body",
                    "label": "HTML Body",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter HTML content",
                    "helper_text": "HTML body of the notification",
                },
                {
                    "field": "subject",
                    "label": "Subject",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter subject",
                    "helper_text": "Subject of the email notification",
                },
                {
                    "field": "notify_reporter",
                    "label": "Notify Reporter",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Send notification to the issue reporter",
                },
                {
                    "field": "notify_assignee",
                    "label": "Notify Assignee",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Send notification to the issue assignee",
                },
                {
                    "field": "notify_watchers",
                    "label": "Notify Watchers",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Send notification to issue watchers",
                },
                {
                    "field": "notify_voters",
                    "label": "Notify Voters",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Send notification to issue voters",
                },
                {
                    "field": "user_account_ids",
                    "label": "User Account IDs",
                    "type": "string",
                    "value": "",
                    "placeholder": "accountId1,accountId2",
                    "helper_text": "Comma-separated list of user account IDs to notify",
                },
                {
                    "field": "group_names",
                    "label": "Group Names",
                    "type": "string",
                    "value": "",
                    "placeholder": "group1,group2",
                    "helper_text": "Comma-separated list of group names to notify",
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "notify_issue",
            "task_name": "tasks.jira.notify_issue",
            "description": "Create an email notification for an issue",
            "label": "Notify Issue",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "subject",
                "text_body",
                "html_body",
                "notify_reporter",
                "notify_assignee",
                "notify_watchers",
                "notify_voters",
                "user_account_ids",
                "group_names",
            ],
        },
        "status_transitions**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to get transitions for",
                },
                {
                    "field": "transition_id",
                    "label": "Transition ID",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter transition ID",
                    "helper_text": "ID of specific transition to get",
                },
                {
                    "field": "expand",
                    "label": "Expand",
                    "type": "string",
                    "value": "",
                    "placeholder": "transitions.fields",
                    "helper_text": "Additional information to include",
                },
                {
                    "field": "skip_remote_only_condition",
                    "label": "Skip Remote Only",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include transitions with remote-only conditions",
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "transitions",
                    "type": "vec<string>",
                    "helper_text": "List of complete transition objects (for detailed access)",
                },
                {
                    "field": "transition_names",
                    "type": "vec<string>",
                    "helper_text": "List of transition names",
                },
                {
                    "field": "transition_ids",
                    "type": "vec<string>",
                    "helper_text": "List of transition IDs",
                },
                {
                    "field": "to_status_names",
                    "type": "vec<string>",
                    "helper_text": "List of target status names",
                },
                {
                    "field": "to_status_ids",
                    "type": "vec<string>",
                    "helper_text": "List of target status IDs",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of transitions",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "status_transitions",
            "task_name": "tasks.jira.status_transitions",
            "description": "Get issue status transitions",
            "label": "Get Status Transitions",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "transition_id",
                "expand",
                "skip_remote_only_condition",
            ],
        },
        "add_attachment**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to add attachment to",
                },
                {
                    "field": "file",
                    "label": "File",
                    "type": "file",
                    "value": "",
                    "helper_text": "File to attach to the issue",
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "attachment_ids",
                    "type": "vec<string>",
                    "helper_text": "List of attachment IDs",
                },
                {
                    "field": "attachment_names",
                    "type": "vec<string>",
                    "helper_text": "List of attachment names",
                },
                {
                    "field": "attachment_sizes",
                    "type": "vec<string>",
                    "helper_text": "List of attachment sizes",
                },
                {
                    "field": "attachment_urls",
                    "type": "vec<string>",
                    "helper_text": "List of attachment URLs",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "add_attachment",
            "task_name": "tasks.jira.add_attachment",
            "description": "Add attachment to issue",
            "label": "Add Attachment",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "file",
            ],
        },
        "read_attachment**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "attachment_id",
                    "label": "Attachment ID",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter attachment ID",
                    "helper_text": "The ID of the attachment to retrieve",
                },
                {
                    "field": "download",
                    "label": "Download",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to download the attachment content",
                },
            ],
            "outputs": [
                {
                    "field": "attachment_id",
                    "type": "string",
                    "helper_text": "The ID of the attachment",
                },
                {
                    "field": "filename",
                    "type": "string",
                    "helper_text": "The filename of the attachment",
                },
                {
                    "field": "size",
                    "type": "string",
                    "helper_text": "The size of the attachment",
                },
                {
                    "field": "mime_type",
                    "type": "string",
                    "helper_text": "The MIME type of the attachment",
                },
                {
                    "field": "author",
                    "type": "string",
                    "helper_text": "The author of the attachment",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "helper_text": "The creation date of the attachment",
                },
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The downloaded file content (when download=true)",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_attachment",
            "task_name": "tasks.jira.read_attachment",
            "description": "Get an attachment",
            "label": "Read Attachment",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "attachment_id",
                "download",
            ],
        },
        "get_attachments**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to get attachments for",
                },
                {
                    "field": "limit",
                    "label": "Limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of attachments to return",
                },
                {
                    "field": "download",
                    "label": "Download",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to download attachment contents",
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "attachment_ids",
                    "type": "vec<string>",
                    "helper_text": "List of attachment IDs",
                },
                {
                    "field": "attachment_names",
                    "type": "vec<string>",
                    "helper_text": "List of attachment names",
                },
                {
                    "field": "attachment_sizes",
                    "type": "vec<string>",
                    "helper_text": "List of attachment sizes",
                },
                {
                    "field": "attachment_urls",
                    "type": "vec<string>",
                    "helper_text": "List of attachment URLs",
                },
                {
                    "field": "authors",
                    "type": "vec<string>",
                    "helper_text": "List of attachment authors",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of attachment creation dates",
                },
                {
                    "field": "mime_types",
                    "type": "vec<string>",
                    "helper_text": "List of attachment MIME types",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "List of downloaded files (when download=true)",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of attachments",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_attachments",
            "task_name": "tasks.jira.get_attachments",
            "description": "Get many attachments",
            "label": "Get Attachments",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "limit",
                "download",
            ],
        },
        "remove_attachment**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "attachment_id",
                    "label": "Attachment ID",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter attachment ID",
                    "helper_text": "The ID of the attachment to remove",
                },
            ],
            "outputs": [
                {
                    "field": "attachment_id",
                    "type": "string",
                    "helper_text": "The ID of the removed attachment",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "remove_attachment",
            "task_name": "tasks.jira.remove_attachment",
            "description": "Remove an attachment",
            "label": "Remove Attachment",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "attachment_id",
            ],
        },
        "add_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to add comment to (e.g. PROJ-123)",
                },
                {
                    "field": "comment",
                    "label": "Comment",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter your comment",
                    "helper_text": "The comment text to add",
                },
                {
                    "field": "visibility_role",
                    "label": "Visibility Role",
                    "type": "string",
                    "value": "",
                    "placeholder": "Public (No Restriction)",
                    "helper_text": "Restrict comment visibility to a project role (leave empty for public comment)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_role&site={inputs.site}&project={inputs.project}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "label": "Comment Id",
                    "type": "string",
                    "helper_text": "ID of the newly created comment",
                },
                {
                    "field": "created_date",
                    "label": "Created Dates",
                    "type": "timestamp",
                    "helper_text": "Creation date of the comment",
                },
                {
                    "field": "updated_date",
                    "type": "timestamp",
                    "helper_text": "Last update date of the comment",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "add_issue_comment",
            "task_name": "tasks.jira.add_issue_comment",
            "description": "Add a comment to a Jira issue",
            "label": "Add Issue Comment",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "comment",
                "visibility_role",
            ],
        },
        "read_issue_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue to get comments for (e.g. PROJ-123)",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "vec<string>",
                    "helper_text": "List of comment IDs",
                },
                {
                    "field": "body",
                    "type": "vec<string>",
                    "helper_text": "List of comment bodies",
                },
                {
                    "field": "created_date",
                    "type": "vec<timestamp>",
                    "helper_text": "List of comment creation dates",
                },
                {
                    "field": "updated_date",
                    "type": "vec<timestamp>",
                    "helper_text": "List of comment update dates",
                },
                {
                    "field": "author_id",
                    "type": "vec<string>",
                    "helper_text": "List of comment author account IDs",
                },
                {
                    "field": "author_email",
                    "type": "vec<string>",
                    "helper_text": "List of comment author email addresses",
                },
                {
                    "field": "author_name",
                    "type": "vec<string>",
                    "helper_text": "List of comment author display names",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of comments",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_issue_comments",
            "task_name": "tasks.jira.read_issue_comments",
            "description": "Get all comments for a Jira issue",
            "label": "Read Issue Comments",
        },
        "remove_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "comment_id",
                    "label": "Comment ID",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter comment ID",
                    "helper_text": "The ID of the comment to remove",
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "The ID of the removed comment",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "remove_comment",
            "task_name": "tasks.jira.remove_comment",
            "description": "Remove a comment",
            "label": "Remove Comment",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "comment_id",
            ],
        },
        "update_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "issue_key",
                    "label": "Issue Key",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter issue key (e.g. PROJ-123)",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "comment_id",
                    "label": "Comment ID",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter comment ID",
                    "helper_text": "The ID of the comment to update",
                },
                {
                    "field": "comment",
                    "label": "Comment",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter updated comment text",
                    "helper_text": "The new comment text",
                },
                {
                    "field": "expand",
                    "label": "Expand",
                    "type": "string",
                    "value": "",
                    "placeholder": "renderedBody",
                    "helper_text": "Additional information to include",
                },
                {
                    "field": "use_wiki_markup",
                    "label": "Use Wiki Markup",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Enable wiki markup parsing",
                },
            ],
            "outputs": [
                {
                    "field": "issue_key",
                    "type": "string",
                    "helper_text": "The key of the issue",
                },
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "The ID of the updated comment",
                },
                {
                    "field": "created_date",
                    "type": "timestamp",
                    "helper_text": "The creation date of the comment",
                },
                {
                    "field": "updated_date",
                    "type": "timestamp",
                    "helper_text": "The update date of the comment",
                },
                {
                    "field": "author",
                    "type": "string",
                    "helper_text": "The author of the comment",
                },
                {
                    "field": "comment_text",
                    "type": "string",
                    "helper_text": "The updated comment text",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_comment",
            "task_name": "tasks.jira.update_comment",
            "description": "Update a comment",
            "label": "Update Comment",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "issue_key",
                "comment_id",
                "comment",
                "expand",
                "use_wiki_markup",
            ],
        },
        "read_user**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "account_id",
                    "label": "Account ID",
                    "type": "string",
                    "value": "",
                    "placeholder": "Enter account ID",
                    "helper_text": "The account ID of the user to retrieve",
                },
                {
                    "field": "expand",
                    "label": "Expand",
                    "type": "string",
                    "value": "",
                    "placeholder": "groups,applicationRoles",
                    "helper_text": "Additional user information to include (comma-separated)",
                },
            ],
            "outputs": [
                {
                    "field": "account_id",
                    "type": "string",
                    "helper_text": "The account ID of the user",
                },
                {
                    "field": "email_address",
                    "type": "string",
                    "helper_text": "The email address of the user",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "The display name of the user",
                },
                {
                    "field": "active",
                    "type": "bool",
                    "helper_text": "Whether the user is active",
                },
                {
                    "field": "account_type",
                    "type": "string",
                    "helper_text": "The account type of the user",
                },
                {
                    "field": "timezone",
                    "type": "string",
                    "helper_text": "The timezone of the user",
                },
                {
                    "field": "locale",
                    "type": "string",
                    "helper_text": "The locale of the user",
                },
                {
                    "field": "groups",
                    "type": "vec<string>",
                    "helper_text": "The groups the user belongs to (when expanded)",
                },
                {
                    "field": "application_roles",
                    "type": "vec<string>",
                    "helper_text": "The application roles of the user (when expanded)",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_user",
            "task_name": "tasks.jira.read_user",
            "description": "Retrieve a user",
            "label": "Read User",
            "inputs_sort_order": [
                "integration",
                "action",
                "site",
                "project",
                "account_id",
                "expand",
            ],
        },
        "get_users**(*)**(*)": {
            "inputs": [
                {
                    "field": "site",
                    "type": "string",
                    "value": "",
                    "label": "Site",
                    "placeholder": "Vectorshift",
                    "helper_text": "The name of the Jira site",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=site_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "project",
                    "type": "string",
                    "value": "",
                    "label": "Project",
                    "placeholder": "Project name",
                    "helper_text": "The name of the project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_name&site={inputs.site}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "account_id",
                    "type": "vec<string>",
                    "helper_text": "The account IDs of the users in the project",
                },
                {
                    "field": "email",
                    "type": "vec<string>",
                    "helper_text": "The email addresses of the users in the project",
                },
                {
                    "field": "display_name",
                    "type": "vec<string>",
                    "helper_text": "The display names of the users in the project",
                },
                {
                    "field": "active",
                    "type": "vec<bool>",
                    "helper_text": "The active status of the users in the project",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Jira API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_users",
            "task_name": "tasks.jira.get_users",
            "description": "Get users from a Jira project",
            "label": "Get Users",
            "inputs_sort_order": ["integration", "action", "site", "project"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        account_id: str = "",
        affected_version: str = "",
        assignee_name: str = "",
        attachment_id: str = "",
        comment: str = "",
        comment_exact: str = "",
        comment_id: str = "",
        component: str = "",
        created: str = "",
        delete_subtasks: bool = False,
        description: str = "",
        description_exact: str = "",
        download: bool = False,
        due: str = "",
        exact_date: Any = {"start": "", "end": ""},
        expand: str = "",
        file: str = "",
        fix_version: str = "",
        group_names: str = "",
        html_body: str = "",
        issue_key: str = "",
        issue_summary: str = "",
        issue_type: str = "",
        labels: str = "",
        limit: int = 10,
        notify_assignee: bool = False,
        notify_reporter: bool = False,
        notify_voters: bool = False,
        notify_watchers: bool = False,
        num_messages: int = 10,
        project: str = "",
        query: str = "",
        reporter_name: str = "",
        resolution: str = "",
        resolved: str = "",
        site: str = "",
        skip_remote_only_condition: bool = False,
        status: str = "",
        subject: str = "",
        summary: str = "",
        summary_exact: str = "",
        text: str = "",
        text_body: str = "",
        text_exact: str = "",
        transition_id: str = "",
        update_assignee_name: str = "",
        update_description: str = "",
        update_issue_type: str = "",
        update_summary: str = "",
        updated: str = "",
        use_wiki_markup: bool = False,
        user_account_ids: str = "",
        visibility_role: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_jira",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if integration is not None:
            self.inputs["integration"] = integration
        if action is not None:
            self.inputs["action"] = action
        if site is not None:
            self.inputs["site"] = site
        if project is not None:
            self.inputs["project"] = project
        if issue_key is not None:
            self.inputs["issue_key"] = issue_key
        if limit is not None:
            self.inputs["limit"] = limit
        if summary is not None:
            self.inputs["summary"] = summary
        if description is not None:
            self.inputs["description"] = description
        if issue_type is not None:
            self.inputs["issue_type"] = issue_type
        if assignee_name is not None:
            self.inputs["assignee_name"] = assignee_name
        if update_summary is not None:
            self.inputs["update_summary"] = update_summary
        if update_description is not None:
            self.inputs["update_description"] = update_description
        if update_issue_type is not None:
            self.inputs["update_issue_type"] = update_issue_type
        if update_assignee_name is not None:
            self.inputs["update_assignee_name"] = update_assignee_name
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if status is not None:
            self.inputs["status"] = status
        if reporter_name is not None:
            self.inputs["reporter_name"] = reporter_name
        if query is not None:
            self.inputs["query"] = query
        if issue_summary is not None:
            self.inputs["issue_summary"] = issue_summary
        if summary_exact is not None:
            self.inputs["summary_exact"] = summary_exact
        if description_exact is not None:
            self.inputs["description_exact"] = description_exact
        if comment is not None:
            self.inputs["comment"] = comment
        if comment_exact is not None:
            self.inputs["comment_exact"] = comment_exact
        if text is not None:
            self.inputs["text"] = text
        if text_exact is not None:
            self.inputs["text_exact"] = text_exact
        if labels is not None:
            self.inputs["labels"] = labels
        if fix_version is not None:
            self.inputs["fix_version"] = fix_version
        if affected_version is not None:
            self.inputs["affected_version"] = affected_version
        if component is not None:
            self.inputs["component"] = component
        if resolution is not None:
            self.inputs["resolution"] = resolution
        if created is not None:
            self.inputs["created"] = created
        if updated is not None:
            self.inputs["updated"] = updated
        if resolved is not None:
            self.inputs["resolved"] = resolved
        if due is not None:
            self.inputs["due"] = due
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if delete_subtasks is not None:
            self.inputs["delete_subtasks"] = delete_subtasks
        if text_body is not None:
            self.inputs["text_body"] = text_body
        if html_body is not None:
            self.inputs["html_body"] = html_body
        if subject is not None:
            self.inputs["subject"] = subject
        if notify_reporter is not None:
            self.inputs["notify_reporter"] = notify_reporter
        if notify_assignee is not None:
            self.inputs["notify_assignee"] = notify_assignee
        if notify_watchers is not None:
            self.inputs["notify_watchers"] = notify_watchers
        if notify_voters is not None:
            self.inputs["notify_voters"] = notify_voters
        if user_account_ids is not None:
            self.inputs["user_account_ids"] = user_account_ids
        if group_names is not None:
            self.inputs["group_names"] = group_names
        if transition_id is not None:
            self.inputs["transition_id"] = transition_id
        if expand is not None:
            self.inputs["expand"] = expand
        if skip_remote_only_condition is not None:
            self.inputs["skip_remote_only_condition"] = skip_remote_only_condition
        if file is not None:
            self.inputs["file"] = file
        if attachment_id is not None:
            self.inputs["attachment_id"] = attachment_id
        if download is not None:
            self.inputs["download"] = download
        if visibility_role is not None:
            self.inputs["visibility_role"] = visibility_role
        if comment_id is not None:
            self.inputs["comment_id"] = comment_id
        if use_wiki_markup is not None:
            self.inputs["use_wiki_markup"] = use_wiki_markup
        if account_id is not None:
            self.inputs["account_id"] = account_id
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationJiraNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_sugar_crm")
class IntegrationSugarCrmNode(Node):
    """
    SugarCRM

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### get_records
        filter: To filter records within module
        module: Your existing module on SugarCRM

    ## Outputs
    ### get_records
        output: The retrieved output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<SugarCRM>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_records": {
            "inputs": [
                {
                    "field": "module",
                    "type": "string",
                    "value": "",
                    "label": "Module",
                    "placeholder": "customer_support",
                    "helper_text": "Your existing module on SugarCRM",
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": "Name = 'John'",
                    "helper_text": "To filter records within module",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "any",
                    "helper_text": "The retrieved output",
                }
            ],
            "name": "get_records",
            "task_name": "tasks.sugar_crm.get_records",
            "description": "Fetch records",
            "label": "Get Records",
            "variant": "default_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        filter: str = "",
        module: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_sugar_crm",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if module is not None:
            self.inputs["module"] = module
        if filter is not None:
            self.inputs["filter"] = filter
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSugarCrmNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_github")
class IntegrationGithubNode(Node):
    """
    Github

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_repositories'
        affiliation: Affiliation filter
        direction: Sort direction
        owner: Owner of the repository
        sort: Sort repositories by
        type: Repository type filter
        use_date: Toggle to use dates
        visibility: Visibility filter
    ### When action = 'get_issues'
        assignee: Assignee filter
        creator: Creator filter
        direction: Sort direction
        labels: Comma-separated list of labels
        mentioned: Mentioned user filter
        milestone: Milestone number
        owner: Owner of the repository
        repository_name: Name of the repository to create
        sort: Sort repositories by
        state: Issue state filter
        use_date: Toggle to use dates
    ### When action = 'create_issue'
        assignees: Comma-separated list of assignee usernames
        issue_body: Body content of the issue
        issue_title: Title of the issue
        labels: Comma-separated list of labels
        milestone: Milestone number
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'create_file'
        author_email: Email of the author
        author_name: Name of the author
        branch_name: Branch to create the file on
        commit_message: Message for the merge commit
        committer_email: Email of the committer
        committer_name: Name of the committer
        file_content: Content of the file
        file_path: Path where the file will be created
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'create_repository'
        auto_init: Initialize repository with a README
        gitignore_template: GitIgnore template to use
        homepage: Homepage URL for the repository
        is_private: Whether the repository should be private
        license_template: License template to use
        repository_description: Description of the repository
        repository_name: Name of the repository to create
    ### When action = 'create_pull_request'
        base: Base branch (target)
        draft: Create as draft pull request
        head: Head branch (source)
        maintainer_can_modify: Allow maintainer modifications
        owner: Owner of the repository
        pull_request_body: Body content of the pull request
        pull_request_title: Title of the pull request
        repository_name: Name of the repository to create
    ### When action = 'get_pull_requests'
        base: Base branch (target)
        direction: Sort direction
        head: Head branch (source)
        owner: Owner of the repository
        repository_name: Name of the repository to create
        sort: Sort repositories by
        state: Issue state filter
        use_date: Toggle to use dates
    ### When action = 'create_branch'
        branch_name: Branch to create the file on
        owner: Owner of the repository
        repository_name: Name of the repository to create
        source_branch: Source branch to create from
    ### When action = 'read_branch'
        branch_name: Branch to create the file on
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'delete_branch'
        branch_name: Branch to create the file on
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'create_issue_comment'
        comment_body: Body content of the comment
        issue_number: Number of the issue to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'update_issue_comment'
        comment_id: ID of the comment to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_comment_body: New body for the comment
    ### When action = 'read_issue_comment'
        comment_id: ID of the comment to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'delete_issue_comment'
        comment_id: ID of the comment to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'merge_pull_request'
        commit_message: Message for the merge commit
        commit_title: Title for the merge commit
        merge_method: Merge method to use
        owner: Owner of the repository
        pull_request_number: Number of the pull request to update
        repository_name: Name of the repository to create
        sha: SHA that pull request head must match
    ### When action = 'create_webhook'
        content_type: Content type for webhook payloads
        insecure_ssl: Allow insecure SSL
        owner: Owner of the repository
        repository_name: Name of the repository to create
        webhook_active: Whether the webhook is active
        webhook_events: Events to trigger webhook (comma-separated)
        webhook_name: Name of the webhook
        webhook_secret: Secret key for webhook security
        webhook_url: URL to send webhook payloads to
    ### When action = 'get_repositories' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_issues' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_pull_requests' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_issue_comments' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_releases' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_branches' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_organization_members' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_webhooks' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'delete_file'
        delete_author_email: Email of the author
        delete_author_name: Name of the author
        delete_branch_name: Branch to delete the file from
        delete_commit_message: Commit message for the file deletion
        delete_committer_email: Email of the committer
        delete_committer_name: Name of the committer
        delete_file_sha: Current SHA of the file to delete
        file_path: Path where the file will be created
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'get_issue_comments'
        direction: Sort direction
        issue_number: Number of the issue to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
        sort: Sort repositories by
        use_date: Toggle to use dates
    ### When action = 'create_release'
        draft: Create as draft pull request
        generate_release_notes: Auto-generate release notes
        owner: Owner of the repository
        prerelease: Mark as prerelease
        release_body: Description of the release
        release_name: Name of the release
        repository_name: Name of the repository to create
        tag_name: Name of the tag for the release
        target_commitish: Commitish value for the release
    ### When action = 'get_repositories' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_issues' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_pull_requests' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_issue_comments' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_releases' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_branches' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_organization_members' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_webhooks' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'update_file'
        file_path: Path where the file will be created
        file_sha: Current SHA of the file
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_author_email: Email of the author
        update_author_name: Name of the author
        update_branch_name: Branch to update the file on
        update_commit_message: Commit message for the file update
        update_committer_email: Email of the committer
        update_committer_name: Name of the committer
        update_file_content: New content of the file
    ### When action = 'read_file'
        file_path: Path where the file will be created
        owner: Owner of the repository
        ref: Branch, tag, or commit to read from
        repository_name: Name of the repository to create
    ### When action = 'get_organization_members'
        filter: Filter members by role
        organization: Name of the organization
        role: Filter by member role
        use_date: Toggle to use dates
    ### When action = 'update_issue'
        issue_number: Number of the issue to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_assignees: New assignees for the issue
        update_issue_body: New body for the issue
        update_issue_state: New state for the issue
        update_issue_title: New title for the issue
        update_labels: New labels for the issue
        update_milestone: New milestone for the issue
    ### When action = 'read_issue'
        issue_number: Number of the issue to update
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'get_repositories' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_issues' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_pull_requests' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_issue_comments' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_releases' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_branches' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_organization_members' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'get_webhooks' and use_date = False
        num_messages: Specify the number of repositories to fetch
    ### When action = 'update_repository'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_has_issues: Enable/disable issues
        update_has_projects: Enable/disable projects
        update_has_wiki: Enable/disable wiki
        update_homepage: New homepage URL
        update_is_private: Update privacy setting
        update_repository_description: New description for the repository
        update_repository_name: New name for the repository
    ### When action = 'read_repository'
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'delete_repository'
        owner: Owner of the repository
        repository_name: Name of the repository to create
    ### When action = 'update_pull_request'
        owner: Owner of the repository
        pull_request_number: Number of the pull request to update
        repository_name: Name of the repository to create
        update_base: New base branch
        update_maintainer_can_modify: Update maintainer modification permission
        update_pull_request_body: New body for the pull request
        update_pull_request_state: New state for the pull request
        update_pull_request_title: New title for the pull request
    ### When action = 'read_pull_request'
        owner: Owner of the repository
        pull_request_number: Number of the pull request to update
        repository_name: Name of the repository to create
    ### When action = 'update_release'
        owner: Owner of the repository
        release_id: ID of the release to update
        repository_name: Name of the repository to create
        update_draft: Update draft status
        update_prerelease: Update prerelease status
        update_release_body: New description for the release
        update_release_name: New name for the release
        update_tag_name: New tag name for the release
        update_target_commitish: New commitish value for the release
    ### When action = 'read_release'
        owner: Owner of the repository
        release_id: ID of the release to update
        repository_name: Name of the repository to create
    ### When action = 'get_releases'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        use_date: Toggle to use dates
    ### When action = 'delete_release'
        owner: Owner of the repository
        release_id: ID of the release to update
        repository_name: Name of the repository to create
    ### When action = 'get_branches'
        owner: Owner of the repository
        protected: Filter by protected status
        repository_name: Name of the repository to create
        use_date: Toggle to use dates
    ### When action = 'update_webhook'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        update_content_type: New content type
        update_insecure_ssl: Update insecure SSL setting
        update_webhook_active: Update webhook active status
        update_webhook_events: New events to trigger webhook
        update_webhook_secret: New secret key for webhook
        update_webhook_url: New URL for webhook payloads
        webhook_id: ID of the webhook to update
    ### When action = 'read_webhook'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        webhook_id: ID of the webhook to update
    ### When action = 'get_webhooks'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        use_date: Toggle to use dates
    ### When action = 'delete_webhook'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        webhook_id: ID of the webhook to update
    ### When action = 'ping_webhook'
        owner: Owner of the repository
        repository_name: Name of the repository to create
        webhook_id: ID of the webhook to update
    ### When action = 'get_repositories' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_issues' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_pull_requests' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_issue_comments' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_releases' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_branches' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_organization_members' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_webhooks' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'read_user'
        username: Username to read information for

    ## Outputs
    ### When action = 'read_pull_request'
        additions_count: Number of additions
        assignees: List of assignees
        base_details: Base branch details
        changed_files_count: Number of changed files
        closed_at: Closure timestamp
        commits_count: Number of commits
        created_at: Creation timestamp
        deletions_count: Number of deletions
        draft: Whether the pull request is a draft
        head_details: Head branch details
        labels: List of labels
        mergeable: Whether the pull request is mergeable
        merged: Whether the pull request is merged
        merged_at: Merge timestamp
        milestone: Milestone details
        pull_request_body: Body of the pull request
        pull_request_details: Pull request details in JSON format
        pull_request_id: ID of the pull request
        pull_request_number: Number of the pull request
        pull_request_state: State of the pull request
        pull_request_title: Title of the pull request
        pull_request_url: URL of the pull request
        requested_reviewers: List of requested reviewers
        updated_at: Last update timestamp
    ### When action = 'read_release'
        assets_details: Release assets details
        author_details: Release author details
        created_at: Creation timestamp
        draft: Whether the release is a draft
        prerelease: Whether the release is a prerelease
        published_at: Publication timestamp
        release_body: Body of the release
        release_details: Release details in JSON format
        release_id: ID of the release
        release_name: Name of the release
        release_url: URL of the release
        tag_name: Tag name of the release
        tarball_url: Tarball download URL
        zipball_url: Zipball download URL
    ### When action = 'get_releases'
        assets_details: List of assets details
        author_details: List of author details
        created_dates: List of creation dates
        draft_flags: List of draft flags
        prerelease_flags: List of prerelease flags
        published_dates: List of publication dates
        raw_data: Raw API response data
        release_bodies: List of release bodies
        release_details: Release details in JSON format
        release_ids: List of release IDs
        release_names: List of release names
        release_urls: List of release URLs
        tag_names: List of tag names
        tarball_urls: List of tarball URLs
        zipball_urls: List of zipball URLs
    ### When action = 'create_issue'
        assignees: List of assignees
        created_at: Creation timestamp
        issue_details: Issue details in JSON format
        issue_id: ID of the created issue
        issue_number: Number of the created issue
        issue_state: State of the created issue
        issue_title: Title of the created issue
        issue_url: URL of the created issue
        labels: List of labels
        milestone: Milestone details
    ### When action = 'update_issue'
        assignees: List of assignees
        issue_details: Issue details in JSON format
        issue_id: ID of the updated issue
        issue_number: Number of the updated issue
        issue_state: State of the updated issue
        issue_title: Title of the updated issue
        issue_url: URL of the updated issue
        labels: List of labels
        milestone: Milestone details
        updated_at: Update timestamp
    ### When action = 'read_issue'
        assignees: List of assignees
        author: Issue author details
        closed_at: Closure timestamp
        comments_count: Number of comments
        created_at: Creation timestamp
        issue_body: Body of the issue
        issue_details: Issue details in JSON format
        issue_id: ID of the issue
        issue_number: Number of the issue
        issue_state: State of the issue
        issue_title: Title of the issue
        issue_url: URL of the issue
        labels: List of labels
        milestone: Milestone details
        updated_at: Last update timestamp
    ### When action = 'get_issues'
        assignees_details: List of assignee details
        author_details: List of author details
        closed_dates: List of closure dates
        comments_counts: List of comment counts
        created_dates: List of creation dates
        issue_bodies: List of issue bodies
        issue_details: Issue details in JSON format
        issue_ids: List of issue IDs
        issue_numbers: List of issue numbers
        issue_states: List of issue states
        issue_titles: List of issue titles
        issue_urls: List of issue URLs
        labels_details: List of label details
        milestone_details: List of milestone details
        raw_data: Raw API response data
        updated_dates: List of update dates
    ### When action = 'get_pull_requests'
        assignees_details: List of assignee details
        base_details: List of base branch details
        closed_dates: List of closure dates
        created_dates: List of creation dates
        draft_flags: List of draft flags
        head_details: List of head branch details
        labels_details: List of label details
        mergeable_flags: List of mergeable flags
        merged_dates: List of merge dates
        merged_flags: List of merged flags
        milestone_details: List of milestone details
        pull_request_bodies: List of pull request bodies
        pull_request_details: Pull request details in JSON format
        pull_request_ids: List of pull request IDs
        pull_request_numbers: List of pull request numbers
        pull_request_states: List of pull request states
        pull_request_titles: List of pull request titles
        pull_request_urls: List of pull request URLs
        raw_data: Raw API response data
        requested_reviewers_details: List of requested reviewer details
        updated_dates: List of update dates
    ### When action = 'create_issue_comment'
        author_details: Comment author details
        comment_body: Body of the created comment
        comment_details: Comment details in JSON format
        comment_id: ID of the created comment
        comment_url: URL of the created comment
        created_at: Creation timestamp
    ### When action = 'update_issue_comment'
        author_details: Comment author details
        comment_body: Body of the updated comment
        comment_details: Comment details in JSON format
        comment_id: ID of the updated comment
        comment_url: URL of the updated comment
        updated_at: Update timestamp
    ### When action = 'read_issue_comment'
        author_details: Comment author details
        comment_body: Body of the comment
        comment_details: Comment details in JSON format
        comment_id: ID of the comment
        comment_url: URL of the comment
        created_at: Creation timestamp
        updated_at: Last update timestamp
    ### When action = 'get_issue_comments'
        author_details: List of comment author details
        comment_bodies: List of comment bodies
        comment_details: Comment details in JSON format
        comment_ids: List of comment IDs
        comment_urls: List of comment URLs
        created_dates: List of creation dates
        raw_data: Raw API response data
        updated_dates: List of update dates
    ### When action = 'read_user'
        avatar_url: Avatar URL of the user
        bio: Bio of the user
        blog: Blog URL of the user
        company: Company of the user
        html_url: Profile URL of the user
        location: Location of the user
        user_details: User details in JSON format
        user_email: Email of the user
        user_id: ID of the user
        user_name: Display name of the user
        username: Username of the user
    ### When action = 'get_organization_members'
        avatar_urls: List of avatar URLs
        html_urls: List of profile URLs
        member_roles: List of member roles
        raw_data: Raw API response data
        user_details: User details in JSON format
        user_emails: List of user emails
        user_ids: List of user IDs
        user_names: List of display names
        user_types: List of user types
        usernames: List of usernames
    ### When action = 'create_branch'
        branch_details: Branch details in JSON format
        branch_name: Name of the created branch
        ref: Reference of the branch
        sha: SHA of the branch
        url: URL of the branch
    ### When action = 'read_branch'
        branch_details: Branch details in JSON format
        branch_name: Name of the branch
        commit_author: Author of the latest commit
        commit_committer: Committer of the latest commit
        commit_date: Date of the latest commit
        commit_message: Message of the latest commit
        commit_url: URL of the latest commit
        protected: Whether the branch is protected
        sha: SHA of the latest commit
    ### When action = 'get_branches'
        branch_details: Branch details in JSON format
        branch_names: List of branch names
        commit_authors: List of commit authors
        commit_committers: List of commit committers
        commit_dates: List of commit dates
        commit_messages: List of commit messages
        commit_shas: List of commit SHAs
        commit_urls: List of commit URLs
        protected_flags: List of protection flags
        raw_data: Raw API response data
    ### When action = 'delete_branch'
        branch_name: Name of the deleted branch
        message: Success message
        success: Whether the branch was successfully deleted
    ### When action = 'create_repository'
        clone_url: Clone URL for the repository
        created_at: Creation timestamp
        is_private: Whether the repository is private
        repository_details: Repository details in JSON format
        repository_full_name: Full name of the repository (owner/repo)
        repository_id: ID of the created repository
        repository_name: Name of the created repository
        repository_url: URL of the repository
        ssh_url: SSH URL for the repository
    ### When action = 'read_repository'
        clone_url: Clone URL for the repository
        created_at: Creation timestamp
        default_branch: Default branch name
        forks_count: Number of forks
        is_fork: Whether the repository is a fork
        is_private: Whether the repository is private
        language: Primary programming language
        open_issues_count: Number of open issues
        owner_details: Repository owner details
        pushed_at: Last push timestamp
        repository_description: Description of the repository
        repository_details: Repository details in JSON format
        repository_full_name: Full name of the repository
        repository_id: ID of the repository
        repository_name: Name of the repository
        repository_url: URL of the repository
        ssh_url: SSH URL for the repository
        stargazers_count: Number of stars
        updated_at: Last update timestamp
        watchers_count: Number of watchers
    ### When action = 'get_repositories'
        clone_urls: List of clone URLs
        created_dates: List of creation dates
        default_branches: List of default branch names
        forks_counts: List of fork counts
        is_private_flags: List of privacy flags
        languages: List of primary languages
        open_issues_counts: List of open issue counts
        owner_details: List of owner details
        pushed_dates: List of last push dates
        raw_data: Raw API response data
        repository_descriptions: List of repository descriptions
        repository_details: Repository details in JSON format
        repository_full_names: List of full repository names
        repository_ids: List of repository IDs
        repository_names: List of repository names
        repository_urls: List of repository URLs
        ssh_urls: List of SSH URLs
        stargazers_counts: List of star counts
        updated_dates: List of update dates
        watchers_counts: List of watcher counts
    ### When action = 'delete_issue_comment'
        comment_id: ID of the deleted comment
        message: Success message
        success: Whether the comment was successfully deleted
    ### When action = 'create_file'
        commit_sha: SHA of the commit
        download_url: Download URL of the file
        file_details: File details in JSON format
        file_path: Path of the created file
        file_url: URL of the created file
        sha: SHA of the created file
    ### When action = 'update_file'
        commit_sha: SHA of the commit
        download_url: Download URL of the file
        file_details: File details in JSON format
        file_path: Path of the updated file
        file_url: URL of the updated file
        sha: New SHA of the updated file
    ### When action = 'delete_file'
        commit_sha: SHA of the commit
        file_path: Path of the deleted file
        message: Success message
        success: Whether the file was successfully deleted
    ### When action = 'create_pull_request'
        created_at: Creation timestamp
        draft: Whether the pull request is a draft
        pull_request_details: Pull request details in JSON format
        pull_request_id: ID of the created pull request
        pull_request_number: Number of the created pull request
        pull_request_state: State of the created pull request
        pull_request_title: Title of the created pull request
        pull_request_url: URL of the created pull request
    ### When action = 'create_release'
        created_at: Creation timestamp
        draft: Whether the release is a draft
        prerelease: Whether the release is a prerelease
        published_at: Publication timestamp
        release_details: Release details in JSON format
        release_id: ID of the created release
        release_name: Name of the created release
        release_url: URL of the created release
        tag_name: Tag name of the created release
        tarball_url: Tarball download URL
        zipball_url: Zipball download URL
    ### When action = 'create_webhook'
        created_at: Creation timestamp
        webhook_active: Whether the webhook is active
        webhook_details: Webhook details in JSON format
        webhook_events: List of webhook events
        webhook_id: ID of the created webhook
        webhook_name: Name of the created webhook
        webhook_url: URL of the created webhook
    ### When action = 'read_webhook'
        created_at: Creation timestamp
        ping_url: Ping URL for the webhook
        test_url: Test URL for the webhook
        updated_at: Last update timestamp
        webhook_active: Whether the webhook is active
        webhook_config: Webhook configuration details
        webhook_details: Webhook details in JSON format
        webhook_events: List of webhook events
        webhook_id: ID of the webhook
        webhook_name: Name of the webhook
        webhook_url: URL of the webhook
    ### When action = 'get_webhooks'
        created_dates: List of creation dates
        ping_urls: List of ping URLs
        raw_data: Raw API response data
        test_urls: List of test URLs
        updated_dates: List of update dates
        webhook_active_flags: List of webhook active flags
        webhook_configs: List of webhook configurations
        webhook_details: Webhook details in JSON format
        webhook_events: List of webhook events
        webhook_ids: List of webhook IDs
        webhook_names: List of webhook names
        webhook_urls: List of webhook URLs
    ### When action = 'ping_webhook'
        delivery_id: ID of the delivery
        message: Response message
        success: Whether the webhook ping was successful
        webhook_details: Webhook response details
    ### When action = 'read_file'
        download_url: Download URL of the file
        encoding: Encoding of the file
        file_content: Content of the file
        file_details: File details in JSON format
        file_name: Name of the file
        file_path: Path of the file
        file_sha: SHA of the file
        file_size: Size of the file in bytes
        file_type: Type of the file
        file_url: URL of the file
        git_url: Git URL of the file
        html_url: HTML URL of the file
    ### When action = 'merge_pull_request'
        merged: Whether the pull request was merged
        message: Merge result message
        pull_request_details: Updated pull request details
        sha: SHA of the merge commit
    ### When action = 'delete_repository'
        message: Success message
        repository_name: Name of the deleted repository
        success: Whether the repository was successfully deleted
    ### When action = 'delete_release'
        message: Success message
        release_id: ID of the deleted release
        success: Whether the release was successfully deleted
    ### When action = 'delete_webhook'
        message: Success message
        success: Whether the webhook was successfully deleted
        webhook_id: ID of the deleted webhook
    ### When action = 'update_pull_request'
        pull_request_details: Pull request details in JSON format
        pull_request_id: ID of the updated pull request
        pull_request_number: Number of the updated pull request
        pull_request_state: State of the updated pull request
        pull_request_title: Title of the updated pull request
        pull_request_url: URL of the updated pull request
        updated_at: Update timestamp
    ### When action = 'update_release'
        release_details: Release details in JSON format
        release_id: ID of the updated release
        release_name: Name of the updated release
        release_url: URL of the updated release
        tag_name: Tag name of the updated release
        updated_at: Update timestamp
    ### When action = 'update_repository'
        repository_details: Repository details in JSON format
        repository_full_name: Full name of the repository
        repository_id: ID of the repository
        repository_name: Updated name of the repository
        repository_url: URL of the repository
        updated_at: Update timestamp
    ### When action = 'update_webhook'
        updated_at: Update timestamp
        webhook_active: Whether the webhook is active
        webhook_details: Webhook details in JSON format
        webhook_events: List of webhook events
        webhook_id: ID of the updated webhook
        webhook_name: Name of the updated webhook
        webhook_url: URL of the updated webhook
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Github>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_repository**(*)**(*)": {
            "inputs": [
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository to create",
                    "label": "Repository Name",
                    "placeholder": "my-awesome-repo",
                },
                {
                    "field": "repository_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the repository",
                    "label": "Description",
                    "placeholder": "This is an awesome repository",
                },
                {
                    "field": "is_private",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the repository should be private",
                    "label": "Private Repository",
                },
                {
                    "field": "auto_init",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Initialize repository with a README",
                    "label": "Auto Initialize",
                },
                {
                    "field": "gitignore_template",
                    "type": "string",
                    "value": "",
                    "helper_text": "GitIgnore template to use",
                    "label": "GitIgnore Template",
                    "placeholder": "Node",
                },
                {
                    "field": "license_template",
                    "type": "string",
                    "value": "",
                    "helper_text": "License template to use",
                    "label": "License Template",
                    "placeholder": "mit",
                },
                {
                    "field": "homepage",
                    "type": "string",
                    "value": "",
                    "helper_text": "Homepage URL for the repository",
                    "label": "Homepage",
                    "placeholder": "https://example.com",
                },
            ],
            "outputs": [
                {
                    "field": "repository_id",
                    "type": "string",
                    "helper_text": "ID of the created repository",
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "helper_text": "Name of the created repository",
                },
                {
                    "field": "repository_full_name",
                    "type": "string",
                    "helper_text": "Full name of the repository (owner/repo)",
                },
                {
                    "field": "repository_url",
                    "type": "string",
                    "helper_text": "URL of the repository",
                },
                {
                    "field": "clone_url",
                    "type": "string",
                    "helper_text": "Clone URL for the repository",
                },
                {
                    "field": "ssh_url",
                    "type": "string",
                    "helper_text": "SSH URL for the repository",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "is_private",
                    "type": "bool",
                    "helper_text": "Whether the repository is private",
                },
                {
                    "field": "repository_details",
                    "type": "vec<string>",
                    "helper_text": "Repository details in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "create_repository",
            "task_name": "tasks.github.create_repository",
            "description": "Create a new repository on GitHub",
            "label": "Create Repository",
        },
        "update_repository**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository to update",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "update_repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the repository",
                    "label": "New Repository Name",
                    "placeholder": "new-repo-name",
                },
                {
                    "field": "update_repository_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the repository",
                    "label": "New Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_homepage",
                    "type": "string",
                    "value": "",
                    "helper_text": "New homepage URL",
                    "label": "New Homepage",
                    "placeholder": "https://newsite.com",
                },
                {
                    "field": "update_is_private",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update privacy setting",
                    "label": "Private Repository",
                },
                {
                    "field": "update_has_issues",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Enable/disable issues",
                    "label": "Has Issues",
                },
                {
                    "field": "update_has_projects",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Enable/disable projects",
                    "label": "Has Projects",
                },
                {
                    "field": "update_has_wiki",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Enable/disable wiki",
                    "label": "Has Wiki",
                },
            ],
            "outputs": [
                {
                    "field": "repository_id",
                    "type": "string",
                    "helper_text": "ID of the repository",
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "helper_text": "Updated name of the repository",
                },
                {
                    "field": "repository_full_name",
                    "type": "string",
                    "helper_text": "Full name of the repository",
                },
                {
                    "field": "repository_url",
                    "type": "string",
                    "helper_text": "URL of the repository",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "repository_details",
                    "type": "vec<string>",
                    "helper_text": "Repository details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_repository",
            "task_name": "tasks.github.update_repository",
            "description": "Update an existing repository on GitHub",
            "label": "Update Repository",
        },
        "read_repository**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository to read",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
            ],
            "outputs": [
                {
                    "field": "repository_id",
                    "type": "string",
                    "helper_text": "ID of the repository",
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "helper_text": "Name of the repository",
                },
                {
                    "field": "repository_full_name",
                    "type": "string",
                    "helper_text": "Full name of the repository",
                },
                {
                    "field": "repository_description",
                    "type": "string",
                    "helper_text": "Description of the repository",
                },
                {
                    "field": "repository_url",
                    "type": "string",
                    "helper_text": "URL of the repository",
                },
                {
                    "field": "clone_url",
                    "type": "string",
                    "helper_text": "Clone URL for the repository",
                },
                {
                    "field": "ssh_url",
                    "type": "string",
                    "helper_text": "SSH URL for the repository",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "pushed_at",
                    "type": "string",
                    "helper_text": "Last push timestamp",
                },
                {
                    "field": "is_private",
                    "type": "bool",
                    "helper_text": "Whether the repository is private",
                },
                {
                    "field": "is_fork",
                    "type": "bool",
                    "helper_text": "Whether the repository is a fork",
                },
                {
                    "field": "language",
                    "type": "string",
                    "helper_text": "Primary programming language",
                },
                {
                    "field": "stargazers_count",
                    "type": "string",
                    "helper_text": "Number of stars",
                },
                {
                    "field": "watchers_count",
                    "type": "string",
                    "helper_text": "Number of watchers",
                },
                {
                    "field": "forks_count",
                    "type": "string",
                    "helper_text": "Number of forks",
                },
                {
                    "field": "open_issues_count",
                    "type": "string",
                    "helper_text": "Number of open issues",
                },
                {
                    "field": "default_branch",
                    "type": "string",
                    "helper_text": "Default branch name",
                },
                {
                    "field": "owner_details",
                    "type": "string",
                    "helper_text": "Repository owner details",
                },
                {
                    "field": "repository_details",
                    "type": "vec<string>",
                    "helper_text": "Repository details in JSON format",
                },
            ],
            "name": "read_repository",
            "task_name": "tasks.github.read_repository",
            "description": "Read details of a GitHub repository",
            "label": "Read Repository",
            "variant": "common_integration_nodes",
        },
        "get_repositories**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner username (optional - defaults to authenticated user)",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "",
                    "helper_text": "Repository type filter",
                    "label": "Type",
                    "placeholder": "all",
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort repositories by",
                    "label": "Sort",
                    "placeholder": "created",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort direction",
                    "label": "Direction",
                    "placeholder": "desc",
                },
                {
                    "field": "visibility",
                    "type": "string",
                    "value": "",
                    "helper_text": "Visibility filter",
                    "label": "Visibility",
                    "placeholder": "all",
                },
                {
                    "field": "affiliation",
                    "type": "string",
                    "value": "",
                    "helper_text": "Affiliation filter",
                    "label": "Affiliation",
                    "placeholder": "owner",
                },
            ],
            "outputs": [
                {
                    "field": "repository_ids",
                    "type": "vec<string>",
                    "helper_text": "List of repository IDs",
                },
                {
                    "field": "repository_names",
                    "type": "vec<string>",
                    "helper_text": "List of repository names",
                },
                {
                    "field": "repository_full_names",
                    "type": "vec<string>",
                    "helper_text": "List of full repository names",
                },
                {
                    "field": "repository_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of repository descriptions",
                },
                {
                    "field": "repository_urls",
                    "type": "vec<string>",
                    "helper_text": "List of repository URLs",
                },
                {
                    "field": "clone_urls",
                    "type": "vec<string>",
                    "helper_text": "List of clone URLs",
                },
                {
                    "field": "ssh_urls",
                    "type": "vec<string>",
                    "helper_text": "List of SSH URLs",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "pushed_dates",
                    "type": "vec<string>",
                    "helper_text": "List of last push dates",
                },
                {
                    "field": "is_private_flags",
                    "type": "vec<string>",
                    "helper_text": "List of privacy flags",
                },
                {
                    "field": "languages",
                    "type": "vec<string>",
                    "helper_text": "List of primary languages",
                },
                {
                    "field": "stargazers_counts",
                    "type": "vec<string>",
                    "helper_text": "List of star counts",
                },
                {
                    "field": "watchers_counts",
                    "type": "vec<string>",
                    "helper_text": "List of watcher counts",
                },
                {
                    "field": "forks_counts",
                    "type": "vec<string>",
                    "helper_text": "List of fork counts",
                },
                {
                    "field": "open_issues_counts",
                    "type": "vec<string>",
                    "helper_text": "List of open issue counts",
                },
                {
                    "field": "default_branches",
                    "type": "vec<string>",
                    "helper_text": "List of default branch names",
                },
                {
                    "field": "owner_details",
                    "type": "vec<string>",
                    "helper_text": "List of owner details",
                },
                {
                    "field": "repository_details",
                    "type": "vec<string>",
                    "helper_text": "Repository details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_repositories",
            "task_name": "tasks.github.get_repositories",
            "description": "Get a list of repositories from GitHub",
            "label": "Get Repositories",
        },
        "get_repositories**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Repositories",
                    "helper_text": "Specify the number of repositories to fetch",
                }
            ],
            "outputs": [],
        },
        "get_repositories**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_repositories**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_repositories**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_repository**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository to delete",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the repository was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "helper_text": "Name of the deleted repository",
                },
            ],
            "name": "delete_repository",
            "task_name": "tasks.github.delete_repository",
            "description": "Delete a GitHub repository",
            "label": "Delete Repository",
            "variant": "common_integration_nodes",
        },
        "create_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Title of the issue",
                    "label": "Issue Title",
                    "placeholder": "Bug: Something is broken",
                },
                {
                    "field": "issue_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the issue",
                    "label": "Issue Body",
                    "placeholder": "Detailed description of the issue",
                },
                {
                    "field": "assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of assignee usernames",
                    "label": "Assignees",
                    "placeholder": "user1,user2",
                },
                {
                    "field": "milestone",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Milestone number",
                    "label": "Milestone",
                    "placeholder": "1",
                },
                {
                    "field": "labels",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of labels",
                    "label": "Labels",
                    "placeholder": "bug,critical",
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "ID of the created issue",
                },
                {
                    "field": "issue_number",
                    "type": "string",
                    "helper_text": "Number of the created issue",
                },
                {
                    "field": "issue_title",
                    "type": "string",
                    "helper_text": "Title of the created issue",
                },
                {
                    "field": "issue_url",
                    "type": "string",
                    "helper_text": "URL of the created issue",
                },
                {
                    "field": "issue_state",
                    "type": "string",
                    "helper_text": "State of the created issue",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "List of labels",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "helper_text": "Milestone details",
                },
                {
                    "field": "issue_details",
                    "type": "vec<string>",
                    "helper_text": "Issue details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_issue",
            "task_name": "tasks.github.create_issue",
            "description": "Create a new issue on GitHub",
            "label": "Create Issue",
        },
        "update_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the issue to update",
                    "label": "Issue Number",
                    "placeholder": "123",
                },
                {
                    "field": "update_issue_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "New title for the issue",
                    "label": "New Issue Title",
                    "placeholder": "Updated title",
                },
                {
                    "field": "update_issue_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "New body for the issue",
                    "label": "New Issue Body",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_issue_state",
                    "type": "string",
                    "value": "",
                    "helper_text": "New state for the issue",
                    "label": "New State",
                    "placeholder": "closed",
                },
                {
                    "field": "update_assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "New assignees for the issue",
                    "label": "New Assignees",
                    "placeholder": "user1,user2",
                },
                {
                    "field": "update_milestone",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "New milestone for the issue",
                    "label": "New Milestone",
                    "placeholder": "2",
                },
                {
                    "field": "update_labels",
                    "type": "string",
                    "value": "",
                    "helper_text": "New labels for the issue",
                    "label": "New Labels",
                    "placeholder": "bug,fixed",
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "ID of the updated issue",
                },
                {
                    "field": "issue_number",
                    "type": "string",
                    "helper_text": "Number of the updated issue",
                },
                {
                    "field": "issue_title",
                    "type": "string",
                    "helper_text": "Title of the updated issue",
                },
                {
                    "field": "issue_url",
                    "type": "string",
                    "helper_text": "URL of the updated issue",
                },
                {
                    "field": "issue_state",
                    "type": "string",
                    "helper_text": "State of the updated issue",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "List of labels",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "helper_text": "Milestone details",
                },
                {
                    "field": "issue_details",
                    "type": "vec<string>",
                    "helper_text": "Issue details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_issue",
            "task_name": "tasks.github.update_issue",
            "description": "Update an existing issue on GitHub",
            "label": "Update Issue",
        },
        "read_issue**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the issue to read",
                    "label": "Issue Number",
                    "placeholder": "123",
                },
            ],
            "outputs": [
                {
                    "field": "issue_id",
                    "type": "string",
                    "helper_text": "ID of the issue",
                },
                {
                    "field": "issue_number",
                    "type": "string",
                    "helper_text": "Number of the issue",
                },
                {
                    "field": "issue_title",
                    "type": "string",
                    "helper_text": "Title of the issue",
                },
                {
                    "field": "issue_body",
                    "type": "string",
                    "helper_text": "Body of the issue",
                },
                {
                    "field": "issue_url",
                    "type": "string",
                    "helper_text": "URL of the issue",
                },
                {
                    "field": "issue_state",
                    "type": "string",
                    "helper_text": "State of the issue",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "closed_at",
                    "type": "string",
                    "helper_text": "Closure timestamp",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "List of labels",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "helper_text": "Milestone details",
                },
                {
                    "field": "author",
                    "type": "string",
                    "helper_text": "Issue author details",
                },
                {
                    "field": "comments_count",
                    "type": "string",
                    "helper_text": "Number of comments",
                },
                {
                    "field": "issue_details",
                    "type": "vec<string>",
                    "helper_text": "Issue details in JSON format",
                },
            ],
            "name": "read_issue",
            "task_name": "tasks.github.read_issue",
            "description": "Read details of a GitHub issue",
            "label": "Read Issue",
            "variant": "common_integration_nodes",
        },
        "get_issues**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "helper_text": "Issue state filter",
                    "label": "State",
                    "placeholder": "open",
                },
                {
                    "field": "labels",
                    "type": "string",
                    "value": "",
                    "helper_text": "Labels filter",
                    "label": "Labels",
                    "placeholder": "bug,enhancement",
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort issues by",
                    "label": "Sort",
                    "placeholder": "created",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort direction",
                    "label": "Direction",
                    "placeholder": "desc",
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "Assignee filter",
                    "label": "Assignee",
                    "placeholder": "username",
                },
                {
                    "field": "creator",
                    "type": "string",
                    "value": "",
                    "helper_text": "Creator filter",
                    "label": "Creator",
                    "placeholder": "username",
                },
                {
                    "field": "mentioned",
                    "type": "string",
                    "value": "",
                    "helper_text": "Mentioned user filter",
                    "label": "Mentioned",
                    "placeholder": "username",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Milestone filter",
                    "label": "Milestone",
                    "placeholder": "v1.0",
                },
            ],
            "outputs": [
                {
                    "field": "issue_ids",
                    "type": "vec<string>",
                    "helper_text": "List of issue IDs",
                },
                {
                    "field": "issue_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of issue numbers",
                },
                {
                    "field": "issue_titles",
                    "type": "vec<string>",
                    "helper_text": "List of issue titles",
                },
                {
                    "field": "issue_bodies",
                    "type": "vec<string>",
                    "helper_text": "List of issue bodies",
                },
                {
                    "field": "issue_urls",
                    "type": "vec<string>",
                    "helper_text": "List of issue URLs",
                },
                {
                    "field": "issue_states",
                    "type": "vec<string>",
                    "helper_text": "List of issue states",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "closed_dates",
                    "type": "vec<string>",
                    "helper_text": "List of closure dates",
                },
                {
                    "field": "assignees_details",
                    "type": "vec<string>",
                    "helper_text": "List of assignee details",
                },
                {
                    "field": "labels_details",
                    "type": "vec<string>",
                    "helper_text": "List of label details",
                },
                {
                    "field": "milestone_details",
                    "type": "vec<string>",
                    "helper_text": "List of milestone details",
                },
                {
                    "field": "author_details",
                    "type": "vec<string>",
                    "helper_text": "List of author details",
                },
                {
                    "field": "comments_counts",
                    "type": "vec<string>",
                    "helper_text": "List of comment counts",
                },
                {
                    "field": "issue_details",
                    "type": "vec<string>",
                    "helper_text": "Issue details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_issues",
            "task_name": "tasks.github.get_issues",
            "description": "Get a list of issues from GitHub",
            "label": "Get Issues",
        },
        "get_issues**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Issues",
                    "helper_text": "Specify the number of issues to fetch",
                }
            ],
            "outputs": [],
        },
        "get_issues**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_issues**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_issues**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_pull_request**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "pull_request_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Title of the pull request",
                    "label": "Pull Request Title",
                    "placeholder": "Add new feature",
                },
                {
                    "field": "head",
                    "type": "string",
                    "value": "",
                    "helper_text": "Head branch (source)",
                    "label": "Head Branch",
                    "placeholder": "feature-branch",
                },
                {
                    "field": "base",
                    "type": "string",
                    "value": "",
                    "helper_text": "Base branch (target)",
                    "label": "Base Branch",
                    "placeholder": "main",
                },
                {
                    "field": "pull_request_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the pull request",
                    "label": "Pull Request Body",
                    "placeholder": "This PR adds a new feature",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Create as draft pull request",
                    "label": "Draft",
                },
                {
                    "field": "maintainer_can_modify",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow maintainer modifications",
                    "label": "Maintainer Can Modify",
                },
            ],
            "outputs": [
                {
                    "field": "pull_request_id",
                    "type": "string",
                    "helper_text": "ID of the created pull request",
                },
                {
                    "field": "pull_request_number",
                    "type": "string",
                    "helper_text": "Number of the created pull request",
                },
                {
                    "field": "pull_request_title",
                    "type": "string",
                    "helper_text": "Title of the created pull request",
                },
                {
                    "field": "pull_request_url",
                    "type": "string",
                    "helper_text": "URL of the created pull request",
                },
                {
                    "field": "pull_request_state",
                    "type": "string",
                    "helper_text": "State of the created pull request",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "helper_text": "Whether the pull request is a draft",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Pull request details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_pull_request",
            "task_name": "tasks.github.create_pull_request",
            "description": "Create a new pull request on GitHub",
            "label": "Create Pull Request",
        },
        "update_pull_request**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "pull_request_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the pull request to update",
                    "label": "Pull Request Number",
                    "placeholder": "123",
                },
                {
                    "field": "update_pull_request_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "New title for the pull request",
                    "label": "New Title",
                    "placeholder": "Updated title",
                },
                {
                    "field": "update_pull_request_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "New body for the pull request",
                    "label": "New Body",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_pull_request_state",
                    "type": "string",
                    "value": "",
                    "helper_text": "New state for the pull request",
                    "label": "New State",
                    "placeholder": "closed",
                },
                {
                    "field": "update_base",
                    "type": "string",
                    "value": "",
                    "helper_text": "New base branch",
                    "label": "New Base Branch",
                    "placeholder": "develop",
                },
                {
                    "field": "update_maintainer_can_modify",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Update maintainer modification permission",
                    "label": "Maintainer Can Modify",
                },
            ],
            "outputs": [
                {
                    "field": "pull_request_id",
                    "type": "string",
                    "helper_text": "ID of the updated pull request",
                },
                {
                    "field": "pull_request_number",
                    "type": "string",
                    "helper_text": "Number of the updated pull request",
                },
                {
                    "field": "pull_request_title",
                    "type": "string",
                    "helper_text": "Title of the updated pull request",
                },
                {
                    "field": "pull_request_url",
                    "type": "string",
                    "helper_text": "URL of the updated pull request",
                },
                {
                    "field": "pull_request_state",
                    "type": "string",
                    "helper_text": "State of the updated pull request",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Pull request details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_pull_request",
            "task_name": "tasks.github.update_pull_request",
            "description": "Update an existing pull request on GitHub",
            "label": "Update Pull Request",
        },
        "read_pull_request**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "pull_request_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the pull request to read",
                    "label": "Pull Request Number",
                    "placeholder": "123",
                },
            ],
            "outputs": [
                {
                    "field": "pull_request_id",
                    "type": "string",
                    "helper_text": "ID of the pull request",
                },
                {
                    "field": "pull_request_number",
                    "type": "string",
                    "helper_text": "Number of the pull request",
                },
                {
                    "field": "pull_request_title",
                    "type": "string",
                    "helper_text": "Title of the pull request",
                },
                {
                    "field": "pull_request_body",
                    "type": "string",
                    "helper_text": "Body of the pull request",
                },
                {
                    "field": "pull_request_url",
                    "type": "string",
                    "helper_text": "URL of the pull request",
                },
                {
                    "field": "pull_request_state",
                    "type": "string",
                    "helper_text": "State of the pull request",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "closed_at",
                    "type": "string",
                    "helper_text": "Closure timestamp",
                },
                {
                    "field": "merged_at",
                    "type": "string",
                    "helper_text": "Merge timestamp",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "helper_text": "Whether the pull request is a draft",
                },
                {
                    "field": "merged",
                    "type": "bool",
                    "helper_text": "Whether the pull request is merged",
                },
                {
                    "field": "mergeable",
                    "type": "bool",
                    "helper_text": "Whether the pull request is mergeable",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees",
                },
                {
                    "field": "requested_reviewers",
                    "type": "vec<string>",
                    "helper_text": "List of requested reviewers",
                },
                {
                    "field": "labels",
                    "type": "vec<string>",
                    "helper_text": "List of labels",
                },
                {
                    "field": "milestone",
                    "type": "string",
                    "helper_text": "Milestone details",
                },
                {
                    "field": "head_details",
                    "type": "string",
                    "helper_text": "Head branch details",
                },
                {
                    "field": "base_details",
                    "type": "string",
                    "helper_text": "Base branch details",
                },
                {
                    "field": "commits_count",
                    "type": "string",
                    "helper_text": "Number of commits",
                },
                {
                    "field": "additions_count",
                    "type": "string",
                    "helper_text": "Number of additions",
                },
                {
                    "field": "deletions_count",
                    "type": "string",
                    "helper_text": "Number of deletions",
                },
                {
                    "field": "changed_files_count",
                    "type": "string",
                    "helper_text": "Number of changed files",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Pull request details in JSON format",
                },
            ],
            "name": "read_pull_request",
            "task_name": "tasks.github.read_pull_request",
            "description": "Read details of a GitHub pull request",
            "label": "Read Pull Request",
            "variant": "common_integration_nodes",
        },
        "get_pull_requests**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "helper_text": "Pull request state filter",
                    "label": "State",
                    "placeholder": "open",
                },
                {
                    "field": "head",
                    "type": "string",
                    "value": "",
                    "helper_text": "Head branch filter",
                    "label": "Head Branch",
                    "placeholder": "feature-branch",
                },
                {
                    "field": "base",
                    "type": "string",
                    "value": "",
                    "helper_text": "Base branch filter",
                    "label": "Base Branch",
                    "placeholder": "main",
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort pull requests by",
                    "label": "Sort",
                    "placeholder": "created",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort direction",
                    "label": "Direction",
                    "placeholder": "desc",
                },
            ],
            "outputs": [
                {
                    "field": "pull_request_ids",
                    "type": "vec<string>",
                    "helper_text": "List of pull request IDs",
                },
                {
                    "field": "pull_request_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of pull request numbers",
                },
                {
                    "field": "pull_request_titles",
                    "type": "vec<string>",
                    "helper_text": "List of pull request titles",
                },
                {
                    "field": "pull_request_bodies",
                    "type": "vec<string>",
                    "helper_text": "List of pull request bodies",
                },
                {
                    "field": "pull_request_urls",
                    "type": "vec<string>",
                    "helper_text": "List of pull request URLs",
                },
                {
                    "field": "pull_request_states",
                    "type": "vec<string>",
                    "helper_text": "List of pull request states",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "closed_dates",
                    "type": "vec<string>",
                    "helper_text": "List of closure dates",
                },
                {
                    "field": "merged_dates",
                    "type": "vec<string>",
                    "helper_text": "List of merge dates",
                },
                {
                    "field": "draft_flags",
                    "type": "vec<string>",
                    "helper_text": "List of draft flags",
                },
                {
                    "field": "merged_flags",
                    "type": "vec<string>",
                    "helper_text": "List of merged flags",
                },
                {
                    "field": "mergeable_flags",
                    "type": "vec<string>",
                    "helper_text": "List of mergeable flags",
                },
                {
                    "field": "assignees_details",
                    "type": "vec<string>",
                    "helper_text": "List of assignee details",
                },
                {
                    "field": "requested_reviewers_details",
                    "type": "vec<string>",
                    "helper_text": "List of requested reviewer details",
                },
                {
                    "field": "labels_details",
                    "type": "vec<string>",
                    "helper_text": "List of label details",
                },
                {
                    "field": "milestone_details",
                    "type": "vec<string>",
                    "helper_text": "List of milestone details",
                },
                {
                    "field": "head_details",
                    "type": "vec<string>",
                    "helper_text": "List of head branch details",
                },
                {
                    "field": "base_details",
                    "type": "vec<string>",
                    "helper_text": "List of base branch details",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Pull request details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_pull_requests",
            "task_name": "tasks.github.get_pull_requests",
            "description": "Get a list of pull requests from GitHub",
            "label": "Get Pull Requests",
        },
        "get_pull_requests**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Pull Requests",
                    "helper_text": "Specify the number of pull requests to fetch",
                }
            ],
            "outputs": [],
        },
        "get_pull_requests**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_pull_requests**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_pull_requests**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "merge_pull_request**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "pull_request_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the pull request to merge",
                    "label": "Pull Request Number",
                    "placeholder": "123",
                },
                {
                    "field": "commit_title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Title for the merge commit",
                    "label": "Commit Title",
                    "placeholder": "Merge pull request",
                },
                {
                    "field": "commit_message",
                    "type": "string",
                    "value": "",
                    "helper_text": "Message for the merge commit",
                    "label": "Commit Message",
                    "placeholder": "Merged feature branch",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "value": "",
                    "helper_text": "SHA that pull request head must match",
                    "label": "SHA",
                    "placeholder": "abc123",
                },
                {
                    "field": "merge_method",
                    "type": "string",
                    "value": "",
                    "helper_text": "Merge method to use",
                    "label": "Merge Method",
                    "placeholder": "merge",
                },
            ],
            "outputs": [
                {
                    "field": "merged",
                    "type": "bool",
                    "helper_text": "Whether the pull request was merged",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "helper_text": "SHA of the merge commit",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Merge result message",
                },
                {
                    "field": "pull_request_details",
                    "type": "vec<string>",
                    "helper_text": "Updated pull request details",
                },
            ],
            "name": "merge_pull_request",
            "task_name": "tasks.github.merge_pull_request",
            "description": "Merge a GitHub pull request",
            "label": "Merge Pull Request",
            "variant": "common_integration_nodes",
        },
        "create_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the issue to comment on",
                    "label": "Issue Number",
                    "placeholder": "123",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the comment",
                    "label": "Comment Body",
                    "placeholder": "This is a comment on the issue",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the created comment",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "helper_text": "Body of the created comment",
                },
                {
                    "field": "comment_url",
                    "type": "string",
                    "helper_text": "URL of the created comment",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "author_details",
                    "type": "string",
                    "helper_text": "Comment author details",
                },
                {
                    "field": "comment_details",
                    "type": "vec<string>",
                    "helper_text": "Comment details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_issue_comment",
            "task_name": "tasks.github.create_issue_comment",
            "description": "Create a new comment on a GitHub issue",
            "label": "Create Issue Comment",
        },
        "update_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "comment_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the comment to update",
                    "label": "Comment ID",
                    "placeholder": "123456",
                },
                {
                    "field": "update_comment_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "New body for the comment",
                    "label": "New Comment Body",
                    "placeholder": "Updated comment content",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the updated comment",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "helper_text": "Body of the updated comment",
                },
                {
                    "field": "comment_url",
                    "type": "string",
                    "helper_text": "URL of the updated comment",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "author_details",
                    "type": "string",
                    "helper_text": "Comment author details",
                },
                {
                    "field": "comment_details",
                    "type": "vec<string>",
                    "helper_text": "Comment details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_issue_comment",
            "task_name": "tasks.github.update_issue_comment",
            "description": "Update an existing comment on a GitHub issue",
            "label": "Update Issue Comment",
        },
        "read_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "comment_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the comment to read",
                    "label": "Comment ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the comment",
                },
                {
                    "field": "comment_body",
                    "type": "string",
                    "helper_text": "Body of the comment",
                },
                {
                    "field": "comment_url",
                    "type": "string",
                    "helper_text": "URL of the comment",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "author_details",
                    "type": "string",
                    "helper_text": "Comment author details",
                },
                {
                    "field": "comment_details",
                    "type": "vec<string>",
                    "helper_text": "Comment details in JSON format",
                },
            ],
            "name": "read_issue_comment",
            "task_name": "tasks.github.read_issue_comment",
            "description": "Read details of a GitHub issue comment",
            "label": "Read Issue Comment",
            "variant": "common_integration_nodes",
        },
        "get_issue_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "issue_number",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Number of the issue to get comments from",
                    "label": "Issue Number",
                    "placeholder": "123",
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "sort",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort comments by",
                    "label": "Sort",
                    "placeholder": "created",
                },
                {
                    "field": "direction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort direction",
                    "label": "Direction",
                    "placeholder": "asc",
                },
            ],
            "outputs": [
                {
                    "field": "comment_ids",
                    "type": "vec<string>",
                    "helper_text": "List of comment IDs",
                },
                {
                    "field": "comment_bodies",
                    "type": "vec<string>",
                    "helper_text": "List of comment bodies",
                },
                {
                    "field": "comment_urls",
                    "type": "vec<string>",
                    "helper_text": "List of comment URLs",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "author_details",
                    "type": "vec<string>",
                    "helper_text": "List of comment author details",
                },
                {
                    "field": "comment_details",
                    "type": "vec<string>",
                    "helper_text": "Comment details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_issue_comments",
            "task_name": "tasks.github.get_issue_comments",
            "description": "Get a list of comments from a GitHub issue",
            "label": "Get Issue Comments",
        },
        "get_issue_comments**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Comments",
                    "helper_text": "Specify the number of comments to fetch",
                }
            ],
            "outputs": [],
        },
        "get_issue_comments**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_issue_comments**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_issue_comments**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_issue_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "comment_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the comment to delete",
                    "label": "Comment ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the comment was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the deleted comment",
                },
            ],
            "name": "delete_issue_comment",
            "task_name": "tasks.github.delete_issue_comment",
            "description": "Delete a GitHub issue comment",
            "label": "Delete Issue Comment",
            "variant": "common_integration_nodes",
        },
        "create_release**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag for the release",
                    "label": "Tag Name",
                    "placeholder": "v1.0.0",
                },
                {
                    "field": "release_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the release",
                    "label": "Release Name",
                    "placeholder": "Version 1.0.0",
                },
                {
                    "field": "release_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the release",
                    "label": "Release Body",
                    "placeholder": "Release notes and changelog",
                },
                {
                    "field": "target_commitish",
                    "type": "string",
                    "value": "",
                    "helper_text": "Commitish value for the release",
                    "label": "Target Commitish",
                    "placeholder": "main",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Create as draft release",
                    "label": "Draft",
                },
                {
                    "field": "prerelease",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark as prerelease",
                    "label": "Prerelease",
                },
                {
                    "field": "generate_release_notes",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Auto-generate release notes",
                    "label": "Generate Release Notes",
                },
            ],
            "outputs": [
                {
                    "field": "release_id",
                    "type": "string",
                    "helper_text": "ID of the created release",
                },
                {
                    "field": "release_name",
                    "type": "string",
                    "helper_text": "Name of the created release",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Tag name of the created release",
                },
                {
                    "field": "release_url",
                    "type": "string",
                    "helper_text": "URL of the created release",
                },
                {
                    "field": "tarball_url",
                    "type": "string",
                    "helper_text": "Tarball download URL",
                },
                {
                    "field": "zipball_url",
                    "type": "string",
                    "helper_text": "Zipball download URL",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "published_at",
                    "type": "string",
                    "helper_text": "Publication timestamp",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "helper_text": "Whether the release is a draft",
                },
                {
                    "field": "prerelease",
                    "type": "bool",
                    "helper_text": "Whether the release is a prerelease",
                },
                {
                    "field": "release_details",
                    "type": "vec<string>",
                    "helper_text": "Release details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_release",
            "task_name": "tasks.github.create_release",
            "description": "Create a new release on GitHub",
            "label": "Create Release",
        },
        "update_release**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "release_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the release to update",
                    "label": "Release ID",
                    "placeholder": "123456",
                },
                {
                    "field": "update_tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New tag name for the release",
                    "label": "New Tag Name",
                    "placeholder": "v1.0.1",
                },
                {
                    "field": "update_release_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the release",
                    "label": "New Release Name",
                    "placeholder": "Version 1.0.1",
                },
                {
                    "field": "update_release_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the release",
                    "label": "New Release Body",
                    "placeholder": "Updated release notes",
                },
                {
                    "field": "update_target_commitish",
                    "type": "string",
                    "value": "",
                    "helper_text": "New commitish value for the release",
                    "label": "New Target Commitish",
                    "placeholder": "main",
                },
                {
                    "field": "update_draft",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update draft status",
                    "label": "Draft",
                },
                {
                    "field": "update_prerelease",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update prerelease status",
                    "label": "Prerelease",
                },
            ],
            "outputs": [
                {
                    "field": "release_id",
                    "type": "string",
                    "helper_text": "ID of the updated release",
                },
                {
                    "field": "release_name",
                    "type": "string",
                    "helper_text": "Name of the updated release",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Tag name of the updated release",
                },
                {
                    "field": "release_url",
                    "type": "string",
                    "helper_text": "URL of the updated release",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "release_details",
                    "type": "vec<string>",
                    "helper_text": "Release details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_release",
            "task_name": "tasks.github.update_release",
            "description": "Update an existing release on GitHub",
            "label": "Update Release",
        },
        "read_release**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "release_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the release to read",
                    "label": "Release ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "release_id",
                    "type": "string",
                    "helper_text": "ID of the release",
                },
                {
                    "field": "release_name",
                    "type": "string",
                    "helper_text": "Name of the release",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Tag name of the release",
                },
                {
                    "field": "release_body",
                    "type": "string",
                    "helper_text": "Body of the release",
                },
                {
                    "field": "release_url",
                    "type": "string",
                    "helper_text": "URL of the release",
                },
                {
                    "field": "tarball_url",
                    "type": "string",
                    "helper_text": "Tarball download URL",
                },
                {
                    "field": "zipball_url",
                    "type": "string",
                    "helper_text": "Zipball download URL",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "published_at",
                    "type": "string",
                    "helper_text": "Publication timestamp",
                },
                {
                    "field": "draft",
                    "type": "bool",
                    "helper_text": "Whether the release is a draft",
                },
                {
                    "field": "prerelease",
                    "type": "bool",
                    "helper_text": "Whether the release is a prerelease",
                },
                {
                    "field": "author_details",
                    "type": "string",
                    "helper_text": "Release author details",
                },
                {
                    "field": "assets_details",
                    "type": "vec<string>",
                    "helper_text": "Release assets details",
                },
                {
                    "field": "release_details",
                    "type": "vec<string>",
                    "helper_text": "Release details in JSON format",
                },
            ],
            "name": "read_release",
            "task_name": "tasks.github.read_release",
            "description": "Read details of a GitHub release",
            "label": "Read Release",
            "variant": "common_integration_nodes",
        },
        "get_releases**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
            ],
            "outputs": [
                {
                    "field": "release_ids",
                    "type": "vec<string>",
                    "helper_text": "List of release IDs",
                },
                {
                    "field": "release_names",
                    "type": "vec<string>",
                    "helper_text": "List of release names",
                },
                {
                    "field": "tag_names",
                    "type": "vec<string>",
                    "helper_text": "List of tag names",
                },
                {
                    "field": "release_bodies",
                    "type": "vec<string>",
                    "helper_text": "List of release bodies",
                },
                {
                    "field": "release_urls",
                    "type": "vec<string>",
                    "helper_text": "List of release URLs",
                },
                {
                    "field": "tarball_urls",
                    "type": "vec<string>",
                    "helper_text": "List of tarball URLs",
                },
                {
                    "field": "zipball_urls",
                    "type": "vec<string>",
                    "helper_text": "List of zipball URLs",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "published_dates",
                    "type": "vec<string>",
                    "helper_text": "List of publication dates",
                },
                {
                    "field": "draft_flags",
                    "type": "vec<string>",
                    "helper_text": "List of draft flags",
                },
                {
                    "field": "prerelease_flags",
                    "type": "vec<string>",
                    "helper_text": "List of prerelease flags",
                },
                {
                    "field": "author_details",
                    "type": "vec<string>",
                    "helper_text": "List of author details",
                },
                {
                    "field": "assets_details",
                    "type": "vec<string>",
                    "helper_text": "List of assets details",
                },
                {
                    "field": "release_details",
                    "type": "vec<string>",
                    "helper_text": "Release details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_releases",
            "task_name": "tasks.github.get_releases",
            "description": "Get a list of releases from GitHub",
            "label": "Get Releases",
        },
        "get_releases**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Releases",
                    "helper_text": "Specify the number of releases to fetch",
                }
            ],
            "outputs": [],
        },
        "get_releases**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_releases**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_releases**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_release**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "release_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the release to delete",
                    "label": "Release ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the release was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "release_id",
                    "type": "string",
                    "helper_text": "ID of the deleted release",
                },
            ],
            "name": "delete_release",
            "task_name": "tasks.github.delete_release",
            "description": "Delete a GitHub release",
            "label": "Delete Release",
            "variant": "common_integration_nodes",
        },
        "create_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path where the file will be created",
                    "label": "File Path",
                    "placeholder": "src/main.js",
                },
                {
                    "field": "file_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content of the file",
                    "label": "File Content",
                    "placeholder": "console.log('Hello World');",
                },
                {
                    "field": "commit_message",
                    "type": "string",
                    "value": "",
                    "helper_text": "Commit message for the file creation",
                    "label": "Commit Message",
                    "placeholder": "Add new file",
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Branch to create the file on",
                    "label": "Branch Name",
                    "placeholder": "main",
                },
                {
                    "field": "committer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the committer",
                    "label": "Committer Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "committer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the committer",
                    "label": "Committer Email",
                    "placeholder": "john@example.com",
                },
                {
                    "field": "author_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the author",
                    "label": "Author Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "author_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the author",
                    "label": "Author Email",
                    "placeholder": "john@example.com",
                },
            ],
            "outputs": [
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the created file",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "helper_text": "SHA of the created file",
                },
                {
                    "field": "commit_sha",
                    "type": "string",
                    "helper_text": "SHA of the commit",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the created file",
                },
                {
                    "field": "download_url",
                    "type": "string",
                    "helper_text": "Download URL of the file",
                },
                {
                    "field": "file_details",
                    "type": "vec<string>",
                    "helper_text": "File details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_file",
            "task_name": "tasks.github.create_file",
            "description": "Create a new file in a GitHub repository",
            "label": "Create File",
        },
        "update_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the file to update",
                    "label": "File Path",
                    "placeholder": "src/main.js",
                },
                {
                    "field": "update_file_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "New content of the file",
                    "label": "New File Content",
                    "placeholder": "console.log('Updated Hello World');",
                },
                {
                    "field": "update_commit_message",
                    "type": "string",
                    "value": "",
                    "helper_text": "Commit message for the file update",
                    "label": "Commit Message",
                    "placeholder": "Update file",
                },
                {
                    "field": "update_branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Branch to update the file on",
                    "label": "Branch Name",
                    "placeholder": "main",
                },
                {
                    "field": "file_sha",
                    "type": "string",
                    "value": "",
                    "helper_text": "Current SHA of the file",
                    "label": "File SHA",
                    "placeholder": "abc123",
                },
                {
                    "field": "update_committer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the committer",
                    "label": "Committer Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "update_committer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the committer",
                    "label": "Committer Email",
                    "placeholder": "john@example.com",
                },
                {
                    "field": "update_author_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the author",
                    "label": "Author Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "update_author_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the author",
                    "label": "Author Email",
                    "placeholder": "john@example.com",
                },
            ],
            "outputs": [
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the updated file",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "helper_text": "New SHA of the updated file",
                },
                {
                    "field": "commit_sha",
                    "type": "string",
                    "helper_text": "SHA of the commit",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the updated file",
                },
                {
                    "field": "download_url",
                    "type": "string",
                    "helper_text": "Download URL of the file",
                },
                {
                    "field": "file_details",
                    "type": "vec<string>",
                    "helper_text": "File details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_file",
            "task_name": "tasks.github.update_file",
            "description": "Update an existing file in a GitHub repository",
            "label": "Update File",
        },
        "read_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the file to read",
                    "label": "File Path",
                    "placeholder": "src/main.js",
                },
                {
                    "field": "ref",
                    "type": "string",
                    "value": "",
                    "helper_text": "Branch, tag, or commit to read from",
                    "label": "Reference",
                    "placeholder": "main",
                },
            ],
            "outputs": [
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the file",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the file",
                },
                {
                    "field": "file_content",
                    "type": "string",
                    "helper_text": "Content of the file",
                },
                {
                    "field": "file_sha",
                    "type": "string",
                    "helper_text": "SHA of the file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the file in bytes",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the file",
                },
                {
                    "field": "download_url",
                    "type": "string",
                    "helper_text": "Download URL of the file",
                },
                {
                    "field": "git_url",
                    "type": "string",
                    "helper_text": "Git URL of the file",
                },
                {
                    "field": "html_url",
                    "type": "string",
                    "helper_text": "HTML URL of the file",
                },
                {
                    "field": "encoding",
                    "type": "string",
                    "helper_text": "Encoding of the file",
                },
                {
                    "field": "file_type",
                    "type": "string",
                    "helper_text": "Type of the file",
                },
                {
                    "field": "file_details",
                    "type": "vec<string>",
                    "helper_text": "File details in JSON format",
                },
            ],
            "name": "read_file",
            "task_name": "tasks.github.read_file",
            "description": "Read a file from a GitHub repository",
            "label": "Read File",
            "variant": "common_integration_nodes",
        },
        "delete_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the file to delete",
                    "label": "File Path",
                    "placeholder": "src/main.js",
                },
                {
                    "field": "delete_commit_message",
                    "type": "string",
                    "value": "",
                    "helper_text": "Commit message for the file deletion",
                    "label": "Commit Message",
                    "placeholder": "Delete file",
                },
                {
                    "field": "delete_branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Branch to delete the file from",
                    "label": "Branch Name",
                    "placeholder": "main",
                },
                {
                    "field": "delete_file_sha",
                    "type": "string",
                    "value": "",
                    "helper_text": "Current SHA of the file to delete",
                    "label": "File SHA",
                    "placeholder": "abc123",
                },
                {
                    "field": "delete_committer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the committer",
                    "label": "Committer Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "delete_committer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the committer",
                    "label": "Committer Email",
                    "placeholder": "john@example.com",
                },
                {
                    "field": "delete_author_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the author",
                    "label": "Author Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "delete_author_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the author",
                    "label": "Author Email",
                    "placeholder": "john@example.com",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the file was successfully deleted",
                },
                {
                    "field": "commit_sha",
                    "type": "string",
                    "helper_text": "SHA of the commit",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the deleted file",
                },
            ],
            "name": "delete_file",
            "task_name": "tasks.github.delete_file",
            "description": "Delete a file from a GitHub repository",
            "label": "Delete File",
            "variant": "common_integration_nodes",
        },
        "create_branch**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the new branch",
                    "label": "Branch Name",
                    "placeholder": "feature-branch",
                },
                {
                    "field": "source_branch",
                    "type": "string",
                    "value": "",
                    "helper_text": "Source branch to create from",
                    "label": "Source Branch",
                    "placeholder": "main",
                },
            ],
            "outputs": [
                {
                    "field": "branch_name",
                    "type": "string",
                    "helper_text": "Name of the created branch",
                },
                {"field": "sha", "type": "string", "helper_text": "SHA of the branch"},
                {
                    "field": "ref",
                    "type": "string",
                    "helper_text": "Reference of the branch",
                },
                {"field": "url", "type": "string", "helper_text": "URL of the branch"},
                {
                    "field": "branch_details",
                    "type": "vec<string>",
                    "helper_text": "Branch details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_branch",
            "task_name": "tasks.github.create_branch",
            "description": "Create a new branch in a GitHub repository",
            "label": "Create Branch",
        },
        "read_branch**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the branch to read",
                    "label": "Branch Name",
                    "placeholder": "feature-branch",
                },
            ],
            "outputs": [
                {
                    "field": "branch_name",
                    "type": "string",
                    "helper_text": "Name of the branch",
                },
                {
                    "field": "sha",
                    "type": "string",
                    "helper_text": "SHA of the latest commit",
                },
                {
                    "field": "commit_url",
                    "type": "string",
                    "helper_text": "URL of the latest commit",
                },
                {
                    "field": "commit_message",
                    "type": "string",
                    "helper_text": "Message of the latest commit",
                },
                {
                    "field": "commit_author",
                    "type": "string",
                    "helper_text": "Author of the latest commit",
                },
                {
                    "field": "commit_committer",
                    "type": "string",
                    "helper_text": "Committer of the latest commit",
                },
                {
                    "field": "commit_date",
                    "type": "string",
                    "helper_text": "Date of the latest commit",
                },
                {
                    "field": "protected",
                    "type": "bool",
                    "helper_text": "Whether the branch is protected",
                },
                {
                    "field": "branch_details",
                    "type": "vec<string>",
                    "helper_text": "Branch details in JSON format",
                },
            ],
            "name": "read_branch",
            "task_name": "tasks.github.read_branch",
            "description": "Read details of a GitHub branch",
            "label": "Read Branch",
            "variant": "common_integration_nodes",
        },
        "get_branches**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "protected",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Filter by protected status",
                    "label": "Protected Only",
                },
            ],
            "outputs": [
                {
                    "field": "branch_names",
                    "type": "vec<string>",
                    "helper_text": "List of branch names",
                },
                {
                    "field": "commit_shas",
                    "type": "vec<string>",
                    "helper_text": "List of commit SHAs",
                },
                {
                    "field": "commit_urls",
                    "type": "vec<string>",
                    "helper_text": "List of commit URLs",
                },
                {
                    "field": "commit_messages",
                    "type": "vec<string>",
                    "helper_text": "List of commit messages",
                },
                {
                    "field": "commit_authors",
                    "type": "vec<string>",
                    "helper_text": "List of commit authors",
                },
                {
                    "field": "commit_committers",
                    "type": "vec<string>",
                    "helper_text": "List of commit committers",
                },
                {
                    "field": "commit_dates",
                    "type": "vec<string>",
                    "helper_text": "List of commit dates",
                },
                {
                    "field": "protected_flags",
                    "type": "vec<string>",
                    "helper_text": "List of protection flags",
                },
                {
                    "field": "branch_details",
                    "type": "vec<string>",
                    "helper_text": "Branch details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_branches",
            "task_name": "tasks.github.get_branches",
            "description": "Get a list of branches from GitHub",
            "label": "Get Branches",
        },
        "get_branches**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Branches",
                    "helper_text": "Specify the number of branches to fetch",
                }
            ],
            "outputs": [],
        },
        "get_branches**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_branches**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_branches**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_branch**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the branch to delete",
                    "label": "Branch Name",
                    "placeholder": "feature-branch",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the branch was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "branch_name",
                    "type": "string",
                    "helper_text": "Name of the deleted branch",
                },
            ],
            "name": "delete_branch",
            "task_name": "tasks.github.delete_branch",
            "description": "Delete a branch from a GitHub repository",
            "label": "Delete Branch",
            "variant": "common_integration_nodes",
        },
        "read_user**(*)**(*)": {
            "inputs": [
                {
                    "field": "username",
                    "type": "string",
                    "value": "",
                    "helper_text": "Username to read information for",
                    "label": "Username",
                    "placeholder": "octocat",
                }
            ],
            "outputs": [
                {"field": "user_id", "type": "string", "helper_text": "ID of the user"},
                {
                    "field": "username",
                    "type": "string",
                    "helper_text": "Username of the user",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Display name of the user",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "helper_text": "Email of the user",
                },
                {
                    "field": "avatar_url",
                    "type": "string",
                    "helper_text": "Avatar URL of the user",
                },
                {
                    "field": "html_url",
                    "type": "string",
                    "helper_text": "Profile URL of the user",
                },
                {"field": "bio", "type": "string", "helper_text": "Bio of the user"},
                {
                    "field": "location",
                    "type": "string",
                    "helper_text": "Location of the user",
                },
                {
                    "field": "company",
                    "type": "string",
                    "helper_text": "Company of the user",
                },
                {
                    "field": "blog",
                    "type": "string",
                    "helper_text": "Blog URL of the user",
                },
                {
                    "field": "user_details",
                    "type": "vec<string>",
                    "helper_text": "User details in JSON format",
                },
            ],
            "name": "read_user",
            "task_name": "tasks.github.read_user",
            "description": "Read details of a GitHub user",
            "label": "Read User",
            "variant": "default_integration_nodes",
        },
        "get_organization_members**(*)**(*)": {
            "inputs": [
                {
                    "field": "organization",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the organization",
                    "label": "Organization",
                    "placeholder": "mycompany",
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter members by role",
                    "label": "Filter",
                    "placeholder": "all",
                },
                {
                    "field": "role",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by member role",
                    "label": "Role",
                    "placeholder": "member",
                },
            ],
            "outputs": [
                {
                    "field": "user_ids",
                    "type": "vec<string>",
                    "helper_text": "List of user IDs",
                },
                {
                    "field": "usernames",
                    "type": "vec<string>",
                    "helper_text": "List of usernames",
                },
                {
                    "field": "user_names",
                    "type": "vec<string>",
                    "helper_text": "List of display names",
                },
                {
                    "field": "user_emails",
                    "type": "vec<string>",
                    "helper_text": "List of user emails",
                },
                {
                    "field": "avatar_urls",
                    "type": "vec<string>",
                    "helper_text": "List of avatar URLs",
                },
                {
                    "field": "html_urls",
                    "type": "vec<string>",
                    "helper_text": "List of profile URLs",
                },
                {
                    "field": "user_types",
                    "type": "vec<string>",
                    "helper_text": "List of user types",
                },
                {
                    "field": "member_roles",
                    "type": "vec<string>",
                    "helper_text": "List of member roles",
                },
                {
                    "field": "user_details",
                    "type": "vec<string>",
                    "helper_text": "User details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_organization_members",
            "task_name": "tasks.github.get_organization_members",
            "description": "Get a list of organization members from GitHub",
            "label": "Get Organization Members",
        },
        "get_organization_members**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Members",
                    "helper_text": "Specify the number of members to fetch",
                }
            ],
            "outputs": [],
        },
        "get_organization_members**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_organization_members**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_organization_members**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the webhook",
                    "label": "Webhook Name",
                    "placeholder": "web",
                },
                {
                    "field": "webhook_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "URL to send webhook payloads to",
                    "label": "Webhook URL",
                    "placeholder": "https://example.com/webhook",
                },
                {
                    "field": "webhook_events",
                    "type": "string",
                    "value": "",
                    "helper_text": "Events to trigger webhook (comma-separated)",
                    "label": "Events",
                    "placeholder": "push,pull_request",
                },
                {
                    "field": "webhook_secret",
                    "type": "string",
                    "value": "",
                    "helper_text": "Secret key for webhook security",
                    "label": "Secret",
                    "placeholder": "mysecret",
                },
                {
                    "field": "webhook_active",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Whether the webhook is active",
                    "label": "Active",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content type for webhook payloads",
                    "label": "Content Type",
                    "placeholder": "json",
                },
                {
                    "field": "insecure_ssl",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Allow insecure SSL",
                    "label": "Insecure SSL",
                },
            ],
            "outputs": [
                {
                    "field": "webhook_id",
                    "type": "string",
                    "helper_text": "ID of the created webhook",
                },
                {
                    "field": "webhook_name",
                    "type": "string",
                    "helper_text": "Name of the created webhook",
                },
                {
                    "field": "webhook_url",
                    "type": "string",
                    "helper_text": "URL of the created webhook",
                },
                {
                    "field": "webhook_events",
                    "type": "vec<string>",
                    "helper_text": "List of webhook events",
                },
                {
                    "field": "webhook_active",
                    "type": "bool",
                    "helper_text": "Whether the webhook is active",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_webhook",
            "task_name": "tasks.github.create_webhook",
            "description": "Create a new webhook on GitHub",
            "label": "Create Webhook",
        },
        "update_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the webhook to update",
                    "label": "Webhook ID",
                    "placeholder": "123456",
                },
                {
                    "field": "update_webhook_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "New URL for webhook payloads",
                    "label": "New Webhook URL",
                    "placeholder": "https://example.com/new-webhook",
                },
                {
                    "field": "update_webhook_events",
                    "type": "string",
                    "value": "",
                    "helper_text": "New events to trigger webhook",
                    "label": "New Events",
                    "placeholder": "push,issues",
                },
                {
                    "field": "update_webhook_secret",
                    "type": "string",
                    "value": "",
                    "helper_text": "New secret key for webhook",
                    "label": "New Secret",
                    "placeholder": "newsecret",
                },
                {
                    "field": "update_webhook_active",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Update webhook active status",
                    "label": "Active",
                },
                {
                    "field": "update_content_type",
                    "type": "string",
                    "value": "",
                    "helper_text": "New content type",
                    "label": "New Content Type",
                    "placeholder": "form",
                },
                {
                    "field": "update_insecure_ssl",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Update insecure SSL setting",
                    "label": "Insecure SSL",
                },
            ],
            "outputs": [
                {
                    "field": "webhook_id",
                    "type": "string",
                    "helper_text": "ID of the updated webhook",
                },
                {
                    "field": "webhook_name",
                    "type": "string",
                    "helper_text": "Name of the updated webhook",
                },
                {
                    "field": "webhook_url",
                    "type": "string",
                    "helper_text": "URL of the updated webhook",
                },
                {
                    "field": "webhook_events",
                    "type": "vec<string>",
                    "helper_text": "List of webhook events",
                },
                {
                    "field": "webhook_active",
                    "type": "bool",
                    "helper_text": "Whether the webhook is active",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Update timestamp",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_webhook",
            "task_name": "tasks.github.update_webhook",
            "description": "Update an existing webhook on GitHub",
            "label": "Update Webhook",
        },
        "read_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the webhook to read",
                    "label": "Webhook ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "webhook_id",
                    "type": "string",
                    "helper_text": "ID of the webhook",
                },
                {
                    "field": "webhook_name",
                    "type": "string",
                    "helper_text": "Name of the webhook",
                },
                {
                    "field": "webhook_url",
                    "type": "string",
                    "helper_text": "URL of the webhook",
                },
                {
                    "field": "webhook_events",
                    "type": "vec<string>",
                    "helper_text": "List of webhook events",
                },
                {
                    "field": "webhook_active",
                    "type": "bool",
                    "helper_text": "Whether the webhook is active",
                },
                {
                    "field": "webhook_config",
                    "type": "string",
                    "helper_text": "Webhook configuration details",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Last update timestamp",
                },
                {
                    "field": "ping_url",
                    "type": "string",
                    "helper_text": "Ping URL for the webhook",
                },
                {
                    "field": "test_url",
                    "type": "string",
                    "helper_text": "Test URL for the webhook",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook details in JSON format",
                },
            ],
            "name": "read_webhook",
            "task_name": "tasks.github.read_webhook",
            "description": "Read details of a GitHub webhook",
            "label": "Read Webhook",
            "variant": "common_integration_nodes",
        },
        "get_webhooks**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
            ],
            "outputs": [
                {
                    "field": "webhook_ids",
                    "type": "vec<string>",
                    "helper_text": "List of webhook IDs",
                },
                {
                    "field": "webhook_names",
                    "type": "vec<string>",
                    "helper_text": "List of webhook names",
                },
                {
                    "field": "webhook_urls",
                    "type": "vec<string>",
                    "helper_text": "List of webhook URLs",
                },
                {
                    "field": "webhook_events",
                    "type": "vec<string>",
                    "helper_text": "List of webhook events",
                },
                {
                    "field": "webhook_active_flags",
                    "type": "vec<string>",
                    "helper_text": "List of webhook active flags",
                },
                {
                    "field": "webhook_configs",
                    "type": "vec<string>",
                    "helper_text": "List of webhook configurations",
                },
                {
                    "field": "created_dates",
                    "type": "vec<string>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "updated_dates",
                    "type": "vec<string>",
                    "helper_text": "List of update dates",
                },
                {
                    "field": "ping_urls",
                    "type": "vec<string>",
                    "helper_text": "List of ping URLs",
                },
                {
                    "field": "test_urls",
                    "type": "vec<string>",
                    "helper_text": "List of test URLs",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_webhooks",
            "task_name": "tasks.github.get_webhooks",
            "description": "Get a list of webhooks from GitHub",
            "label": "Get Webhooks",
        },
        "get_webhooks**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Webhooks",
                    "helper_text": "Specify the number of webhooks to fetch",
                }
            ],
            "outputs": [],
        },
        "get_webhooks**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_webhooks**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_webhooks**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the webhook to delete",
                    "label": "Webhook ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the webhook was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "webhook_id",
                    "type": "string",
                    "helper_text": "ID of the deleted webhook",
                },
            ],
            "name": "delete_webhook",
            "task_name": "tasks.github.delete_webhook",
            "description": "Delete a GitHub webhook",
            "label": "Delete Webhook",
            "variant": "common_integration_nodes",
        },
        "ping_webhook**(*)**(*)": {
            "inputs": [
                {
                    "field": "owner",
                    "type": "string",
                    "value": "",
                    "helper_text": "Owner of the repository",
                    "label": "Owner",
                    "placeholder": "Select owner",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=owner&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 1,
                },
                {
                    "field": "repository_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the repository",
                    "label": "Repository Name",
                    "placeholder": "Select repository",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=repository_name&owner={inputs.owner}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 2,
                },
                {
                    "field": "webhook_id",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "ID of the webhook to ping",
                    "label": "Webhook ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the webhook ping was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Response message",
                },
                {
                    "field": "delivery_id",
                    "type": "string",
                    "helper_text": "ID of the delivery",
                },
                {
                    "field": "webhook_details",
                    "type": "vec<string>",
                    "helper_text": "Webhook response details",
                },
            ],
            "name": "ping_webhook",
            "task_name": "tasks.github.ping_webhook",
            "description": "Ping a GitHub webhook",
            "label": "Ping Webhook",
            "variant": "common_integration_nodes",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        affiliation: str = "",
        assignee: str = "",
        assignees: str = "",
        author_email: str = "",
        author_name: str = "",
        auto_init: bool = True,
        base: str = "",
        branch_name: str = "",
        comment_body: str = "",
        comment_id: int = 0,
        commit_message: str = "",
        commit_title: str = "",
        committer_email: str = "",
        committer_name: str = "",
        content_type: str = "",
        creator: str = "",
        delete_author_email: str = "",
        delete_author_name: str = "",
        delete_branch_name: str = "",
        delete_commit_message: str = "",
        delete_committer_email: str = "",
        delete_committer_name: str = "",
        delete_file_sha: str = "",
        direction: str = "",
        draft: bool = False,
        exact_date: Any = {"start": "", "end": ""},
        file_content: str = "",
        file_path: str = "",
        file_sha: str = "",
        filter: str = "",
        generate_release_notes: bool = False,
        gitignore_template: str = "",
        head: str = "",
        homepage: str = "",
        insecure_ssl: bool = False,
        is_private: bool = False,
        issue_body: str = "",
        issue_number: int = 0,
        issue_title: str = "",
        labels: str = "",
        license_template: str = "",
        maintainer_can_modify: bool = True,
        mentioned: str = "",
        merge_method: str = "",
        milestone: int = 0,
        num_messages: int = 10,
        organization: str = "",
        owner: str = "",
        prerelease: bool = False,
        protected: bool = False,
        pull_request_body: str = "",
        pull_request_number: int = 0,
        pull_request_title: str = "",
        ref: str = "",
        release_body: str = "",
        release_id: int = 0,
        release_name: str = "",
        repository_description: str = "",
        repository_name: str = "",
        role: str = "",
        sha: str = "",
        sort: str = "",
        source_branch: str = "",
        state: str = "",
        tag_name: str = "",
        target_commitish: str = "",
        type: str = "",
        update_assignees: str = "",
        update_author_email: str = "",
        update_author_name: str = "",
        update_base: str = "",
        update_branch_name: str = "",
        update_comment_body: str = "",
        update_commit_message: str = "",
        update_committer_email: str = "",
        update_committer_name: str = "",
        update_content_type: str = "",
        update_draft: bool = False,
        update_file_content: str = "",
        update_has_issues: bool = True,
        update_has_projects: bool = True,
        update_has_wiki: bool = True,
        update_homepage: str = "",
        update_insecure_ssl: bool = False,
        update_is_private: bool = False,
        update_issue_body: str = "",
        update_issue_state: str = "",
        update_issue_title: str = "",
        update_labels: str = "",
        update_maintainer_can_modify: bool = True,
        update_milestone: int = 0,
        update_prerelease: bool = False,
        update_pull_request_body: str = "",
        update_pull_request_state: str = "",
        update_pull_request_title: str = "",
        update_release_body: str = "",
        update_release_name: str = "",
        update_repository_description: str = "",
        update_repository_name: str = "",
        update_tag_name: str = "",
        update_target_commitish: str = "",
        update_webhook_active: bool = True,
        update_webhook_events: str = "",
        update_webhook_secret: str = "",
        update_webhook_url: str = "",
        username: str = "",
        visibility: str = "",
        webhook_active: bool = True,
        webhook_events: str = "",
        webhook_id: int = 0,
        webhook_name: str = "",
        webhook_secret: str = "",
        webhook_url: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_github",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if repository_name is not None:
            self.inputs["repository_name"] = repository_name
        if repository_description is not None:
            self.inputs["repository_description"] = repository_description
        if is_private is not None:
            self.inputs["is_private"] = is_private
        if auto_init is not None:
            self.inputs["auto_init"] = auto_init
        if gitignore_template is not None:
            self.inputs["gitignore_template"] = gitignore_template
        if license_template is not None:
            self.inputs["license_template"] = license_template
        if homepage is not None:
            self.inputs["homepage"] = homepage
        if owner is not None:
            self.inputs["owner"] = owner
        if update_repository_name is not None:
            self.inputs["update_repository_name"] = update_repository_name
        if update_repository_description is not None:
            self.inputs["update_repository_description"] = update_repository_description
        if update_homepage is not None:
            self.inputs["update_homepage"] = update_homepage
        if update_is_private is not None:
            self.inputs["update_is_private"] = update_is_private
        if update_has_issues is not None:
            self.inputs["update_has_issues"] = update_has_issues
        if update_has_projects is not None:
            self.inputs["update_has_projects"] = update_has_projects
        if update_has_wiki is not None:
            self.inputs["update_has_wiki"] = update_has_wiki
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if type is not None:
            self.inputs["type"] = type
        if sort is not None:
            self.inputs["sort"] = sort
        if direction is not None:
            self.inputs["direction"] = direction
        if visibility is not None:
            self.inputs["visibility"] = visibility
        if affiliation is not None:
            self.inputs["affiliation"] = affiliation
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if issue_title is not None:
            self.inputs["issue_title"] = issue_title
        if issue_body is not None:
            self.inputs["issue_body"] = issue_body
        if assignees is not None:
            self.inputs["assignees"] = assignees
        if milestone is not None:
            self.inputs["milestone"] = milestone
        if labels is not None:
            self.inputs["labels"] = labels
        if issue_number is not None:
            self.inputs["issue_number"] = issue_number
        if update_issue_title is not None:
            self.inputs["update_issue_title"] = update_issue_title
        if update_issue_body is not None:
            self.inputs["update_issue_body"] = update_issue_body
        if update_issue_state is not None:
            self.inputs["update_issue_state"] = update_issue_state
        if update_assignees is not None:
            self.inputs["update_assignees"] = update_assignees
        if update_milestone is not None:
            self.inputs["update_milestone"] = update_milestone
        if update_labels is not None:
            self.inputs["update_labels"] = update_labels
        if state is not None:
            self.inputs["state"] = state
        if assignee is not None:
            self.inputs["assignee"] = assignee
        if creator is not None:
            self.inputs["creator"] = creator
        if mentioned is not None:
            self.inputs["mentioned"] = mentioned
        if pull_request_title is not None:
            self.inputs["pull_request_title"] = pull_request_title
        if head is not None:
            self.inputs["head"] = head
        if base is not None:
            self.inputs["base"] = base
        if pull_request_body is not None:
            self.inputs["pull_request_body"] = pull_request_body
        if draft is not None:
            self.inputs["draft"] = draft
        if maintainer_can_modify is not None:
            self.inputs["maintainer_can_modify"] = maintainer_can_modify
        if pull_request_number is not None:
            self.inputs["pull_request_number"] = pull_request_number
        if update_pull_request_title is not None:
            self.inputs["update_pull_request_title"] = update_pull_request_title
        if update_pull_request_body is not None:
            self.inputs["update_pull_request_body"] = update_pull_request_body
        if update_pull_request_state is not None:
            self.inputs["update_pull_request_state"] = update_pull_request_state
        if update_base is not None:
            self.inputs["update_base"] = update_base
        if update_maintainer_can_modify is not None:
            self.inputs["update_maintainer_can_modify"] = update_maintainer_can_modify
        if commit_title is not None:
            self.inputs["commit_title"] = commit_title
        if commit_message is not None:
            self.inputs["commit_message"] = commit_message
        if sha is not None:
            self.inputs["sha"] = sha
        if merge_method is not None:
            self.inputs["merge_method"] = merge_method
        if comment_body is not None:
            self.inputs["comment_body"] = comment_body
        if comment_id is not None:
            self.inputs["comment_id"] = comment_id
        if update_comment_body is not None:
            self.inputs["update_comment_body"] = update_comment_body
        if tag_name is not None:
            self.inputs["tag_name"] = tag_name
        if release_name is not None:
            self.inputs["release_name"] = release_name
        if release_body is not None:
            self.inputs["release_body"] = release_body
        if target_commitish is not None:
            self.inputs["target_commitish"] = target_commitish
        if prerelease is not None:
            self.inputs["prerelease"] = prerelease
        if generate_release_notes is not None:
            self.inputs["generate_release_notes"] = generate_release_notes
        if release_id is not None:
            self.inputs["release_id"] = release_id
        if update_tag_name is not None:
            self.inputs["update_tag_name"] = update_tag_name
        if update_release_name is not None:
            self.inputs["update_release_name"] = update_release_name
        if update_release_body is not None:
            self.inputs["update_release_body"] = update_release_body
        if update_target_commitish is not None:
            self.inputs["update_target_commitish"] = update_target_commitish
        if update_draft is not None:
            self.inputs["update_draft"] = update_draft
        if update_prerelease is not None:
            self.inputs["update_prerelease"] = update_prerelease
        if file_path is not None:
            self.inputs["file_path"] = file_path
        if file_content is not None:
            self.inputs["file_content"] = file_content
        if branch_name is not None:
            self.inputs["branch_name"] = branch_name
        if committer_name is not None:
            self.inputs["committer_name"] = committer_name
        if committer_email is not None:
            self.inputs["committer_email"] = committer_email
        if author_name is not None:
            self.inputs["author_name"] = author_name
        if author_email is not None:
            self.inputs["author_email"] = author_email
        if update_file_content is not None:
            self.inputs["update_file_content"] = update_file_content
        if update_commit_message is not None:
            self.inputs["update_commit_message"] = update_commit_message
        if update_branch_name is not None:
            self.inputs["update_branch_name"] = update_branch_name
        if file_sha is not None:
            self.inputs["file_sha"] = file_sha
        if update_committer_name is not None:
            self.inputs["update_committer_name"] = update_committer_name
        if update_committer_email is not None:
            self.inputs["update_committer_email"] = update_committer_email
        if update_author_name is not None:
            self.inputs["update_author_name"] = update_author_name
        if update_author_email is not None:
            self.inputs["update_author_email"] = update_author_email
        if ref is not None:
            self.inputs["ref"] = ref
        if delete_commit_message is not None:
            self.inputs["delete_commit_message"] = delete_commit_message
        if delete_branch_name is not None:
            self.inputs["delete_branch_name"] = delete_branch_name
        if delete_file_sha is not None:
            self.inputs["delete_file_sha"] = delete_file_sha
        if delete_committer_name is not None:
            self.inputs["delete_committer_name"] = delete_committer_name
        if delete_committer_email is not None:
            self.inputs["delete_committer_email"] = delete_committer_email
        if delete_author_name is not None:
            self.inputs["delete_author_name"] = delete_author_name
        if delete_author_email is not None:
            self.inputs["delete_author_email"] = delete_author_email
        if source_branch is not None:
            self.inputs["source_branch"] = source_branch
        if protected is not None:
            self.inputs["protected"] = protected
        if username is not None:
            self.inputs["username"] = username
        if organization is not None:
            self.inputs["organization"] = organization
        if filter is not None:
            self.inputs["filter"] = filter
        if role is not None:
            self.inputs["role"] = role
        if webhook_name is not None:
            self.inputs["webhook_name"] = webhook_name
        if webhook_url is not None:
            self.inputs["webhook_url"] = webhook_url
        if webhook_events is not None:
            self.inputs["webhook_events"] = webhook_events
        if webhook_secret is not None:
            self.inputs["webhook_secret"] = webhook_secret
        if webhook_active is not None:
            self.inputs["webhook_active"] = webhook_active
        if content_type is not None:
            self.inputs["content_type"] = content_type
        if insecure_ssl is not None:
            self.inputs["insecure_ssl"] = insecure_ssl
        if webhook_id is not None:
            self.inputs["webhook_id"] = webhook_id
        if update_webhook_url is not None:
            self.inputs["update_webhook_url"] = update_webhook_url
        if update_webhook_events is not None:
            self.inputs["update_webhook_events"] = update_webhook_events
        if update_webhook_secret is not None:
            self.inputs["update_webhook_secret"] = update_webhook_secret
        if update_webhook_active is not None:
            self.inputs["update_webhook_active"] = update_webhook_active
        if update_content_type is not None:
            self.inputs["update_content_type"] = update_content_type
        if update_insecure_ssl is not None:
            self.inputs["update_insecure_ssl"] = update_insecure_ssl
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGithubNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_zendesk")
class IntegrationZendeskNode(Node):
    """
    Zendesk

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_tickets'
        assignee: Assignee of the ticket
        body: Search in the full ticket content
        brand: Filter by brand
        comment: Search in ticket comments
        comment_exact: Match comment exactly
        description: Search in the ticket description
        due: Tickets due on this date
        external_id: Search by external ID
        group: Filter by assigned group
        include: Include related data (e.g. users)
        organization: Organization of the ticket
        priority: Priority of the ticket
        requester: Requester of the ticket
        satisfaction: Customer satisfaction rating
        solved: Tickets solved on this date
        sort_by: Field to sort results by
        sort_order: Order of sorting (asc/desc)
        status: Status of the ticket
        subject: Search tickets by subject
        subject_exact: Match subject exactly
        ticket_form: Filter by ticket form
        ticket_type: Type of the ticket
        updated: Tickets updated on this date
        use_date: Toggle to use dates
    ### When action = 'get_tickets' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'search_users'
        email: Email of the user to search for
        external_id: Search by external ID
        limit: Maximum number of ticket fields to retrieve
        name: Name of the user to search for
        phone: Phone number of the user to search for
        role: Filter users by role
        search_query: Search query for users
    ### When action = 'get_tickets' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'list_ticket_fields'
        limit: Maximum number of ticket fields to retrieve
    ### When action = 'list_users'
        limit: Maximum number of ticket fields to retrieve
        role: Filter users by role
    ### When action = 'list_organizations'
        limit: Maximum number of ticket fields to retrieve
        return_all: Whether to return all organizations
    ### When action = 'get_tickets' and use_date = False
        num_messages: Specify the number of tickets to fetch
    ### When action = 'create_organization'
        organization_details: Additional details about the organization
        organization_domain_names: Domain names for the organization (comma-separated)
        organization_external_id: External ID for the organization
        organization_group_id: Group ID for the organization
        organization_name: Name of the organization
        organization_notes: Notes about the organization
        organization_shared_comments: Whether the organization has shared comments
        organization_shared_tickets: Whether the organization has shared tickets
        organization_tags: Tags for the organization
    ### When action = 'update_organization'
        organization_details: Additional details about the organization
        organization_domain_names: Domain names for the organization (comma-separated)
        organization_external_id: External ID for the organization
        organization_group_id: Group ID for the organization
        organization_id: Select the Zendesk organization to delete
        organization_name: Name of the organization
        organization_notes: Notes about the organization
        organization_shared_comments: Whether the organization has shared comments
        organization_shared_tickets: Whether the organization has shared tickets
        organization_tags: Tags for the organization
    ### When action = 'delete_organization'
        organization_id: Select the Zendesk organization to delete
    ### When action = 'get_organization'
        organization_id: Select the Zendesk organization to delete
    ### When action = 'get_organization_related_data'
        organization_id: Select the Zendesk organization to delete
    ### When action = 'create_comment'
        public: Whether the comment should be public
        ticket_body: Body content of the ticket
        ticket_id: Select the Zendesk ticket to update
    ### When action = 'create_ticket'
        requester_email: Email of the requester
        requester_name: Name of the requester (Required if requester email is not already registered)
        ticket_body: Body content of the ticket
        ticket_priority: Priority of the ticket
        ticket_status: Status of the ticket
        ticket_subject: Subject content of the ticket
        ticket_type: Type of the ticket
    ### When action = 'get_ticket_field'
        ticket_field_id: ID of the ticket field to retrieve
    ### When action = 'update_ticket'
        ticket_id: Select the Zendesk ticket to update
        ticket_priority: Priority of the ticket
        ticket_status: Status of the ticket
        ticket_type: Type of the ticket
        update_ticket_assignee_id: The ID of the assignee to update the ticket to
        update_ticket_body: Body content of the ticket
        update_ticket_subject: Subject content of the ticket
    ### When action = 'read_ticket'
        ticket_id: Select the Zendesk ticket to update
    ### When action = 'delete_ticket'
        ticket_id: Select the Zendesk ticket to update
    ### When action = 'recover_ticket'
        ticket_id: Select the Zendesk ticket to update
    ### When action = 'read_ticket_comments'
        ticket_id: Select the Zendesk ticket to update
    ### When action = 'get_tickets' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'create_user'
        user_alias: Alias for the user
        user_custom_role_id: Custom role ID for the user
        user_details: Details for the user
        user_email: Email address of the user
        user_external_id: External ID for the user
        user_locale: Locale for the user
        user_moderator: Whether the user is a moderator
        user_name: Name of the user
        user_notes: Notes for the user
        user_only_private_comments: Whether the user only has private comments
        user_organization_id: Organization ID for the user
        user_phone: Phone number of the user
        user_report_csv: Whether the user can generate reports in CSV format
        user_restricted_agent: Whether the user is a restricted agent
        user_role: Role of the user
        user_signature: Signature for the user
        user_suspended: Whether the user is suspended
        user_tags: Tags for the user
        user_ticket_restriction: Ticket restriction for the user
        user_timezone: Timezone for the user
    ### When action = 'update_user'
        user_alias: Alias for the user
        user_custom_role_id: Custom role ID for the user
        user_details: Details for the user
        user_email: Email address of the user
        user_id: Select the Zendesk user to delete
        user_locale: Locale for the user
        user_moderator: Whether the user is a moderator
        user_name: Name of the user
        user_notes: Notes for the user
        user_only_private_comments: Whether the user only has private comments
        user_organization_id: Organization ID for the user
        user_phone: Phone number of the user
        user_report_csv: Whether the user can generate reports in CSV format
        user_restricted_agent: Whether the user is a restricted agent
        user_role: Role of the user
        user_signature: Signature for the user
        user_suspended: Whether the user is suspended
        user_tags: Tags for the user
        user_ticket_restriction: Ticket restriction for the user
        user_timezone: Timezone for the user
    ### When action = 'delete_user'
        user_id: Select the Zendesk user to delete
    ### When action = 'get_user'
        user_id: Select the Zendesk user to delete
    ### When action = 'get_user_organizations'
        user_id: Select the Zendesk user to delete
    ### When action = 'get_user_related_data'
        user_id: Select the Zendesk user to delete

    ## Outputs
    ### When action = 'get_ticket_field'
        active: Whether the ticket field is active
        created_at: Date and time the ticket field was created
        custom_field_options: Custom field options in JSON format
        position: Position of the ticket field
        raw_data: Raw API response in JSON format
        required: Whether the ticket field is required
        tag: Tag of the ticket field
        ticket_field_description: Description of the ticket field
        ticket_field_details: Ticket field details in JSON format
        ticket_field_id: ID of the ticket field
        ticket_field_title: Title of the ticket field
        ticket_field_type: Type of the ticket field
        ticket_field_url: URL of the ticket field
        updated_at: Date and time the ticket field was last updated
    ### When action = 'get_user_related_data'
        assigned_tickets: Tickets assigned to the user in JSON format
        ccd_tickets: Tickets where user is CC'd in JSON format
        organizations: User's organizations in JSON format
        raw_data: Raw API response in JSON format
        related_data: All user related data in JSON format
        requested_tickets: Tickets requested by the user in JSON format
    ### When action = 'create_ticket'
        created_at: Date and time the ticket was created
        raw_data: Raw API response in JSON format
        ticket_assignee_id: ID of the ticket assignee
        ticket_body: Body of the created ticket
        ticket_details: Ticket details in JSON format
        ticket_id: Ticket ID of the created ticket
        ticket_priority: Priority of the created ticket
        ticket_requester_id: ID of the ticket requester
        ticket_status: Status of the created ticket
        ticket_subject: Subject of the created ticket
        ticket_type: Type of the created ticket
        ticket_url: URL of the created ticket
        updated_at: Date and time the ticket was last updated
    ### When action = 'read_ticket'
        created_at: Date and time the ticket was created
        raw_data: Raw API response in JSON format
        ticket_assignee_id: ID of ticket assignee
        ticket_attachments: Attachments of the ticket
        ticket_body: Body of the ticket
        ticket_details: Ticket details in JSON format
        ticket_priority: Priority of the ticket
        ticket_requester_id: ID of ticket requester
        ticket_status: Status of the ticket
        ticket_subject: Subject of the ticket
        ticket_type: Type of the ticket
        ticket_url: URL of the ticket
        updated_at: Date and time the ticket was last updated
    ### When action = 'get_tickets'
        created_at: Date and time the tickets was created
        raw_data: Raw API response in JSON format
        ticket_assignee_id: ID of tickets assignee
        ticket_attachments: Attachments of the tickets
        ticket_body: Body of the tickets
        ticket_details: Tickets details in JSON format
        ticket_id: ID of the tickets
        ticket_priority: Priority of the tickets
        ticket_requester_id: ID of tickets requester
        ticket_status: Status of the tickets
        ticket_subject: Subject of the tickets
        ticket_type: Type of the tickets
        ticket_url: URL of the tickets
        updated_at: Date and time the tickets was last updated
    ### When action = 'list_ticket_fields'
        created_at: Creation dates of the ticket fields
        raw_data: Raw API response in JSON format
        ticket_field_active: Active status of the ticket fields
        ticket_field_descriptions: Descriptions of the ticket fields
        ticket_field_ids: IDs of the ticket fields
        ticket_field_positions: Positions of the ticket fields
        ticket_field_required: Required status of the ticket fields
        ticket_field_tags: Tags of the ticket fields
        ticket_field_titles: Titles of the ticket fields
        ticket_field_types: Types of the ticket fields
        ticket_field_urls: URLs of the ticket fields
        ticket_fields_details: Ticket fields details in JSON format
        total_count: Total number of ticket fields
        updated_at: Last update dates of the ticket fields
    ### When action = 'create_user'
        created_at: Date and time the user was created
        external_id: External ID of the user
        raw_data: Raw API response in JSON format
        updated_at: Date and time the user was last updated
        user_active: Whether the user is active
        user_details: User details in JSON format
        user_email: Email of the user
        user_id: ID of the created user
        user_locale: Locale of the user
        user_name: Name of the user
        user_organization_id: Organization ID of the user
        user_phone: Phone number of the user
        user_role: Role of the user
        user_tags: Tags associated with the user
        user_timezone: Timezone of the user
        user_url: URL of the user
        user_verified: Whether the user is verified
    ### When action = 'get_user'
        created_at: Date and time the user was created
        external_id: External ID of the user
        raw_data: Raw API response in JSON format
        updated_at: Date and time the user was last updated
        user_active: Whether the user is active
        user_details: User details in JSON format
        user_email: Email of the user
        user_id: ID of the user
        user_locale: Locale of the user
        user_name: Name of the user
        user_organization_id: Organization ID of the user
        user_phone: Phone number of the user
        user_role: Role of the user
        user_tags: Tags associated with the user
        user_timezone: Timezone of the user
        user_url: URL of the user
        user_verified: Whether the user is verified
    ### When action = 'list_users'
        created_at: Creation dates of the users
        organization_ids: Organization IDs of the users
        raw_data: Raw API response in JSON format
        updated_at: Last update dates of the users
        user_active: Active status of the users
        user_emails: Emails of the users
        user_ids: IDs of the users
        user_names: Names of the users
        user_phones: Phone numbers of the users
        user_roles: Roles of the users
        user_urls: URLs of the users
        users_details: Users details in JSON format
    ### When action = 'update_user'
        created_at: Date and time the user was created
        raw_data: Raw API response in JSON format
        updated_at: Date and time the user was last updated
        user_details: Updated user details in JSON format
        user_email: Updated email of the user
        user_id: ID of the updated user
        user_name: Updated name of the user
        user_organization_id: Updated organization ID of the user
        user_role: Updated role of the user
        user_url: URL of the user
    ### When action = 'create_organization'
        created_at: Date and time the organization was created
        organization_details: Organization details in JSON format
        organization_domain_names: Domain names of the organization
        organization_external_id: External ID of the organization
        organization_group_id: Group ID of the organization
        organization_id: ID of the created organization
        organization_name: Name of the organization
        organization_shared_comments: Whether the organization has shared comments
        organization_shared_tickets: Whether the organization has shared tickets
        organization_tags: Tags associated with the organization
        organization_url: URL of the organization
        raw_data: Raw API response in JSON format
        updated_at: Date and time the organization was last updated
    ### When action = 'get_organization'
        created_at: Date and time the organization was created
        organization_details: Organization details in JSON format
        organization_domain_names: Domain names of the organization
        organization_external_id: External ID of the organization
        organization_group_id: Group ID of the organization
        organization_id: ID of the organization
        organization_name: Name of the organization
        organization_shared_comments: Whether the organization has shared comments
        organization_shared_tickets: Whether the organization has shared tickets
        organization_tags: Tags associated with the organization
        organization_url: URL of the organization
        raw_data: Raw API response in JSON format
        updated_at: Date and time the organization was last updated
    ### When action = 'list_organizations'
        created_at: Creation dates of the organizations
        organization_domain_names: Domain names of the organizations
        organization_ids: IDs of the organizations
        organization_names: Names of the organizations
        organization_tags: Tags of the organizations
        organization_urls: URLs of the organizations
        organizations_details: Organizations details in JSON format
        raw_data: Raw API response in JSON format
        total_count: Total number of organizations
        updated_at: Last update dates of the organizations
    ### When action = 'update_organization'
        created_at: Date and time the organization was created
        organization_details: Updated organization details in JSON format
        organization_domain_names: Updated domain names of the organization
        organization_id: ID of the updated organization
        organization_name: Updated name of the organization
        organization_tags: Updated tags of the organization
        organization_url: URL of the organization
        raw_data: Raw API response in JSON format
        updated_at: Date and time the organization was last updated
    ### When action = 'delete_organization'
        organization_id: ID of the deleted organization
        raw_data: Raw API response in JSON format
        success: Whether the organization was successfully deleted
    ### When action = 'get_organization_related_data'
        organization_id: ID of the organization
        raw_data: Raw API response in JSON format
        tickets_count: Number of tickets in the organization
        users_count: Number of users in the organization
    ### When action = 'get_user_organizations'
        organization_ids: IDs of the user's organizations
        organization_names: Names of the user's organizations
        organization_urls: URLs of the user's organizations
        organizations_details: Organizations details in JSON format
        raw_data: Raw API response in JSON format
        total_count: Total number of organizations
    ### When action = 'update_ticket'
        raw_data: Raw API response in JSON format
        ticket_body: Body of the updated ticket
        ticket_details: Ticket details in JSON format
        ticket_id: ID of the updated ticket
        ticket_priority: Priority of the updated ticket
        ticket_status: Status of the updated ticket
        ticket_subject: Subject of the updated ticket
        ticket_type: Type of the updated ticket
        updated_at: Date and time the ticket was last updated
    ### When action = 'delete_ticket'
        raw_data: Raw API response in JSON format
        success: Whether the ticket was successfully deleted
        ticket_id: ID of the deleted ticket
    ### When action = 'recover_ticket'
        raw_data: Raw API response in JSON format
        ticket_details: Recovered ticket details in JSON format
        ticket_id: ID of the recovered ticket
    ### When action = 'create_comment'
        raw_data: Raw API response in JSON format
        ticket_details: Ticket details in JSON format
    ### When action = 'read_ticket_comments'
        raw_data: Raw API response in JSON format
        ticket_attachments: Attachments of the ticket
        ticket_comments: Ticket comments in JSON format
        ticket_details: Ticket details in JSON format
    ### When action = 'delete_user'
        raw_data: Raw API response in JSON format
        success: Whether the user was successfully deleted
        user_details: User details in JSON format
        user_id: ID of the deleted user
    ### When action = 'search_users'
        raw_data: Raw API response in JSON format
        search_query: The search query used
        total_count: Total number of matching users
        user_emails: Emails of the matching users
        user_ids: IDs of the matching users
        user_names: Names of the matching users
        user_roles: Roles of the matching users
        users_details: Users details in JSON format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Zendesk>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_subject",
                    "type": "string",
                    "value": "",
                    "helper_text": "Subject content of the ticket",
                    "label": "Subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the ticket",
                    "label": "Body",
                    "placeholder": "Clicking on submit button doens’t work",
                },
                {
                    "field": "requester_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the requester",
                    "label": "Requester Email",
                    "placeholder": "john@company.com",
                },
                {
                    "field": "requester_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the requester (Required if requester email is not already registered)",
                    "label": "Requester Name",
                    "placeholder": "John Smith",
                },
                {
                    "field": "ticket_priority",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "ticket_status",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "Ticket ID of the created ticket",
                },
                {
                    "field": "ticket_subject",
                    "type": "string",
                    "helper_text": "Subject of the created ticket",
                },
                {
                    "field": "ticket_body",
                    "type": "string",
                    "helper_text": "Body of the created ticket",
                },
                {
                    "field": "ticket_status",
                    "type": "string",
                    "helper_text": "Status of the created ticket",
                },
                {
                    "field": "ticket_priority",
                    "type": "string",
                    "helper_text": "Priority of the created ticket",
                },
                {
                    "field": "ticket_type",
                    "type": "string",
                    "helper_text": "Type of the created ticket",
                },
                {
                    "field": "ticket_url",
                    "type": "string",
                    "helper_text": "URL of the created ticket",
                },
                {
                    "field": "ticket_requester_id",
                    "type": "string",
                    "helper_text": "ID of the ticket requester",
                },
                {
                    "field": "ticket_assignee_id",
                    "type": "string",
                    "helper_text": "ID of the ticket assignee",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the ticket was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the ticket was last updated",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_ticket",
            "task_name": "tasks.zendesk.create_ticket",
            "description": "Create a new ticket on Zendesk",
            "label": "Create Ticket",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "ticket_subject",
                "ticket_body",
                "requester_email",
                "requester_name",
            ],
            "required": [
                "ticket_id",
                "ticket_subject",
                "ticket_body",
                "requester_email",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
            ],
        },
        "update_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk ticket to update",
                    "label": "Select Ticket",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=ticket_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "update_ticket_subject",
                    "type": "string",
                    "value": "",
                    "helper_text": "Subject content of the ticket",
                    "label": "Subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "update_ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Body content of the ticket",
                    "label": "Body",
                    "placeholder": "Clicking on submit button not working",
                },
                {
                    "field": "update_ticket_assignee_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the assignee to update the ticket to",
                    "label": "Assignee ID",
                    "placeholder": "1234",
                },
                {
                    "field": "ticket_priority",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "ticket_status",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "ID of the updated ticket",
                },
                {
                    "field": "ticket_subject",
                    "type": "string",
                    "helper_text": "Subject of the updated ticket",
                },
                {
                    "field": "ticket_body",
                    "type": "string",
                    "helper_text": "Body of the updated ticket",
                },
                {
                    "field": "ticket_status",
                    "type": "string",
                    "helper_text": "Status of the updated ticket",
                },
                {
                    "field": "ticket_priority",
                    "type": "string",
                    "helper_text": "Priority of the updated ticket",
                },
                {
                    "field": "ticket_type",
                    "type": "string",
                    "helper_text": "Type of the updated ticket",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the ticket was last updated",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_ticket",
            "task_name": "tasks.zendesk.update_ticket",
            "description": "Update an existing ticket on Zendesk",
            "label": "Update Ticket",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "ticket_id",
                "update_ticket_subject",
                "update_ticket_body",
                "update_ticket_assignee_id",
            ],
            "required": ["ticket_id"],
        },
        "read_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk ticket to read",
                    "label": "Select Ticket",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=ticket_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "ticket_subject",
                    "type": "string",
                    "helper_text": "Subject of the ticket",
                },
                {
                    "field": "ticket_body",
                    "type": "vec<string>",
                    "helper_text": "Body of the ticket",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Date and time the ticket was created",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Date and time the ticket was last updated",
                },
                {
                    "field": "ticket_priority",
                    "type": "string",
                    "helper_text": "Priority of the ticket",
                },
                {
                    "field": "ticket_type",
                    "type": "string",
                    "helper_text": "Type of the ticket",
                },
                {
                    "field": "ticket_status",
                    "type": "string",
                    "helper_text": "Status of the ticket",
                },
                {
                    "field": "ticket_url",
                    "type": "string",
                    "helper_text": "URL of the ticket",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<file>",
                    "helper_text": "Attachments of the ticket",
                },
                {
                    "field": "ticket_assignee_id",
                    "type": "string",
                    "helper_text": "ID of ticket assignee",
                },
                {
                    "field": "ticket_requester_id",
                    "type": "string",
                    "helper_text": "ID of ticket requester",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "name": "read_ticket",
            "task_name": "tasks.zendesk.read_ticket",
            "description": "Read an existing ticket on Zendesk",
            "label": "Read Ticket",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "ticket_id"],
            "required": ["ticket_id"],
        },
        "get_tickets**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "label": "Assignee",
                    "helper_text": "Assignee of the ticket",
                    "placeholder": "John Smith",
                },
                {
                    "field": "requester",
                    "type": "string",
                    "value": "",
                    "label": "Requester",
                    "helper_text": "Requester of the ticket",
                    "placeholder": "John Smith",
                },
                {
                    "field": "organization",
                    "type": "string",
                    "value": "",
                    "label": "Organization",
                    "helper_text": "Organization of the ticket",
                    "placeholder": "Acme Corp",
                },
                {
                    "field": "priority",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Priority of the ticket",
                    "label": "Priority",
                    "placeholder": "High",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Low", "value": "Low"},
                            {"label": "Normal", "value": "Normal"},
                            {"label": "High", "value": "High"},
                            {"label": "Urgent", "value": "Urgent"},
                        ],
                    },
                },
                {
                    "field": "ticket_type",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Type of the ticket",
                    "label": "Type",
                    "placeholder": "Incident",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Question", "value": "Question"},
                            {"label": "Incident", "value": "Incident"},
                            {"label": "Problem", "value": "Problem"},
                            {"label": "Task", "value": "Task"},
                        ],
                    },
                },
                {
                    "field": "status",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Status of the ticket",
                    "label": "Status",
                    "placeholder": "Open",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "New", "value": "New"},
                            {"label": "Open", "value": "Open"},
                            {"label": "Pending", "value": "Pending"},
                            {"label": "Hold", "value": "Hold"},
                            {"label": "Solved", "value": "Solved"},
                            {"label": "Closed", "value": "Closed"},
                        ],
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "helper_text": "Search tickets by subject",
                    "placeholder": "Incident report",
                },
                {
                    "field": "subject_exact",
                    "type": "string",
                    "value": "",
                    "label": "Subject Exact",
                    "helper_text": "Match subject exactly",
                    "placeholder": "Incident report",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "Search in the ticket description",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "helper_text": "Search in the full ticket content",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "helper_text": "Search in ticket comments",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "comment_exact",
                    "type": "string",
                    "value": "",
                    "label": "Comment Exact",
                    "helper_text": "Match comment exactly",
                    "placeholder": "Clicking on submit button doesn't work",
                },
                {
                    "field": "updated",
                    "type": "string",
                    "value": "",
                    "label": "Updated Date",
                    "helper_text": "Tickets updated on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "solved",
                    "type": "string",
                    "value": "",
                    "label": "Solved Date",
                    "helper_text": "Tickets solved on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "due",
                    "type": "string",
                    "value": "",
                    "label": "Due Date",
                    "helper_text": "Tickets due on this date",
                    "placeholder": "YYYY-MM-DD",
                },
                {
                    "field": "brand",
                    "type": "string",
                    "value": "",
                    "label": "Brand",
                    "helper_text": "Filter by brand",
                    "placeholder": "Acme Corp",
                },
                {
                    "field": "satisfaction",
                    "type": "enum<string>",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Customer satisfaction rating",
                    "label": "Satisfaction",
                    "placeholder": "Good",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Good", "value": "good"},
                            {"label": "Bad", "value": "bad"},
                            {"label": "Offered", "value": "offered"},
                        ],
                    },
                },
                {
                    "field": "ticket_form",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Form",
                    "helper_text": "Filter by ticket form",
                    "placeholder": "Support",
                },
                {
                    "field": "group",
                    "type": "string",
                    "value": "",
                    "label": "Group",
                    "helper_text": "Filter by assigned group",
                    "placeholder": "Support",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "helper_text": "Field to sort results by",
                    "placeholder": "created_at",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "helper_text": "Order of sorting (asc/desc)",
                    "placeholder": "desc",
                },
                {
                    "field": "external_id",
                    "type": "string",
                    "value": "",
                    "label": "External ID",
                    "helper_text": "Search by external ID",
                    "placeholder": "123",
                },
                {
                    "field": "include",
                    "type": "string",
                    "value": "",
                    "label": "Include",
                    "helper_text": "Include related data (e.g. users)",
                    "placeholder": "users,groups,organizations",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "vec<string>",
                    "helper_text": "ID of the tickets",
                },
                {
                    "field": "ticket_subject",
                    "type": "vec<string>",
                    "helper_text": "Subject of the tickets",
                },
                {
                    "field": "ticket_body",
                    "type": "vec<string>",
                    "helper_text": "Body of the tickets",
                },
                {
                    "field": "created_at",
                    "type": "vec<string>",
                    "helper_text": "Date and time the tickets was created",
                },
                {
                    "field": "updated_at",
                    "type": "vec<string>",
                    "helper_text": "Date and time the tickets was last updated",
                },
                {
                    "field": "ticket_priority",
                    "type": "vec<string>",
                    "helper_text": "Priority of the tickets",
                },
                {
                    "field": "ticket_type",
                    "type": "vec<string>",
                    "helper_text": "Type of the tickets",
                },
                {
                    "field": "ticket_status",
                    "type": "vec<string>",
                    "helper_text": "Status of the tickets",
                },
                {
                    "field": "ticket_url",
                    "type": "vec<string>",
                    "helper_text": "URL of the tickets",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<vec<file>>",
                    "helper_text": "Attachments of the tickets",
                },
                {
                    "field": "ticket_assignee_id",
                    "type": "vec<string>",
                    "helper_text": "ID of tickets assignee",
                },
                {
                    "field": "ticket_requester_id",
                    "type": "vec<string>",
                    "helper_text": "ID of tickets requester",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Tickets details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_tickets",
            "task_name": "tasks.zendesk.get_tickets",
            "description": "Get a list of tickets from Zendesk",
            "label": "Get Tickets",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "ticket_subject",
                "ticket_body",
                "requester_email",
                "requester_name",
                "ticket_priority",
                "ticket_type",
                "ticket_status",
                "assignee",
                "requester",
                "organization",
                "subject",
                "subject_exact",
                "description",
                "body",
                "comment",
                "comment_exact",
                "updated",
                "solved",
                "due",
                "brand",
                "satisfaction",
                "ticket_form",
                "group",
                "sort_by",
                "sort_order",
                "external_id",
                "include",
            ],
            "required": ["num_messages"],
        },
        "get_tickets**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Tickets",
                    "helper_text": "Specify the number of tickets to fetch",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "delete_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk ticket to delete",
                    "label": "Select Ticket",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=ticket_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "ID of the deleted ticket",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the ticket was successfully deleted",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "delete_ticket",
            "task_name": "tasks.zendesk.delete_ticket",
            "description": "Delete a ticket on Zendesk",
            "label": "Delete Ticket",
            "inputs_sort_order": ["integration", "action", "ticket_id"],
            "required": ["ticket_id"],
        },
        "recover_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Enter the Zendesk ticket to recover",
                    "label": "Ticket ID",
                    "placeholder": "123",
                }
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "ID of the recovered ticket",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Recovered ticket details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "recover_ticket",
            "task_name": "tasks.zendesk.recover_ticket",
            "description": "Recover a deleted ticket on Zendesk",
            "label": "Recover Ticket",
            "inputs_sort_order": ["integration", "action", "ticket_id"],
            "required": ["ticket_id"],
        },
        "create_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk ticket to add comment to",
                    "label": "Select Ticket",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=ticket_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "ticket_body",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content of the comment",
                    "label": "Comment Body",
                    "placeholder": "Clicking on submit button not working",
                },
                {
                    "field": "public",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Whether the comment should be public",
                    "label": "Public",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "name": "create_comment",
            "task_name": "tasks.zendesk.create_comment",
            "description": "Create a new comment on a Zendesk ticket",
            "label": "Create Comment",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "ticket_id",
                "ticket_body",
                "public",
            ],
            "required": ["ticket_id", "ticket_body"],
        },
        "read_ticket_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk ticket to read comments from",
                    "label": "Select Ticket",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=ticket_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "ticket_comments",
                    "type": "vec<string>",
                    "helper_text": "Ticket comments in JSON format",
                },
                {
                    "field": "ticket_attachments",
                    "type": "vec<file>",
                    "helper_text": "Attachments of the ticket",
                },
                {
                    "field": "ticket_details",
                    "type": "string",
                    "helper_text": "Ticket details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "name": "read_ticket_comments",
            "task_name": "tasks.zendesk.read_ticket_comments",
            "description": "Read comments from an existing ticket on Zendesk",
            "label": "Read Ticket Comments",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "ticket_id"],
            "required": ["ticket_id"],
        },
        "get_ticket_field**(*)**(*)": {
            "inputs": [
                {
                    "field": "ticket_field_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the ticket field to retrieve",
                    "label": "Ticket Field ID",
                    "placeholder": "123456789",
                }
            ],
            "outputs": [
                {
                    "field": "ticket_field_id",
                    "type": "string",
                    "helper_text": "ID of the ticket field",
                },
                {
                    "field": "ticket_field_title",
                    "type": "string",
                    "helper_text": "Title of the ticket field",
                },
                {
                    "field": "ticket_field_type",
                    "type": "string",
                    "helper_text": "Type of the ticket field",
                },
                {
                    "field": "ticket_field_description",
                    "type": "string",
                    "helper_text": "Description of the ticket field",
                },
                {
                    "field": "position",
                    "type": "int32",
                    "helper_text": "Position of the ticket field",
                },
                {
                    "field": "active",
                    "type": "bool",
                    "helper_text": "Whether the ticket field is active",
                },
                {
                    "field": "required",
                    "type": "bool",
                    "helper_text": "Whether the ticket field is required",
                },
                {
                    "field": "tag",
                    "type": "string",
                    "helper_text": "Tag of the ticket field",
                },
                {
                    "field": "ticket_field_url",
                    "type": "string",
                    "helper_text": "URL of the ticket field",
                },
                {
                    "field": "custom_field_options",
                    "type": "string",
                    "helper_text": "Custom field options in JSON format",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the ticket field was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the ticket field was last updated",
                },
                {
                    "field": "ticket_field_details",
                    "type": "string",
                    "helper_text": "Ticket field details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_ticket_field",
            "task_name": "tasks.zendesk.get_ticket_field",
            "description": "Get a ticket field from Zendesk",
            "label": "Get Ticket Field",
            "inputs_sort_order": ["integration", "action", "ticket_field_id"],
            "required": ["ticket_field_id"],
        },
        "list_ticket_fields**(*)**(*)": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of ticket fields to retrieve",
                    "label": "Limit",
                    "placeholder": "10",
                }
            ],
            "outputs": [
                {
                    "field": "ticket_field_ids",
                    "type": "vec<string>",
                    "helper_text": "IDs of the ticket fields",
                },
                {
                    "field": "ticket_field_titles",
                    "type": "vec<string>",
                    "helper_text": "Titles of the ticket fields",
                },
                {
                    "field": "ticket_field_types",
                    "type": "vec<string>",
                    "helper_text": "Types of the ticket fields",
                },
                {
                    "field": "ticket_field_descriptions",
                    "type": "vec<string>",
                    "helper_text": "Descriptions of the ticket fields",
                },
                {
                    "field": "ticket_field_positions",
                    "type": "vec<int32>",
                    "helper_text": "Positions of the ticket fields",
                },
                {
                    "field": "ticket_field_active",
                    "type": "vec<bool>",
                    "helper_text": "Active status of the ticket fields",
                },
                {
                    "field": "ticket_field_required",
                    "type": "vec<bool>",
                    "helper_text": "Required status of the ticket fields",
                },
                {
                    "field": "ticket_field_tags",
                    "type": "vec<string>",
                    "helper_text": "Tags of the ticket fields",
                },
                {
                    "field": "ticket_field_urls",
                    "type": "vec<string>",
                    "helper_text": "URLs of the ticket fields",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of ticket fields",
                },
                {
                    "field": "created_at",
                    "type": "vec<timestamp>",
                    "helper_text": "Creation dates of the ticket fields",
                },
                {
                    "field": "updated_at",
                    "type": "vec<timestamp>",
                    "helper_text": "Last update dates of the ticket fields",
                },
                {
                    "field": "ticket_fields_details",
                    "type": "string",
                    "helper_text": "Ticket fields details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "list_ticket_fields",
            "task_name": "tasks.zendesk.list_ticket_fields",
            "description": "List ticket fields from Zendesk",
            "label": "List Ticket Fields",
            "inputs_sort_order": ["integration", "action", "limit"],
            "required": [],
        },
        "create_user**(*)**(*)": {
            "inputs": [
                {
                    "field": "user_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the user",
                    "label": "User Name",
                    "placeholder": "John Smith",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email address of the user",
                    "label": "User Email",
                    "placeholder": "john.smith@company.com",
                },
                {
                    "field": "user_role",
                    "type": "enum<string>",
                    "value": "end-user",
                    "helper_text": "Role of the user",
                    "label": "User Role",
                    "placeholder": "end-user",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "End User", "value": "end-user"},
                            {"label": "Agent", "value": "agent"},
                            {"label": "Admin", "value": "admin"},
                        ],
                    },
                },
                {
                    "field": "user_phone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Phone number of the user",
                    "label": "Phone",
                    "placeholder": "+1234567890",
                },
                {
                    "field": "user_organization_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Organization ID for the user",
                    "label": "Organization",
                    "placeholder": "Select organization",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=organization_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "user_external_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "External ID for the user",
                    "label": "External ID",
                    "placeholder": "external123",
                },
                {
                    "field": "user_alias",
                    "type": "string",
                    "value": "",
                    "helper_text": "Alias for the user",
                    "label": "Alias",
                    "placeholder": "john.smith",
                },
                {
                    "field": "user_details",
                    "type": "string",
                    "value": "",
                    "helper_text": "Details for the user",
                    "label": "Details",
                    "placeholder": "Internal notes",
                },
                {
                    "field": "user_notes",
                    "type": "string",
                    "value": "",
                    "helper_text": "Notes for the user",
                    "label": "Notes",
                    "placeholder": "Internal notes",
                },
                {
                    "field": "user_locale",
                    "type": "string",
                    "value": "",
                    "helper_text": "Locale for the user",
                    "label": "Locale",
                    "placeholder": "en-US",
                },
                {
                    "field": "user_timezone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Timezone for the user",
                    "label": "Timezone",
                    "placeholder": "America/New_York",
                    "component": {"type": "dropdown", "referenced_options": "timezone"},
                },
                {
                    "field": "user_signature",
                    "type": "string",
                    "value": "",
                    "helper_text": "Signature for the user",
                    "label": "Signature",
                    "placeholder": "Best regards, John Smith",
                },
                {
                    "field": "user_moderator",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user is a moderator",
                    "label": "Moderator",
                },
                {
                    "field": "user_custom_role_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Custom role ID for the user",
                    "label": "Custom Role ID",
                    "placeholder": "123456789",
                },
                {
                    "field": "user_only_private_comments",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user only has private comments",
                    "label": "Only Private Comments",
                },
                {
                    "field": "user_restricted_agent",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user is a restricted agent",
                    "label": "Restricted Agent",
                },
                {
                    "field": "user_suspended",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user is suspended",
                    "label": "Suspended",
                },
                {
                    "field": "user_report_csv",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user can generate reports in CSV format",
                    "label": "Report CSV",
                },
                {
                    "field": "user_ticket_restriction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Ticket restriction for the user",
                    "label": "Ticket Restriction",
                    "placeholder": "All",
                },
                {
                    "field": "user_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "Tags for the user",
                    "label": "Tags",
                    "placeholder": "tag1,tag2,tag3",
                },
            ],
            "outputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "ID of the created user",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Name of the user",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "helper_text": "Email of the user",
                },
                {
                    "field": "user_role",
                    "type": "string",
                    "helper_text": "Role of the user",
                },
                {
                    "field": "user_phone",
                    "type": "string",
                    "helper_text": "Phone number of the user",
                },
                {
                    "field": "user_organization_id",
                    "type": "string",
                    "helper_text": "Organization ID of the user",
                },
                {
                    "field": "external_id",
                    "type": "string",
                    "helper_text": "External ID of the user",
                },
                {
                    "field": "user_timezone",
                    "type": "string",
                    "helper_text": "Timezone of the user",
                },
                {
                    "field": "user_tags",
                    "type": "vec<string>",
                    "helper_text": "Tags associated with the user",
                },
                {
                    "field": "user_active",
                    "type": "bool",
                    "helper_text": "Whether the user is active",
                },
                {
                    "field": "user_verified",
                    "type": "bool",
                    "helper_text": "Whether the user is verified",
                },
                {
                    "field": "user_locale",
                    "type": "string",
                    "helper_text": "Locale of the user",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the user was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the user was last updated",
                },
                {
                    "field": "user_url",
                    "type": "string",
                    "helper_text": "URL of the user",
                },
                {
                    "field": "user_details",
                    "type": "string",
                    "helper_text": "User details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_user",
            "task_name": "tasks.zendesk.create_user",
            "description": "Create a new user on Zendesk",
            "label": "Create User",
            "inputs_sort_order": [
                "integration",
                "action",
                "user_name",
                "user_email",
                "user_role",
                "user_phone",
                "user_organization_id",
                "user_external_id",
                "user_alias",
                "user_details",
                "user_notes",
                "user_locale",
                "user_timezone",
                "user_signature",
                "user_moderator",
                "user_custom_role_id",
                "user_only_private_comments",
                "user_restricted_agent",
                "user_suspended",
                "user_report_csv",
                "user_ticket_restriction",
                "user_tags",
            ],
            "required": ["user_name", "user_email"],
        },
        "delete_user**(*)**(*)": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk user to delete",
                    "label": "Select User",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "ID of the deleted user",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the user was successfully deleted",
                },
                {
                    "field": "user_details",
                    "type": "string",
                    "helper_text": "User details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "delete_user",
            "task_name": "tasks.zendesk.delete_user",
            "description": "Delete a user on Zendesk",
            "label": "Delete User",
            "inputs_sort_order": ["integration", "action", "user_id"],
            "required": ["user_id"],
        },
        "get_user**(*)**(*)": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk user to retrieve",
                    "label": "Select User",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {"field": "user_id", "type": "string", "helper_text": "ID of the user"},
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Name of the user",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "helper_text": "Email of the user",
                },
                {
                    "field": "user_role",
                    "type": "string",
                    "helper_text": "Role of the user",
                },
                {
                    "field": "user_phone",
                    "type": "string",
                    "helper_text": "Phone number of the user",
                },
                {
                    "field": "user_organization_id",
                    "type": "string",
                    "helper_text": "Organization ID of the user",
                },
                {
                    "field": "external_id",
                    "type": "string",
                    "helper_text": "External ID of the user",
                },
                {
                    "field": "user_timezone",
                    "type": "string",
                    "helper_text": "Timezone of the user",
                },
                {
                    "field": "user_tags",
                    "type": "vec<string>",
                    "helper_text": "Tags associated with the user",
                },
                {
                    "field": "user_active",
                    "type": "bool",
                    "helper_text": "Whether the user is active",
                },
                {
                    "field": "user_verified",
                    "type": "bool",
                    "helper_text": "Whether the user is verified",
                },
                {
                    "field": "user_locale",
                    "type": "string",
                    "helper_text": "Locale of the user",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the user was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the user was last updated",
                },
                {
                    "field": "user_url",
                    "type": "string",
                    "helper_text": "URL of the user",
                },
                {
                    "field": "user_details",
                    "type": "string",
                    "helper_text": "User details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_user",
            "task_name": "tasks.zendesk.get_user",
            "description": "Get a user from Zendesk",
            "label": "Get User",
            "inputs_sort_order": ["integration", "action", "user_id"],
            "required": ["user_id"],
        },
        "list_users**(*)**(*)": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of users to retrieve",
                    "label": "Limit",
                    "placeholder": "10",
                },
                {
                    "field": "role",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Filter users by role",
                    "label": "Role Filter",
                    "placeholder": "All",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "All", "value": ""},
                            {"label": "End User", "value": "end-user"},
                            {"label": "Agent", "value": "agent"},
                            {"label": "Admin", "value": "admin"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "user_ids",
                    "type": "vec<string>",
                    "helper_text": "IDs of the users",
                },
                {
                    "field": "user_names",
                    "type": "vec<string>",
                    "helper_text": "Names of the users",
                },
                {
                    "field": "user_emails",
                    "type": "vec<string>",
                    "helper_text": "Emails of the users",
                },
                {
                    "field": "user_roles",
                    "type": "vec<string>",
                    "helper_text": "Roles of the users",
                },
                {
                    "field": "user_phones",
                    "type": "vec<string>",
                    "helper_text": "Phone numbers of the users",
                },
                {
                    "field": "user_active",
                    "type": "vec<bool>",
                    "helper_text": "Active status of the users",
                },
                {
                    "field": "user_urls",
                    "type": "vec<string>",
                    "helper_text": "URLs of the users",
                },
                {
                    "field": "organization_ids",
                    "type": "vec<string>",
                    "helper_text": "Organization IDs of the users",
                },
                {
                    "field": "created_at",
                    "type": "vec<timestamp>",
                    "helper_text": "Creation dates of the users",
                },
                {
                    "field": "updated_at",
                    "type": "vec<timestamp>",
                    "helper_text": "Last update dates of the users",
                },
                {
                    "field": "users_details",
                    "type": "string",
                    "helper_text": "Users details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "list_users",
            "task_name": "tasks.zendesk.list_users",
            "description": "List users from Zendesk",
            "label": "List Users",
            "inputs_sort_order": ["integration", "action", "limit", "role"],
            "required": [],
        },
        "search_users**(*)**(*)": {
            "inputs": [
                {
                    "field": "search_query",
                    "type": "string",
                    "value": "",
                    "helper_text": "Search query for users",
                    "label": "Search Query",
                    "placeholder": "name:john",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email of the user to search for",
                    "label": "Email",
                    "placeholder": "john@company.com",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the user to search for",
                    "label": "Name",
                    "placeholder": "John Smith",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Phone number of the user to search for",
                    "label": "Phone",
                    "placeholder": "+1234567890",
                },
                {
                    "field": "role",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Role of the user to search for",
                    "label": "Role",
                    "placeholder": "All",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "All", "value": ""},
                            {"label": "End User", "value": "end-user"},
                            {"label": "Agent", "value": "agent"},
                            {"label": "Admin", "value": "admin"},
                        ],
                    },
                },
                {
                    "field": "external_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "External ID of the user to search for",
                    "label": "External ID",
                    "placeholder": "external123",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of users to retrieve",
                    "label": "Limit",
                    "placeholder": "10",
                },
            ],
            "outputs": [
                {
                    "field": "user_ids",
                    "type": "vec<string>",
                    "helper_text": "IDs of the matching users",
                },
                {
                    "field": "user_names",
                    "type": "vec<string>",
                    "helper_text": "Names of the matching users",
                },
                {
                    "field": "user_emails",
                    "type": "vec<string>",
                    "helper_text": "Emails of the matching users",
                },
                {
                    "field": "user_roles",
                    "type": "vec<string>",
                    "helper_text": "Roles of the matching users",
                },
                {
                    "field": "search_query",
                    "type": "string",
                    "helper_text": "The search query used",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of matching users",
                },
                {
                    "field": "users_details",
                    "type": "string",
                    "helper_text": "Users details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "search_users",
            "task_name": "tasks.zendesk.search_users",
            "description": "Search users on Zendesk",
            "label": "Search Users",
            "inputs_sort_order": [
                "integration",
                "action",
                "search_query",
                "email",
                "name",
                "phone",
                "role",
                "external_id",
                "limit",
            ],
            "required": ["limit"],
        },
        "get_user_organizations**(*)**(*)": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk user",
                    "label": "Select User",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "organization_ids",
                    "type": "vec<string>",
                    "helper_text": "IDs of the user's organizations",
                },
                {
                    "field": "organization_names",
                    "type": "vec<string>",
                    "helper_text": "Names of the user's organizations",
                },
                {
                    "field": "organization_urls",
                    "type": "vec<string>",
                    "helper_text": "URLs of the user's organizations",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of organizations",
                },
                {
                    "field": "organizations_details",
                    "type": "string",
                    "helper_text": "Organizations details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_user_organizations",
            "task_name": "tasks.zendesk.get_user_organizations",
            "description": "Get organizations for a user on Zendesk",
            "label": "Get User Organizations",
            "inputs_sort_order": ["integration", "action", "user_id"],
            "required": ["user_id"],
        },
        "get_user_related_data**(*)**(*)": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk user",
                    "label": "Select User",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "requested_tickets",
                    "type": "string",
                    "helper_text": "Tickets requested by the user in JSON format",
                },
                {
                    "field": "ccd_tickets",
                    "type": "string",
                    "helper_text": "Tickets where user is CC'd in JSON format",
                },
                {
                    "field": "assigned_tickets",
                    "type": "string",
                    "helper_text": "Tickets assigned to the user in JSON format",
                },
                {
                    "field": "organizations",
                    "type": "string",
                    "helper_text": "User's organizations in JSON format",
                },
                {
                    "field": "related_data",
                    "type": "string",
                    "helper_text": "All user related data in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_user_related_data",
            "task_name": "tasks.zendesk.get_user_related_data",
            "description": "Get related data for a user on Zendesk",
            "label": "Get User Related Data",
            "inputs_sort_order": ["integration", "action", "user_id"],
            "required": ["user_id"],
        },
        "update_user**(*)**(*)": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk user to update",
                    "label": "Select User",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=user_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated name of the user",
                    "label": "User Name",
                    "placeholder": "John Smith",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated email address of the user",
                    "label": "User Email",
                    "placeholder": "john.smith@company.com",
                },
                {
                    "field": "user_role",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "Updated role of the user",
                    "label": "User Role",
                    "placeholder": "end-user",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "End User", "value": "end-user"},
                            {"label": "Agent", "value": "agent"},
                            {"label": "Admin", "value": "admin"},
                        ],
                    },
                },
                {
                    "field": "user_phone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated phone number of the user",
                    "label": "Phone",
                    "placeholder": "+1234567890",
                },
                {
                    "field": "user_organization_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated organization ID for the user",
                    "label": "Organization",
                    "placeholder": "Select organization",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=organization_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "user_alias",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated alias for the user",
                    "label": "Alias",
                    "placeholder": "john.smith",
                },
                {
                    "field": "user_details",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated details for the user",
                    "label": "Details",
                    "placeholder": "Internal notes",
                },
                {
                    "field": "user_notes",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated notes for the user",
                    "label": "Notes",
                    "placeholder": "Internal notes",
                },
                {
                    "field": "user_locale",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated locale for the user",
                    "label": "Locale",
                    "placeholder": "en-US",
                },
                {
                    "field": "user_timezone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated timezone for the user",
                    "label": "Timezone",
                    "placeholder": "America/New_York",
                    "component": {"type": "dropdown", "referenced_options": "timezone"},
                },
                {
                    "field": "user_signature",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated signature for the user",
                    "label": "Signature",
                    "placeholder": "Best regards, John Smith",
                },
                {
                    "field": "user_moderator",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user is a moderator",
                    "label": "Moderator",
                },
                {
                    "field": "user_custom_role_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated custom role ID for the user",
                    "label": "Custom Role ID",
                    "placeholder": "123456789",
                },
                {
                    "field": "user_only_private_comments",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user only has private comments",
                    "label": "Only Private Comments",
                },
                {
                    "field": "user_restricted_agent",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user is a restricted agent",
                    "label": "Restricted Agent",
                },
                {
                    "field": "user_suspended",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user is suspended",
                    "label": "Suspended",
                },
                {
                    "field": "user_report_csv",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the user can generate reports in CSV format",
                    "label": "Report CSV",
                },
                {
                    "field": "user_ticket_restriction",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated ticket restriction for the user",
                    "label": "Ticket Restriction",
                    "placeholder": "All",
                },
                {
                    "field": "user_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated tags for the user",
                    "label": "Tags",
                    "placeholder": "tag1,tag2,tag3",
                },
            ],
            "outputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "ID of the updated user",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Updated name of the user",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "helper_text": "Updated email of the user",
                },
                {
                    "field": "user_role",
                    "type": "string",
                    "helper_text": "Updated role of the user",
                },
                {
                    "field": "user_organization_id",
                    "type": "string",
                    "helper_text": "Updated organization ID of the user",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the user was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the user was last updated",
                },
                {
                    "field": "user_url",
                    "type": "string",
                    "helper_text": "URL of the user",
                },
                {
                    "field": "user_details",
                    "type": "string",
                    "helper_text": "Updated user details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_user",
            "task_name": "tasks.zendesk.update_user",
            "description": "Update a user on Zendesk",
            "label": "Update User",
            "inputs_sort_order": [
                "integration",
                "action",
                "user_id",
                "user_name",
                "user_email",
                "user_role",
                "user_phone",
                "user_organization_id",
                "user_alias",
                "user_details",
                "user_notes",
                "user_locale",
                "user_timezone",
                "user_signature",
                "user_moderator",
                "user_custom_role_id",
                "user_only_private_comments",
                "user_restricted_agent",
                "user_suspended",
                "user_report_csv",
                "user_ticket_restriction",
                "user_tags",
            ],
            "required": ["user_id"],
        },
        "create_organization**(*)**(*)": {
            "inputs": [
                {
                    "field": "organization_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the organization",
                    "label": "Organization Name",
                    "placeholder": "Acme Corp",
                },
                {
                    "field": "organization_domain_names",
                    "type": "string",
                    "value": "",
                    "helper_text": "Domain names for the organization (comma-separated)",
                    "label": "Domain Names",
                    "placeholder": "acme.com,acmecorp.com",
                },
                {
                    "field": "organization_details",
                    "type": "string",
                    "value": "",
                    "helper_text": "Additional details about the organization",
                    "label": "Details",
                    "placeholder": "Customer organization details",
                },
                {
                    "field": "organization_notes",
                    "type": "string",
                    "value": "",
                    "helper_text": "Notes about the organization",
                    "label": "Notes",
                    "placeholder": "Internal notes",
                },
                {
                    "field": "organization_external_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "External ID for the organization",
                    "label": "External ID",
                    "placeholder": "external123",
                },
                {
                    "field": "organization_group_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Group ID for the organization",
                    "label": "Group ID",
                    "placeholder": "123456789",
                },
                {
                    "field": "organization_shared_tickets",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the organization has shared tickets",
                    "label": "Shared Tickets",
                },
                {
                    "field": "organization_shared_comments",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the organization has shared comments",
                    "label": "Shared Comments",
                },
                {
                    "field": "organization_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "Tags for the organization",
                    "label": "Tags",
                    "placeholder": "tag1,tag2,tag3",
                },
            ],
            "outputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "helper_text": "ID of the created organization",
                },
                {
                    "field": "organization_name",
                    "type": "string",
                    "helper_text": "Name of the organization",
                },
                {
                    "field": "organization_domain_names",
                    "type": "vec<string>",
                    "helper_text": "Domain names of the organization",
                },
                {
                    "field": "organization_external_id",
                    "type": "string",
                    "helper_text": "External ID of the organization",
                },
                {
                    "field": "organization_shared_tickets",
                    "type": "bool",
                    "helper_text": "Whether the organization has shared tickets",
                },
                {
                    "field": "organization_shared_comments",
                    "type": "bool",
                    "helper_text": "Whether the organization has shared comments",
                },
                {
                    "field": "organization_tags",
                    "type": "vec<string>",
                    "helper_text": "Tags associated with the organization",
                },
                {
                    "field": "organization_group_id",
                    "type": "string",
                    "helper_text": "Group ID of the organization",
                },
                {
                    "field": "organization_url",
                    "type": "string",
                    "helper_text": "URL of the organization",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the organization was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the organization was last updated",
                },
                {
                    "field": "organization_details",
                    "type": "string",
                    "helper_text": "Organization details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_organization",
            "task_name": "tasks.zendesk.create_organization",
            "description": "Create a new organization on Zendesk",
            "label": "Create Organization",
            "inputs_sort_order": [
                "integration",
                "action",
                "organization_name",
                "organization_domain_names",
                "organization_details",
                "organization_notes",
                "organization_external_id",
                "organization_group_id",
                "organization_shared_tickets",
                "organization_shared_comments",
                "organization_tags",
            ],
            "required": ["organization_name"],
        },
        "delete_organization**(*)**(*)": {
            "inputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk organization to delete",
                    "label": "Select Organization",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=organization_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "helper_text": "ID of the deleted organization",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the organization was successfully deleted",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "delete_organization",
            "task_name": "tasks.zendesk.delete_organization",
            "description": "Delete an organization on Zendesk",
            "label": "Delete Organization",
            "inputs_sort_order": ["integration", "action", "organization_id"],
            "required": ["organization_id"],
        },
        "get_organization**(*)**(*)": {
            "inputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk organization to retrieve",
                    "label": "Select Organization",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=organization_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "helper_text": "ID of the organization",
                },
                {
                    "field": "organization_name",
                    "type": "string",
                    "helper_text": "Name of the organization",
                },
                {
                    "field": "organization_domain_names",
                    "type": "vec<string>",
                    "helper_text": "Domain names of the organization",
                },
                {
                    "field": "organization_external_id",
                    "type": "string",
                    "helper_text": "External ID of the organization",
                },
                {
                    "field": "organization_shared_tickets",
                    "type": "bool",
                    "helper_text": "Whether the organization has shared tickets",
                },
                {
                    "field": "organization_shared_comments",
                    "type": "bool",
                    "helper_text": "Whether the organization has shared comments",
                },
                {
                    "field": "organization_tags",
                    "type": "vec<string>",
                    "helper_text": "Tags associated with the organization",
                },
                {
                    "field": "organization_group_id",
                    "type": "string",
                    "helper_text": "Group ID of the organization",
                },
                {
                    "field": "organization_url",
                    "type": "string",
                    "helper_text": "URL of the organization",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the organization was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the organization was last updated",
                },
                {
                    "field": "organization_details",
                    "type": "string",
                    "helper_text": "Organization details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_organization",
            "task_name": "tasks.zendesk.get_organization",
            "description": "Get an organization from Zendesk",
            "label": "Get Organization",
            "inputs_sort_order": ["integration", "action", "organization_id"],
            "required": ["organization_id"],
        },
        "list_organizations**(*)**(*)": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of organizations to retrieve",
                    "label": "Limit",
                    "placeholder": "10",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to return all organizations",
                    "label": "Return All",
                },
            ],
            "outputs": [
                {
                    "field": "organization_ids",
                    "type": "vec<string>",
                    "helper_text": "IDs of the organizations",
                },
                {
                    "field": "organization_names",
                    "type": "vec<string>",
                    "helper_text": "Names of the organizations",
                },
                {
                    "field": "organization_domain_names",
                    "type": "vec<vec<string>>",
                    "helper_text": "Domain names of the organizations",
                },
                {
                    "field": "organization_urls",
                    "type": "vec<string>",
                    "helper_text": "URLs of the organizations",
                },
                {
                    "field": "organization_tags",
                    "type": "vec<vec<string>>",
                    "helper_text": "Tags of the organizations",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of organizations",
                },
                {
                    "field": "created_at",
                    "type": "vec<timestamp>",
                    "helper_text": "Creation dates of the organizations",
                },
                {
                    "field": "updated_at",
                    "type": "vec<timestamp>",
                    "helper_text": "Last update dates of the organizations",
                },
                {
                    "field": "organizations_details",
                    "type": "string",
                    "helper_text": "Organizations details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "list_organizations",
            "task_name": "tasks.zendesk.list_organizations",
            "description": "List organizations from Zendesk",
            "label": "List Organizations",
            "inputs_sort_order": ["integration", "action", "limit", "return_all"],
            "required": [],
        },
        "get_organization_related_data**(*)**(*)": {
            "inputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk organization",
                    "label": "Select Organization",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=organization_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "helper_text": "ID of the organization",
                },
                {
                    "field": "tickets_count",
                    "type": "int32",
                    "helper_text": "Number of tickets in the organization",
                },
                {
                    "field": "users_count",
                    "type": "int32",
                    "helper_text": "Number of users in the organization",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_organization_related_data",
            "task_name": "tasks.zendesk.get_organization_related_data",
            "description": "Get related data for an organization on Zendesk",
            "label": "Get Organization Related Data",
            "inputs_sort_order": ["integration", "action", "organization_id"],
            "required": ["organization_id"],
        },
        "update_organization**(*)**(*)": {
            "inputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the Zendesk organization to update",
                    "label": "Select Organization",
                    "placeholder": "123",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=organization_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "organization_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated name of the organization",
                    "label": "Organization Name",
                    "placeholder": "Acme Corp",
                },
                {
                    "field": "organization_domain_names",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated domain names for the organization (comma-separated)",
                    "label": "Domain Names",
                    "placeholder": "acme.com,acmecorp.com",
                },
                {
                    "field": "organization_details",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated details about the organization",
                    "label": "Details",
                    "placeholder": "Customer organization details",
                },
                {
                    "field": "organization_notes",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated notes about the organization",
                    "label": "Notes",
                    "placeholder": "Internal notes",
                },
                {
                    "field": "organization_external_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated external ID for the organization",
                    "label": "External ID",
                    "placeholder": "external123",
                },
                {
                    "field": "organization_group_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated group ID for the organization",
                    "label": "Group ID",
                    "placeholder": "123456789",
                },
                {
                    "field": "organization_shared_tickets",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the organization has shared tickets",
                    "label": "Shared Tickets",
                },
                {
                    "field": "organization_shared_comments",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether the organization has shared comments",
                    "label": "Shared Comments",
                },
                {
                    "field": "organization_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "Updated tags for the organization",
                    "label": "Tags",
                    "placeholder": "tag1,tag2,tag3",
                },
            ],
            "outputs": [
                {
                    "field": "organization_id",
                    "type": "string",
                    "helper_text": "ID of the updated organization",
                },
                {
                    "field": "organization_name",
                    "type": "string",
                    "helper_text": "Updated name of the organization",
                },
                {
                    "field": "organization_domain_names",
                    "type": "vec<string>",
                    "helper_text": "Updated domain names of the organization",
                },
                {
                    "field": "organization_url",
                    "type": "string",
                    "helper_text": "URL of the organization",
                },
                {
                    "field": "organization_tags",
                    "type": "vec<string>",
                    "helper_text": "Updated tags of the organization",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the organization was created",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Date and time the organization was last updated",
                },
                {
                    "field": "organization_details",
                    "type": "string",
                    "helper_text": "Updated organization details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_organization",
            "task_name": "tasks.zendesk.update_organization",
            "description": "Update an organization on Zendesk",
            "label": "Update Organization",
            "inputs_sort_order": [
                "integration",
                "action",
                "organization_id",
                "organization_name",
                "organization_domain_names",
                "organization_details",
                "organization_notes",
                "organization_external_id",
                "organization_group_id",
                "organization_shared_tickets",
                "organization_shared_comments",
                "organization_tags",
            ],
            "required": ["organization_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        assignee: str = "",
        body: str = "",
        brand: str = "",
        comment: str = "",
        comment_exact: str = "",
        description: str = "",
        due: str = "",
        email: str = "",
        exact_date: Any = {"start": "", "end": ""},
        external_id: str = "",
        group: str = "",
        include: str = "",
        limit: int = 10,
        name: str = "",
        num_messages: int = 10,
        organization: str = "",
        organization_details: str = "",
        organization_domain_names: str = "",
        organization_external_id: str = "",
        organization_group_id: str = "",
        organization_id: str = "",
        organization_name: str = "",
        organization_notes: str = "",
        organization_shared_comments: bool = False,
        organization_shared_tickets: bool = False,
        organization_tags: str = "",
        phone: str = "",
        priority: str = "",
        public: bool = True,
        requester: str = "",
        requester_email: str = "",
        requester_name: str = "",
        return_all: bool = False,
        role: str = "",
        satisfaction: str = "",
        search_query: str = "",
        solved: str = "",
        sort_by: str = "",
        sort_order: str = "",
        status: str = "",
        subject: str = "",
        subject_exact: str = "",
        ticket_body: str = "",
        ticket_field_id: str = "",
        ticket_form: str = "",
        ticket_id: str = "",
        ticket_priority: str = "",
        ticket_status: str = "",
        ticket_subject: str = "",
        ticket_type: str = "",
        update_ticket_assignee_id: str = "",
        update_ticket_body: str = "",
        update_ticket_subject: str = "",
        updated: str = "",
        user_alias: str = "",
        user_custom_role_id: str = "",
        user_details: str = "",
        user_email: str = "",
        user_external_id: str = "",
        user_id: str = "",
        user_locale: str = "",
        user_moderator: bool = False,
        user_name: str = "",
        user_notes: str = "",
        user_only_private_comments: bool = False,
        user_organization_id: str = "",
        user_phone: str = "",
        user_report_csv: bool = False,
        user_restricted_agent: bool = False,
        user_role: str = "end-user",
        user_signature: str = "",
        user_suspended: bool = False,
        user_tags: str = "",
        user_ticket_restriction: str = "",
        user_timezone: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_zendesk",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if ticket_subject is not None:
            self.inputs["ticket_subject"] = ticket_subject
        if ticket_body is not None:
            self.inputs["ticket_body"] = ticket_body
        if requester_email is not None:
            self.inputs["requester_email"] = requester_email
        if requester_name is not None:
            self.inputs["requester_name"] = requester_name
        if ticket_priority is not None:
            self.inputs["ticket_priority"] = ticket_priority
        if ticket_type is not None:
            self.inputs["ticket_type"] = ticket_type
        if ticket_status is not None:
            self.inputs["ticket_status"] = ticket_status
        if ticket_id is not None:
            self.inputs["ticket_id"] = ticket_id
        if update_ticket_subject is not None:
            self.inputs["update_ticket_subject"] = update_ticket_subject
        if update_ticket_body is not None:
            self.inputs["update_ticket_body"] = update_ticket_body
        if update_ticket_assignee_id is not None:
            self.inputs["update_ticket_assignee_id"] = update_ticket_assignee_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if assignee is not None:
            self.inputs["assignee"] = assignee
        if requester is not None:
            self.inputs["requester"] = requester
        if organization is not None:
            self.inputs["organization"] = organization
        if priority is not None:
            self.inputs["priority"] = priority
        if status is not None:
            self.inputs["status"] = status
        if subject is not None:
            self.inputs["subject"] = subject
        if subject_exact is not None:
            self.inputs["subject_exact"] = subject_exact
        if description is not None:
            self.inputs["description"] = description
        if body is not None:
            self.inputs["body"] = body
        if comment is not None:
            self.inputs["comment"] = comment
        if comment_exact is not None:
            self.inputs["comment_exact"] = comment_exact
        if updated is not None:
            self.inputs["updated"] = updated
        if solved is not None:
            self.inputs["solved"] = solved
        if due is not None:
            self.inputs["due"] = due
        if brand is not None:
            self.inputs["brand"] = brand
        if satisfaction is not None:
            self.inputs["satisfaction"] = satisfaction
        if ticket_form is not None:
            self.inputs["ticket_form"] = ticket_form
        if group is not None:
            self.inputs["group"] = group
        if sort_by is not None:
            self.inputs["sort_by"] = sort_by
        if sort_order is not None:
            self.inputs["sort_order"] = sort_order
        if external_id is not None:
            self.inputs["external_id"] = external_id
        if include is not None:
            self.inputs["include"] = include
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if public is not None:
            self.inputs["public"] = public
        if ticket_field_id is not None:
            self.inputs["ticket_field_id"] = ticket_field_id
        if limit is not None:
            self.inputs["limit"] = limit
        if user_name is not None:
            self.inputs["user_name"] = user_name
        if user_email is not None:
            self.inputs["user_email"] = user_email
        if user_role is not None:
            self.inputs["user_role"] = user_role
        if user_phone is not None:
            self.inputs["user_phone"] = user_phone
        if user_organization_id is not None:
            self.inputs["user_organization_id"] = user_organization_id
        if user_external_id is not None:
            self.inputs["user_external_id"] = user_external_id
        if user_alias is not None:
            self.inputs["user_alias"] = user_alias
        if user_details is not None:
            self.inputs["user_details"] = user_details
        if user_notes is not None:
            self.inputs["user_notes"] = user_notes
        if user_locale is not None:
            self.inputs["user_locale"] = user_locale
        if user_timezone is not None:
            self.inputs["user_timezone"] = user_timezone
        if user_signature is not None:
            self.inputs["user_signature"] = user_signature
        if user_moderator is not None:
            self.inputs["user_moderator"] = user_moderator
        if user_custom_role_id is not None:
            self.inputs["user_custom_role_id"] = user_custom_role_id
        if user_only_private_comments is not None:
            self.inputs["user_only_private_comments"] = user_only_private_comments
        if user_restricted_agent is not None:
            self.inputs["user_restricted_agent"] = user_restricted_agent
        if user_suspended is not None:
            self.inputs["user_suspended"] = user_suspended
        if user_report_csv is not None:
            self.inputs["user_report_csv"] = user_report_csv
        if user_ticket_restriction is not None:
            self.inputs["user_ticket_restriction"] = user_ticket_restriction
        if user_tags is not None:
            self.inputs["user_tags"] = user_tags
        if user_id is not None:
            self.inputs["user_id"] = user_id
        if role is not None:
            self.inputs["role"] = role
        if search_query is not None:
            self.inputs["search_query"] = search_query
        if email is not None:
            self.inputs["email"] = email
        if name is not None:
            self.inputs["name"] = name
        if phone is not None:
            self.inputs["phone"] = phone
        if organization_name is not None:
            self.inputs["organization_name"] = organization_name
        if organization_domain_names is not None:
            self.inputs["organization_domain_names"] = organization_domain_names
        if organization_details is not None:
            self.inputs["organization_details"] = organization_details
        if organization_notes is not None:
            self.inputs["organization_notes"] = organization_notes
        if organization_external_id is not None:
            self.inputs["organization_external_id"] = organization_external_id
        if organization_group_id is not None:
            self.inputs["organization_group_id"] = organization_group_id
        if organization_shared_tickets is not None:
            self.inputs["organization_shared_tickets"] = organization_shared_tickets
        if organization_shared_comments is not None:
            self.inputs["organization_shared_comments"] = organization_shared_comments
        if organization_tags is not None:
            self.inputs["organization_tags"] = organization_tags
        if organization_id is not None:
            self.inputs["organization_id"] = organization_id
        if return_all is not None:
            self.inputs["return_all"] = return_all
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationZendeskNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_stripe")
class IntegrationStripeNode(Node):
    """
    Stripe

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### add_customer_card
        card_customer_id: ID of the customer to add card to
        card_token: Token representing the card information
    ### create_charge
        charge_amount: Amount to charge in cents
        charge_currency: Three-letter currency code
        charge_description: Description of the charge
        charge_source: Payment source ID or token
        customer_id: ID of the customer to retrieve
    ### read_charge
        charge_id: ID of the charge to retrieve
    ### update_charge
        charge_id: ID of the charge to retrieve
        update_charge_description: New description for the charge
    ### create_coupon
        coupon_amount_off: Fixed amount off in cents
        coupon_currency: Currency for amount_off coupons
        coupon_duration: Duration of the coupon
        coupon_duration_in_months: Duration in months for repeating coupons
        coupon_max_redemptions: Maximum number of redemptions
        coupon_name: Name of the coupon
        coupon_percent_off: Percentage off
    ### create_customer
        customer_description: Description of the customer
        customer_email: Email address of the customer
        customer_name: Full name of the customer
        customer_phone: Phone number of the customer
    ### get_customers
        customer_email: Email address of the customer
        limit: Number of customers to retrieve
    ### read_customer
        customer_id: ID of the customer to retrieve
    ### update_customer
        customer_id: ID of the customer to retrieve
        update_customer_description: New description for the customer
        update_customer_email: New email for the customer
        update_customer_name: New name for the customer
        update_customer_phone: New phone for the customer
    ### delete_customer
        customer_id: ID of the customer to retrieve
    ### get_charges
        customer_id: ID of the customer to retrieve
        limit: Number of customers to retrieve
    ### delete_source
        delete_source_customer_id: ID of the customer whose source to delete
        delete_source_id: ID of the source to delete
    ### get_coupons
        limit: Number of customers to retrieve
    ### read_customer_card
        read_card_customer_id: ID of the customer whose card to retrieve
        read_card_source_id: ID of the card/source to retrieve
    ### read_source
        read_source_id: ID of the source to retrieve
    ### remove_customer_card
        remove_card_customer_id: ID of the customer whose card to remove
        remove_card_id: ID of the card to remove
    ### create_source
        source_amount: Amount in cents for this source
        source_currency: Three-letter currency code
        source_customer_id: ID of the customer to attach the source to
        source_statement_descriptor: Text to display on customer's statement
        source_type: Type of source to create
    ### create_token
        token_card_number: Card number
        token_cvc: Card security code
        token_exp_month: Expiration month
        token_exp_year: Expiration year

    ## Outputs
    ### get_balance
        available: Available balance amounts by currency
        livemode: Whether this is live or test mode
        object: Object type identifier
        pending: Pending balance amounts by currency
        raw_data: Raw response from Stripe API
    ### add_customer_card
        brand: Card brand (e.g., Visa, MasterCard)
        card_id: Unique ID of the added card
        customer_id: Customer ID the card is attached to
        exp_month: Card expiration month
        exp_year: Card expiration year
        fingerprint: Unique fingerprint for the card
        last4: Last 4 digits of the card
        raw_data: Raw response from Stripe API
    ### read_customer_card
        brand: Card brand (e.g., Visa, MasterCard)
        card_id: Unique ID of the card
        customer_id: Customer ID the card is attached to
        exp_month: Card expiration month
        exp_year: Card expiration year
        fingerprint: Unique fingerprint for the card
        last4: Last 4 digits of the card
        raw_data: Raw response from Stripe API
    ### create_token
        card_brand: Brand of the card
        card_exp_month: Card expiration month
        card_exp_year: Card expiration year
        card_fingerprint: Unique fingerprint for the card
        card_last4: Last 4 digits of the card
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
        token_id: Unique ID of the created token
        token_type: Type of the token
    ### remove_customer_card
        card_id: ID of the removed card
        deleted: Whether the card was successfully deleted
        message: Success message
        raw_data: Raw response from Stripe API
    ### create_charge
        charge_amount: Amount charged in cents
        charge_currency: Currency of the charge
        charge_customer: Customer ID associated with charge
        charge_description: Charge description
        charge_id: Unique ID of the created charge
        charge_paid: Whether the charge was paid
        charge_status: Status of the charge
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
    ### read_charge
        charge_amount: Amount charged in cents
        charge_currency: Currency of the charge
        charge_customer: Customer ID associated with charge
        charge_description: Charge description
        charge_id: Unique ID of the charge
        charge_paid: Whether the charge was paid
        charge_status: Status of the charge
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
    ### update_charge
        charge_amount: Amount charged in cents
        charge_currency: Currency of the charge
        charge_customer: Customer ID associated with charge
        charge_description: Charge description
        charge_id: Unique ID of the charge
        charge_paid: Whether the charge was paid
        charge_status: Status of the charge
        message: Success message
        raw_data: Raw response from Stripe API
    ### get_charges
        charge_amounts: List of charge amounts
        charge_currencies: List of charge currencies
        charge_customers: List of associated customer IDs
        charge_descriptions: List of charge descriptions
        charge_ids: List of charge IDs
        charge_paids: List of paid status booleans
        charge_statuses: List of charge statuses
        created_ats: List of creation timestamps
        raw_data: Raw response from Stripe API
    ### create_coupon
        coupon_amount_off: Fixed amount off in cents
        coupon_currency: Currency of the coupon
        coupon_duration: Duration of the coupon
        coupon_duration_in_months: Duration in months
        coupon_id: Unique ID of the created coupon
        coupon_max_redemptions: Maximum redemptions allowed
        coupon_name: Name of the coupon
        coupon_percent_off: Percentage off
        coupon_times_redeemed: Times already redeemed
        coupon_valid: Whether the coupon is valid
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
    ### get_coupons
        coupon_amount_offs: List of amount offs
        coupon_currencies: List of coupon currencies
        coupon_durations: List of coupon durations
        coupon_ids: List of coupon IDs
        coupon_names: List of coupon names
        coupon_percent_offs: List of percent offs
        coupon_valids: List of validity statuses
        created_ats: List of creation timestamps
        raw_data: Raw response from Stripe API
    ### create_customer
        created_at: Creation timestamp in RFC3339 format
        customer_description: Customer description
        customer_email: Customer's email address
        customer_id: Unique ID of the created customer
        customer_name: Customer's full name
        customer_phone: Customer's phone number
        raw_data: Raw response from Stripe API
    ### read_customer
        created_at: Creation timestamp in RFC3339 format
        customer_description: Customer description
        customer_email: Customer's email address
        customer_id: Unique ID of the customer
        customer_name: Customer's full name
        customer_phone: Customer's phone number
        raw_data: Raw response from Stripe API
    ### create_source
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
        source_amount: Amount for the source in cents
        source_currency: Currency of the source
        source_customer: Customer ID the source is attached to
        source_id: Unique ID of the created source
        source_status: Status of the source
        source_type: Type of the source
    ### read_source
        created_at: Creation timestamp in RFC3339 format
        raw_data: Raw response from Stripe API
        source_amount: Amount for the source in cents
        source_currency: Currency of the source
        source_customer: Customer ID the source is attached to
        source_id: Unique ID of the source
        source_status: Status of the source
        source_type: Type of the source
    ### get_customers
        created_ats: List of creation timestamps
        customer_descriptions: List of customer descriptions
        customer_emails: List of customer emails
        customer_ids: List of customer IDs
        customer_names: List of customer names
        customer_phones: List of customer phones
        raw_data: Raw response from Stripe API
    ### update_customer
        customer_description: Customer description
        customer_email: Customer's email address
        customer_id: Unique ID of the customer
        customer_name: Customer's full name
        customer_phone: Customer's phone number
        message: Success message
        raw_data: Raw response from Stripe API
    ### delete_customer
        customer_id: ID of the deleted customer
        deleted: Whether the deletion was successful
        message: Success message
        raw_data: Raw response from Stripe API
    ### delete_source
        deleted: Whether the source was successfully deleted
        message: Success message
        raw_data: Raw response from Stripe API
        source_id: ID of the deleted source
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Stripe>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_balance": {
            "inputs": [],
            "outputs": [
                {
                    "field": "object",
                    "type": "string",
                    "helper_text": "Object type identifier",
                },
                {
                    "field": "available",
                    "type": "string",
                    "helper_text": "Available balance amounts by currency",
                },
                {
                    "field": "pending",
                    "type": "string",
                    "helper_text": "Pending balance amounts by currency",
                },
                {
                    "field": "livemode",
                    "type": "bool",
                    "helper_text": "Whether this is live or test mode",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_balance",
            "task_name": "tasks.stripe.get_balance",
            "description": "Retrieve the balance of your Stripe account",
            "label": "Get Balance",
            "inputs_sort_order": ["integration", "action"],
        },
        "create_customer": {
            "inputs": [
                {
                    "field": "customer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Full name of the customer",
                    "label": "Customer Name",
                    "placeholder": "John Doe",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Email address of the customer",
                    "label": "Customer Email",
                    "placeholder": "john@example.com",
                },
                {
                    "field": "customer_phone",
                    "type": "string",
                    "value": "",
                    "helper_text": "Phone number of the customer",
                    "label": "Customer Phone",
                    "placeholder": "+1-555-123-4567",
                },
                {
                    "field": "customer_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the customer",
                    "label": "Customer Description",
                    "placeholder": "VIP customer",
                },
            ],
            "outputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created customer",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "helper_text": "Customer's email address",
                },
                {
                    "field": "customer_name",
                    "type": "string",
                    "helper_text": "Customer's full name",
                },
                {
                    "field": "customer_phone",
                    "type": "string",
                    "helper_text": "Customer's phone number",
                },
                {
                    "field": "customer_description",
                    "type": "string",
                    "helper_text": "Customer description",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_customer",
            "task_name": "tasks.stripe.create_customer",
            "description": "Create a new customer in Stripe",
            "label": "Create Customer",
            "inputs_sort_order": [
                "integration",
                "action",
                "customer_name",
                "customer_email",
                "customer_phone",
                "customer_description",
            ],
        },
        "read_customer": {
            "inputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to retrieve",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                }
            ],
            "outputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Unique ID of the customer",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "helper_text": "Customer's email address",
                },
                {
                    "field": "customer_name",
                    "type": "string",
                    "helper_text": "Customer's full name",
                },
                {
                    "field": "customer_phone",
                    "type": "string",
                    "helper_text": "Customer's phone number",
                },
                {
                    "field": "customer_description",
                    "type": "string",
                    "helper_text": "Customer description",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "read_customer",
            "task_name": "tasks.stripe.read_customer",
            "description": "Retrieve details of an existing customer",
            "label": "Read Customer",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "customer_id"],
        },
        "update_customer": {
            "inputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to update",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "update_customer_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the customer",
                    "label": "New Customer Name",
                    "placeholder": "Jane Doe",
                },
                {
                    "field": "update_customer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "New email for the customer",
                    "label": "New Customer Email",
                    "placeholder": "jane@example.com",
                },
                {
                    "field": "update_customer_phone",
                    "type": "string",
                    "value": "",
                    "helper_text": "New phone for the customer",
                    "label": "New Customer Phone",
                    "placeholder": "+1-555-987-6543",
                },
                {
                    "field": "update_customer_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the customer",
                    "label": "New Customer Description",
                    "placeholder": "Updated description",
                },
            ],
            "outputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Unique ID of the customer",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "helper_text": "Customer's email address",
                },
                {
                    "field": "customer_name",
                    "type": "string",
                    "helper_text": "Customer's full name",
                },
                {
                    "field": "customer_phone",
                    "type": "string",
                    "helper_text": "Customer's phone number",
                },
                {
                    "field": "customer_description",
                    "type": "string",
                    "helper_text": "Customer description",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_customer",
            "task_name": "tasks.stripe.update_customer",
            "description": "Update an existing customer's information",
            "label": "Update Customer",
            "inputs_sort_order": [
                "integration",
                "action",
                "customer_id",
                "update_customer_name",
                "update_customer_email",
                "update_customer_phone",
                "update_customer_description",
            ],
        },
        "delete_customer": {
            "inputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to delete",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                }
            ],
            "outputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "ID of the deleted customer",
                },
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "delete_customer",
            "task_name": "tasks.stripe.delete_customer",
            "description": "Delete an existing customer",
            "label": "Delete Customer",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "customer_id"],
        },
        "get_customers": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Number of customers to retrieve",
                    "label": "Number of Customers",
                    "placeholder": "10",
                },
                {
                    "field": "customer_email",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by customer email",
                    "label": "Filter by Email",
                    "placeholder": "john@example.com",
                },
            ],
            "outputs": [
                {
                    "field": "customer_ids",
                    "type": "vec<string>",
                    "helper_text": "List of customer IDs",
                },
                {
                    "field": "customer_emails",
                    "type": "vec<string>",
                    "helper_text": "List of customer emails",
                },
                {
                    "field": "customer_names",
                    "type": "vec<string>",
                    "helper_text": "List of customer names",
                },
                {
                    "field": "customer_phones",
                    "type": "vec<string>",
                    "helper_text": "List of customer phones",
                },
                {
                    "field": "customer_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of customer descriptions",
                },
                {
                    "field": "created_ats",
                    "type": "vec<timestamp>",
                    "helper_text": "List of creation timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_customers",
            "task_name": "tasks.stripe.get_customers",
            "description": "Retrieve a list of customers",
            "label": "Get Customers",
            "inputs_sort_order": ["integration", "action", "limit", "customer_email"],
        },
        "create_charge": {
            "inputs": [
                {
                    "field": "charge_amount",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Amount to charge in cents",
                    "label": "Charge Amount (cents)",
                    "placeholder": "5000",
                },
                {
                    "field": "charge_currency",
                    "type": "string",
                    "value": "USD",
                    "helper_text": "Three-letter currency code",
                    "label": "Currency",
                    "placeholder": "USD",
                },
                {
                    "field": "charge_source",
                    "type": "string",
                    "value": "",
                    "helper_text": "Payment source ID or token",
                    "label": "Payment Source",
                    "placeholder": "tok_visa",
                },
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Customer ID to associate with charge",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "charge_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the charge",
                    "label": "Charge Description",
                    "placeholder": "Payment for services",
                },
            ],
            "outputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created charge",
                },
                {
                    "field": "charge_amount",
                    "type": "int32",
                    "helper_text": "Amount charged in cents",
                },
                {
                    "field": "charge_currency",
                    "type": "string",
                    "helper_text": "Currency of the charge",
                },
                {
                    "field": "charge_customer",
                    "type": "string",
                    "helper_text": "Customer ID associated with charge",
                },
                {
                    "field": "charge_description",
                    "type": "string",
                    "helper_text": "Charge description",
                },
                {
                    "field": "charge_status",
                    "type": "string",
                    "helper_text": "Status of the charge",
                },
                {
                    "field": "charge_paid",
                    "type": "bool",
                    "helper_text": "Whether the charge was paid",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_charge",
            "task_name": "tasks.stripe.create_charge",
            "description": "Create a new charge",
            "label": "Create Charge",
            "inputs_sort_order": [
                "integration",
                "action",
                "charge_amount",
                "charge_currency",
                "charge_source",
                "customer_id",
                "charge_description",
            ],
        },
        "read_charge": {
            "inputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the charge to retrieve",
                    "label": "Charge ID",
                    "placeholder": "ch_123456789",
                }
            ],
            "outputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "helper_text": "Unique ID of the charge",
                },
                {
                    "field": "charge_amount",
                    "type": "int32",
                    "helper_text": "Amount charged in cents",
                },
                {
                    "field": "charge_currency",
                    "type": "string",
                    "helper_text": "Currency of the charge",
                },
                {
                    "field": "charge_customer",
                    "type": "string",
                    "helper_text": "Customer ID associated with charge",
                },
                {
                    "field": "charge_description",
                    "type": "string",
                    "helper_text": "Charge description",
                },
                {
                    "field": "charge_status",
                    "type": "string",
                    "helper_text": "Status of the charge",
                },
                {
                    "field": "charge_paid",
                    "type": "bool",
                    "helper_text": "Whether the charge was paid",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "read_charge",
            "task_name": "tasks.stripe.read_charge",
            "description": "Retrieve details of an existing charge",
            "label": "Read Charge",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "charge_id"],
        },
        "update_charge": {
            "inputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the charge to update",
                    "label": "Charge ID",
                    "placeholder": "ch_123456789",
                },
                {
                    "field": "update_charge_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the charge",
                    "label": "New Description",
                    "placeholder": "Updated payment description",
                },
            ],
            "outputs": [
                {
                    "field": "charge_id",
                    "type": "string",
                    "helper_text": "Unique ID of the charge",
                },
                {
                    "field": "charge_amount",
                    "type": "int32",
                    "helper_text": "Amount charged in cents",
                },
                {
                    "field": "charge_currency",
                    "type": "string",
                    "helper_text": "Currency of the charge",
                },
                {
                    "field": "charge_customer",
                    "type": "string",
                    "helper_text": "Customer ID associated with charge",
                },
                {
                    "field": "charge_description",
                    "type": "string",
                    "helper_text": "Charge description",
                },
                {
                    "field": "charge_status",
                    "type": "string",
                    "helper_text": "Status of the charge",
                },
                {
                    "field": "charge_paid",
                    "type": "bool",
                    "helper_text": "Whether the charge was paid",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_charge",
            "task_name": "tasks.stripe.update_charge",
            "description": "Update an existing charge",
            "label": "Update Charge",
            "inputs_sort_order": [
                "integration",
                "action",
                "charge_id",
                "update_charge_description",
            ],
        },
        "get_charges": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Number of charges to retrieve",
                    "label": "Number of Charges",
                    "placeholder": "10",
                },
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by customer ID",
                    "label": "Filter by Customer ID",
                    "placeholder": "cus_123456789",
                },
            ],
            "outputs": [
                {
                    "field": "charge_ids",
                    "type": "vec<string>",
                    "helper_text": "List of charge IDs",
                },
                {
                    "field": "charge_amounts",
                    "type": "vec<int32>",
                    "helper_text": "List of charge amounts",
                },
                {
                    "field": "charge_currencies",
                    "type": "vec<string>",
                    "helper_text": "List of charge currencies",
                },
                {
                    "field": "charge_customers",
                    "type": "vec<string>",
                    "helper_text": "List of associated customer IDs",
                },
                {
                    "field": "charge_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of charge descriptions",
                },
                {
                    "field": "charge_statuses",
                    "type": "vec<string>",
                    "helper_text": "List of charge statuses",
                },
                {
                    "field": "charge_paids",
                    "type": "vec<bool>",
                    "helper_text": "List of paid status booleans",
                },
                {
                    "field": "created_ats",
                    "type": "vec<timestamp>",
                    "helper_text": "List of creation timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_charges",
            "task_name": "tasks.stripe.get_charges",
            "description": "Retrieve a list of charges",
            "label": "Get Charges",
            "inputs_sort_order": ["integration", "action", "limit", "customer_id"],
        },
        "create_coupon": {
            "inputs": [
                {
                    "field": "coupon_duration",
                    "type": "string",
                    "value": "once",
                    "helper_text": "Duration of the coupon",
                    "label": "Duration",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Once", "value": "once"},
                            {"label": "Repeating", "value": "repeating"},
                            {"label": "Forever", "value": "forever"},
                        ],
                    },
                },
                {
                    "field": "coupon_amount_off",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Fixed amount off in cents",
                    "label": "Amount Off (cents)",
                    "placeholder": "1000",
                },
                {
                    "field": "coupon_percent_off",
                    "type": "float",
                    "value": 0.0,
                    "helper_text": "Percentage off",
                    "label": "Percent Off",
                    "placeholder": "25.0",
                },
                {
                    "field": "coupon_currency",
                    "type": "string",
                    "value": "USD",
                    "helper_text": "Currency for amount_off coupons",
                    "label": "Currency",
                    "placeholder": "USD",
                },
                {
                    "field": "coupon_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the coupon",
                    "label": "Coupon Name",
                    "placeholder": "Holiday Sale",
                },
                {
                    "field": "coupon_duration_in_months",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Duration in months for repeating coupons",
                    "label": "Duration (months)",
                },
                {
                    "field": "coupon_max_redemptions",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Maximum number of redemptions",
                    "label": "Max Redemptions",
                },
            ],
            "outputs": [
                {
                    "field": "coupon_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created coupon",
                },
                {
                    "field": "coupon_name",
                    "type": "string",
                    "helper_text": "Name of the coupon",
                },
                {
                    "field": "coupon_duration",
                    "type": "string",
                    "helper_text": "Duration of the coupon",
                },
                {
                    "field": "coupon_amount_off",
                    "type": "int32",
                    "helper_text": "Fixed amount off in cents",
                },
                {
                    "field": "coupon_percent_off",
                    "type": "float",
                    "helper_text": "Percentage off",
                },
                {
                    "field": "coupon_currency",
                    "type": "string",
                    "helper_text": "Currency of the coupon",
                },
                {
                    "field": "coupon_duration_in_months",
                    "type": "int32",
                    "helper_text": "Duration in months",
                },
                {
                    "field": "coupon_max_redemptions",
                    "type": "int32",
                    "helper_text": "Maximum redemptions allowed",
                },
                {
                    "field": "coupon_times_redeemed",
                    "type": "int32",
                    "helper_text": "Times already redeemed",
                },
                {
                    "field": "coupon_valid",
                    "type": "bool",
                    "helper_text": "Whether the coupon is valid",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_coupon",
            "task_name": "tasks.stripe.create_coupon",
            "description": "Create a new coupon",
            "label": "Create Coupon",
            "inputs_sort_order": [
                "integration",
                "action",
                "coupon_duration",
                "coupon_amount_off",
                "coupon_percent_off",
                "coupon_currency",
                "coupon_name",
                "coupon_duration_in_months",
                "coupon_max_redemptions",
            ],
        },
        "get_coupons": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Number of coupons to retrieve",
                    "label": "Number of Coupons",
                    "placeholder": "10",
                }
            ],
            "outputs": [
                {
                    "field": "coupon_ids",
                    "type": "vec<string>",
                    "helper_text": "List of coupon IDs",
                },
                {
                    "field": "coupon_names",
                    "type": "vec<string>",
                    "helper_text": "List of coupon names",
                },
                {
                    "field": "coupon_durations",
                    "type": "vec<string>",
                    "helper_text": "List of coupon durations",
                },
                {
                    "field": "coupon_amount_offs",
                    "type": "vec<int32>",
                    "helper_text": "List of amount offs",
                },
                {
                    "field": "coupon_percent_offs",
                    "type": "vec<float>",
                    "helper_text": "List of percent offs",
                },
                {
                    "field": "coupon_currencies",
                    "type": "vec<string>",
                    "helper_text": "List of coupon currencies",
                },
                {
                    "field": "coupon_valids",
                    "type": "vec<bool>",
                    "helper_text": "List of validity statuses",
                },
                {
                    "field": "created_ats",
                    "type": "vec<timestamp>",
                    "helper_text": "List of creation timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_coupons",
            "task_name": "tasks.stripe.get_coupons",
            "description": "Retrieve a list of coupons",
            "label": "Get Coupons",
            "inputs_sort_order": ["integration", "action", "limit"],
        },
        "add_customer_card": {
            "inputs": [
                {
                    "field": "card_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to add card to",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "card_token",
                    "type": "string",
                    "value": "",
                    "helper_text": "Token representing the card information",
                    "label": "Card Token",
                    "placeholder": "tok_1IMfKdJhRTnqS5TKQVG1LI9o",
                },
            ],
            "outputs": [
                {
                    "field": "card_id",
                    "type": "string",
                    "helper_text": "Unique ID of the added card",
                },
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Customer ID the card is attached to",
                },
                {
                    "field": "brand",
                    "type": "string",
                    "helper_text": "Card brand (e.g., Visa, MasterCard)",
                },
                {
                    "field": "last4",
                    "type": "string",
                    "helper_text": "Last 4 digits of the card",
                },
                {
                    "field": "exp_month",
                    "type": "int32",
                    "helper_text": "Card expiration month",
                },
                {
                    "field": "exp_year",
                    "type": "int32",
                    "helper_text": "Card expiration year",
                },
                {
                    "field": "fingerprint",
                    "type": "string",
                    "helper_text": "Unique fingerprint for the card",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "add_customer_card",
            "task_name": "tasks.stripe.add_customer_card",
            "description": "Add a card to a customer",
            "label": "Add Customer Card",
            "inputs_sort_order": [
                "integration",
                "action",
                "card_customer_id",
                "card_token",
            ],
        },
        "read_customer_card": {
            "inputs": [
                {
                    "field": "read_card_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer whose card to retrieve",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "read_card_source_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the card/source to retrieve",
                    "label": "Source ID",
                    "placeholder": "card_1A2B3C4D5E6F7G8H",
                },
            ],
            "outputs": [
                {
                    "field": "card_id",
                    "type": "string",
                    "helper_text": "Unique ID of the card",
                },
                {
                    "field": "customer_id",
                    "type": "string",
                    "helper_text": "Customer ID the card is attached to",
                },
                {
                    "field": "brand",
                    "type": "string",
                    "helper_text": "Card brand (e.g., Visa, MasterCard)",
                },
                {
                    "field": "last4",
                    "type": "string",
                    "helper_text": "Last 4 digits of the card",
                },
                {
                    "field": "exp_month",
                    "type": "int32",
                    "helper_text": "Card expiration month",
                },
                {
                    "field": "exp_year",
                    "type": "int32",
                    "helper_text": "Card expiration year",
                },
                {
                    "field": "fingerprint",
                    "type": "string",
                    "helper_text": "Unique fingerprint for the card",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "read_customer_card",
            "task_name": "tasks.stripe.read_customer_card",
            "description": "Retrieve details of a customer's card",
            "label": "Read Customer Card",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "read_card_customer_id",
                "read_card_source_id",
            ],
        },
        "remove_customer_card": {
            "inputs": [
                {
                    "field": "remove_card_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer whose card to remove",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "remove_card_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the card to remove",
                    "label": "Card ID",
                    "placeholder": "card_1A2B3C4D5E6F7G8H",
                },
            ],
            "outputs": [
                {
                    "field": "card_id",
                    "type": "string",
                    "helper_text": "ID of the removed card",
                },
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the card was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "remove_customer_card",
            "task_name": "tasks.stripe.remove_customer_card",
            "description": "Remove a card from a customer",
            "label": "Remove Customer Card",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "remove_card_customer_id",
                "remove_card_id",
            ],
        },
        "create_source": {
            "inputs": [
                {
                    "field": "source_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer to attach the source to",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "source_type",
                    "type": "string",
                    "value": "wechat",
                    "helper_text": "Type of source to create",
                    "label": "Source Type",
                    "component": {
                        "type": "dropdown",
                        "options": [{"label": "WeChat", "value": "wechat"}],
                    },
                },
                {
                    "field": "source_amount",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Amount in cents for this source",
                    "label": "Amount (cents)",
                    "placeholder": "5000",
                },
                {
                    "field": "source_currency",
                    "type": "string",
                    "value": "USD",
                    "helper_text": "Three-letter currency code",
                    "label": "Currency",
                    "placeholder": "USD",
                },
                {
                    "field": "source_statement_descriptor",
                    "type": "string",
                    "value": "",
                    "helper_text": "Text to display on customer's statement",
                    "label": "Statement Descriptor",
                    "placeholder": "Payment description",
                },
            ],
            "outputs": [
                {
                    "field": "source_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created source",
                },
                {
                    "field": "source_type",
                    "type": "string",
                    "helper_text": "Type of the source",
                },
                {
                    "field": "source_amount",
                    "type": "int32",
                    "helper_text": "Amount for the source in cents",
                },
                {
                    "field": "source_currency",
                    "type": "string",
                    "helper_text": "Currency of the source",
                },
                {
                    "field": "source_status",
                    "type": "string",
                    "helper_text": "Status of the source",
                },
                {
                    "field": "source_customer",
                    "type": "string",
                    "helper_text": "Customer ID the source is attached to",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_source",
            "task_name": "tasks.stripe.create_source",
            "description": "Create a new payment source",
            "label": "Create Source",
            "inputs_sort_order": [
                "integration",
                "action",
                "source_customer_id",
                "source_type",
                "source_amount",
                "source_currency",
                "source_statement_descriptor",
            ],
        },
        "read_source": {
            "inputs": [
                {
                    "field": "read_source_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the source to retrieve",
                    "label": "Source ID",
                    "placeholder": "src_123456789",
                }
            ],
            "outputs": [
                {
                    "field": "source_id",
                    "type": "string",
                    "helper_text": "Unique ID of the source",
                },
                {
                    "field": "source_type",
                    "type": "string",
                    "helper_text": "Type of the source",
                },
                {
                    "field": "source_amount",
                    "type": "int32",
                    "helper_text": "Amount for the source in cents",
                },
                {
                    "field": "source_currency",
                    "type": "string",
                    "helper_text": "Currency of the source",
                },
                {
                    "field": "source_status",
                    "type": "string",
                    "helper_text": "Status of the source",
                },
                {
                    "field": "source_customer",
                    "type": "string",
                    "helper_text": "Customer ID the source is attached to",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "read_source",
            "task_name": "tasks.stripe.read_source",
            "description": "Retrieve details of a source",
            "label": "Read Source",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "read_source_id"],
        },
        "delete_source": {
            "inputs": [
                {
                    "field": "delete_source_customer_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the customer whose source to delete",
                    "label": "Customer ID",
                    "placeholder": "cus_123456789",
                },
                {
                    "field": "delete_source_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the source to delete",
                    "label": "Source ID",
                    "placeholder": "src_123456789",
                },
            ],
            "outputs": [
                {
                    "field": "source_id",
                    "type": "string",
                    "helper_text": "ID of the deleted source",
                },
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the source was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "name": "delete_source",
            "task_name": "tasks.stripe.delete_source",
            "description": "Delete a source from a customer",
            "label": "Delete Source",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "delete_source_customer_id",
                "delete_source_id",
            ],
        },
        "create_token": {
            "inputs": [
                {
                    "field": "token_card_number",
                    "type": "string",
                    "value": "",
                    "helper_text": "Card number",
                    "label": "Card Number",
                    "placeholder": "4242424242424242",
                },
                {
                    "field": "token_cvc",
                    "type": "string",
                    "value": "",
                    "helper_text": "Card security code",
                    "label": "CVC",
                    "placeholder": "314",
                },
                {
                    "field": "token_exp_month",
                    "type": "string",
                    "value": "",
                    "helper_text": "Expiration month",
                    "label": "Expiration Month",
                    "placeholder": "10",
                },
                {
                    "field": "token_exp_year",
                    "type": "string",
                    "value": "",
                    "helper_text": "Expiration year",
                    "label": "Expiration Year",
                    "placeholder": "2027",
                },
            ],
            "outputs": [
                {
                    "field": "token_id",
                    "type": "string",
                    "helper_text": "Unique ID of the created token",
                },
                {
                    "field": "token_type",
                    "type": "string",
                    "helper_text": "Type of the token",
                },
                {
                    "field": "card_brand",
                    "type": "string",
                    "helper_text": "Brand of the card",
                },
                {
                    "field": "card_last4",
                    "type": "string",
                    "helper_text": "Last 4 digits of the card",
                },
                {
                    "field": "card_exp_month",
                    "type": "int32",
                    "helper_text": "Card expiration month",
                },
                {
                    "field": "card_exp_year",
                    "type": "int32",
                    "helper_text": "Card expiration year",
                },
                {
                    "field": "card_fingerprint",
                    "type": "string",
                    "helper_text": "Unique fingerprint for the card",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp in RFC3339 format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Stripe API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "create_token",
            "task_name": "tasks.stripe.create_token",
            "description": "Create a new card token",
            "label": "Create Token",
            "inputs_sort_order": [
                "integration",
                "action",
                "token_card_number",
                "token_cvc",
                "token_exp_month",
                "token_exp_year",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        card_customer_id: str = "",
        card_token: str = "",
        charge_amount: int = 0,
        charge_currency: str = "USD",
        charge_description: str = "",
        charge_id: str = "",
        charge_source: str = "",
        coupon_amount_off: int = 0,
        coupon_currency: str = "USD",
        coupon_duration: str = "once",
        coupon_duration_in_months: int = 0,
        coupon_max_redemptions: int = 0,
        coupon_name: str = "",
        coupon_percent_off: Any = 0.0,
        customer_description: str = "",
        customer_email: str = "",
        customer_id: str = "",
        customer_name: str = "",
        customer_phone: str = "",
        delete_source_customer_id: str = "",
        delete_source_id: str = "",
        limit: int = 10,
        read_card_customer_id: str = "",
        read_card_source_id: str = "",
        read_source_id: str = "",
        remove_card_customer_id: str = "",
        remove_card_id: str = "",
        source_amount: int = 0,
        source_currency: str = "USD",
        source_customer_id: str = "",
        source_statement_descriptor: str = "",
        source_type: str = "wechat",
        token_card_number: str = "",
        token_cvc: str = "",
        token_exp_month: str = "",
        token_exp_year: str = "",
        update_charge_description: str = "",
        update_customer_description: str = "",
        update_customer_email: str = "",
        update_customer_name: str = "",
        update_customer_phone: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_stripe",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if customer_name is not None:
            self.inputs["customer_name"] = customer_name
        if customer_email is not None:
            self.inputs["customer_email"] = customer_email
        if customer_phone is not None:
            self.inputs["customer_phone"] = customer_phone
        if customer_description is not None:
            self.inputs["customer_description"] = customer_description
        if customer_id is not None:
            self.inputs["customer_id"] = customer_id
        if update_customer_name is not None:
            self.inputs["update_customer_name"] = update_customer_name
        if update_customer_email is not None:
            self.inputs["update_customer_email"] = update_customer_email
        if update_customer_phone is not None:
            self.inputs["update_customer_phone"] = update_customer_phone
        if update_customer_description is not None:
            self.inputs["update_customer_description"] = update_customer_description
        if limit is not None:
            self.inputs["limit"] = limit
        if charge_amount is not None:
            self.inputs["charge_amount"] = charge_amount
        if charge_currency is not None:
            self.inputs["charge_currency"] = charge_currency
        if charge_source is not None:
            self.inputs["charge_source"] = charge_source
        if charge_description is not None:
            self.inputs["charge_description"] = charge_description
        if charge_id is not None:
            self.inputs["charge_id"] = charge_id
        if update_charge_description is not None:
            self.inputs["update_charge_description"] = update_charge_description
        if coupon_duration is not None:
            self.inputs["coupon_duration"] = coupon_duration
        if coupon_amount_off is not None:
            self.inputs["coupon_amount_off"] = coupon_amount_off
        if coupon_percent_off is not None:
            self.inputs["coupon_percent_off"] = coupon_percent_off
        if coupon_currency is not None:
            self.inputs["coupon_currency"] = coupon_currency
        if coupon_name is not None:
            self.inputs["coupon_name"] = coupon_name
        if coupon_duration_in_months is not None:
            self.inputs["coupon_duration_in_months"] = coupon_duration_in_months
        if coupon_max_redemptions is not None:
            self.inputs["coupon_max_redemptions"] = coupon_max_redemptions
        if card_customer_id is not None:
            self.inputs["card_customer_id"] = card_customer_id
        if card_token is not None:
            self.inputs["card_token"] = card_token
        if read_card_customer_id is not None:
            self.inputs["read_card_customer_id"] = read_card_customer_id
        if read_card_source_id is not None:
            self.inputs["read_card_source_id"] = read_card_source_id
        if remove_card_customer_id is not None:
            self.inputs["remove_card_customer_id"] = remove_card_customer_id
        if remove_card_id is not None:
            self.inputs["remove_card_id"] = remove_card_id
        if source_customer_id is not None:
            self.inputs["source_customer_id"] = source_customer_id
        if source_type is not None:
            self.inputs["source_type"] = source_type
        if source_amount is not None:
            self.inputs["source_amount"] = source_amount
        if source_currency is not None:
            self.inputs["source_currency"] = source_currency
        if source_statement_descriptor is not None:
            self.inputs["source_statement_descriptor"] = source_statement_descriptor
        if read_source_id is not None:
            self.inputs["read_source_id"] = read_source_id
        if delete_source_customer_id is not None:
            self.inputs["delete_source_customer_id"] = delete_source_customer_id
        if delete_source_id is not None:
            self.inputs["delete_source_id"] = delete_source_id
        if token_card_number is not None:
            self.inputs["token_card_number"] = token_card_number
        if token_cvc is not None:
            self.inputs["token_cvc"] = token_cvc
        if token_exp_month is not None:
            self.inputs["token_exp_month"] = token_exp_month
        if token_exp_year is not None:
            self.inputs["token_exp_year"] = token_exp_year
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationStripeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_teams")
class IntegrationTeamsNode(Node):
    """
    Teams

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_task
        assigned_to: User ID to assign the task to
        bucket_id: Select the bucket to create the task in
        due_date: Due date for the task (YYYY-MM-DD format)
        percent_complete: Completion percentage (0-100)
        plan_id: Select the planner plan to create the task in
        task_title: Title of the task
        team_id: Select the team where you want to create the channel
    ### update_task
        assigned_to: User ID to assign the task to
        bucket_id: Select the bucket to create the task in
        due_date: Due date for the task (YYYY-MM-DD format)
        percent_complete: Completion percentage (0-100)
        plan_id: Select the planner plan to create the task in
        task_id: Select the task to delete
        task_title: Title of the task
        team_id: Select the team where you want to create the channel
    ### delete_task
        bucket_id: Select the bucket to create the task in
        plan_id: Select the planner plan to create the task in
        task_id: Select the task to delete
        team_id: Select the team where you want to create the channel
    ### get_task
        bucket_id: Select the bucket to create the task in
        plan_id: Select the planner plan to create the task in
        task_id: Select the task to delete
        team_id: Select the team where you want to create the channel
    ### create_channel
        channel_description: Optional description for the channel
        channel_name: Name of the channel to create
        channel_type: Type of channel (standard or private)
        team_id: Select the team where you want to create the channel
    ### update_channel
        channel_description: Optional description for the channel
        channel_id: Select the channel to delete
        channel_name: Name of the channel to create
        team_id: Select the team where you want to create the channel
    ### delete_channel
        channel_id: Select the channel to delete
        team_id: Select the team where you want to create the channel
    ### get_channel
        channel_id: Select the channel to delete
        team_id: Select the team where you want to create the channel
    ### send_message
        channel_id: Select the channel to delete
        content_type: Type of message content
        message_content: The message content to post
        reply_to_message_id: ID of message to reply to (optional)
        team_id: Select the team where you want to create the channel
    ### list_channel_messages
        channel_id: Select the channel to delete
        limit: Maximum number of messages to retrieve
        team_id: Select the team where you want to create the channel
    ### list_channels
        channel_type: Type of channel (standard or private)
        select_fields: Comma-separated list of fields to return. Leave empty for all fields
        team_id: Select the team where you want to create the channel
    ### create_chat_message
        chat_id: Select the chat to send message to
        content_type: Type of message content
        message_content: The message content to post
    ### get_chat_message
        chat_id: Select the chat to send message to
        message_id: ID of the message to retrieve
    ### list_chat_messages
        chat_id: Select the chat to send message to
        limit: Maximum number of messages to retrieve
    ### list_tasks
        limit: Maximum number of messages to retrieve
        plan_id: Select the planner plan to create the task in
        team_id: Select the team where you want to create the channel

    ## Outputs
    ### create_task
        bucket_id: Bucket ID of the task
        created_at: Creation timestamp
        due_date: Due date of the task
        has_description: Whether the task has a description
        percent_complete: Completion percentage
        plan_id: Plan ID of the task
        raw_data: Raw response data from Teams API
        task_id: ID of the created task
        task_title: Title of the created task
    ### get_task
        bucket_id: Bucket ID of the task
        completed_at: Completion timestamp
        conversation_thread_id: Conversation thread ID
        created_at: Creation timestamp
        due_date: Due date of the task
        has_description: Whether the task has a description
        percent_complete: Completion percentage
        plan_id: Plan ID of the task
        raw_data: Raw response data from Teams API
        task_id: ID of the task
        task_title: Title of the task
    ### create_channel
        channel_description: Description of the created channel
        channel_email: Email address of the created channel
        channel_id: ID of the created channel
        channel_name: Name of the created channel
        channel_type: Type of the created channel
        channel_web_url: Web URL of the created channel
        created_at: Creation timestamp
        raw_data: Raw response data from Teams API
    ### get_channel
        channel_description: Description of the channel
        channel_email: Email address of the channel
        channel_id: ID of the channel
        channel_name: Name of the channel
        channel_type: Type of the channel
        channel_web_url: Web URL of the channel
        created_at: Creation timestamp
        raw_data: Raw response data from Teams API
    ### update_channel
        channel_id: ID of the updated channel
        success: Whether the channel was updated successfully
    ### list_channels
        channel_ids: List of channel IDs
        channel_names: List of channel names
        raw_data: Raw response data from Teams API
        total_count: Total number of channels found
    ### send_message
        content_type: Content type of the message
        created_at: Creation timestamp
        from_user: Display name of the message sender
        from_user_email: Email of the message sender
        message_content: Content of the message
        message_id: ID of the created message
        message_type: Type of the message
        raw_data: Raw response data from Teams API
        web_url: Web URL of the message
    ### create_chat_message
        content_type: Content type of the message
        created_at: Creation timestamp
        from_user: Display name of the message sender
        from_user_email: Email of the message sender
        message_content: Content of the message
        message_id: ID of the created message
        message_type: Type of the message
        raw_data: Raw response data from Teams API
        web_url: Web URL of the message
    ### get_chat_message
        content_type: Content type of the message
        created_at: Creation timestamp
        from_user: Display name of the message sender
        from_user_email: Email of the message sender
        last_modified_at: Last modification timestamp
        message_content: Content of the message
        message_id: ID of the message
        message_type: Type of the message
        raw_data: Raw response data from Teams API
        web_url: Web URL of the message
    ### list_channel_messages
        has_next_page: Whether there are more messages available
        message_ids: List of message IDs
        message_summaries: List of message summaries
        raw_data: Raw response data from Teams API
        total_count: Total number of messages found
    ### list_chat_messages
        has_next_page: Whether there are more messages available
        message_ids: List of message IDs
        message_summaries: List of message summaries
        raw_data: Raw response data from Teams API
        total_count: Total number of messages found
    ### list_tasks
        has_next_page: Whether there are more tasks available
        raw_data: Raw response data from Teams API
        task_ids: List of task IDs
        task_titles: List of task titles
        total_count: Total number of tasks found
    ### delete_channel
        message: Confirmation message
        success: Whether the channel was deleted successfully
    ### delete_task
        message: Confirmation message
        success: Whether the task was deleted successfully
        task_id: ID of the deleted task
    ### update_task
        message: Message indicating the result of the update
        success: Whether the task was updated successfully
        task_id: ID of the updated task
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Teams>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_channel": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "helper_text": "Select the team where you want to create the channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "value": "",
                    "label": "Channel Name",
                    "placeholder": "General",
                    "helper_text": "Name of the channel to create",
                },
                {
                    "field": "channel_description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Channel description",
                    "helper_text": "Optional description for the channel",
                },
                {
                    "field": "channel_type",
                    "type": "string",
                    "value": "standard",
                    "label": "Channel Type",
                    "helper_text": "Type of channel (standard or private)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Standard", "value": "standard"},
                            {"label": "Private", "value": "private"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the created channel",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the created channel",
                },
                {
                    "field": "channel_description",
                    "type": "string",
                    "helper_text": "Description of the created channel",
                },
                {
                    "field": "channel_web_url",
                    "type": "string",
                    "helper_text": "Web URL of the created channel",
                },
                {
                    "field": "channel_email",
                    "type": "string",
                    "helper_text": "Email address of the created channel",
                },
                {
                    "field": "channel_type",
                    "type": "string",
                    "helper_text": "Type of the created channel",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "create_channel",
            "task_name": "tasks.teams.create_channel",
            "description": "Create a new channel in a Microsoft Teams team",
            "label": "Create Channel",
            "variant": "common_integration_nodes",
            "required": ["team_id", "channel_name"],
            "inputs_sort_order": [
                "team_id",
                "channel_name",
                "channel_description",
                "channel_type",
            ],
        },
        "delete_channel": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "helper_text": "Select the team containing the channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel_id",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "helper_text": "Select the channel to delete",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the channel was deleted successfully",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Confirmation message",
                },
            ],
            "name": "delete_channel",
            "task_name": "tasks.teams.delete_channel",
            "description": "Delete a channel from a Microsoft Teams team",
            "label": "Delete Channel",
            "variant": "common_integration_nodes",
            "required": ["team_id", "channel_id"],
            "inputs_sort_order": ["team_id", "channel_id"],
        },
        "get_channel": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "helper_text": "Select the team containing the channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel_id",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "helper_text": "Select the channel to retrieve",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the channel",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the channel",
                },
                {
                    "field": "channel_description",
                    "type": "string",
                    "helper_text": "Description of the channel",
                },
                {
                    "field": "channel_web_url",
                    "type": "string",
                    "helper_text": "Web URL of the channel",
                },
                {
                    "field": "channel_email",
                    "type": "string",
                    "helper_text": "Email address of the channel",
                },
                {
                    "field": "channel_type",
                    "type": "string",
                    "helper_text": "Type of the channel",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "get_channel",
            "task_name": "tasks.teams.get_channel",
            "description": "Get details of a specific channel in a Microsoft Teams team",
            "label": "Get Channel",
            "variant": "common_integration_nodes",
            "required": ["team_id", "channel_id"],
            "inputs_sort_order": ["team_id", "channel_id"],
        },
        "list_channels": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "helper_text": "Select the team to list channels from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel_type",
                    "type": "string",
                    "value": "",
                    "label": "Channel Type",
                    "helper_text": "Filter by channel type",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "All Types", "value": ""},
                            {"label": "Standard", "value": "standard"},
                            {"label": "Private", "value": "private"},
                            {"label": "Shared", "value": "shared"},
                        ],
                    },
                },
                {
                    "field": "select_fields",
                    "type": "string",
                    "value": "",
                    "label": "Select Fields",
                    "helper_text": "Comma-separated list of fields to return. Leave empty for all fields",
                    "placeholder": "id,displayName,description",
                },
            ],
            "outputs": [
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of channels found",
                },
                {
                    "field": "channel_names",
                    "type": "vec<string>",
                    "helper_text": "List of channel names",
                },
                {
                    "field": "channel_ids",
                    "type": "vec<string>",
                    "helper_text": "List of channel IDs",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "list_channels",
            "task_name": "tasks.teams.list_channels",
            "description": "List all channels in a Microsoft Teams team",
            "label": "List Channels",
            "variant": "common_integration_nodes",
            "required": ["team_id"],
            "inputs_sort_order": ["team_id", "channel_type", "select_fields"],
        },
        "update_channel": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "helper_text": "Select the team containing the channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel_id",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "helper_text": "Select the channel to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "value": "",
                    "label": "New Channel Name",
                    "placeholder": "Updated channel name",
                    "helper_text": "New name for the channel",
                },
                {
                    "field": "channel_description",
                    "type": "string",
                    "value": "",
                    "label": "New Description",
                    "placeholder": "Updated description",
                    "helper_text": "New description for the channel",
                },
            ],
            "outputs": [
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "ID of the updated channel",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the channel was updated successfully",
                },
            ],
            "name": "update_channel",
            "task_name": "tasks.teams.update_channel",
            "description": "Update a channel in a Microsoft Teams team",
            "label": "Update Channel",
            "variant": "common_integration_nodes",
            "required": ["team_id", "channel_id"],
            "inputs_sort_order": [
                "team_id",
                "channel_id",
                "channel_name",
                "channel_description",
            ],
        },
        "send_message": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "helper_text": "Select the team containing the channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel_id",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "helper_text": "Select the channel to post message to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "message_content",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message content to post",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "value": "text",
                    "label": "Content Type",
                    "helper_text": "Type of message content",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                },
                {
                    "field": "reply_to_message_id",
                    "type": "string",
                    "value": "",
                    "label": "Reply To Message ID",
                    "placeholder": "Optional reply message ID",
                    "helper_text": "ID of message to reply to (optional)",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the created message",
                },
                {
                    "field": "message_type",
                    "type": "string",
                    "helper_text": "Type of the message",
                },
                {
                    "field": "message_content",
                    "type": "string",
                    "helper_text": "Content of the message",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "Content type of the message",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "web_url",
                    "type": "string",
                    "helper_text": "Web URL of the message",
                },
                {
                    "field": "from_user",
                    "type": "string",
                    "helper_text": "Display name of the message sender",
                },
                {
                    "field": "from_user_email",
                    "type": "string",
                    "helper_text": "Email of the message sender",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "send_message",
            "task_name": "tasks.teams.create_channel_message",
            "description": "Post a new message to a specific Teams channel",
            "label": "Create Channel Message",
            "variant": "common_integration_nodes",
            "required": ["team_id", "channel_id", "message_content"],
            "inputs_sort_order": [
                "team_id",
                "channel_id",
                "message_content",
                "content_type",
                "reply_to_message_id",
            ],
        },
        "list_channel_messages": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team",
                    "helper_text": "Select the team containing the channel",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "channel_id",
                    "type": "string",
                    "value": "",
                    "label": "Channel",
                    "helper_text": "Select the channel to list messages from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=channel&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Maximum number of messages to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of messages found",
                },
                {
                    "field": "message_ids",
                    "type": "vec<string>",
                    "helper_text": "List of message IDs",
                },
                {
                    "field": "message_summaries",
                    "type": "vec<string>",
                    "helper_text": "List of message summaries",
                },
                {
                    "field": "has_next_page",
                    "type": "bool",
                    "helper_text": "Whether there are more messages available",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "list_channel_messages",
            "task_name": "tasks.teams.list_channel_messages",
            "description": "List all messages in a specific Teams channel",
            "label": "List Channel Messages",
            "variant": "common_integration_nodes",
            "required": ["team_id", "channel_id", "limit"],
            "inputs_sort_order": ["team_id", "channel_id", "limit"],
        },
        "create_chat_message": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "19:meeting_...",
                    "helper_text": "Select the chat to send message to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=chat&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "message_content",
                    "type": "string",
                    "value": "",
                    "label": "Message",
                    "placeholder": "Hello World!",
                    "helper_text": "The message content to send",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "value": "text",
                    "label": "Content Type",
                    "helper_text": "Type of message content",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text"},
                            {"label": "HTML", "value": "html"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the created message",
                },
                {
                    "field": "message_type",
                    "type": "string",
                    "helper_text": "Type of the message",
                },
                {
                    "field": "message_content",
                    "type": "string",
                    "helper_text": "Content of the message",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "Content type of the message",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "web_url",
                    "type": "string",
                    "helper_text": "Web URL of the message",
                },
                {
                    "field": "from_user",
                    "type": "string",
                    "helper_text": "Display name of the message sender",
                },
                {
                    "field": "from_user_email",
                    "type": "string",
                    "helper_text": "Email of the message sender",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "create_chat_message",
            "task_name": "tasks.teams.create_chat_message",
            "description": "Send a new message to a specific Teams chat",
            "label": "Create Chat Message",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "message_content"],
            "inputs_sort_order": ["chat_id", "message_content", "content_type"],
        },
        "get_chat_message": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "19:meeting_...",
                    "helper_text": "Select the chat containing the message",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=chat&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "label": "Message ID",
                    "placeholder": "1234567890",
                    "helper_text": "ID of the message to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the message",
                },
                {
                    "field": "message_type",
                    "type": "string",
                    "helper_text": "Type of the message",
                },
                {
                    "field": "message_content",
                    "type": "string",
                    "helper_text": "Content of the message",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "Content type of the message",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "last_modified_at",
                    "type": "timestamp",
                    "helper_text": "Last modification timestamp",
                },
                {
                    "field": "web_url",
                    "type": "string",
                    "helper_text": "Web URL of the message",
                },
                {
                    "field": "from_user",
                    "type": "string",
                    "helper_text": "Display name of the message sender",
                },
                {
                    "field": "from_user_email",
                    "type": "string",
                    "helper_text": "Email of the message sender",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "get_chat_message",
            "task_name": "tasks.teams.get_chat_message",
            "description": "Get details of a specific message in a Teams chat",
            "label": "Get Chat Message",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "message_id"],
            "inputs_sort_order": ["chat_id", "message_id"],
        },
        "list_chat_messages": {
            "inputs": [
                {
                    "field": "chat_id",
                    "type": "string",
                    "value": "",
                    "label": "Chat ID",
                    "placeholder": "19:meeting_...",
                    "helper_text": "Select the chat to list messages from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=chat&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Maximum number of messages to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of messages found",
                },
                {
                    "field": "message_ids",
                    "type": "vec<string>",
                    "helper_text": "List of message IDs",
                },
                {
                    "field": "message_summaries",
                    "type": "vec<string>",
                    "helper_text": "List of message summaries",
                },
                {
                    "field": "has_next_page",
                    "type": "bool",
                    "helper_text": "Whether there are more messages available",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "list_chat_messages",
            "task_name": "tasks.teams.list_chat_messages",
            "description": "List all messages in a specific Teams chat",
            "label": "List Chat Messages",
            "variant": "common_integration_nodes",
            "required": ["chat_id", "limit"],
            "inputs_sort_order": ["chat_id", "limit"],
        },
        "create_task": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team ID",
                    "placeholder": "team123",
                    "helper_text": "Select the team to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "plan_id",
                    "type": "string",
                    "value": "",
                    "label": "Plan ID",
                    "placeholder": "plan123",
                    "helper_text": "Select the planner plan to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=plan&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_id",
                    "type": "string",
                    "value": "",
                    "label": "Bucket ID",
                    "placeholder": "bucket123",
                    "helper_text": "Select the bucket to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&plan_id={inputs.plan_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_title",
                    "type": "string",
                    "value": "",
                    "label": "Task Title",
                    "placeholder": "Complete project",
                    "helper_text": "Title of the task",
                },
                {
                    "field": "due_date",
                    "type": "string",
                    "value": "",
                    "label": "Due Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Due date for the task (YYYY-MM-DD format)",
                },
                {
                    "field": "percent_complete",
                    "type": "int32",
                    "value": 0,
                    "label": "Percent Complete",
                    "helper_text": "Completion percentage (0-100)",
                },
                {
                    "field": "assigned_to",
                    "type": "string",
                    "value": "",
                    "label": "Assigned To",
                    "placeholder": "user123",
                    "helper_text": "User ID to assign the task to",
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the created task",
                },
                {
                    "field": "task_title",
                    "type": "string",
                    "helper_text": "Title of the created task",
                },
                {
                    "field": "plan_id",
                    "type": "string",
                    "helper_text": "Plan ID of the task",
                },
                {
                    "field": "bucket_id",
                    "type": "string",
                    "helper_text": "Bucket ID of the task",
                },
                {
                    "field": "percent_complete",
                    "type": "int32",
                    "helper_text": "Completion percentage",
                },
                {
                    "field": "due_date",
                    "type": "timestamp",
                    "helper_text": "Due date of the task",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "has_description",
                    "type": "bool",
                    "helper_text": "Whether the task has a description",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "create_task",
            "task_name": "tasks.teams.create_task",
            "description": "Create a new task in Microsoft Planner",
            "label": "Create Task",
            "variant": "common_integration_nodes",
            "required": ["team_id", "plan_id", "bucket_id", "task_title"],
            "inputs_sort_order": [
                "team_id",
                "plan_id",
                "bucket_id",
                "task_title",
                "due_date",
                "percent_complete",
                "assigned_to",
            ],
        },
        "delete_task": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team ID",
                    "placeholder": "team123",
                    "helper_text": "Select the team to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "plan_id",
                    "type": "string",
                    "value": "",
                    "label": "Plan ID",
                    "placeholder": "plan123",
                    "helper_text": "Select the planner plan to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=plan&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_id",
                    "type": "string",
                    "value": "",
                    "label": "Bucket ID",
                    "placeholder": "bucket123",
                    "helper_text": "Select the bucket to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&plan_id={inputs.plan_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "label": "Task ID",
                    "placeholder": "task123",
                    "helper_text": "Select the task to delete",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&plan_id={inputs.plan_id}&bucket_id={inputs.bucket_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was deleted successfully",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the deleted task",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Confirmation message",
                },
            ],
            "name": "delete_task",
            "task_name": "tasks.teams.delete_task",
            "description": "Delete a task from Microsoft Planner",
            "label": "Delete Task",
            "variant": "common_integration_nodes",
            "required": ["team_id", "plan_id", "bucket_id", "task_id"],
            "inputs_sort_order": ["team_id", "plan_id", "bucket_id", "task_id"],
        },
        "get_task": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team ID",
                    "placeholder": "team123",
                    "helper_text": "Select the team to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "plan_id",
                    "type": "string",
                    "value": "",
                    "label": "Plan ID",
                    "placeholder": "plan123",
                    "helper_text": "Select the planner plan to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=plan&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_id",
                    "type": "string",
                    "value": "",
                    "label": "Bucket ID",
                    "placeholder": "bucket123",
                    "helper_text": "Select the bucket to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&plan_id={inputs.plan_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "label": "Task ID",
                    "placeholder": "task123",
                    "helper_text": "Select the task to retrieve",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&plan_id={inputs.plan_id}&bucket_id={inputs.bucket_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {
                    "field": "task_title",
                    "type": "string",
                    "helper_text": "Title of the task",
                },
                {
                    "field": "plan_id",
                    "type": "string",
                    "helper_text": "Plan ID of the task",
                },
                {
                    "field": "bucket_id",
                    "type": "string",
                    "helper_text": "Bucket ID of the task",
                },
                {
                    "field": "percent_complete",
                    "type": "int32",
                    "helper_text": "Completion percentage",
                },
                {
                    "field": "due_date",
                    "type": "timestamp",
                    "helper_text": "Due date of the task",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "completed_at",
                    "type": "timestamp",
                    "helper_text": "Completion timestamp",
                },
                {
                    "field": "has_description",
                    "type": "bool",
                    "helper_text": "Whether the task has a description",
                },
                {
                    "field": "conversation_thread_id",
                    "type": "string",
                    "helper_text": "Conversation thread ID",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "get_task",
            "task_name": "tasks.teams.get_task",
            "description": "Get details of a specific task in Microsoft Planner",
            "label": "Get Task",
            "variant": "common_integration_nodes",
            "required": ["team_id", "plan_id", "bucket_id", "task_id"],
            "inputs_sort_order": ["team_id", "plan_id", "bucket_id", "task_id"],
        },
        "list_tasks": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team ID",
                    "placeholder": "team123",
                    "helper_text": "Select the team to list tasks from (optional - leave blank for user's tasks)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "plan_id",
                    "type": "string",
                    "value": "",
                    "label": "Plan ID",
                    "placeholder": "plan123",
                    "helper_text": "Select the plan to list tasks from (optional - leave blank for user's tasks)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=plan&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Maximum number of tasks to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of tasks found",
                },
                {
                    "field": "task_ids",
                    "type": "vec<string>",
                    "helper_text": "List of task IDs",
                },
                {
                    "field": "task_titles",
                    "type": "vec<string>",
                    "helper_text": "List of task titles",
                },
                {
                    "field": "has_next_page",
                    "type": "bool",
                    "helper_text": "Whether there are more tasks available",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Teams API",
                },
            ],
            "name": "list_tasks",
            "task_name": "tasks.teams.list_tasks",
            "description": "List tasks from Microsoft Planner",
            "label": "List Tasks",
            "variant": "common_integration_nodes",
            "required": ["limit"],
            "inputs_sort_order": ["team_id", "plan_id", "limit"],
        },
        "update_task": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "label": "Team ID",
                    "placeholder": "team123",
                    "helper_text": "Select the team to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "plan_id",
                    "type": "string",
                    "value": "",
                    "label": "Plan ID",
                    "placeholder": "plan123",
                    "helper_text": "Select the planner plan to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=plan&team_id={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_id",
                    "type": "string",
                    "value": "",
                    "label": "Bucket ID",
                    "placeholder": "bucket123",
                    "helper_text": "Select the bucket to create the task in",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&plan_id={inputs.plan_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "label": "Task ID",
                    "placeholder": "task123",
                    "helper_text": "Select the task to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task&plan_id={inputs.plan_id}&bucket_id={inputs.bucket_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_title",
                    "type": "string",
                    "value": "",
                    "label": "New Task Title",
                    "placeholder": "Updated task title",
                    "helper_text": "New title for the task",
                },
                {
                    "field": "due_date",
                    "type": "string",
                    "value": "",
                    "label": "New Due Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "New due date for the task (YYYY-MM-DD format)",
                },
                {
                    "field": "percent_complete",
                    "type": "int32",
                    "value": 0,
                    "label": "Percent Complete",
                    "helper_text": "New completion percentage (0-100)",
                },
                {
                    "field": "bucket_id",
                    "type": "string",
                    "value": "",
                    "label": "New Bucket ID",
                    "placeholder": "bucket123",
                    "helper_text": "New bucket ID to move the task to",
                },
                {
                    "field": "assigned_to",
                    "type": "string",
                    "value": "",
                    "label": "Assigned To",
                    "placeholder": "user123",
                    "helper_text": "User ID to assign the task to",
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the updated task",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Message indicating the result of the update",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was updated successfully",
                },
            ],
            "name": "update_task",
            "task_name": "tasks.teams.update_task",
            "description": "Update a task in Microsoft Planner",
            "label": "Update Task",
            "variant": "common_integration_nodes",
            "required": ["team_id", "plan_id", "bucket_id", "task_id"],
            "inputs_sort_order": [
                "team_id",
                "plan_id",
                "bucket_id",
                "task_id",
                "task_title",
                "due_date",
                "percent_complete",
                "bucket_id",
                "assigned_to",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        assigned_to: str = "",
        bucket_id: str = "",
        channel_description: str = "",
        channel_id: str = "",
        channel_name: str = "",
        channel_type: str = "standard",
        chat_id: str = "",
        content_type: str = "text",
        due_date: str = "",
        limit: int = 10,
        message_content: str = "",
        message_id: str = "",
        percent_complete: int = 0,
        plan_id: str = "",
        reply_to_message_id: str = "",
        select_fields: str = "",
        task_id: str = "",
        task_title: str = "",
        team_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_teams",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team_id is not None:
            self.inputs["team_id"] = team_id
        if channel_name is not None:
            self.inputs["channel_name"] = channel_name
        if channel_description is not None:
            self.inputs["channel_description"] = channel_description
        if channel_type is not None:
            self.inputs["channel_type"] = channel_type
        if channel_id is not None:
            self.inputs["channel_id"] = channel_id
        if select_fields is not None:
            self.inputs["select_fields"] = select_fields
        if message_content is not None:
            self.inputs["message_content"] = message_content
        if content_type is not None:
            self.inputs["content_type"] = content_type
        if reply_to_message_id is not None:
            self.inputs["reply_to_message_id"] = reply_to_message_id
        if limit is not None:
            self.inputs["limit"] = limit
        if chat_id is not None:
            self.inputs["chat_id"] = chat_id
        if message_id is not None:
            self.inputs["message_id"] = message_id
        if plan_id is not None:
            self.inputs["plan_id"] = plan_id
        if bucket_id is not None:
            self.inputs["bucket_id"] = bucket_id
        if task_title is not None:
            self.inputs["task_title"] = task_title
        if due_date is not None:
            self.inputs["due_date"] = due_date
        if percent_complete is not None:
            self.inputs["percent_complete"] = percent_complete
        if assigned_to is not None:
            self.inputs["assigned_to"] = assigned_to
        if task_id is not None:
            self.inputs["task_id"] = task_id
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationTeamsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_x")
class IntegrationXNode(Node):
    """
    X

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_post
        text: The text of the post
    ### create_thread
        text: The text of the post

    ## Outputs
    ### create_post
        post_url: URL of the created post
    ### create_thread
        post_url: URL of the created thread
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<X>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_post": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Hello World!",
                    "helper_text": "The text of the post",
                }
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created post",
                }
            ],
            "name": "create_post",
            "task_name": "tasks.x.create_post",
            "description": "Create a new post on X",
            "label": "Create Post",
        },
        "create_thread": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": '["Post1", "Post2", "Post3"]',
                    "helper_text": "A list of text to be posted as a thread",
                }
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created thread",
                }
            ],
            "name": "create_thread",
            "task_name": "tasks.x.create_thread",
            "description": "Create a new thread on X",
            "label": "Create Thread",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        text: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_x",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if text is not None:
            self.inputs["text"] = text
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationXNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_gohighlevel")
class IntegrationGohighlevelNode(Node):
    """
    GoHighLevel

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_opportunity
        contact_name: Name of the existing contact to link to the opportunity. One contact can only be linked to one opportunity.
        name: Name of the opportunity
        pipeline_name: Name of the existing pipeline to link to the opportunity
        status: Status of the opportunity (must be one of: 'open', 'won', 'lost', 'abandoned')
        value: Money value of the opportunity
    ### create_contact
        email: Email address of the contact
        first_name: First name of the contact
        last_name: Last name of the contact
        phone: Phone number of the contact

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<GoHighLevel>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_contact": {
            "inputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "First name of the contact",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Last name of the contact",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@doe.com",
                    "helper_text": "Email address of the contact",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1 888-888-8888",
                    "helper_text": "Phone number of the contact",
                },
            ],
            "outputs": [],
            "name": "create_contact",
            "task_name": "tasks.gohighlevel.create_contact",
            "description": "Create a new contact on GoHighLevel",
            "label": "Create Contact",
        },
        "create_opportunity": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "First op",
                    "helper_text": "Name of the opportunity",
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "",
                    "label": "Status",
                    "placeholder": "open",
                    "helper_text": "Status of the opportunity (must be one of: 'open', 'won', 'lost', 'abandoned')",
                },
                {
                    "field": "value",
                    "type": "string",
                    "value": "",
                    "label": "Value",
                    "placeholder": "500",
                    "helper_text": "Money value of the opportunity",
                },
                {
                    "field": "pipeline_name",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline Name",
                    "placeholder": "onboarding",
                    "helper_text": "Name of the existing pipeline to link to the opportunity",
                },
                {
                    "field": "contact_name",
                    "type": "string",
                    "value": "",
                    "label": "Contact Name",
                    "placeholder": "John",
                    "helper_text": "Name of the existing contact to link to the opportunity. One contact can only be linked to one opportunity.",
                },
            ],
            "outputs": [],
            "name": "create_opportunity",
            "task_name": "tasks.gohighlevel.create_opportunity",
            "description": "Create a new opportunity on GoHighLevel",
            "label": "Create Opportunity",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        contact_name: str = "",
        email: str = "",
        first_name: str = "",
        last_name: str = "",
        name: str = "",
        phone: str = "",
        pipeline_name: str = "",
        status: str = "",
        value: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_gohighlevel",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if email is not None:
            self.inputs["email"] = email
        if phone is not None:
            self.inputs["phone"] = phone
        if name is not None:
            self.inputs["name"] = name
        if status is not None:
            self.inputs["status"] = status
        if value is not None:
            self.inputs["value"] = value
        if pipeline_name is not None:
            self.inputs["pipeline_name"] = pipeline_name
        if contact_name is not None:
            self.inputs["contact_name"] = contact_name
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGohighlevelNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_peopledatalabs")
class IntegrationPeopledatalabsNode(Node):
    """
    PeopleDataLabs

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### enrich_person
        company: The name, website, or social URL of a company where the person has worked
        email: Email address of the person
        first_name: First name of the person
        last_name: Last name of the person
        location: The location where a person lives (can be address, city, country, etc.)
        profile_url: Social media profile URLs for the contact (LinkedIn, Twitter, Facebook, etc.)
    ### search_companies
        company_size_ranges: Comma-separated list of company size ranges. The value should be one of the ones mentioned here: https://docs.peopledatalabs.com/docs/company-sizes
        country: Name of the country
        founded_year_range: A range representing the founding year of the company
        industries: Comma-separated list of industries
        number_of_results: Number of results to return
        tags: Comma-separated tags associated with the company
    ### search_people
        country: Name of the country
        job_company_names: Comma-separated list of company names to search within
        job_titles: Comma-separated list of job titles
        number_of_results: Number of results to return
        skills: Comma-separated list of skills to search for
    ### search_people_query
        es_query: A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping
        number_of_results: Number of results to return
        sql: A valid SQL query
    ### search_companies_query
        es_query: A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping
        number_of_results: Number of results to return
        sql: A valid SQL query
    ### enrich_company
        name: The name of the company
        profile: Company social media profile URL
        website: Company website URL

    ## Outputs
    ### enrich_person
        output: Enriched person data including additional information found
    ### search_people
        output: List of matching people profiles
    ### search_people_query
        output: List of matching people profiles
    ### enrich_company
        output: Enriched company data including additional information found
    ### search_companies
        output: List of matching company profiles
    ### search_companies_query
        output: List of matching company profiles
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<PeopleDataLabs>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "enrich_person": {
            "inputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "First name of the person",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Last name of the person",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "San Francisco, CA",
                    "helper_text": "The location where a person lives (can be address, city, country, etc.)",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@doe.com",
                    "helper_text": "Email address of the person",
                },
                {
                    "field": "company",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "The name, website, or social URL of a company where the person has worked",
                },
                {
                    "field": "profile_url",
                    "type": "string",
                    "value": "",
                    "label": "Profile URL",
                    "placeholder": "linkedin.com/in/johnsmith",
                    "helper_text": "Social media profile URLs for the contact (LinkedIn, Twitter, Facebook, etc.)",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Enriched person data including additional information found",
                }
            ],
            "name": "enrich_person",
            "task_name": "tasks.peopledatalabs.enrich_person",
            "description": "Enrich Person",
            "label": "Enrich Person",
        },
        "search_people": {
            "inputs": [
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "US",
                    "helper_text": "Name of the country",
                },
                {
                    "field": "job_titles",
                    "type": "string",
                    "value": "",
                    "label": "Job Titles",
                    "placeholder": "Software Engineer, Product Manager, CTO",
                    "helper_text": "Comma-separated list of job titles",
                },
                {
                    "field": "job_company_names",
                    "type": "string",
                    "value": "",
                    "label": "Job Company Names",
                    "placeholder": "Google, Microsoft, Apple",
                    "helper_text": "Comma-separated list of company names to search within",
                },
                {
                    "field": "skills",
                    "type": "string",
                    "value": "",
                    "label": "Skills",
                    "placeholder": "Python, Machine Learning, Leadership",
                    "helper_text": "Comma-separated list of skills to search for",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching people profiles",
                }
            ],
            "name": "search_people",
            "task_name": "tasks.peopledatalabs.search_people",
            "description": "Search People",
            "label": "Search People",
        },
        "search_people_query": {
            "inputs": [
                {
                    "field": "es_query",
                    "type": "string",
                    "value": "",
                    "label": "ES Query",
                    "placeholder": '{"query": {"match_all": {}}}',
                    "helper_text": "A valid Elasticsearch query. Available Fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping",
                },
                {
                    "field": "sql",
                    "type": "string",
                    "value": "",
                    "label": "SQL",
                    "placeholder": '{"query": {"match": {"job_title": "Software Engineer"}}}',
                    "helper_text": "A valid SQL query",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching people profiles",
                }
            ],
            "name": "search_people_query",
            "task_name": "tasks.peopledatalabs.search_people_query",
            "description": "Search People (query)",
            "label": "Search People (query)",
        },
        "enrich_company": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "The name of the company",
                },
                {
                    "field": "profile",
                    "type": "string",
                    "value": "",
                    "label": "Profile",
                    "placeholder": "linkedin.com/company/acme-corp",
                    "helper_text": "Company social media profile URL",
                },
                {
                    "field": "website",
                    "type": "string",
                    "value": "",
                    "label": "Website",
                    "placeholder": "www.acmecorp.com",
                    "helper_text": "Company website URL",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Enriched company data including additional information found",
                }
            ],
            "name": "enrich_company",
            "task_name": "tasks.peopledatalabs.enrich_company",
            "description": "Enrich Company",
            "label": "Enrich Company",
        },
        "search_companies": {
            "inputs": [
                {
                    "field": "tags",
                    "type": "string",
                    "value": "",
                    "label": "Tags",
                    "placeholder": "B2B, SaaS, Fintech",
                    "helper_text": "Comma-separated tags associated with the company",
                },
                {
                    "field": "industries",
                    "type": "string",
                    "value": "",
                    "label": "Industries",
                    "placeholder": "Technology, Healthcare, Finance",
                    "helper_text": "Comma-separated list of industries",
                },
                {
                    "field": "company_size_ranges",
                    "type": "string",
                    "value": "",
                    "label": "Company Size Ranges",
                    "placeholder": "1-10, 11-50, 51-200, 201-500, 501-1000, 1000+",
                    "helper_text": "Comma-separated list of company size ranges. The value should be one of the ones mentioned here: https://docs.peopledatalabs.com/docs/company-sizes",
                },
                {
                    "field": "founded_year_range",
                    "type": "string",
                    "value": "",
                    "label": "Founded Year Range",
                    "placeholder": "2015-2020",
                    "helper_text": "A range representing the founding year of the company",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "US",
                    "helper_text": "Name of the country",
                },
                {
                    "field": "number_of_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching company profiles",
                }
            ],
            "name": "search_companies",
            "task_name": "tasks.peopledatalabs.search_companies",
            "description": "Search Companies",
            "label": "Search Companies",
        },
        "search_companies_query": {
            "inputs": [
                {
                    "field": "es_query",
                    "type": "string",
                    "value": "",
                    "label": "Elastic Search Query",
                    "placeholder": '{"query": {"match_all": {}}}',
                    "helper_text": "A valid Elasticsearch query. Available fields: https://docs.peopledatalabs.com/docs/elasticsearch-mapping-company",
                },
                {
                    "field": "sql",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT * FROM companies WHERE industry = 'Technology'",
                    "helper_text": "A valid SQL Query. Available fields: https://docs.peopledatalabs.com/docs/company-schema",
                },
                {
                    "field": "number_of_results",
                    "type": "int32",
                    "value": 10,
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Number of results to display",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of matching company profiles",
                }
            ],
            "name": "search_companies_query",
            "task_name": "tasks.peopledatalabs.search_companies_query",
            "description": "Search Companies (query)",
            "label": "Search Companies (query)",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        company: str = "",
        company_size_ranges: str = "",
        country: str = "",
        email: str = "",
        es_query: str = "",
        first_name: str = "",
        founded_year_range: str = "",
        industries: str = "",
        job_company_names: str = "",
        job_titles: str = "",
        last_name: str = "",
        location: str = "",
        name: str = "",
        number_of_results: str = "",
        profile: str = "",
        profile_url: str = "",
        skills: str = "",
        sql: str = "",
        tags: str = "",
        website: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_peopledatalabs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if location is not None:
            self.inputs["location"] = location
        if email is not None:
            self.inputs["email"] = email
        if company is not None:
            self.inputs["company"] = company
        if profile_url is not None:
            self.inputs["profile_url"] = profile_url
        if country is not None:
            self.inputs["country"] = country
        if job_titles is not None:
            self.inputs["job_titles"] = job_titles
        if job_company_names is not None:
            self.inputs["job_company_names"] = job_company_names
        if skills is not None:
            self.inputs["skills"] = skills
        if number_of_results is not None:
            self.inputs["number_of_results"] = number_of_results
        if es_query is not None:
            self.inputs["es_query"] = es_query
        if sql is not None:
            self.inputs["sql"] = sql
        if name is not None:
            self.inputs["name"] = name
        if profile is not None:
            self.inputs["profile"] = profile
        if website is not None:
            self.inputs["website"] = website
        if tags is not None:
            self.inputs["tags"] = tags
        if industries is not None:
            self.inputs["industries"] = industries
        if company_size_ranges is not None:
            self.inputs["company_size_ranges"] = company_size_ranges
        if founded_year_range is not None:
            self.inputs["founded_year_range"] = founded_year_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPeopledatalabsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_dropbox")
class IntegrationDropboxNode(Node):
    """
    Dropbox

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### delete_file
        delete_file_id: Select file to delete
    ### copy_file
        destination_folder_id: Select the destination folder
        new_file_name: Name for the copied file
        source_file_id: Select the file to copy
    ### move_file
        destination_folder_id: Select the destination folder
        new_file_name: Name for the copied file
        source_file_id: Select the file to copy
    ### copy_folder
        destination_folder_id: Select the destination folder
        new_folder_name: Name for the copied folder
        source_folder_id: Select folder to copy
    ### move_folder
        destination_folder_id: Select the destination folder
        new_folder_name: Name for the copied folder
        source_folder_id: Select folder to copy
    ### add_file
        file: Content of the file to upload
        folder_id: Select the folder where you want to post the file to
    ### search
        file_types: Filter by file types (comma-separated)
        search_folder_id: ID of folder to search within (optional)
        search_limit: Maximum number of search results
        search_query: Query to search for files and folders
    ### get_files
        folder_id: Select the folder where you want to post the file to
        include_deleted: Include deleted files
        include_subfolders: Include files from subfolders
        limit: Number of files to retrieve
    ### read_folder
        folder_id: Select the folder where you want to post the file to
        include_deleted: Include deleted files
        limit: Number of files to retrieve
        recursive: Whether to list folder contents recursively
    ### delete_folder
        folder_id: Select the folder where you want to post the file to
    ### create_folder
        folder_name: Name of the folder to create
        parent_folder_id: Select parent folder
    ### read_file
        read_file_id: Select file to read

    ## Outputs
    ### delete_file
        deleted_file_id: ID of the deleted file
        raw_data: Raw data of the response
        success: Whether the deletion was successful
    ### read_file
        file: File object
        file_name: Name of the file
        file_path: Path of the file
        file_size: Size of the file
        mime_type: MIME type of the file
        modified_time: Last modified date of the file
        raw_data: Raw data of the response
    ### add_file
        file_id: ID of the uploaded file
        file_name: Name of the uploaded file
        file_path: Path of the uploaded file
        modified_time: Last modified date of the file
        raw_data: Raw data of the response
    ### get_files
        file_ids: List of file IDs
        file_names: List of file names
        file_paths: List of file paths
        file_sizes: List of file sizes
        files: List of files
        has_more: Whether there are more files available
        mime_types: List of file MIME types
        modified_times: List of file modified times
        raw_data: Raw data of the response
        total_count: Total number of files
    ### create_folder
        folder_id: ID of the created folder
        folder_name: Name of the created folder
        folder_path: Path of the created folder
        success: Whether the creation was successful
    ### delete_folder
        folder_id: ID of the deleted folder
        folder_name: Name of the deleted folder
        folder_path: Path of the deleted folder
        raw_data: Raw data of the response
        success: Whether the deletion was successful
    ### move_folder
        folder_id: ID of the moved folder
        folder_name: Name of the moved folder
        folder_path: Path of the moved folder
        raw_data: Raw data of the response
    ### read_folder
        has_more: Whether there are more items available
        item_ids: List of item IDs
        item_names: List of item names
        item_paths: List of item paths
        item_sizes: List of item sizes
        item_types: List of item types (file/folder)
        raw_data: Raw response from Dropbox API
        total_count: Total number of items returned
    ### move_file
        moved_file_id: ID of the moved file
        moved_file_name: Name of the moved file
        moved_file_path: Path of the moved file
        raw_data: Raw data of the response
        success: Whether the move was successful
    ### copy_file
        new_file_id: ID of the copied file
        new_file_name: Name of the copied file
        new_file_path: Path of the copied file
        raw_data: Raw data of the response
        success: Whether the copy was successful
    ### copy_folder
        new_folder_id: ID of the copied folder
        new_folder_name: Name of the copied folder
        new_folder_path: Path of the copied folder
        success: Whether the copy was successful
    ### search
        raw_data: Raw data of the response
        result_highlights: List of highlights from search
        result_ids: List of file/folder IDs from search
        result_names: List of file/folder names from search
        result_paths: List of file/folder paths from search
        result_types: List of result types (file/folder)
        total_results: Total number of search results
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Dropbox>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "add_file": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder where you want to post the file to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 3,
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "helper_text": "Content of the file to upload",
                    "label": "File",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the uploaded file",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the uploaded file",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the uploaded file",
                },
                {
                    "field": "modified_time",
                    "type": "timestamp",
                    "helper_text": "Last modified date of the file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "add_file",
            "task_name": "tasks.dropbox.upload_file",
            "description": "Add a file to Dropbox",
            "label": "Add File",
            "inputs_sort_order": ["integration", "action", "folder_id", "file"],
        },
        "read_file": {
            "inputs": [
                {
                    "field": "read_file_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select file to read",
                    "label": "File",
                    "placeholder": "file_123",
                    "order": 3,
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {"field": "file", "type": "file", "helper_text": "File object"},
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the file",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Path of the file",
                },
                {
                    "field": "mime_type",
                    "type": "string",
                    "helper_text": "MIME type of the file",
                },
                {
                    "field": "modified_time",
                    "type": "timestamp",
                    "helper_text": "Last modified date of the file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "read_file",
            "task_name": "tasks.dropbox.read_file",
            "description": "Read a file from Dropbox",
            "label": "Read File",
            "inputs_sort_order": ["integration", "action", "read_file_id"],
        },
        "delete_file": {
            "inputs": [
                {
                    "field": "delete_file_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select file to delete",
                    "label": "File",
                    "placeholder": "file_123",
                    "order": 3,
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "deleted_file_id",
                    "type": "string",
                    "helper_text": "ID of the deleted file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "delete_file",
            "task_name": "tasks.dropbox.delete_file",
            "description": "Delete a file from Dropbox",
            "label": "Delete File",
            "inputs_sort_order": ["integration", "action", "delete_file_id"],
        },
        "copy_file": {
            "inputs": [
                {
                    "field": "source_file_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the file to copy",
                    "label": "Source File",
                    "placeholder": "file_123",
                    "order": 3,
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "destination_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select the destination folder",
                    "label": "Destination Folder",
                    "placeholder": "folder_456",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 4,
                },
                {
                    "field": "new_file_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name for the copied file",
                    "label": "New File Name",
                    "placeholder": "copy_of_document.pdf",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "new_file_id",
                    "type": "string",
                    "helper_text": "ID of the copied file",
                },
                {
                    "field": "new_file_name",
                    "type": "string",
                    "helper_text": "Name of the copied file",
                },
                {
                    "field": "new_file_path",
                    "type": "string",
                    "helper_text": "Path of the copied file",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the copy was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "copy_file",
            "task_name": "tasks.dropbox.copy_file",
            "description": "Copy a file in Dropbox",
            "label": "Copy File",
            "inputs_sort_order": [
                "integration",
                "action",
                "source_file_id",
                "destination_folder_id",
                "new_file_name",
            ],
        },
        "move_file": {
            "inputs": [
                {
                    "field": "source_file_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select file to move",
                    "label": "Source File",
                    "placeholder": "file_123",
                    "order": 3,
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "destination_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select the destination folder",
                    "label": "Destination Folder",
                    "placeholder": "folder_456",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 4,
                },
                {
                    "field": "new_file_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the moved file (optional)",
                    "label": "New File Name",
                    "placeholder": "moved_document.pdf",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "moved_file_id",
                    "type": "string",
                    "helper_text": "ID of the moved file",
                },
                {
                    "field": "moved_file_name",
                    "type": "string",
                    "helper_text": "Name of the moved file",
                },
                {
                    "field": "moved_file_path",
                    "type": "string",
                    "helper_text": "Path of the moved file",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the move was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "move_file",
            "task_name": "tasks.dropbox.move_file",
            "description": "Move a file in Dropbox",
            "label": "Move File",
            "inputs_sort_order": [
                "integration",
                "action",
                "source_file_id",
                "destination_folder_id",
                "new_file_name",
            ],
        },
        "get_files": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select folder to list files from",
                    "label": "Folder",
                    "placeholder": "folder_123",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 3,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Number of files to retrieve",
                    "label": "Limit",
                    "order": 4,
                },
                {
                    "field": "include_subfolders",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include files from subfolders",
                    "label": "Include Subfolders",
                    "order": 5,
                },
                {
                    "field": "include_deleted",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include deleted files",
                    "label": "Include Deleted",
                    "order": 6,
                },
            ],
            "outputs": [
                {"field": "files", "type": "vec<file>", "helper_text": "List of files"},
                {
                    "field": "file_ids",
                    "type": "vec<string>",
                    "helper_text": "List of file IDs",
                },
                {
                    "field": "file_names",
                    "type": "vec<string>",
                    "helper_text": "List of file names",
                },
                {
                    "field": "file_paths",
                    "type": "vec<string>",
                    "helper_text": "List of file paths",
                },
                {
                    "field": "file_sizes",
                    "type": "vec<string>",
                    "helper_text": "List of file sizes",
                },
                {
                    "field": "modified_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of file modified times",
                },
                {
                    "field": "mime_types",
                    "type": "vec<string>",
                    "helper_text": "List of file MIME types",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of files",
                },
                {
                    "field": "has_more",
                    "type": "bool",
                    "helper_text": "Whether there are more files available",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "get_files",
            "task_name": "tasks.dropbox.get_files",
            "description": "Get a list of files from Dropbox",
            "label": "Get Files",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "limit",
                "include_subfolders",
                "include_deleted",
            ],
        },
        "create_folder": {
            "inputs": [
                {
                    "field": "folder_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the folder to create",
                    "label": "Folder Name",
                    "placeholder": "New Folder",
                    "order": 3,
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select parent folder",
                    "label": "Parent Folder",
                    "placeholder": "folder_123",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the created folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the created folder",
                },
                {
                    "field": "folder_path",
                    "type": "string",
                    "helper_text": "Path of the created folder",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the creation was successful",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "create_folder",
            "task_name": "tasks.dropbox.create_folder",
            "description": "Create a new folder in Dropbox",
            "label": "Create Folder",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_name",
                "parent_folder_id",
            ],
        },
        "read_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select folder to read",
                    "label": "Folder",
                    "placeholder": "folder_123",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 3,
                },
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to list folder contents recursively",
                    "label": "Recursive",
                    "order": 4,
                },
                {
                    "field": "include_deleted",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Whether to include deleted items",
                    "label": "Include Deleted",
                    "order": 5,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of items to return",
                    "label": "Limit",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "item_ids",
                    "type": "vec<string>",
                    "helper_text": "List of item IDs",
                },
                {
                    "field": "item_names",
                    "type": "vec<string>",
                    "helper_text": "List of item names",
                },
                {
                    "field": "item_types",
                    "type": "vec<string>",
                    "helper_text": "List of item types (file/folder)",
                },
                {
                    "field": "item_paths",
                    "type": "vec<string>",
                    "helper_text": "List of item paths",
                },
                {
                    "field": "item_sizes",
                    "type": "vec<string>",
                    "helper_text": "List of item sizes",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of items returned",
                },
                {
                    "field": "has_more",
                    "type": "bool",
                    "helper_text": "Whether there are more items available",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Dropbox API",
                },
            ],
            "name": "read_folder",
            "task_name": "tasks.dropbox.read_folder",
            "description": "Read contents of a folder from Dropbox",
            "label": "Read Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "recursive",
                "include_deleted",
                "limit",
            ],
        },
        "delete_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select folder to delete",
                    "label": "Folder",
                    "placeholder": "folder_123",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the deleted folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the deleted folder",
                },
                {
                    "field": "folder_path",
                    "type": "string",
                    "helper_text": "Path of the deleted folder",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "name": "delete_folder",
            "task_name": "tasks.dropbox.delete_folder",
            "description": "Delete a folder from Dropbox",
            "label": "Delete Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "folder_id"],
        },
        "copy_folder": {
            "inputs": [
                {
                    "field": "source_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select folder to copy",
                    "label": "Source Folder",
                    "placeholder": "folder_123",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 3,
                },
                {
                    "field": "destination_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select the destination folder",
                    "label": "Destination Folder",
                    "placeholder": "folder_456",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 4,
                },
                {
                    "field": "new_folder_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name for the copied folder",
                    "label": "New Folder Name",
                    "placeholder": "Copy of Folder",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "new_folder_id",
                    "type": "string",
                    "helper_text": "ID of the copied folder",
                },
                {
                    "field": "new_folder_name",
                    "type": "string",
                    "helper_text": "Name of the copied folder",
                },
                {
                    "field": "new_folder_path",
                    "type": "string",
                    "helper_text": "Path of the copied folder",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the copy was successful",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "copy_folder",
            "task_name": "tasks.dropbox.copy_folder",
            "description": "Copy a folder in Dropbox",
            "label": "Copy Folder",
            "inputs_sort_order": [
                "integration",
                "action",
                "source_folder_id",
                "destination_folder_id",
                "new_folder_name",
            ],
        },
        "move_folder": {
            "inputs": [
                {
                    "field": "source_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select folder to move",
                    "label": "Source Folder",
                    "placeholder": "folder_123",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 3,
                },
                {
                    "field": "destination_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select the destination folder",
                    "label": "Destination Folder",
                    "placeholder": "folder_456",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                    "order": 4,
                },
                {
                    "field": "new_folder_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the moved folder",
                    "label": "New Folder Name",
                    "placeholder": "Moved Folder",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the moved folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the moved folder",
                },
                {
                    "field": "folder_path",
                    "type": "string",
                    "helper_text": "Path of the moved folder",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "variant": "common_integration_file_nodes",
            "name": "move_folder",
            "task_name": "tasks.dropbox.move_folder",
            "description": "Move a folder in Dropbox",
            "label": "Move Folder",
            "inputs_sort_order": [
                "integration",
                "action",
                "source_folder_id",
                "destination_folder_id",
                "new_folder_name",
            ],
        },
        "search": {
            "inputs": [
                {
                    "field": "search_query",
                    "type": "string",
                    "value": "",
                    "helper_text": "Query to search for files and folders",
                    "label": "Search Query",
                    "placeholder": "document.pdf",
                    "order": 3,
                },
                {
                    "field": "search_folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of folder to search within (optional)",
                    "label": "Search Folder",
                    "placeholder": "folder_123",
                    "order": 4,
                },
                {
                    "field": "search_limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of search results",
                    "label": "Search Limit",
                    "order": 5,
                },
                {
                    "field": "file_types",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by file types (comma-separated)",
                    "label": "File Types",
                    "placeholder": "pdf",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "result_ids",
                    "type": "vec<string>",
                    "helper_text": "List of file/folder IDs from search",
                },
                {
                    "field": "result_names",
                    "type": "vec<string>",
                    "helper_text": "List of file/folder names from search",
                },
                {
                    "field": "result_types",
                    "type": "vec<string>",
                    "helper_text": "List of result types (file/folder)",
                },
                {
                    "field": "result_paths",
                    "type": "vec<string>",
                    "helper_text": "List of file/folder paths from search",
                },
                {
                    "field": "result_highlights",
                    "type": "vec<string>",
                    "helper_text": "List of highlights from search",
                },
                {
                    "field": "total_results",
                    "type": "int32",
                    "helper_text": "Total number of search results",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw data of the response",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "search",
            "task_name": "tasks.dropbox.search",
            "description": "Search for files and folders in Dropbox",
            "label": "Search",
            "inputs_sort_order": [
                "integration",
                "action",
                "search_query",
                "search_folder_id",
                "search_limit",
                "file_types",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        delete_file_id: str = "",
        destination_folder_id: str = "",
        file: str = "",
        file_types: str = "",
        folder_id: str = "",
        folder_name: str = "",
        include_deleted: bool = False,
        include_subfolders: bool = False,
        limit: int = 10,
        new_file_name: str = "",
        new_folder_name: str = "",
        parent_folder_id: str = "",
        read_file_id: str = "",
        recursive: bool = False,
        search_folder_id: str = "",
        search_limit: int = 10,
        search_query: str = "",
        source_file_id: str = "",
        source_folder_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_dropbox",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if file is not None:
            self.inputs["file"] = file
        if read_file_id is not None:
            self.inputs["read_file_id"] = read_file_id
        if delete_file_id is not None:
            self.inputs["delete_file_id"] = delete_file_id
        if source_file_id is not None:
            self.inputs["source_file_id"] = source_file_id
        if destination_folder_id is not None:
            self.inputs["destination_folder_id"] = destination_folder_id
        if new_file_name is not None:
            self.inputs["new_file_name"] = new_file_name
        if limit is not None:
            self.inputs["limit"] = limit
        if include_subfolders is not None:
            self.inputs["include_subfolders"] = include_subfolders
        if include_deleted is not None:
            self.inputs["include_deleted"] = include_deleted
        if folder_name is not None:
            self.inputs["folder_name"] = folder_name
        if parent_folder_id is not None:
            self.inputs["parent_folder_id"] = parent_folder_id
        if recursive is not None:
            self.inputs["recursive"] = recursive
        if source_folder_id is not None:
            self.inputs["source_folder_id"] = source_folder_id
        if new_folder_name is not None:
            self.inputs["new_folder_name"] = new_folder_name
        if search_query is not None:
            self.inputs["search_query"] = search_query
        if search_folder_id is not None:
            self.inputs["search_folder_id"] = search_folder_id
        if search_limit is not None:
            self.inputs["search_limit"] = search_limit
        if file_types is not None:
            self.inputs["file_types"] = file_types
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDropboxNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_hubspot")
class IntegrationHubspotNode(Node):
    """
    Hubspot

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'create_company'
        about_us: About the company
        annual_revenue: Annual revenue
        city: City of residence
        company_domain_name: Company's domain name
        company_owner: Owner's user ID
        country_region: Country or region
        create_company_name: Required company name
        description: Company description
        industry: Type of industry
        lead_status: Filter by lead status
        lifecycle: Lifecycle stage
        number_of_employees: Employee count
        phone_number: Main phone number
        website_url: Contact's website
    ### When action = 'create_deal'
        amount: Deal amount
        associated_company: Associated company IDs
        associated_vids: Associated contact IDs
        close_date: Close date
        create_deal_stage: Required deal stage ID
        deal_name: Deal name
        deal_owner: Deal owner ID
        deal_type: Deal type
        description: Company description
        pipeline: Pipeline ID
    ### When action = 'get_deals'
        amount: Deal amount
        close_date: Close date
        created_date: Filter by creation date (YYYY-MM-DD)
        deal_currency_code: Filter by currency code
        deal_name: Deal name
        deal_stage: Filter by deal stage
        deal_type: Deal type
        hs_analytics_source: Filter by original source
        hs_date_entered_closed_lost: Filter by date entered closed lost
        hs_date_entered_closed_won: Filter by date entered closed won
        hs_deal_stage_probability: Filter by deal probability
        hs_forecast_amount: Filter by forecast amount
        hs_is_closed: Filter by closed status
        hs_is_deal_split: Filter by deal split status
        hs_latest_source: Filter by latest source
        hubspot_owner_id: Filter by contact owner ID
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        num_associated_contacts: Filter by number of associated contacts
        num_contacted_notes: Filter by number of contact notes
        pipeline: Pipeline ID
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        use_date: Toggle to use dates
    ### When action = 'get_companies'
        annual_revenue: Annual revenue
        city: City of residence
        country: Country name
        created_date: Filter by creation date (YYYY-MM-DD)
        domain: Search by domain
        founded_year: Filter by founded year
        hs_analytics_source: Filter by original source
        hs_analytics_source_data_1: Filter by source data 1
        hs_analytics_source_data_2: Filter by source data 2
        hubspot_owner_id: Filter by contact owner ID
        industry: Type of industry
        is_public: Filter by public company status
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        lead_status: Filter by lead status
        lifecycle_stage: Filter by lifecycle stage
        name: Search by company name
        number_of_employees: Employee count
        phone: Search by phone number
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        state: Search by state
        type: Filter by company type
        use_date: Toggle to use dates
        web_technologies: Filter by web technologies
        zip: Search by zip code
    ### When action = 'create_contact'
        associated_company_id: ID of associated company
        city: City of residence
        company: Name of the company
        country: Country name
        create_email: Required contact email
        custom_properties: Custom properties to add to the contact
        first_name: Contact's first name
        job_title: Job title of the contact
        last_name: Contact's last name
        mobile_phone_number: Mobile number
        phone_number: Main phone number
        postal_code: Postal or ZIP code
        state_region: State or region
        street_address: Street address
        website_url: Contact's website
    ### When action = 'create_ticket'
        associated_company_ids: Associated companies
        associated_contact_ids: Associated contacts
        category: Ticket category
        close_date: Close date
        create_ticket_name: Ticket subject (required)
        create_ticket_pipeline_id: Pipeline ID (required)
        create_ticket_stage_id: Stage ID (required)
        description: Company description
        priority: Priority level
        ticket_owner_id: Ticket owner ID
    ### When action = 'add_contact_to_list'
        by: Method to identify contacts: email or id
        contact_ids: Comma-separated contact IDs
        emails: Array of email addresses (when by=email)
        list_id: HubSpot list ID (required)
    ### When action = 'get_contacts'
        city: City of residence
        company_name: Search by company name
        country: Country name
        created_date: Filter by creation date (YYYY-MM-DD)
        email: Search by email address
        first_name: Contact's first name
        hs_analytics_source: Filter by original source
        hs_latest_source: Filter by latest source
        hs_lead_status: Filter by HubSpot lead status
        hubspot_owner_id: Filter by contact owner ID
        job_title: Job title of the contact
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        last_name: Contact's last name
        lead_status: Filter by lead status
        lifecycle_stage: Filter by lifecycle stage
        phone: Search by phone number
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        state: Search by state
        use_date: Toggle to use dates
        website: Search by website
    ### When action = 'get_tickets'
        closed_date: Filter by closed date (YYYY-MM-DD)
        created_date: Filter by creation date (YYYY-MM-DD)
        first_agent_reply_date: Filter by first agent reply date
        hs_num_times_contacted: Filter by number of times contacted
        hs_pipeline: Filter by pipeline
        hs_pipeline_stage: Filter by pipeline stage
        hs_resolution: Filter by ticket resolution
        hs_ticket_category: Filter by ticket category
        hs_ticket_priority: Filter by ticket priority
        hs_time_to_close: Filter by time to close (milliseconds)
        hs_time_to_first_agent_reply: Filter by time to first agent reply
        hubspot_owner_id: Filter by contact owner ID
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        source_type: Filter by source type
        subject: Search by ticket subject
        tags: Filter by tags (comma-separated)
        use_date: Toggle to use dates
    ### When action = 'get_engagements'
        company_id: Filter by associated company ID
        contact_id: Filter by associated contact ID
        created_date: Filter by creation date (YYYY-MM-DD)
        deal_id: Filter by associated deal ID
        engagement_type: Filter by engagement type (CALL, EMAIL, MEETING, TASK)
        hs_activity_type: Filter by activity type
        hs_communication_channel_type: Filter by communication channel type
        hs_communication_logged_from: Filter by where engagement was logged from
        hubspot_owner_id: Filter by contact owner ID
        last_modified_date: Filter by last modified date (YYYY-MM-DD)
        properties: Comma-separated properties to fetch
        query: General search query
        sort_by: Field to sort by
        sort_order: Sort order (asc/desc)
        timestamp: Engagement timestamp (ISO format)
        use_date: Toggle to use dates
    ### When action = 'create_engagement'
        company_ids: Comma-separated company IDs
        contact_ids: Comma-separated contact IDs
        create_engagement_type: Select Engagement type (required)
        deal_ids: Comma-separated deal IDs
        metadata: Type-specific metadata (JSON)
        owner_id: Engagement owner ID
        timestamp: Engagement timestamp (ISO format)
    ### When action = 'remove_contact_from_list'
        contact_ids: Comma-separated contact IDs
        list_id: HubSpot list ID (required)
    ### When action = 'get_contacts' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_companies' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_deals' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_tickets' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_engagements' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'delete_company'
        delete_company_id: HubSpot company ID to delete (required)
    ### When action = 'delete_contact'
        delete_contact_id: HubSpot contact ID to delete (required)
    ### When action = 'delete_deal'
        delete_deal_id: HubSpot deal ID to delete (required)
    ### When action = 'delete_engagement'
        delete_engagement_id: HubSpot engagement ID to delete (required)
        type: Filter by company type
    ### When action = 'delete_ticket'
        delete_ticket_id: HubSpot ticket ID to delete (required)
    ### When action = 'get_contacts' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_companies' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_deals' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_tickets' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_engagements' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_company'
        include_merge_audits: Include merge history if true
        properties: Comma-separated properties to fetch
        read_company_id: HubSpot company ID to read (required)
    ### When action = 'read_deal'
        include_property_versions: Include property history if true
        properties: Comma-separated properties to fetch
        read_deal_id: HubSpot deal ID to read (required)
    ### When action = 'get_contacts' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'get_companies' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'get_deals' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'get_tickets' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'get_engagements' and use_date = False
        num_messages: Specify the number of contacts to fetch
    ### When action = 'read_contact'
        properties: Comma-separated properties to fetch
        read_contact_id: HubSpot contact ID to read (required)
        show_list_memberships: Include list memberships
    ### When action = 'read_ticket'
        properties: Comma-separated properties to fetch
        read_ticket_id: HubSpot ticket ID to read (required)
    ### When action = 'read_engagement'
        properties: Comma-separated properties to fetch
        read_engagement_id: HubSpot engagement ID to read (required)
        type: Filter by company type
    ### When action = 'update_company'
        update_about_us: About the company
        update_annual_revenue: Annual revenue
        update_city: City of residence
        update_company_domain_name: Company domain
        update_company_id: HubSpot company ID to update (required)
        update_company_name: Company name
        update_company_owner: Owner's user ID
        update_country_region: Country or region
        update_description: Company description
        update_industry: Type of industry
        update_lead_status: Lead status
        update_lifecycle: Lifecycle stage
        update_number_of_employees: Employee count
        update_phone_number: Main phone number
        update_website_url: Contact's website
    ### When action = 'update_deal'
        update_amount: Deal amount
        update_close_date: Close date
        update_deal_id: HubSpot deal ID to update (required)
        update_deal_name: Deal name
        update_deal_owner: Deal owner ID
        update_deal_stage: Deal stage ID
        update_deal_type: Deal type
        update_description: Company description
        update_pipeline: Pipeline ID
    ### When action = 'update_ticket'
        update_category: Ticket category
        update_close_date: Close date
        update_description: Company description
        update_priority: Priority level
        update_stage_id: Stage ID
        update_ticket_id: HubSpot ticket ID to update (required)
        update_ticket_name: Ticket subject
        update_ticket_owner_id: Ticket owner ID
    ### When action = 'update_contact'
        update_city: City of residence
        update_company: Name of the company
        update_contact_id: HubSpot contact ID to update (required)
        update_country: Country name
        update_custom_properties: Custom properties to add to the contact
        update_email: Contact email
        update_first_name: Contact's first name
        update_job_title: Job title of the contact
        update_last_name: Contact's last name
        update_mobile_phone_number: Mobile number
        update_phone_number: Main phone number
        update_postal_code: Postal or ZIP code
        update_state_region: State or region
        update_street_address: Street address
        update_website_url: Contact's website
    ### When action = 'get_contacts' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_companies' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_deals' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_tickets' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_engagements' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_deal'
        amount: Deal amount
        close_date: Deal close date
        deal_id: HubSpot deal ID
        deal_name: Deal name
        deal_owner: Deal owner
        deal_type: Deal type
        description: Deal description
        pipeline: Deal pipeline
        probability: Deal probability
        raw_data: Full response data
        stage: Deal stage
    ### When action = 'get_deals'
        amounts: List of amounts
        close_dates: List of close dates
        deal_ids: List of deal IDs
        deal_names: List of deal names
        deal_owners: List of owners
        deal_types: List of deal types
        descriptions: List of descriptions
        pipelines: List of pipelines
        probabilities: List of probabilities
        raw_data: Full response data
        stages: List of stages
        total: Total deals retrieved
    ### When action = 'read_company'
        annual_revenue: Annual revenue
        city: City
        company_id: HubSpot company ID
        country: Country
        description: Company description
        domain: Company domain
        industry: Industry
        name: Company name
        number_of_employees: Employee count
        phone_number: Phone number
        raw_data: Full response data
        state: State
        website: Website
    ### When action = 'get_companies'
        annual_revenues: List of revenues
        cities: List of cities
        company_ids: List of company IDs
        countries: List of countries
        descriptions: List of descriptions
        domains: List of domains
        industries: List of industries
        names: List of company names
        number_of_employees: List of employee counts
        phone_numbers: List of phone numbers
        raw_data: Full response data
        states: List of states
        total: Total count returned
        websites: List of websites
    ### When action = 'get_engagements'
        bodies: Engagement bodies/notes
        created_ats: Created dates
        engagement_ids: HubSpot engagement IDs
        engagement_types: Engagement types (call, email, meeting, task)
        owner_ids: Engagement owner IDs
        raw_data: Raw response data
        subjects: Engagement subjects
        timestamps: Engagement timestamps
        total: Total number of engagements retrieved
        updated_ats: Updated dates
    ### When action = 'read_engagement'
        body: Engagement body/notes
        created_at: Created date
        engagement_id: HubSpot engagement ID
        engagement_type: Engagement type (call, email, meeting, task)
        owner_id: Engagement owner ID
        raw_data: Raw response data
        subject: Engagement subject
        timestamp: Engagement timestamp
        updated_at: Updated date
    ### When action = 'get_tickets'
        categories: Ticket categories
        created_ats: Created dates
        descriptions: Ticket descriptions
        owners: Ticket owners
        pipelines: Ticket pipelines
        priorities: Ticket priorities
        raw_data: Raw response data
        stages: Ticket stages
        statuses: Ticket statuses
        subjects: Ticket subjects
        ticket_ids: HubSpot ticket IDs
        total: Total number of tickets retrieved
        updated_ats: Updated dates
    ### When action = 'read_ticket'
        category: Ticket category
        created_at: Created date
        description: Ticket description
        owner: Ticket owner
        pipeline: Ticket pipeline
        priority: Ticket priority
        raw_data: Raw response data
        stage: Ticket stage
        status: Ticket status
        subject: Ticket subject
        ticket_id: HubSpot ticket ID
        updated_at: Updated date
    ### When action = 'get_contacts'
        cities: List of cities
        companies: List of companies
        contact_ids: List of contact IDs
        countries: List of countries
        emails: List of email addresses
        first_names: List of first names
        job_titles: List of job titles
        last_names: List of last names
        phone_numbers: List of phone numbers
        raw_data: Raw response from HubSpot
        states: List of states
        total: Total contacts retrieved
        websites: List of websites
    ### When action = 'read_contact'
        city: Contact's city
        company: Contact's company
        contact_id: HubSpot contact ID
        country: Contact's country
        email: Contact's email address
        first_name: Contact's first name
        job_title: Contact's job title
        last_name: Contact's last name
        phone_number: Contact's phone number
        raw_data: Raw response from HubSpot
        state: Contact's state
        website: Contact's website
    ### When action = 'create_company'
        company_id: HubSpot company ID
    ### When action = 'create_contact'
        contact_id: HubSpot contact ID
    ### When action = 'create_deal'
        deal_id: HubSpot deal ID
    ### When action = 'delete_contact'
        deleted: True if contact was deleted
    ### When action = 'delete_company'
        deleted: True if company was deleted
    ### When action = 'delete_deal'
        deleted: True if deal was deleted
    ### When action = 'delete_ticket'
        deleted: Whether the ticket was deleted
    ### When action = 'delete_engagement'
        deleted: Whether the engagement was deleted
    ### When action = 'create_engagement'
        engagement_id: HubSpot engagement ID
    ### When action = 'add_contact_to_list'
        success: Whether contacts were added successfully
    ### When action = 'remove_contact_from_list'
        success: Whether contacts were removed successfully
    ### When action = 'create_ticket'
        ticket_id: HubSpot ticket ID
    ### When action = 'update_contact'
        updated: True if contact was updated
    ### When action = 'update_company'
        updated: True if update succeeded
    ### When action = 'update_deal'
        updated: True if deal was updated
    ### When action = 'update_ticket'
        updated: Whether the ticket was updated
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Hubspot>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_contact**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@example.com",
                    "helper_text": "Required contact email",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "company",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "Name of the company",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "value": "",
                    "label": "Job Title",
                    "placeholder": "Sales Manager",
                    "helper_text": "Job title of the contact",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Main phone number",
                },
                {
                    "field": "mobile_phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Mobile Phone",
                    "placeholder": "+1-555-987-6543",
                    "helper_text": "Mobile number",
                },
                {
                    "field": "street_address",
                    "type": "string",
                    "value": "",
                    "label": "Street Address",
                    "placeholder": "123 Main St",
                    "helper_text": "Street address",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "City of residence",
                },
                {
                    "field": "state_region",
                    "type": "string",
                    "value": "",
                    "label": "State/Region",
                    "placeholder": "MA",
                    "helper_text": "State or region",
                },
                {
                    "field": "postal_code",
                    "type": "string",
                    "value": "",
                    "label": "Postal Code",
                    "placeholder": "02101",
                    "helper_text": "Postal or ZIP code",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "United States",
                    "helper_text": "Country name",
                },
                {
                    "field": "website_url",
                    "type": "string",
                    "value": "",
                    "label": "Website URL",
                    "placeholder": "https://example.com",
                    "helper_text": "Contact's website",
                },
                {
                    "field": "associated_company_id",
                    "type": "string",
                    "value": "",
                    "label": "Associated Company ID",
                    "placeholder": "12345",
                    "helper_text": "ID of associated company",
                },
                {
                    "field": "custom_properties",
                    "type": "string",
                    "value": "",
                    "label": "Custom Properties",
                    "helper_text": "Custom properties to add to the contact",
                },
            ],
            "outputs": [
                {
                    "field": "contact_id",
                    "type": "string",
                    "helper_text": "HubSpot contact ID",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "create_contact",
            "task_name": "tasks.hubspot.create_contact",
            "description": "Creates a new contact",
            "label": "Create Contact",
        },
        "update_contact**(*)**(*)": {
            "inputs": [
                {
                    "field": "update_contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot contact ID to update (required)",
                },
                {
                    "field": "update_email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@example.com",
                    "helper_text": "Contact email",
                },
                {
                    "field": "update_first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "update_last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "update_company",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "Name of the company",
                },
                {
                    "field": "update_job_title",
                    "type": "string",
                    "value": "",
                    "label": "Job Title",
                    "placeholder": "Sales Manager",
                    "helper_text": "Job title of the contact",
                },
                {
                    "field": "update_phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Main phone number",
                },
                {
                    "field": "update_mobile_phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Mobile Phone",
                    "placeholder": "+1-555-987-6543",
                    "helper_text": "Mobile number",
                },
                {
                    "field": "update_street_address",
                    "type": "string",
                    "value": "",
                    "label": "Street Address",
                    "placeholder": "123 Main St",
                    "helper_text": "Street address",
                },
                {
                    "field": "update_city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "City of residence",
                },
                {
                    "field": "update_state_region",
                    "type": "string",
                    "value": "",
                    "label": "State/Region",
                    "placeholder": "MA",
                    "helper_text": "State or region",
                },
                {
                    "field": "update_postal_code",
                    "type": "string",
                    "value": "",
                    "label": "Postal Code",
                    "placeholder": "02101",
                    "helper_text": "Postal or ZIP code",
                },
                {
                    "field": "update_country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "United States",
                    "helper_text": "Country name",
                },
                {
                    "field": "update_website_url",
                    "type": "string",
                    "value": "",
                    "label": "Website URL",
                    "placeholder": "https://example.com",
                    "helper_text": "Contact's website",
                },
                {
                    "field": "update_custom_properties",
                    "type": "string",
                    "value": "",
                    "label": "Custom Properties",
                    "helper_text": "Custom properties to add to the contact",
                },
            ],
            "outputs": [
                {
                    "field": "updated",
                    "type": "bool",
                    "helper_text": "True if contact was updated",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_contact",
            "task_name": "tasks.hubspot.update_contact",
            "description": "Updates an existing contact",
            "label": "Update Contact",
        },
        "delete_contact**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot contact ID to delete (required)",
                }
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "True if contact was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_contact",
            "task_name": "tasks.hubspot.delete_contact",
            "description": "Deletes a contact by ID",
            "label": "Delete Contact",
        },
        "read_contact**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot contact ID to read (required)",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "show_list_memberships",
                    "type": "bool",
                    "value": False,
                    "label": "Show List Memberships",
                    "helper_text": "Include list memberships",
                },
            ],
            "outputs": [
                {
                    "field": "contact_id",
                    "type": "string",
                    "helper_text": "HubSpot contact ID",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "Contact's email address",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "helper_text": "Contact's phone number",
                },
                {
                    "field": "company",
                    "type": "string",
                    "helper_text": "Contact's company",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "helper_text": "Contact's job title",
                },
                {"field": "city", "type": "string", "helper_text": "Contact's city"},
                {"field": "state", "type": "string", "helper_text": "Contact's state"},
                {
                    "field": "country",
                    "type": "string",
                    "helper_text": "Contact's country",
                },
                {
                    "field": "website",
                    "type": "string",
                    "helper_text": "Contact's website",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from HubSpot",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_contact",
            "task_name": "tasks.hubspot.read_contact",
            "description": "Retrieves a specific contact by ID",
            "label": "Read Contact",
        },
        "get_contacts**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "john",
                    "helper_text": "General search query",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@example.com",
                    "helper_text": "Search by email address",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "John",
                    "helper_text": "Search by first name",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Doe",
                    "helper_text": "Search by last name",
                },
                {
                    "field": "company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company",
                    "placeholder": "Acme Corp",
                    "helper_text": "Search by company name",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "value": "",
                    "label": "Job Title",
                    "placeholder": "Manager",
                    "helper_text": "Search by job title",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Search by phone number",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "Search by city",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "label": "State",
                    "placeholder": "MA",
                    "helper_text": "Search by state",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "United States",
                    "helper_text": "Search by country",
                },
                {
                    "field": "website",
                    "type": "string",
                    "value": "",
                    "label": "Website",
                    "placeholder": "example.com",
                    "helper_text": "Search by website",
                },
                {
                    "field": "lifecycle_stage",
                    "type": "string",
                    "value": "",
                    "label": "Lifecycle Stage",
                    "placeholder": "lead",
                    "helper_text": "Filter by lifecycle stage",
                },
                {
                    "field": "lead_status",
                    "type": "string",
                    "value": "",
                    "label": "Lead Status",
                    "placeholder": "new",
                    "helper_text": "Filter by lead status",
                },
                {
                    "field": "hs_lead_status",
                    "type": "string",
                    "value": "",
                    "label": "HubSpot Lead Status",
                    "placeholder": "NEW",
                    "helper_text": "Filter by HubSpot lead status",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "hs_analytics_source",
                    "type": "string",
                    "value": "",
                    "label": "Original Source",
                    "placeholder": "ORGANIC_SEARCH",
                    "helper_text": "Filter by original source",
                },
                {
                    "field": "hs_latest_source",
                    "type": "string",
                    "value": "",
                    "label": "Latest Source",
                    "placeholder": "DIRECT_TRAFFIC",
                    "helper_text": "Filter by latest source",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by contact owner ID",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "createdate",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "contact_ids",
                    "type": "vec<string>",
                    "helper_text": "List of contact IDs",
                },
                {
                    "field": "first_names",
                    "type": "vec<string>",
                    "helper_text": "List of first names",
                },
                {
                    "field": "last_names",
                    "type": "vec<string>",
                    "helper_text": "List of last names",
                },
                {
                    "field": "emails",
                    "type": "vec<string>",
                    "helper_text": "List of email addresses",
                },
                {
                    "field": "phone_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of phone numbers",
                },
                {
                    "field": "companies",
                    "type": "vec<string>",
                    "helper_text": "List of companies",
                },
                {
                    "field": "job_titles",
                    "type": "vec<string>",
                    "helper_text": "List of job titles",
                },
                {
                    "field": "cities",
                    "type": "vec<string>",
                    "helper_text": "List of cities",
                },
                {
                    "field": "states",
                    "type": "vec<string>",
                    "helper_text": "List of states",
                },
                {
                    "field": "countries",
                    "type": "vec<string>",
                    "helper_text": "List of countries",
                },
                {
                    "field": "websites",
                    "type": "vec<string>",
                    "helper_text": "List of websites",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total contacts retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from HubSpot",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_contacts",
            "task_name": "tasks.hubspot.get_contacts",
            "description": "Retrieves multiple contacts with advanced filtering",
            "label": "Get Contacts",
        },
        "get_contacts**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Contacts",
                    "helper_text": "Specify the number of contacts to fetch",
                }
            ],
            "outputs": [],
        },
        "get_contacts**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_contacts**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_contacts**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_company**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "Required company name",
                },
                {
                    "field": "about_us",
                    "type": "string",
                    "value": "",
                    "label": "About Us",
                    "placeholder": "Leading software company",
                    "helper_text": "About the company",
                },
                {
                    "field": "annual_revenue",
                    "type": "int32",
                    "value": 0,
                    "label": "Annual Revenue",
                    "helper_text": "Annual revenue",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "City",
                },
                {
                    "field": "company_domain_name",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "acme.com",
                    "helper_text": "Company's domain name",
                },
                {
                    "field": "company_owner",
                    "type": "string",
                    "value": "",
                    "label": "Company Owner",
                    "placeholder": "12345",
                    "helper_text": "Owner's user ID",
                },
                {
                    "field": "country_region",
                    "type": "string",
                    "value": "",
                    "label": "Country/Region",
                    "placeholder": "United States",
                    "helper_text": "Country or region",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Company description",
                    "helper_text": "Company description",
                },
                {
                    "field": "industry",
                    "type": "string",
                    "value": "ACCOUNTING",
                    "helper_text": "Type of industry",
                    "placeholder": "Accounting",
                    "label": "Industry",
                    "component": {"type": "dropdown", "referenced_options": "industry"},
                },
                {
                    "field": "lifecycle",
                    "type": "string",
                    "value": "subscriber",
                    "helper_text": "Lifecycle stage",
                    "placeholder": "Subscriber",
                    "label": "Lifecycle",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "life_cycle",
                    },
                },
                {
                    "field": "lead_status",
                    "type": "string",
                    "value": "NEW",
                    "helper_text": "Lead status",
                    "placeholder": "New",
                    "label": "Lead Status",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "lead_status",
                    },
                },
                {
                    "field": "number_of_employees",
                    "type": "int32",
                    "value": 0,
                    "label": "Number of Employees",
                    "helper_text": "Employee count",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Phone number",
                },
                {
                    "field": "website_url",
                    "type": "string",
                    "value": "",
                    "label": "Website URL",
                    "placeholder": "https://acme.com",
                    "helper_text": "Website URL",
                },
            ],
            "outputs": [
                {
                    "field": "company_id",
                    "type": "string",
                    "helper_text": "HubSpot company ID",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "create_company",
            "task_name": "tasks.hubspot.create_company",
            "description": "Creates a new company",
            "label": "Create Company",
        },
        "update_company**(*)**(*)": {
            "inputs": [
                {
                    "field": "update_company_id",
                    "type": "string",
                    "value": "",
                    "label": "Company ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot company ID to update (required)",
                },
                {
                    "field": "update_company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "Company name",
                },
                {
                    "field": "update_about_us",
                    "type": "string",
                    "value": "",
                    "label": "About Us",
                    "placeholder": "Leading software company",
                    "helper_text": "About the company",
                },
                {
                    "field": "update_annual_revenue",
                    "type": "int32",
                    "value": 0,
                    "label": "Annual Revenue",
                    "helper_text": "Annual revenue",
                },
                {
                    "field": "update_city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "City",
                },
                {
                    "field": "update_company_domain_name",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "acme.com",
                    "helper_text": "Company domain",
                },
                {
                    "field": "update_company_owner",
                    "type": "string",
                    "value": "",
                    "label": "Company Owner",
                    "placeholder": "12345",
                    "helper_text": "Owner's user ID",
                },
                {
                    "field": "update_country_region",
                    "type": "string",
                    "value": "",
                    "label": "Country/Region",
                    "placeholder": "United States",
                    "helper_text": "Country or region",
                },
                {
                    "field": "update_description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Company description",
                    "helper_text": "Company description",
                },
                {
                    "field": "update_industry",
                    "type": "string",
                    "value": "ACCOUNTING",
                    "helper_text": "Type of industry",
                    "placeholder": "Accounting",
                    "label": "Industry",
                    "component": {"type": "dropdown", "referenced_options": "industry"},
                },
                {
                    "field": "update_lifecycle",
                    "type": "string",
                    "value": "subscriber",
                    "helper_text": "Lifecycle stage",
                    "placeholder": "Subscriber",
                    "label": "Lifecycle",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "life_cycle",
                    },
                },
                {
                    "field": "update_lead_status",
                    "type": "string",
                    "value": "NEW",
                    "helper_text": "Lead status",
                    "placeholder": "New",
                    "label": "Lead Status",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "lead_status",
                    },
                },
                {
                    "field": "update_number_of_employees",
                    "type": "int32",
                    "value": 0,
                    "label": "Number of Employees",
                    "helper_text": "Employee count",
                },
                {
                    "field": "update_phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Phone number",
                },
                {
                    "field": "update_website_url",
                    "type": "string",
                    "value": "",
                    "label": "Website URL",
                    "placeholder": "https://acme.com",
                    "helper_text": "Website URL",
                },
            ],
            "outputs": [
                {
                    "field": "updated",
                    "type": "bool",
                    "helper_text": "True if update succeeded",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_company",
            "task_name": "tasks.hubspot.update_company",
            "description": "Updates an existing company",
            "label": "Update Company",
        },
        "delete_company**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_company_id",
                    "type": "string",
                    "value": "",
                    "label": "Company ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot company ID to delete (required)",
                }
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "True if company was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_company",
            "task_name": "tasks.hubspot.delete_company",
            "description": "Deletes a company by ID",
            "label": "Delete Company",
        },
        "read_company**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_company_id",
                    "type": "string",
                    "value": "",
                    "label": "Company ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot company ID to read (required)",
                },
                {
                    "field": "include_merge_audits",
                    "type": "bool",
                    "value": False,
                    "label": "Include Merge Audits",
                    "helper_text": "Include merge history if true",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
            ],
            "outputs": [
                {
                    "field": "company_id",
                    "type": "string",
                    "helper_text": "HubSpot company ID",
                },
                {"field": "name", "type": "string", "helper_text": "Company name"},
                {"field": "domain", "type": "string", "helper_text": "Company domain"},
                {
                    "field": "phone_number",
                    "type": "string",
                    "helper_text": "Phone number",
                },
                {"field": "city", "type": "string", "helper_text": "City"},
                {"field": "state", "type": "string", "helper_text": "State"},
                {"field": "country", "type": "string", "helper_text": "Country"},
                {"field": "industry", "type": "string", "helper_text": "Industry"},
                {"field": "website", "type": "string", "helper_text": "Website"},
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Company description",
                },
                {
                    "field": "number_of_employees",
                    "type": "string",
                    "helper_text": "Employee count",
                },
                {
                    "field": "annual_revenue",
                    "type": "string",
                    "helper_text": "Annual revenue",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Full response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_company",
            "task_name": "tasks.hubspot.read_company",
            "description": "Retrieves a specific company by ID",
            "label": "Read Company",
        },
        "get_companies**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "acme",
                    "helper_text": "General search query",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Acme Corp",
                    "helper_text": "Search by company name",
                },
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "acme.com",
                    "helper_text": "Search by domain",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Search by phone number",
                },
                {
                    "field": "city",
                    "type": "string",
                    "value": "",
                    "label": "City",
                    "placeholder": "Boston",
                    "helper_text": "Search by city",
                },
                {
                    "field": "state",
                    "type": "string",
                    "value": "",
                    "label": "State",
                    "placeholder": "MA",
                    "helper_text": "Search by state",
                },
                {
                    "field": "country",
                    "type": "string",
                    "value": "",
                    "label": "Country",
                    "placeholder": "United States",
                    "helper_text": "Search by country",
                },
                {
                    "field": "zip",
                    "type": "string",
                    "value": "",
                    "label": "Zip Code",
                    "placeholder": "02101",
                    "helper_text": "Search by zip code",
                },
                {
                    "field": "industry",
                    "type": "string",
                    "value": "",
                    "label": "Industry",
                    "placeholder": "Technology",
                    "helper_text": "Filter by industry",
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "",
                    "label": "Company Type",
                    "placeholder": "PROSPECT",
                    "helper_text": "Filter by company type",
                },
                {
                    "field": "lifecycle_stage",
                    "type": "string",
                    "value": "",
                    "label": "Lifecycle Stage",
                    "placeholder": "customer",
                    "helper_text": "Filter by lifecycle stage",
                },
                {
                    "field": "lead_status",
                    "type": "string",
                    "value": "",
                    "label": "Lead Status",
                    "placeholder": "NEW",
                    "helper_text": "Filter by lead status",
                },
                {
                    "field": "number_of_employees",
                    "type": "string",
                    "value": "",
                    "label": "Number of Employees",
                    "placeholder": "1-10",
                    "helper_text": "Filter by employee count range",
                },
                {
                    "field": "annual_revenue",
                    "type": "string",
                    "value": "",
                    "label": "Annual Revenue",
                    "placeholder": "1000000",
                    "helper_text": "Filter by annual revenue",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by company owner ID",
                },
                {
                    "field": "hs_analytics_source",
                    "type": "string",
                    "value": "",
                    "label": "Original Source",
                    "placeholder": "ORGANIC_SEARCH",
                    "helper_text": "Filter by original source",
                },
                {
                    "field": "hs_analytics_source_data_1",
                    "type": "string",
                    "value": "",
                    "label": "Source Data 1",
                    "placeholder": "google",
                    "helper_text": "Filter by source data 1",
                },
                {
                    "field": "hs_analytics_source_data_2",
                    "type": "string",
                    "value": "",
                    "label": "Source Data 2",
                    "placeholder": "keywords",
                    "helper_text": "Filter by source data 2",
                },
                {
                    "field": "web_technologies",
                    "type": "string",
                    "value": "",
                    "label": "Web Technologies",
                    "placeholder": "wordpress",
                    "helper_text": "Filter by web technologies",
                },
                {
                    "field": "founded_year",
                    "type": "string",
                    "value": "",
                    "label": "Founded Year",
                    "placeholder": "2020",
                    "helper_text": "Filter by founded year",
                },
                {
                    "field": "is_public",
                    "type": "bool",
                    "value": False,
                    "label": "Is Public Company",
                    "helper_text": "Filter by public company status",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "createdate",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "company_ids",
                    "type": "vec<string>",
                    "helper_text": "List of company IDs",
                },
                {
                    "field": "names",
                    "type": "vec<string>",
                    "helper_text": "List of company names",
                },
                {
                    "field": "domains",
                    "type": "vec<string>",
                    "helper_text": "List of domains",
                },
                {
                    "field": "phone_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of phone numbers",
                },
                {
                    "field": "cities",
                    "type": "vec<string>",
                    "helper_text": "List of cities",
                },
                {
                    "field": "states",
                    "type": "vec<string>",
                    "helper_text": "List of states",
                },
                {
                    "field": "countries",
                    "type": "vec<string>",
                    "helper_text": "List of countries",
                },
                {
                    "field": "industries",
                    "type": "vec<string>",
                    "helper_text": "List of industries",
                },
                {
                    "field": "websites",
                    "type": "vec<string>",
                    "helper_text": "List of websites",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of descriptions",
                },
                {
                    "field": "number_of_employees",
                    "type": "vec<string>",
                    "helper_text": "List of employee counts",
                },
                {
                    "field": "annual_revenues",
                    "type": "vec<string>",
                    "helper_text": "List of revenues",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total count returned",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Full response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_companies",
            "task_name": "tasks.hubspot.get_companies",
            "description": "Retrieves multiple companies with advanced filtering",
            "label": "Get Companies",
        },
        "get_companies**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Companies",
                    "helper_text": "Specify the number of companies to fetch",
                }
            ],
            "outputs": [],
        },
        "get_companies**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_companies**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_companies**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_deal**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_deal_stage",
                    "type": "string",
                    "value": "",
                    "label": "Stage",
                    "placeholder": "appointmentscheduled",
                    "helper_text": "Required deal stage ID",
                },
                {
                    "field": "deal_name",
                    "type": "string",
                    "value": "",
                    "label": "Deal Name",
                    "placeholder": "Enterprise Solution 2024",
                    "helper_text": "Deal name",
                },
                {
                    "field": "amount",
                    "type": "int32",
                    "value": 0,
                    "label": "Amount",
                    "helper_text": "Deal amount",
                },
                {
                    "field": "close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Close date",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Deal description",
                    "helper_text": "Deal description",
                },
                {
                    "field": "deal_owner",
                    "type": "string",
                    "value": "",
                    "label": "Deal Owner",
                    "placeholder": "12345",
                    "helper_text": "Deal owner ID",
                },
                {
                    "field": "deal_type",
                    "type": "string",
                    "value": "",
                    "label": "Deal Type",
                    "placeholder": "newbusiness",
                    "helper_text": "Deal type",
                },
                {
                    "field": "pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "default",
                    "helper_text": "Pipeline ID",
                },
                {
                    "field": "associated_company",
                    "type": "string",
                    "value": "",
                    "label": "Associated Companies",
                    "placeholder": "12345",
                    "helper_text": "Associated company IDs",
                },
                {
                    "field": "associated_vids",
                    "type": "string",
                    "value": "",
                    "label": "Associated Contacts",
                    "placeholder": "12345",
                    "helper_text": "Associated contact IDs",
                },
            ],
            "outputs": [
                {"field": "deal_id", "type": "string", "helper_text": "HubSpot deal ID"}
            ],
            "variant": "common_integration_nodes",
            "name": "create_deal",
            "task_name": "tasks.hubspot.create_deal",
            "description": "Creates a new deal",
            "label": "Create Deal",
        },
        "update_deal**(*)**(*)": {
            "inputs": [
                {
                    "field": "update_deal_id",
                    "type": "string",
                    "value": "",
                    "label": "Deal ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot deal ID to update (required)",
                },
                {
                    "field": "update_deal_stage",
                    "type": "string",
                    "value": "",
                    "label": "Stage",
                    "placeholder": "appointmentscheduled",
                    "helper_text": "Deal stage ID",
                },
                {
                    "field": "update_deal_name",
                    "type": "string",
                    "value": "",
                    "label": "Deal Name",
                    "placeholder": "Enterprise Solution 2024",
                    "helper_text": "Deal name",
                },
                {
                    "field": "update_amount",
                    "type": "int32",
                    "value": 0,
                    "label": "Amount",
                    "helper_text": "Deal amount",
                },
                {
                    "field": "update_close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Close date",
                },
                {
                    "field": "update_description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Deal description",
                    "helper_text": "Deal description",
                },
                {
                    "field": "update_deal_owner",
                    "type": "string",
                    "value": "",
                    "label": "Deal Owner",
                    "placeholder": "12345",
                    "helper_text": "Deal owner ID",
                },
                {
                    "field": "update_deal_type",
                    "type": "string",
                    "value": "",
                    "label": "Deal Type",
                    "placeholder": "newbusiness",
                    "helper_text": "Deal type",
                },
                {
                    "field": "update_pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "default",
                    "helper_text": "Pipeline ID",
                },
            ],
            "outputs": [
                {
                    "field": "updated",
                    "type": "bool",
                    "helper_text": "True if deal was updated",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_deal",
            "task_name": "tasks.hubspot.update_deal",
            "description": "Updates an existing deal",
            "label": "Update Deal",
        },
        "delete_deal**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_deal_id",
                    "type": "string",
                    "value": "",
                    "label": "Deal ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot deal ID to delete (required)",
                }
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "True if deal was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_deal",
            "task_name": "tasks.hubspot.delete_deal",
            "description": "Deletes a deal by ID",
            "label": "Delete Deal",
        },
        "read_deal**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_deal_id",
                    "type": "string",
                    "value": "",
                    "label": "Deal ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot deal ID to read (required)",
                },
                {
                    "field": "include_property_versions",
                    "type": "bool",
                    "value": False,
                    "label": "Include Property Versions",
                    "helper_text": "Include property history if true",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated fields to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "deal_id",
                    "type": "string",
                    "helper_text": "HubSpot deal ID",
                },
                {"field": "deal_name", "type": "string", "helper_text": "Deal name"},
                {"field": "amount", "type": "string", "helper_text": "Deal amount"},
                {"field": "stage", "type": "string", "helper_text": "Deal stage"},
                {"field": "pipeline", "type": "string", "helper_text": "Deal pipeline"},
                {
                    "field": "close_date",
                    "type": "string",
                    "helper_text": "Deal close date",
                },
                {"field": "deal_type", "type": "string", "helper_text": "Deal type"},
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Deal description",
                },
                {"field": "deal_owner", "type": "string", "helper_text": "Deal owner"},
                {
                    "field": "probability",
                    "type": "string",
                    "helper_text": "Deal probability",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Full response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_deal",
            "task_name": "tasks.hubspot.read_deal",
            "description": "Retrieves a specific deal by ID",
            "label": "Read Deal",
        },
        "get_deals**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "enterprise",
                    "helper_text": "General search query",
                },
                {
                    "field": "deal_name",
                    "type": "string",
                    "value": "",
                    "label": "Deal Name",
                    "placeholder": "Enterprise Solution",
                    "helper_text": "Search by deal name",
                },
                {
                    "field": "amount",
                    "type": "string",
                    "value": "",
                    "label": "Amount",
                    "placeholder": "50000",
                    "helper_text": "Filter by deal amount",
                },
                {
                    "field": "deal_stage",
                    "type": "string",
                    "value": "",
                    "label": "Deal Stage",
                    "placeholder": "closedwon",
                    "helper_text": "Filter by deal stage",
                },
                {
                    "field": "pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "default",
                    "helper_text": "Filter by pipeline",
                },
                {
                    "field": "deal_type",
                    "type": "string",
                    "value": "",
                    "label": "Deal Type",
                    "placeholder": "newbusiness",
                    "helper_text": "Filter by deal type",
                },
                {
                    "field": "close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Filter by close date (YYYY-MM-DD)",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by deal owner ID",
                },
                {
                    "field": "deal_currency_code",
                    "type": "string",
                    "value": "",
                    "label": "Currency Code",
                    "placeholder": "USD",
                    "helper_text": "Filter by currency code",
                },
                {
                    "field": "hs_deal_stage_probability",
                    "type": "string",
                    "value": "",
                    "label": "Deal Probability",
                    "placeholder": "0.5",
                    "helper_text": "Filter by deal probability",
                },
                {
                    "field": "num_associated_contacts",
                    "type": "string",
                    "value": "",
                    "label": "Associated Contacts",
                    "placeholder": "5",
                    "helper_text": "Filter by number of associated contacts",
                },
                {
                    "field": "num_contacted_notes",
                    "type": "string",
                    "value": "",
                    "label": "Contact Notes",
                    "placeholder": "10",
                    "helper_text": "Filter by number of contact notes",
                },
                {
                    "field": "hs_analytics_source",
                    "type": "string",
                    "value": "",
                    "label": "Original Source",
                    "placeholder": "ORGANIC_SEARCH",
                    "helper_text": "Filter by original source",
                },
                {
                    "field": "hs_latest_source",
                    "type": "string",
                    "value": "",
                    "label": "Latest Source",
                    "placeholder": "DIRECT_TRAFFIC",
                    "helper_text": "Filter by latest source",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "hs_date_entered_closed_won",
                    "type": "string",
                    "value": "",
                    "label": "Date Closed Won",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by date entered closed won",
                },
                {
                    "field": "hs_date_entered_closed_lost",
                    "type": "string",
                    "value": "",
                    "label": "Date Closed Lost",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by date entered closed lost",
                },
                {
                    "field": "hs_forecast_amount",
                    "type": "string",
                    "value": "",
                    "label": "Forecast Amount",
                    "placeholder": "45000",
                    "helper_text": "Filter by forecast amount",
                },
                {
                    "field": "hs_is_closed",
                    "type": "bool",
                    "value": False,
                    "label": "Is Closed",
                    "helper_text": "Filter by closed status",
                },
                {
                    "field": "hs_is_deal_split",
                    "type": "bool",
                    "value": False,
                    "label": "Is Deal Split",
                    "helper_text": "Filter by deal split status",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "createdate",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "deal_ids",
                    "type": "vec<string>",
                    "helper_text": "List of deal IDs",
                },
                {
                    "field": "deal_names",
                    "type": "vec<string>",
                    "helper_text": "List of deal names",
                },
                {
                    "field": "amounts",
                    "type": "vec<string>",
                    "helper_text": "List of amounts",
                },
                {
                    "field": "stages",
                    "type": "vec<string>",
                    "helper_text": "List of stages",
                },
                {
                    "field": "pipelines",
                    "type": "vec<string>",
                    "helper_text": "List of pipelines",
                },
                {
                    "field": "close_dates",
                    "type": "vec<string>",
                    "helper_text": "List of close dates",
                },
                {
                    "field": "deal_types",
                    "type": "vec<string>",
                    "helper_text": "List of deal types",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of descriptions",
                },
                {
                    "field": "deal_owners",
                    "type": "vec<string>",
                    "helper_text": "List of owners",
                },
                {
                    "field": "probabilities",
                    "type": "vec<string>",
                    "helper_text": "List of probabilities",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total deals retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Full response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_deals",
            "task_name": "tasks.hubspot.get_deals",
            "description": "Retrieves multiple deals with advanced filtering",
            "label": "Get Deals",
        },
        "get_deals**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Deals",
                    "helper_text": "Specify the number of deals to fetch",
                }
            ],
            "outputs": [],
        },
        "get_deals**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_deals**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_deals**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_ticket_pipeline_id",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline ID",
                    "placeholder": "0",
                    "helper_text": "Pipeline ID (required)",
                },
                {
                    "field": "create_ticket_stage_id",
                    "type": "string",
                    "value": "",
                    "label": "Stage ID",
                    "placeholder": "1",
                    "helper_text": "Stage ID (required)",
                },
                {
                    "field": "create_ticket_name",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Subject",
                    "placeholder": "Technical Support Request",
                    "helper_text": "Ticket subject (required)",
                },
                {
                    "field": "category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "TECHNICAL_SUPPORT",
                    "helper_text": "Ticket category",
                },
                {
                    "field": "close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Close date",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Customer needs help with...",
                    "helper_text": "Ticket description",
                },
                {
                    "field": "priority",
                    "type": "string",
                    "value": "",
                    "label": "Priority",
                    "placeholder": "HIGH",
                    "helper_text": "Priority level",
                },
                {
                    "field": "ticket_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Owner",
                    "placeholder": "12345",
                    "helper_text": "Ticket owner ID",
                },
                {
                    "field": "associated_company_ids",
                    "type": "string",
                    "value": "",
                    "label": "Associated Companies",
                    "helper_text": "Associated companies",
                },
                {
                    "field": "associated_contact_ids",
                    "type": "string",
                    "value": "",
                    "label": "Associated Contacts",
                    "helper_text": "Associated contacts",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "HubSpot ticket ID",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "create_ticket",
            "task_name": "tasks.hubspot.create_ticket",
            "description": "Creates a new support ticket",
            "label": "Create Ticket",
        },
        "update_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "update_ticket_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot ticket ID to update (required)",
                },
                {
                    "field": "update_ticket_name",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Subject",
                    "placeholder": "Technical Support Request",
                    "helper_text": "Ticket subject",
                },
                {
                    "field": "update_category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "TECHNICAL_SUPPORT",
                    "helper_text": "Ticket category",
                },
                {
                    "field": "update_description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Customer needs help with...",
                    "helper_text": "Ticket description",
                },
                {
                    "field": "update_priority",
                    "type": "string",
                    "value": "",
                    "label": "Priority",
                    "placeholder": "HIGH",
                    "helper_text": "Priority level",
                },
                {
                    "field": "update_stage_id",
                    "type": "string",
                    "value": "",
                    "label": "Stage ID",
                    "placeholder": "2",
                    "helper_text": "Stage ID",
                },
                {
                    "field": "update_ticket_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket Owner",
                    "placeholder": "12345",
                    "helper_text": "Ticket owner ID",
                },
                {
                    "field": "update_close_date",
                    "type": "string",
                    "value": "",
                    "label": "Close Date",
                    "placeholder": "2024-12-31",
                    "helper_text": "Close date",
                },
            ],
            "outputs": [
                {
                    "field": "updated",
                    "type": "bool",
                    "helper_text": "Whether the ticket was updated",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "update_ticket",
            "task_name": "tasks.hubspot.update_ticket",
            "description": "Updates an existing ticket",
            "label": "Update Ticket",
        },
        "delete_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_ticket_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot ticket ID to delete (required)",
                }
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the ticket was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_ticket",
            "task_name": "tasks.hubspot.delete_ticket",
            "description": "Deletes a ticket by ID",
            "label": "Delete Ticket",
        },
        "read_ticket**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_ticket_id",
                    "type": "string",
                    "value": "",
                    "label": "Ticket ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot ticket ID to read (required)",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Properties to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_id",
                    "type": "string",
                    "helper_text": "HubSpot ticket ID",
                },
                {"field": "subject", "type": "string", "helper_text": "Ticket subject"},
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Ticket description",
                },
                {"field": "status", "type": "string", "helper_text": "Ticket status"},
                {
                    "field": "priority",
                    "type": "string",
                    "helper_text": "Ticket priority",
                },
                {
                    "field": "category",
                    "type": "string",
                    "helper_text": "Ticket category",
                },
                {
                    "field": "pipeline",
                    "type": "string",
                    "helper_text": "Ticket pipeline",
                },
                {"field": "stage", "type": "string", "helper_text": "Ticket stage"},
                {"field": "owner", "type": "string", "helper_text": "Ticket owner"},
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Created date",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Updated date",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_ticket",
            "task_name": "tasks.hubspot.read_ticket",
            "description": "Retrieves a specific ticket by ID",
            "label": "Read Ticket",
        },
        "get_tickets**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "support request",
                    "helper_text": "General search query",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Technical Support",
                    "helper_text": "Search by ticket subject",
                },
                {
                    "field": "hs_ticket_category",
                    "type": "string",
                    "value": "",
                    "label": "Category",
                    "placeholder": "TECHNICAL_SUPPORT",
                    "helper_text": "Filter by ticket category",
                },
                {
                    "field": "hs_ticket_priority",
                    "type": "string",
                    "value": "",
                    "label": "Priority",
                    "placeholder": "HIGH",
                    "helper_text": "Filter by ticket priority",
                },
                {
                    "field": "hs_pipeline_stage",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline Stage",
                    "placeholder": "1",
                    "helper_text": "Filter by pipeline stage",
                },
                {
                    "field": "hs_pipeline",
                    "type": "string",
                    "value": "",
                    "label": "Pipeline",
                    "placeholder": "0",
                    "helper_text": "Filter by pipeline",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by ticket owner ID",
                },
                {
                    "field": "hs_resolution",
                    "type": "string",
                    "value": "",
                    "label": "Resolution",
                    "placeholder": "RESOLVED",
                    "helper_text": "Filter by ticket resolution",
                },
                {
                    "field": "source_type",
                    "type": "string",
                    "value": "",
                    "label": "Source Type",
                    "placeholder": "EMAIL",
                    "helper_text": "Filter by source type",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "closed_date",
                    "type": "string",
                    "value": "",
                    "label": "Closed Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by closed date (YYYY-MM-DD)",
                },
                {
                    "field": "first_agent_reply_date",
                    "type": "string",
                    "value": "",
                    "label": "First Agent Reply Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by first agent reply date",
                },
                {
                    "field": "hs_time_to_close",
                    "type": "string",
                    "value": "",
                    "label": "Time to Close",
                    "placeholder": "3600000",
                    "helper_text": "Filter by time to close (milliseconds)",
                },
                {
                    "field": "hs_time_to_first_agent_reply",
                    "type": "string",
                    "value": "",
                    "label": "Time to First Reply",
                    "placeholder": "1800000",
                    "helper_text": "Filter by time to first agent reply",
                },
                {
                    "field": "hs_num_times_contacted",
                    "type": "string",
                    "value": "",
                    "label": "Times Contacted",
                    "placeholder": "5",
                    "helper_text": "Filter by number of times contacted",
                },
                {
                    "field": "tags",
                    "type": "string",
                    "value": "",
                    "label": "Tags",
                    "placeholder": "urgent,bug",
                    "helper_text": "Filter by tags (comma-separated)",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "createdate",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "ticket_ids",
                    "type": "vec<string>",
                    "helper_text": "HubSpot ticket IDs",
                },
                {
                    "field": "subjects",
                    "type": "vec<string>",
                    "helper_text": "Ticket subjects",
                },
                {
                    "field": "descriptions",
                    "type": "vec<string>",
                    "helper_text": "Ticket descriptions",
                },
                {
                    "field": "statuses",
                    "type": "vec<string>",
                    "helper_text": "Ticket statuses",
                },
                {
                    "field": "priorities",
                    "type": "vec<string>",
                    "helper_text": "Ticket priorities",
                },
                {
                    "field": "categories",
                    "type": "vec<string>",
                    "helper_text": "Ticket categories",
                },
                {
                    "field": "pipelines",
                    "type": "vec<string>",
                    "helper_text": "Ticket pipelines",
                },
                {
                    "field": "stages",
                    "type": "vec<string>",
                    "helper_text": "Ticket stages",
                },
                {
                    "field": "owners",
                    "type": "vec<string>",
                    "helper_text": "Ticket owners",
                },
                {
                    "field": "created_ats",
                    "type": "vec<string>",
                    "helper_text": "Created dates",
                },
                {
                    "field": "updated_ats",
                    "type": "vec<string>",
                    "helper_text": "Updated dates",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of tickets retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_tickets",
            "task_name": "tasks.hubspot.get_tickets",
            "description": "Retrieves multiple tickets with advanced filtering",
            "label": "Get Tickets",
        },
        "get_tickets**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Tickets",
                    "helper_text": "Specify the number of tickets to fetch",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_tickets**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_engagement**(*)**(*)": {
            "inputs": [
                {
                    "field": "create_engagement_type",
                    "type": "string",
                    "value": "call",
                    "label": "Type",
                    "placeholder": "Call",
                    "helper_text": "Select Engagement type (required)",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "engagement_type",
                    },
                },
                {
                    "field": "metadata",
                    "type": "string",
                    "value": "",
                    "label": "Metadata",
                    "placeholder": '{"body": "Call notes"}',
                    "helper_text": "Type-specific metadata (JSON)",
                },
                {
                    "field": "company_ids",
                    "type": "string",
                    "value": "",
                    "label": "Company IDs",
                    "placeholder": "123,456",
                    "helper_text": "Comma-separated company IDs",
                },
                {
                    "field": "contact_ids",
                    "type": "string",
                    "value": "",
                    "label": "Contact IDs",
                    "placeholder": "789,101",
                    "helper_text": "Comma-separated contact IDs",
                },
                {
                    "field": "deal_ids",
                    "type": "string",
                    "value": "",
                    "label": "Deal IDs",
                    "placeholder": "111,222",
                    "helper_text": "Comma-separated deal IDs",
                },
                {
                    "field": "owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Engagement owner ID",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "label": "Timestamp",
                    "placeholder": "2024-01-01T12:00:00Z",
                    "helper_text": "Engagement timestamp (ISO format)",
                },
            ],
            "outputs": [
                {
                    "field": "engagement_id",
                    "type": "string",
                    "helper_text": "HubSpot engagement ID",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "create_engagement",
            "task_name": "tasks.hubspot.create_engagement",
            "description": "Creates a new engagement (call, email, meeting, or task)",
            "label": "Create Engagement",
        },
        "delete_engagement**(*)**(*)": {
            "inputs": [
                {
                    "field": "delete_engagement_id",
                    "type": "string",
                    "value": "",
                    "label": "Engagement ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot engagement ID to delete (required)",
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "call",
                    "label": "Engagement Type",
                    "placeholder": "call",
                    "helper_text": "Type of engagement (call, email, meeting, task, note)",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "engagement_type",
                    },
                },
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the engagement was deleted",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "delete_engagement",
            "task_name": "tasks.hubspot.delete_engagement",
            "description": "Deletes an engagement by ID",
            "label": "Delete Engagement",
        },
        "read_engagement**(*)**(*)": {
            "inputs": [
                {
                    "field": "read_engagement_id",
                    "type": "string",
                    "value": "",
                    "label": "Engagement ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot engagement ID to read (required)",
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "call",
                    "label": "Engagement Type",
                    "placeholder": "call",
                    "helper_text": "Type of engagement (call, email, meeting, task, note)",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "engagement_type",
                    },
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
            ],
            "outputs": [
                {
                    "field": "engagement_id",
                    "type": "string",
                    "helper_text": "HubSpot engagement ID",
                },
                {
                    "field": "engagement_type",
                    "type": "string",
                    "helper_text": "Engagement type (call, email, meeting, task)",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "helper_text": "Engagement timestamp",
                },
                {
                    "field": "body",
                    "type": "string",
                    "helper_text": "Engagement body/notes",
                },
                {
                    "field": "subject",
                    "type": "string",
                    "helper_text": "Engagement subject",
                },
                {
                    "field": "owner_id",
                    "type": "string",
                    "helper_text": "Engagement owner ID",
                },
                {
                    "field": "created_at",
                    "type": "string",
                    "helper_text": "Created date",
                },
                {
                    "field": "updated_at",
                    "type": "string",
                    "helper_text": "Updated date",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_engagement",
            "task_name": "tasks.hubspot.read_engagement",
            "description": "Retrieves a specific engagement by ID",
            "label": "Read Engagement",
        },
        "get_engagements**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "helper_text": "Comma-separated properties to fetch",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "meeting",
                    "helper_text": "General search query",
                },
                {
                    "field": "engagement_type",
                    "type": "string",
                    "value": "",
                    "label": "Engagement Type",
                    "placeholder": "CALL",
                    "helper_text": "Filter by engagement type (CALL, EMAIL, MEETING, TASK)",
                },
                {
                    "field": "hubspot_owner_id",
                    "type": "string",
                    "value": "",
                    "label": "Owner ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by engagement owner ID",
                },
                {
                    "field": "contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by associated contact ID",
                },
                {
                    "field": "company_id",
                    "type": "string",
                    "value": "",
                    "label": "Company ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by associated company ID",
                },
                {
                    "field": "deal_id",
                    "type": "string",
                    "value": "",
                    "label": "Deal ID",
                    "placeholder": "12345",
                    "helper_text": "Filter by associated deal ID",
                },
                {
                    "field": "created_date",
                    "type": "string",
                    "value": "",
                    "label": "Created Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by creation date (YYYY-MM-DD)",
                },
                {
                    "field": "last_modified_date",
                    "type": "string",
                    "value": "",
                    "label": "Last Modified Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by last modified date (YYYY-MM-DD)",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "value": "",
                    "label": "Engagement Date",
                    "placeholder": "2024-01-01",
                    "helper_text": "Filter by engagement date (YYYY-MM-DD)",
                },
                {
                    "field": "hs_communication_channel_type",
                    "type": "string",
                    "value": "",
                    "label": "Communication Channel",
                    "placeholder": "EMAIL",
                    "helper_text": "Filter by communication channel type",
                },
                {
                    "field": "hs_communication_logged_from",
                    "type": "string",
                    "value": "",
                    "label": "Logged From",
                    "placeholder": "CRM",
                    "helper_text": "Filter by where engagement was logged from",
                },
                {
                    "field": "hs_activity_type",
                    "type": "string",
                    "value": "",
                    "label": "Activity Type",
                    "placeholder": "INCOMING_EMAIL",
                    "helper_text": "Filter by activity type",
                },
                {
                    "field": "sort_by",
                    "type": "string",
                    "value": "",
                    "label": "Sort By",
                    "placeholder": "timestamp",
                    "helper_text": "Field to sort by",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "placeholder": "desc",
                    "helper_text": "Sort order (asc/desc)",
                },
            ],
            "outputs": [
                {
                    "field": "engagement_ids",
                    "type": "vec<string>",
                    "helper_text": "HubSpot engagement IDs",
                },
                {
                    "field": "engagement_types",
                    "type": "vec<string>",
                    "helper_text": "Engagement types (call, email, meeting, task)",
                },
                {
                    "field": "timestamps",
                    "type": "vec<string>",
                    "helper_text": "Engagement timestamps",
                },
                {
                    "field": "bodies",
                    "type": "vec<string>",
                    "helper_text": "Engagement bodies/notes",
                },
                {
                    "field": "subjects",
                    "type": "vec<string>",
                    "helper_text": "Engagement subjects",
                },
                {
                    "field": "owner_ids",
                    "type": "vec<string>",
                    "helper_text": "Engagement owner IDs",
                },
                {
                    "field": "created_ats",
                    "type": "vec<string>",
                    "helper_text": "Created dates",
                },
                {
                    "field": "updated_ats",
                    "type": "vec<string>",
                    "helper_text": "Updated dates",
                },
                {
                    "field": "total",
                    "type": "int32",
                    "helper_text": "Total number of engagements retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_engagements",
            "task_name": "tasks.hubspot.get_engagements",
            "description": "Retrieves multiple engagements with advanced filtering",
            "label": "Get Engagements",
        },
        "get_engagements**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Engagements",
                    "helper_text": "Specify the number of engagements to fetch",
                }
            ],
            "outputs": [],
        },
        "get_engagements**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_engagements**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_engagements**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "add_contact_to_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "label": "List ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot list ID (required)",
                },
                {
                    "field": "by",
                    "type": "string",
                    "value": "email",
                    "label": "Identify By",
                    "placeholder": "email",
                    "helper_text": "Method to identify contacts: email or id",
                },
                {
                    "field": "emails",
                    "type": "string",
                    "value": "",
                    "label": "Email Addresses",
                    "helper_text": "Array of email addresses (when by=email)",
                },
                {
                    "field": "contact_ids",
                    "type": "string",
                    "value": "",
                    "label": "Contact IDs",
                    "helper_text": "Array of contact IDs (when by=id)",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether contacts were added successfully",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "add_contact_to_list",
            "task_name": "tasks.hubspot.add_contact_to_list",
            "description": "Adds contacts to a contact list",
            "label": "Add Contact to List",
        },
        "remove_contact_from_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "label": "List ID",
                    "placeholder": "12345",
                    "helper_text": "HubSpot list ID (required)",
                },
                {
                    "field": "contact_ids",
                    "type": "string",
                    "value": "",
                    "label": "Contact IDs",
                    "helper_text": "Array of contact IDs to remove",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether contacts were removed successfully",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "remove_contact_from_list",
            "task_name": "tasks.hubspot.remove_contact_from_list",
            "description": "Removes contacts from a contact list",
            "label": "Remove Contact from List",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        about_us: str = "",
        amount: int = 0,
        annual_revenue: int = 0,
        associated_company: str = "",
        associated_company_id: str = "",
        associated_company_ids: str = "",
        associated_contact_ids: str = "",
        associated_vids: str = "",
        by: str = "email",
        category: str = "",
        city: str = "",
        close_date: str = "",
        closed_date: str = "",
        company: str = "",
        company_domain_name: str = "",
        company_id: str = "",
        company_ids: str = "",
        company_name: str = "",
        company_owner: str = "",
        contact_id: str = "",
        contact_ids: str = "",
        country: str = "",
        country_region: str = "",
        create_company_name: str = "",
        create_deal_stage: str = "",
        create_email: str = "",
        create_engagement_type: str = "call",
        create_ticket_name: str = "",
        create_ticket_pipeline_id: str = "",
        create_ticket_stage_id: str = "",
        created_date: str = "",
        custom_properties: str = "",
        deal_currency_code: str = "",
        deal_id: str = "",
        deal_ids: str = "",
        deal_name: str = "",
        deal_owner: str = "",
        deal_stage: str = "",
        deal_type: str = "",
        delete_company_id: str = "",
        delete_contact_id: str = "",
        delete_deal_id: str = "",
        delete_engagement_id: str = "",
        delete_ticket_id: str = "",
        description: str = "",
        domain: str = "",
        email: str = "",
        emails: str = "",
        engagement_type: str = "",
        exact_date: Any = {"start": "", "end": ""},
        first_agent_reply_date: str = "",
        first_name: str = "",
        founded_year: str = "",
        hs_activity_type: str = "",
        hs_analytics_source: str = "",
        hs_analytics_source_data_1: str = "",
        hs_analytics_source_data_2: str = "",
        hs_communication_channel_type: str = "",
        hs_communication_logged_from: str = "",
        hs_date_entered_closed_lost: str = "",
        hs_date_entered_closed_won: str = "",
        hs_deal_stage_probability: str = "",
        hs_forecast_amount: str = "",
        hs_is_closed: bool = False,
        hs_is_deal_split: bool = False,
        hs_latest_source: str = "",
        hs_lead_status: str = "",
        hs_num_times_contacted: str = "",
        hs_pipeline: str = "",
        hs_pipeline_stage: str = "",
        hs_resolution: str = "",
        hs_ticket_category: str = "",
        hs_ticket_priority: str = "",
        hs_time_to_close: str = "",
        hs_time_to_first_agent_reply: str = "",
        hubspot_owner_id: str = "",
        include_merge_audits: bool = False,
        include_property_versions: bool = False,
        industry: str = "ACCOUNTING",
        is_public: bool = False,
        job_title: str = "",
        last_modified_date: str = "",
        last_name: str = "",
        lead_status: str = "",
        lifecycle: str = "subscriber",
        lifecycle_stage: str = "",
        list_id: str = "",
        metadata: str = "",
        mobile_phone_number: str = "",
        name: str = "",
        num_associated_contacts: str = "",
        num_contacted_notes: str = "",
        num_messages: int = 10,
        number_of_employees: int = 0,
        owner_id: str = "",
        phone: str = "",
        phone_number: str = "",
        pipeline: str = "",
        postal_code: str = "",
        priority: str = "",
        properties: str = "",
        query: str = "",
        read_company_id: str = "",
        read_contact_id: str = "",
        read_deal_id: str = "",
        read_engagement_id: str = "",
        read_ticket_id: str = "",
        show_list_memberships: bool = False,
        sort_by: str = "",
        sort_order: str = "",
        source_type: str = "",
        state: str = "",
        state_region: str = "",
        street_address: str = "",
        subject: str = "",
        tags: str = "",
        ticket_owner_id: str = "",
        timestamp: str = "",
        type: str = "",
        update_about_us: str = "",
        update_amount: int = 0,
        update_annual_revenue: int = 0,
        update_category: str = "",
        update_city: str = "",
        update_close_date: str = "",
        update_company: str = "",
        update_company_domain_name: str = "",
        update_company_id: str = "",
        update_company_name: str = "",
        update_company_owner: str = "",
        update_contact_id: str = "",
        update_country: str = "",
        update_country_region: str = "",
        update_custom_properties: str = "",
        update_deal_id: str = "",
        update_deal_name: str = "",
        update_deal_owner: str = "",
        update_deal_stage: str = "",
        update_deal_type: str = "",
        update_description: str = "",
        update_email: str = "",
        update_first_name: str = "",
        update_industry: str = "ACCOUNTING",
        update_job_title: str = "",
        update_last_name: str = "",
        update_lead_status: str = "NEW",
        update_lifecycle: str = "subscriber",
        update_mobile_phone_number: str = "",
        update_number_of_employees: int = 0,
        update_phone_number: str = "",
        update_pipeline: str = "",
        update_postal_code: str = "",
        update_priority: str = "",
        update_stage_id: str = "",
        update_state_region: str = "",
        update_street_address: str = "",
        update_ticket_id: str = "",
        update_ticket_name: str = "",
        update_ticket_owner_id: str = "",
        update_website_url: str = "",
        web_technologies: str = "",
        website: str = "",
        website_url: str = "",
        zip: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_hubspot",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if create_email is not None:
            self.inputs["create_email"] = create_email
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if company is not None:
            self.inputs["company"] = company
        if job_title is not None:
            self.inputs["job_title"] = job_title
        if phone_number is not None:
            self.inputs["phone_number"] = phone_number
        if mobile_phone_number is not None:
            self.inputs["mobile_phone_number"] = mobile_phone_number
        if street_address is not None:
            self.inputs["street_address"] = street_address
        if city is not None:
            self.inputs["city"] = city
        if state_region is not None:
            self.inputs["state_region"] = state_region
        if postal_code is not None:
            self.inputs["postal_code"] = postal_code
        if country is not None:
            self.inputs["country"] = country
        if website_url is not None:
            self.inputs["website_url"] = website_url
        if associated_company_id is not None:
            self.inputs["associated_company_id"] = associated_company_id
        if custom_properties is not None:
            self.inputs["custom_properties"] = custom_properties
        if update_contact_id is not None:
            self.inputs["update_contact_id"] = update_contact_id
        if update_email is not None:
            self.inputs["update_email"] = update_email
        if update_first_name is not None:
            self.inputs["update_first_name"] = update_first_name
        if update_last_name is not None:
            self.inputs["update_last_name"] = update_last_name
        if update_company is not None:
            self.inputs["update_company"] = update_company
        if update_job_title is not None:
            self.inputs["update_job_title"] = update_job_title
        if update_phone_number is not None:
            self.inputs["update_phone_number"] = update_phone_number
        if update_mobile_phone_number is not None:
            self.inputs["update_mobile_phone_number"] = update_mobile_phone_number
        if update_street_address is not None:
            self.inputs["update_street_address"] = update_street_address
        if update_city is not None:
            self.inputs["update_city"] = update_city
        if update_state_region is not None:
            self.inputs["update_state_region"] = update_state_region
        if update_postal_code is not None:
            self.inputs["update_postal_code"] = update_postal_code
        if update_country is not None:
            self.inputs["update_country"] = update_country
        if update_website_url is not None:
            self.inputs["update_website_url"] = update_website_url
        if update_custom_properties is not None:
            self.inputs["update_custom_properties"] = update_custom_properties
        if delete_contact_id is not None:
            self.inputs["delete_contact_id"] = delete_contact_id
        if read_contact_id is not None:
            self.inputs["read_contact_id"] = read_contact_id
        if properties is not None:
            self.inputs["properties"] = properties
        if show_list_memberships is not None:
            self.inputs["show_list_memberships"] = show_list_memberships
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if query is not None:
            self.inputs["query"] = query
        if email is not None:
            self.inputs["email"] = email
        if company_name is not None:
            self.inputs["company_name"] = company_name
        if phone is not None:
            self.inputs["phone"] = phone
        if state is not None:
            self.inputs["state"] = state
        if website is not None:
            self.inputs["website"] = website
        if lifecycle_stage is not None:
            self.inputs["lifecycle_stage"] = lifecycle_stage
        if lead_status is not None:
            self.inputs["lead_status"] = lead_status
        if hs_lead_status is not None:
            self.inputs["hs_lead_status"] = hs_lead_status
        if created_date is not None:
            self.inputs["created_date"] = created_date
        if last_modified_date is not None:
            self.inputs["last_modified_date"] = last_modified_date
        if hs_analytics_source is not None:
            self.inputs["hs_analytics_source"] = hs_analytics_source
        if hs_latest_source is not None:
            self.inputs["hs_latest_source"] = hs_latest_source
        if hubspot_owner_id is not None:
            self.inputs["hubspot_owner_id"] = hubspot_owner_id
        if sort_by is not None:
            self.inputs["sort_by"] = sort_by
        if sort_order is not None:
            self.inputs["sort_order"] = sort_order
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if create_company_name is not None:
            self.inputs["create_company_name"] = create_company_name
        if about_us is not None:
            self.inputs["about_us"] = about_us
        if annual_revenue is not None:
            self.inputs["annual_revenue"] = annual_revenue
        if company_domain_name is not None:
            self.inputs["company_domain_name"] = company_domain_name
        if company_owner is not None:
            self.inputs["company_owner"] = company_owner
        if country_region is not None:
            self.inputs["country_region"] = country_region
        if description is not None:
            self.inputs["description"] = description
        if industry is not None:
            self.inputs["industry"] = industry
        if lifecycle is not None:
            self.inputs["lifecycle"] = lifecycle
        if number_of_employees is not None:
            self.inputs["number_of_employees"] = number_of_employees
        if update_company_id is not None:
            self.inputs["update_company_id"] = update_company_id
        if update_company_name is not None:
            self.inputs["update_company_name"] = update_company_name
        if update_about_us is not None:
            self.inputs["update_about_us"] = update_about_us
        if update_annual_revenue is not None:
            self.inputs["update_annual_revenue"] = update_annual_revenue
        if update_company_domain_name is not None:
            self.inputs["update_company_domain_name"] = update_company_domain_name
        if update_company_owner is not None:
            self.inputs["update_company_owner"] = update_company_owner
        if update_country_region is not None:
            self.inputs["update_country_region"] = update_country_region
        if update_description is not None:
            self.inputs["update_description"] = update_description
        if update_industry is not None:
            self.inputs["update_industry"] = update_industry
        if update_lifecycle is not None:
            self.inputs["update_lifecycle"] = update_lifecycle
        if update_lead_status is not None:
            self.inputs["update_lead_status"] = update_lead_status
        if update_number_of_employees is not None:
            self.inputs["update_number_of_employees"] = update_number_of_employees
        if delete_company_id is not None:
            self.inputs["delete_company_id"] = delete_company_id
        if read_company_id is not None:
            self.inputs["read_company_id"] = read_company_id
        if include_merge_audits is not None:
            self.inputs["include_merge_audits"] = include_merge_audits
        if name is not None:
            self.inputs["name"] = name
        if domain is not None:
            self.inputs["domain"] = domain
        if zip is not None:
            self.inputs["zip"] = zip
        if type is not None:
            self.inputs["type"] = type
        if hs_analytics_source_data_1 is not None:
            self.inputs["hs_analytics_source_data_1"] = hs_analytics_source_data_1
        if hs_analytics_source_data_2 is not None:
            self.inputs["hs_analytics_source_data_2"] = hs_analytics_source_data_2
        if web_technologies is not None:
            self.inputs["web_technologies"] = web_technologies
        if founded_year is not None:
            self.inputs["founded_year"] = founded_year
        if is_public is not None:
            self.inputs["is_public"] = is_public
        if create_deal_stage is not None:
            self.inputs["create_deal_stage"] = create_deal_stage
        if deal_name is not None:
            self.inputs["deal_name"] = deal_name
        if amount is not None:
            self.inputs["amount"] = amount
        if close_date is not None:
            self.inputs["close_date"] = close_date
        if deal_owner is not None:
            self.inputs["deal_owner"] = deal_owner
        if deal_type is not None:
            self.inputs["deal_type"] = deal_type
        if pipeline is not None:
            self.inputs["pipeline"] = pipeline
        if associated_company is not None:
            self.inputs["associated_company"] = associated_company
        if associated_vids is not None:
            self.inputs["associated_vids"] = associated_vids
        if update_deal_id is not None:
            self.inputs["update_deal_id"] = update_deal_id
        if update_deal_stage is not None:
            self.inputs["update_deal_stage"] = update_deal_stage
        if update_deal_name is not None:
            self.inputs["update_deal_name"] = update_deal_name
        if update_amount is not None:
            self.inputs["update_amount"] = update_amount
        if update_close_date is not None:
            self.inputs["update_close_date"] = update_close_date
        if update_deal_owner is not None:
            self.inputs["update_deal_owner"] = update_deal_owner
        if update_deal_type is not None:
            self.inputs["update_deal_type"] = update_deal_type
        if update_pipeline is not None:
            self.inputs["update_pipeline"] = update_pipeline
        if delete_deal_id is not None:
            self.inputs["delete_deal_id"] = delete_deal_id
        if read_deal_id is not None:
            self.inputs["read_deal_id"] = read_deal_id
        if include_property_versions is not None:
            self.inputs["include_property_versions"] = include_property_versions
        if deal_stage is not None:
            self.inputs["deal_stage"] = deal_stage
        if deal_currency_code is not None:
            self.inputs["deal_currency_code"] = deal_currency_code
        if hs_deal_stage_probability is not None:
            self.inputs["hs_deal_stage_probability"] = hs_deal_stage_probability
        if num_associated_contacts is not None:
            self.inputs["num_associated_contacts"] = num_associated_contacts
        if num_contacted_notes is not None:
            self.inputs["num_contacted_notes"] = num_contacted_notes
        if hs_date_entered_closed_won is not None:
            self.inputs["hs_date_entered_closed_won"] = hs_date_entered_closed_won
        if hs_date_entered_closed_lost is not None:
            self.inputs["hs_date_entered_closed_lost"] = hs_date_entered_closed_lost
        if hs_forecast_amount is not None:
            self.inputs["hs_forecast_amount"] = hs_forecast_amount
        if hs_is_closed is not None:
            self.inputs["hs_is_closed"] = hs_is_closed
        if hs_is_deal_split is not None:
            self.inputs["hs_is_deal_split"] = hs_is_deal_split
        if create_ticket_pipeline_id is not None:
            self.inputs["create_ticket_pipeline_id"] = create_ticket_pipeline_id
        if create_ticket_stage_id is not None:
            self.inputs["create_ticket_stage_id"] = create_ticket_stage_id
        if create_ticket_name is not None:
            self.inputs["create_ticket_name"] = create_ticket_name
        if category is not None:
            self.inputs["category"] = category
        if priority is not None:
            self.inputs["priority"] = priority
        if ticket_owner_id is not None:
            self.inputs["ticket_owner_id"] = ticket_owner_id
        if associated_company_ids is not None:
            self.inputs["associated_company_ids"] = associated_company_ids
        if associated_contact_ids is not None:
            self.inputs["associated_contact_ids"] = associated_contact_ids
        if update_ticket_id is not None:
            self.inputs["update_ticket_id"] = update_ticket_id
        if update_ticket_name is not None:
            self.inputs["update_ticket_name"] = update_ticket_name
        if update_category is not None:
            self.inputs["update_category"] = update_category
        if update_priority is not None:
            self.inputs["update_priority"] = update_priority
        if update_stage_id is not None:
            self.inputs["update_stage_id"] = update_stage_id
        if update_ticket_owner_id is not None:
            self.inputs["update_ticket_owner_id"] = update_ticket_owner_id
        if delete_ticket_id is not None:
            self.inputs["delete_ticket_id"] = delete_ticket_id
        if read_ticket_id is not None:
            self.inputs["read_ticket_id"] = read_ticket_id
        if subject is not None:
            self.inputs["subject"] = subject
        if hs_ticket_category is not None:
            self.inputs["hs_ticket_category"] = hs_ticket_category
        if hs_ticket_priority is not None:
            self.inputs["hs_ticket_priority"] = hs_ticket_priority
        if hs_pipeline_stage is not None:
            self.inputs["hs_pipeline_stage"] = hs_pipeline_stage
        if hs_pipeline is not None:
            self.inputs["hs_pipeline"] = hs_pipeline
        if hs_resolution is not None:
            self.inputs["hs_resolution"] = hs_resolution
        if source_type is not None:
            self.inputs["source_type"] = source_type
        if closed_date is not None:
            self.inputs["closed_date"] = closed_date
        if first_agent_reply_date is not None:
            self.inputs["first_agent_reply_date"] = first_agent_reply_date
        if hs_time_to_close is not None:
            self.inputs["hs_time_to_close"] = hs_time_to_close
        if hs_time_to_first_agent_reply is not None:
            self.inputs["hs_time_to_first_agent_reply"] = hs_time_to_first_agent_reply
        if hs_num_times_contacted is not None:
            self.inputs["hs_num_times_contacted"] = hs_num_times_contacted
        if tags is not None:
            self.inputs["tags"] = tags
        if create_engagement_type is not None:
            self.inputs["create_engagement_type"] = create_engagement_type
        if metadata is not None:
            self.inputs["metadata"] = metadata
        if company_ids is not None:
            self.inputs["company_ids"] = company_ids
        if contact_ids is not None:
            self.inputs["contact_ids"] = contact_ids
        if deal_ids is not None:
            self.inputs["deal_ids"] = deal_ids
        if owner_id is not None:
            self.inputs["owner_id"] = owner_id
        if timestamp is not None:
            self.inputs["timestamp"] = timestamp
        if delete_engagement_id is not None:
            self.inputs["delete_engagement_id"] = delete_engagement_id
        if read_engagement_id is not None:
            self.inputs["read_engagement_id"] = read_engagement_id
        if engagement_type is not None:
            self.inputs["engagement_type"] = engagement_type
        if contact_id is not None:
            self.inputs["contact_id"] = contact_id
        if company_id is not None:
            self.inputs["company_id"] = company_id
        if deal_id is not None:
            self.inputs["deal_id"] = deal_id
        if hs_communication_channel_type is not None:
            self.inputs["hs_communication_channel_type"] = hs_communication_channel_type
        if hs_communication_logged_from is not None:
            self.inputs["hs_communication_logged_from"] = hs_communication_logged_from
        if hs_activity_type is not None:
            self.inputs["hs_activity_type"] = hs_activity_type
        if list_id is not None:
            self.inputs["list_id"] = list_id
        if by is not None:
            self.inputs["by"] = by
        if emails is not None:
            self.inputs["emails"] = emails
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationHubspotNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_elasticsearch")
class IntegrationElasticsearchNode(Node):
    """
    Elasticsearch

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### search_index
        index: Elasticsearch index name
        query: Query to search over index in JSON format

    ## Outputs
    ### search_index
        output: Search results from the Elasticsearch index
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Elasticsearch>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "search_index": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "JSON Query",
                    "placeholder": '{"query_string": {"query": "mountain*", "fields": ["title", "description"]}}',
                    "helper_text": "Query to search over index in JSON format",
                },
                {
                    "field": "index",
                    "type": "string",
                    "value": "",
                    "label": "Index",
                    "placeholder": "my-index",
                    "helper_text": "Elasticsearch index name",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Search results from the Elasticsearch index",
                }
            ],
            "name": "search_index",
            "task_name": "tasks.elasticsearch.search_index",
            "description": "Query your Elasticsearch index",
            "label": "Search Elasticsearch index",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        index: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_elasticsearch",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if index is not None:
            self.inputs["index"] = index
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationElasticsearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mongodb")
class IntegrationMongodbNode(Node):
    """
    MongoDB

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### find
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### find_one
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### aggregate
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### mongodb_nl
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### mongodb_nl_aggregation
        collection: The collection on which to perform the query
        query: The MongoDB query to find all matching records
    ### insert
        collection: The collection on which to perform the query
        document: The document to insert (JSON format)
    ### update
        collection: The collection on which to perform the query
        filter: The filter to select documents to update (JSON format)
        update: The update operation (JSON format)
    ### delete
        collection: The collection on which to perform the query
        filter: The filter to select documents to update (JSON format)
    ### find_and_update
        collection: The collection on which to perform the query
        filter: The filter to select documents to update (JSON format)
        update: The update operation (JSON format)
    ### find_and_replace
        collection: The collection on which to perform the query
        filter: The filter to select documents to update (JSON format)
        replacement: The replacement document (JSON format)

    ## Outputs
    ### Common Outputs
        output: Results of the Query. Example: {“name”: “John”, “age”: 29, “height”: 185}
        raw_data: Raw unprocessed data from MongoDB operation
    ### delete
        deleted_count: Number of documents deleted
        success: Whether the operation was successful
    ### insert
        inserted_id: The ID of the inserted document
        success: Whether the operation was successful
    ### update
        matched_count: Number of documents matched by the filter
        modified_count: Number of documents actually modified
        success: Whether the operation was successful
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<MongoDB>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "output",
            "helper_text": "Results of the Query. Example: {“name”: “John”, “age”: 29, “height”: 185}",
        },
        {
            "field": "raw_data",
            "helper_text": "Raw unprocessed data from MongoDB operation",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "find": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "find",
            "task_name": "tasks.mongodb.find",
            "description": "Query MongoDB data",
            "label": "MongoDB Find",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "collection", "query"],
        },
        "find_one": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "find_one",
            "task_name": "tasks.mongodb.find_one",
            "description": "Query MongoDB data",
            "label": "MongoDB Find One",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "collection", "query"],
        },
        "aggregate": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "aggregate",
            "task_name": "tasks.mongodb.aggregate",
            "description": "Run an Aggregation on MongoDB data",
            "label": "MongoDB Aggregate",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "collection", "query"],
        },
        "mongodb_nl": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "mongodb_nl",
            "task_name": "tasks.mongodb.mongodb_nl",
            "description": "Query MongoDB data with Natural Language",
            "label": "NL Query",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "collection", "query"],
        },
        "mongodb_nl_aggregation": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "{“name”: “John”, “age”: {“gte”: 28}}",
                    "helper_text": "The MongoDB query to find all matching records",
                },
            ],
            "outputs": [],
            "name": "mongodb_nl_aggregation",
            "task_name": "tasks.mongodb.mongodb_nl_aggregation",
            "description": "Aggregate MongoDB data with Natural Language",
            "label": "NL Aggregation",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "collection", "query"],
        },
        "insert": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection in which to insert the document",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "document",
                    "type": "string",
                    "value": "",
                    "label": "Document",
                    "placeholder": '{"name": "John", "age": 30, "city": "New York"}',
                    "helper_text": "The document to insert (JSON format)",
                },
            ],
            "outputs": [
                {
                    "field": "inserted_id",
                    "type": "string",
                    "helper_text": "The ID of the inserted document",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw unprocessed data from MongoDB operation",
                },
            ],
            "name": "insert",
            "task_name": "tasks.mongodb.insert",
            "description": "Insert a document into MongoDB collection",
            "label": "Insert Document",
            "variant": "common_integration_nodes",
            "required": ["collection", "document"],
            "inputs_sort_order": ["integration", "action", "collection", "document"],
        },
        "update": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection in which to update documents",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": '{"age": {"$gte": 18}}',
                    "helper_text": "The filter to select documents to update (JSON format)",
                },
                {
                    "field": "update",
                    "type": "string",
                    "value": "",
                    "label": "Update",
                    "placeholder": '{"$set": {"status": "active"}}',
                    "helper_text": "The update operation (JSON format)",
                },
            ],
            "outputs": [
                {
                    "field": "matched_count",
                    "type": "int32",
                    "helper_text": "Number of documents matched by the filter",
                },
                {
                    "field": "modified_count",
                    "type": "int32",
                    "helper_text": "Number of documents actually modified",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw unprocessed data from MongoDB operation",
                },
            ],
            "name": "update",
            "task_name": "tasks.mongodb.update",
            "description": "Update documents in MongoDB collection",
            "label": "Update Documents",
            "variant": "common_integration_nodes",
            "required": ["collection", "filter", "update"],
            "inputs_sort_order": [
                "integration",
                "action",
                "collection",
                "filter",
                "update",
            ],
        },
        "delete": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection from which to delete documents",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": '{"status": "inactive"}',
                    "helper_text": "The filter to select documents to delete (JSON format)",
                },
            ],
            "outputs": [
                {
                    "field": "deleted_count",
                    "type": "int32",
                    "helper_text": "Number of documents deleted",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw unprocessed data from MongoDB operation",
                },
            ],
            "name": "delete",
            "task_name": "tasks.mongodb.delete",
            "description": "Delete documents from MongoDB collection",
            "label": "Delete Documents",
            "variant": "common_integration_nodes",
            "required": ["collection", "filter"],
            "inputs_sort_order": ["integration", "action", "collection", "filter"],
        },
        "find_and_update": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection in which to find and update a document",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": '{"name": "John"}',
                    "helper_text": "The filter to select the document to update (JSON format)",
                },
                {
                    "field": "update",
                    "type": "string",
                    "value": "",
                    "label": "Update",
                    "placeholder": '{"$set": {"age": 31}}',
                    "helper_text": "The update operation (JSON format)",
                },
            ],
            "outputs": [],
            "name": "find_and_update",
            "task_name": "tasks.mongodb.find_and_update",
            "description": "Find and update a single document in MongoDB collection",
            "label": "Find and Update Document",
            "variant": "common_integration_nodes",
            "required": ["collection", "filter", "update"],
            "inputs_sort_order": [
                "integration",
                "action",
                "collection",
                "filter",
                "update",
            ],
        },
        "find_and_replace": {
            "inputs": [
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "helper_text": "The collection in which to find and replace a document",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "label": "Filter",
                    "placeholder": '{"name": "John"}',
                    "helper_text": "The filter to select the document to replace (JSON format)",
                },
                {
                    "field": "replacement",
                    "type": "string",
                    "value": "",
                    "label": "Replacement",
                    "placeholder": '{"name": "John", "age": 32, "city": "Boston"}',
                    "helper_text": "The replacement document (JSON format)",
                },
            ],
            "outputs": [],
            "name": "find_and_replace",
            "task_name": "tasks.mongodb.find_and_replace",
            "description": "Find and replace a single document in MongoDB collection",
            "label": "Find and Replace Document",
            "variant": "common_integration_nodes",
            "required": ["collection", "filter", "replacement"],
            "inputs_sort_order": [
                "integration",
                "action",
                "collection",
                "filter",
                "replacement",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        collection: str = "",
        document: str = "",
        filter: str = "",
        query: str = "",
        replacement: str = "",
        update: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mongodb",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if collection is not None:
            self.inputs["collection"] = collection
        if query is not None:
            self.inputs["query"] = query
        if document is not None:
            self.inputs["document"] = document
        if filter is not None:
            self.inputs["filter"] = filter
        if update is not None:
            self.inputs["update"] = update
        if replacement is not None:
            self.inputs["replacement"] = replacement
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMongodbNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_snowflake")
class IntegrationSnowflakeNode(Node):
    """
    Snowflake

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your Snowflake account
    ### insert
        data: JSON object with column-value pairs to insert
        database: Select the Database on which to perform the query
        return_id: Return the ID of the inserted record (if available)
        schema: Select the schema to be used in the query
        table_name: Choose the table to insert into
        warehouse: Select the SQL Warehouse which will perform the operation
    ### update
        data: JSON object with column-value pairs to insert
        database: Select the Database on which to perform the query
        limit: Maximum number of rows to update (0 for no limit)
        schema: Select the schema to be used in the query
        table_name: Choose the table to insert into
        warehouse: Select the SQL Warehouse which will perform the operation
        where_clause: WHERE condition to identify records to update
    ### nl
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation
    ### raw_sql
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation
    ### nl_agent
        database: Select the Database on which to perform the query
        query: SQL Query to execute
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        schema: Select the schema to be used in the query
        sql_generation_model: The sql_generation_model input
        warehouse: Select the SQL Warehouse which will perform the operation

    ## Outputs
    ### Common Outputs
        output: Results of the query or operation. Example: [{"name": "John", "age": 29, "department": "Engineering"}]
    ### insert
        affected_rows: Number of rows inserted
        raw_data: Raw response from Snowflake
        sql_query: Generated SQL query
        success: Whether the insert operation succeeded
    ### update
        affected_rows: Number of rows updated
        raw_data: Raw response from Snowflake
        sql_query: Generated SQL query
        success: Whether the update operation succeeded
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your Snowflake account",
            "value": None,
            "type": "integration<Snowflake>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "output",
            "helper_text": 'Results of the query or operation. Example: [{"name": "John", "age": 29, "department": "Engineering"}]',
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.snowflake.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.snowflake.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "warehouse",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the SQL Warehouse which will perform the operation",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.snowflake.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
        "insert": {
            "inputs": [
                {
                    "field": "warehouse",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the Warehouse to use for the operation",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "placeholder": "Select table",
                    "helper_text": "Choose the table to insert into",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=table_name&database={inputs.database}&schema={inputs.schema}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "data",
                    "type": "string",
                    "value": "",
                    "label": "Data",
                    "placeholder": '{"column1": "value1", "column2": "value2"}',
                    "helper_text": "JSON object with column-value pairs to insert",
                },
                {
                    "field": "return_id",
                    "type": "bool",
                    "value": False,
                    "label": "Return ID",
                    "helper_text": "Return the ID of the inserted record (if available)",
                },
            ],
            "outputs": [
                {
                    "field": "affected_rows",
                    "type": "int32",
                    "helper_text": "Number of rows inserted",
                },
                {
                    "field": "sql_query",
                    "type": "string",
                    "helper_text": "Generated SQL query",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the insert operation succeeded",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Snowflake",
                },
            ],
            "name": "insert",
            "task_name": "tasks.snowflake.insert",
            "description": "Insert new data into a Snowflake table",
            "label": "Insert Data",
            "variant": "common_integration_nodes",
            "required": ["warehouse", "table_name", "data"],
            "inputs_sort_order": [
                "integration",
                "action",
                "warehouse",
                "database",
                "schema",
                "table_name",
                "data",
                "return_id",
            ],
        },
        "update": {
            "inputs": [
                {
                    "field": "warehouse",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "helper_text": "Select the Warehouse to use for the operation",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=warehouse&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "",
                    "label": "Database",
                    "helper_text": "Select the Database on which to perform the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "helper_text": "Select the schema to be used in the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=schema&database={inputs.database}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "placeholder": "Select table",
                    "helper_text": "Choose the table to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=table_name&database={inputs.database}&schema={inputs.schema}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "data",
                    "type": "string",
                    "value": "",
                    "label": "Update Data",
                    "placeholder": '{"column1": "new_value1", "column2": "new_value2"}',
                    "helper_text": "JSON object with column-value pairs to update",
                },
                {
                    "field": "where_clause",
                    "type": "string",
                    "value": "",
                    "label": "WHERE Condition",
                    "placeholder": "id = 123",
                    "helper_text": "WHERE condition to identify records to update",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 0,
                    "label": "Update Limit",
                    "helper_text": "Maximum number of rows to update (0 for no limit)",
                },
            ],
            "outputs": [
                {
                    "field": "affected_rows",
                    "type": "int32",
                    "helper_text": "Number of rows updated",
                },
                {
                    "field": "sql_query",
                    "type": "string",
                    "helper_text": "Generated SQL query",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the update operation succeeded",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Snowflake",
                },
            ],
            "name": "update",
            "task_name": "tasks.snowflake.update",
            "description": "Update existing data in a Snowflake table",
            "label": "Update Data",
            "variant": "common_integration_nodes",
            "required": ["warehouse", "table_name", "data", "where_clause"],
            "inputs_sort_order": [
                "integration",
                "action",
                "warehouse",
                "database",
                "schema",
                "table_name",
                "data",
                "where_clause",
                "limit",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        data: str = "",
        database: str = "",
        limit: int = 0,
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        return_id: bool = False,
        schema: str = "",
        sql_generation_model: str = "gpt-4-turbo-preview",
        table_name: str = "",
        warehouse: str = "",
        where_clause: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_snowflake",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if warehouse is not None:
            self.inputs["warehouse"] = warehouse
        if database is not None:
            self.inputs["database"] = database
        if schema is not None:
            self.inputs["schema"] = schema
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if table_name is not None:
            self.inputs["table_name"] = table_name
        if data is not None:
            self.inputs["data"] = data
        if return_id is not None:
            self.inputs["return_id"] = return_id
        if where_clause is not None:
            self.inputs["where_clause"] = where_clause
        if limit is not None:
            self.inputs["limit"] = limit
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationSnowflakeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_pinecone")
class IntegrationPineconeNode(Node):
    """
    Pinecone

    ## Inputs
    ### Common Inputs
        action: The action input
        integration: Connect to your account
    ### query_pinecone
        embedding_model: Select the embedding model to use to embed the query
        index: The Pinecone index to query
        namespace: Select the namespace to query (queries across all namespaces if left empty)
        query: Natural Language query

    ## Outputs
    ### query_pinecone
        output: Query output in Langchain-style documents
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "The action input",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Pinecone>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "query_pinecone": {
            "inputs": [
                {
                    "field": "embedding_model",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Embedding Model",
                    "helper_text": "Select the embedding model to use to embed the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {
                                "label": "OpenAI Text Embedding 3 Small",
                                "value": "openai/text-embedding-3-small",
                            },
                            {
                                "label": "OpenAI Text Embedding 3 Large",
                                "value": "openai/text-embedding-3-large",
                            },
                            {
                                "label": "OpenAI Text Embedding Ada 002",
                                "value": "openai/text-embedding-ada-002",
                            },
                            {
                                "label": "Cohere Embed English v3.0",
                                "value": "cohere/embed-english-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual v3.0",
                                "value": "cohere/embed-multilingual-v3.0",
                            },
                            {
                                "label": "Cohere Embed English Light v3.0",
                                "value": "cohere/embed-english-light-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual Light v3.0",
                                "value": "cohere/embed-multilingual-light-v3.0",
                            },
                        ],
                    },
                },
                {
                    "field": "index",
                    "type": "string",
                    "value": "",
                    "label": "Index",
                    "helper_text": "The Pinecone index to query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=index&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "namespace",
                    "type": "string",
                    "value": "",
                    "label": "Namespace",
                    "helper_text": "Select the namespace to query (queries across all namespaces if left empty)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=namespace&index={inputs.index}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“Birthday parties in March”",
                    "helper_text": "Natural Language query",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "any",
                    "helper_text": "Query output in Langchain-style documents",
                }
            ],
            "name": "query_pinecone",
            "task_name": "tasks.vectordbs.integrations.pinecone.query",
            "description": "Query Pinecone data",
            "label": "Query Pinecone",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        embedding_model: str = "",
        index: str = "",
        namespace: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_pinecone",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if index is not None:
            self.inputs["index"] = index
        if namespace is not None:
            self.inputs["namespace"] = namespace
        if query is not None:
            self.inputs["query"] = query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPineconeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_postgres")
class IntegrationPostgresNode(Node):
    """
    Postgres

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### select
        columns: Choose specific columns
        limit: Maximum number of rows to return
        order_by: Optional ORDER BY clause
        table_name: Choose the table to query
        where_clause: Optional WHERE condition (without WHERE keyword)
    ### delete
        confirm_delete: Confirm that you want to delete the specified records
        delete_entire_table: WARNING: This will drop the entire table
        limit: Maximum number of rows to return
        table_name: Choose the table to query
        where_clause: Optional WHERE condition (without WHERE keyword)
    ### insert_or_update
        conflict_columns: Comma-separated column names that define uniqueness constraint
        data: JSON object with column-value pairs to insert
        table_name: Choose the table to query
    ### insert
        data: JSON object with column-value pairs to insert
        return_id: Return the ID of the inserted record
        table_name: Choose the table to query
    ### update
        data: JSON object with column-value pairs to insert
        limit: Maximum number of rows to return
        table_name: Choose the table to query
        where_clause: Optional WHERE condition (without WHERE keyword)
    ### execute_query
        parameters: Parameters for parameterized queries (optional)
        sql_query: SQL query to execute
    ### nl
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### raw_sql
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### nl_agent
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### describe_table
        table_name: Choose the table to query

    ## Outputs
    ### Common Outputs
        output: Query results in Markdown format
    ### insert
        affected_rows: Number of rows inserted
        inserted_id: ID of the inserted record (if available)
        raw_data: Raw response from database
        sql_query: Generated SQL query
        success: Whether the insert operation succeeded
    ### update
        affected_rows: Number of rows updated
        raw_data: Raw response from database
        sql_query: Generated SQL query
        success: Whether the update operation succeeded
    ### delete
        affected_rows: Number of rows deleted
        raw_data: Raw response from database
        sql_query: Generated SQL query
        success: Whether the delete operation succeeded
        table_dropped: Whether the entire table was dropped
    ### insert_or_update
        affected_rows: Number of rows affected
        raw_data: Raw response from database
        record_id: ID of the inserted or updated record (if available)
        sql_query: Generated SQL query
        success: Whether the operation succeeded
    ### execute_query
        columns: Column names in the result set
        execution_time: Query execution time in seconds
        raw_data: Raw JSON response
        results: Query results as JSON
        row_count: Number of rows returned
        sql_query: The executed SQL query
        success: Whether the query executed successfully
    ### select
        columns: Column names in the result set
        raw_data: Raw JSON response
        results: Selected data as JSON
        row_count: Number of rows returned
        sql_query: Generated SQL query
    ### describe_table
        columns: List of column names
        raw_data: Raw schema data
        row_count: Approximate number of rows in the table
        schema: Detailed table schema information
        table_type: Type of table (BASE TABLE, VIEW, etc.)
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Postgres>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Query results in Markdown format"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query to be converted to SQL",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query for the LLM agent to process",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.postgres.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
        "execute_query": {
            "inputs": [
                {
                    "field": "sql_query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT * FROM users WHERE age > 21",
                    "helper_text": "SQL query to execute",
                },
                {
                    "field": "parameters",
                    "type": "vec<string>",
                    "value": [],
                    "label": "Query Parameters",
                    "helper_text": "Parameters for parameterized queries (optional)",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Query results in Markdown format",
                },
                {
                    "field": "results",
                    "type": "string",
                    "helper_text": "Query results as JSON",
                },
                {
                    "field": "row_count",
                    "type": "int32",
                    "helper_text": "Number of rows returned",
                },
                {
                    "field": "columns",
                    "type": "vec<string>",
                    "helper_text": "Column names in the result set",
                },
                {
                    "field": "execution_time",
                    "type": "float64",
                    "helper_text": "Query execution time in seconds",
                },
                {
                    "field": "sql_query",
                    "type": "string",
                    "helper_text": "The executed SQL query",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the query executed successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw JSON response",
                },
            ],
            "name": "execute_query",
            "task_name": "tasks.postgres.execute_query",
            "description": "Execute a custom SQL query",
            "label": "Execute Query",
            "variant": "common_integration_nodes",
            "required": ["sql_query"],
            "inputs_sort_order": ["integration", "action", "sql_query", "parameters"],
        },
        "select": {
            "inputs": [
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "placeholder": "Select table",
                    "helper_text": "Choose the table to query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=table_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "columns",
                    "type": "string",
                    "value": "",
                    "label": "Columns",
                    "placeholder": "Select columns",
                    "helper_text": "Choose specific columns",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=columns&table={inputs.table_name}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "where_clause",
                    "type": "string",
                    "value": "",
                    "label": "WHERE Condition",
                    "placeholder": "column = 'value'",
                    "helper_text": "Optional WHERE condition (without WHERE keyword)",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "label": "ORDER BY",
                    "placeholder": "column_name ASC",
                    "helper_text": "Optional ORDER BY clause",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Maximum number of rows to return",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Query results in Markdown format",
                },
                {
                    "field": "results",
                    "type": "string",
                    "helper_text": "Selected data as JSON",
                },
                {
                    "field": "row_count",
                    "type": "int32",
                    "helper_text": "Number of rows returned",
                },
                {
                    "field": "columns",
                    "type": "vec<string>",
                    "helper_text": "Column names in the result set",
                },
                {
                    "field": "sql_query",
                    "type": "string",
                    "helper_text": "Generated SQL query",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw JSON response",
                },
            ],
            "name": "select",
            "task_name": "tasks.postgres.select",
            "description": "Select data from a specific table with optional filtering and ordering",
            "label": "Select",
            "variant": "common_integration_nodes",
            "required": ["table_name", "columns", "limit"],
            "inputs_sort_order": [
                "integration",
                "action",
                "table_name",
                "columns",
                "where_clause",
                "order_by",
                "limit",
            ],
        },
        "insert": {
            "inputs": [
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "placeholder": "Select table",
                    "helper_text": "Choose the table to insert into",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=table_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "data",
                    "type": "string",
                    "value": "",
                    "label": "Data",
                    "placeholder": '{"column1": "value1", "column2": "value2"}',
                    "helper_text": "JSON object with column-value pairs to insert",
                },
                {
                    "field": "return_id",
                    "type": "bool",
                    "value": True,
                    "label": "Return ID",
                    "helper_text": "Return the ID of the inserted record",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Success message with details",
                },
                {
                    "field": "inserted_id",
                    "type": "string",
                    "helper_text": "ID of the inserted record (if available)",
                },
                {
                    "field": "affected_rows",
                    "type": "int32",
                    "helper_text": "Number of rows inserted",
                },
                {
                    "field": "sql_query",
                    "type": "string",
                    "helper_text": "Generated SQL query",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the insert operation succeeded",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from database",
                },
            ],
            "name": "insert",
            "task_name": "tasks.postgres.insert",
            "description": "Insert new data into a database table",
            "label": "Insert",
            "variant": "common_integration_nodes",
            "required": ["table_name", "data"],
            "inputs_sort_order": [
                "integration",
                "action",
                "table_name",
                "data",
                "return_id",
            ],
        },
        "update": {
            "inputs": [
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "placeholder": "Select table",
                    "helper_text": "Choose the table to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=table_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "data",
                    "type": "string",
                    "value": "",
                    "label": "Update Data",
                    "placeholder": '{"column1": "new_value1", "column2": "new_value2"}',
                    "helper_text": "JSON object with column-value pairs to update",
                },
                {
                    "field": "where_clause",
                    "type": "string",
                    "value": "",
                    "label": "WHERE Condition",
                    "placeholder": "id = 123",
                    "helper_text": "WHERE condition to identify records to update",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 0,
                    "label": "Update Limit",
                    "helper_text": "Maximum number of rows to update (0 for no limit)",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Success message with details",
                },
                {
                    "field": "affected_rows",
                    "type": "int32",
                    "helper_text": "Number of rows updated",
                },
                {
                    "field": "sql_query",
                    "type": "string",
                    "helper_text": "Generated SQL query",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the update operation succeeded",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from database",
                },
            ],
            "name": "update",
            "task_name": "tasks.postgres.update",
            "description": "Update existing data in a database table",
            "label": "Update",
            "variant": "common_integration_nodes",
            "required": ["table_name", "data", "where_clause", "limit"],
            "inputs_sort_order": [
                "integration",
                "action",
                "table_name",
                "data",
                "where_clause",
                "limit",
            ],
        },
        "delete": {
            "inputs": [
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "placeholder": "Select table",
                    "helper_text": "Choose the table to delete from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=table_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "where_clause",
                    "type": "string",
                    "value": "",
                    "label": "WHERE Condition",
                    "placeholder": "id = 123",
                    "helper_text": "WHERE condition to identify records to delete (leave empty to drop entire table)",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 0,
                    "label": "Delete Limit",
                    "helper_text": "Maximum number of rows to delete (0 for no limit)",
                },
                {
                    "field": "delete_entire_table",
                    "type": "bool",
                    "value": False,
                    "label": "Drop Entire Table",
                    "helper_text": "WARNING: This will drop the entire table",
                },
                {
                    "field": "confirm_delete",
                    "type": "bool",
                    "value": False,
                    "label": "Confirm Delete",
                    "helper_text": "Confirm that you want to delete the specified records",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Success message with details",
                },
                {
                    "field": "affected_rows",
                    "type": "int32",
                    "helper_text": "Number of rows deleted",
                },
                {
                    "field": "sql_query",
                    "type": "string",
                    "helper_text": "Generated SQL query",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the delete operation succeeded",
                },
                {
                    "field": "table_dropped",
                    "type": "bool",
                    "helper_text": "Whether the entire table was dropped",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from database",
                },
            ],
            "name": "delete",
            "task_name": "tasks.postgres.delete",
            "description": "Delete data from a database table or drop the entire table",
            "label": "Delete",
            "variant": "common_integration_nodes",
            "required": ["table_name", "confirm_delete", "limit"],
            "inputs_sort_order": [
                "integration",
                "action",
                "table_name",
                "where_clause",
                "limit",
                "delete_entire_table",
                "confirm_delete",
            ],
        },
        "insert_or_update": {
            "inputs": [
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "placeholder": "Select table",
                    "helper_text": "Choose the table to insert or update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=table_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "data",
                    "type": "string",
                    "value": "",
                    "label": "Data",
                    "placeholder": '{"id": 1, "name": "John", "email": "john@example.com"}',
                    "helper_text": "JSON object with column-value pairs to insert or update",
                },
                {
                    "field": "conflict_columns",
                    "type": "string",
                    "value": "id",
                    "label": "Conflict Columns",
                    "placeholder": "id",
                    "helper_text": "Comma-separated column names that define uniqueness constraint",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Success message with details",
                },
                {
                    "field": "record_id",
                    "type": "string",
                    "helper_text": "ID of the inserted or updated record (if available)",
                },
                {
                    "field": "affected_rows",
                    "type": "int32",
                    "helper_text": "Number of rows affected",
                },
                {
                    "field": "sql_query",
                    "type": "string",
                    "helper_text": "Generated SQL query",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation succeeded",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from database",
                },
            ],
            "name": "insert_or_update",
            "task_name": "tasks.postgres.insert_or_update",
            "description": "Insert new data or update existing data using PostgreSQL's ON CONFLICT feature",
            "label": "Insert or Update",
            "variant": "common_integration_nodes",
            "required": ["table_name", "data", "conflict_columns"],
            "inputs_sort_order": [
                "integration",
                "action",
                "table_name",
                "data",
                "conflict_columns",
            ],
        },
        "describe_table": {
            "inputs": [
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "placeholder": "Select table",
                    "helper_text": "Choose the table to describe",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=table_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Table schema information in readable format",
                },
                {
                    "field": "columns",
                    "type": "vec<string>",
                    "helper_text": "List of column names",
                },
                {
                    "field": "schema",
                    "type": "string",
                    "helper_text": "Detailed table schema information",
                },
                {
                    "field": "row_count",
                    "type": "int32",
                    "helper_text": "Approximate number of rows in the table",
                },
                {
                    "field": "table_type",
                    "type": "string",
                    "helper_text": "Type of table (BASE TABLE, VIEW, etc.)",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw schema data",
                },
            ],
            "name": "describe_table",
            "task_name": "tasks.postgres.describe_table",
            "description": "Get detailed information about a database table structure",
            "label": "Describe Table",
            "variant": "common_integration_nodes",
            "required": ["table_name"],
            "inputs_sort_order": ["integration", "action", "table_name"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        columns: str = "",
        confirm_delete: bool = False,
        conflict_columns: str = "id",
        data: str = "",
        delete_entire_table: bool = False,
        limit: int = 10,
        order_by: str = "",
        parameters: List[str] = [],
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        return_id: bool = True,
        sql_generation_model: str = "gpt-4-turbo-preview",
        sql_query: str = "",
        table_name: str = "",
        where_clause: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_postgres",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if sql_query is not None:
            self.inputs["sql_query"] = sql_query
        if parameters is not None:
            self.inputs["parameters"] = parameters
        if table_name is not None:
            self.inputs["table_name"] = table_name
        if columns is not None:
            self.inputs["columns"] = columns
        if where_clause is not None:
            self.inputs["where_clause"] = where_clause
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if limit is not None:
            self.inputs["limit"] = limit
        if data is not None:
            self.inputs["data"] = data
        if return_id is not None:
            self.inputs["return_id"] = return_id
        if delete_entire_table is not None:
            self.inputs["delete_entire_table"] = delete_entire_table
        if confirm_delete is not None:
            self.inputs["confirm_delete"] = confirm_delete
        if conflict_columns is not None:
            self.inputs["conflict_columns"] = conflict_columns
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationPostgresNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mysql")
class IntegrationMysqlNode(Node):
    """
    MySQL

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### nl
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### raw_sql
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input
    ### nl_agent
        query: Natural language query to be converted to SQL
        query_agent_model: The query_agent_model input
        query_type: The query_type input
        sql_generation_model: The sql_generation_model input

    ## Outputs
    ### Common Outputs
        output: Query results in Markdown table format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<MySQL>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Query results in Markdown table format"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "nl": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query to be converted to SQL",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Generate and execute a SQL query",
            "label": "Natural Language Query",
        },
        "raw_sql": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "SQL Query to execute",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "raw_sql",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Execute a SQL query",
            "label": "Raw SQL Query",
        },
        "nl_agent": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "select * from dummy_table",
                    "helper_text": "Natural language query for the LLM agent to process",
                },
                {
                    "field": "query_type",
                    "type": "string",
                    "value": "Raw SQL",
                    "label": "Query Type",
                    "hidden": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "sql_generation_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "SQL Generation Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "query_agent_model",
                    "type": "string",
                    "value": "gpt-4-turbo-preview",
                    "label": "Query Agent Model",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
            ],
            "outputs": [],
            "name": "nl_agent",
            "task_name": "tasks.tables.integrations.mysql.query",
            "description": "Let an LLM agent query the database",
            "label": "Natural Language Agent",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        query: str = "",
        query_agent_model: str = "gpt-4-turbo-preview",
        query_type: str = "Raw SQL",
        sql_generation_model: str = "gpt-4-turbo-preview",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mysql",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if query_type is not None:
            self.inputs["query_type"] = query_type
        if sql_generation_model is not None:
            self.inputs["sql_generation_model"] = sql_generation_model
        if query_agent_model is not None:
            self.inputs["query_agent_model"] = query_agent_model
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMysqlNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_wordpress")
class IntegrationWordpressNode(Node):
    """
    Wordpress

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_post
        post_content: The content of the post
        post_title: The title of the post
        wordpress_url: Wordpress domain URL

    ## Outputs
    ### create_post
        post_url: URL of the created WordPress post
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Wordpress>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_post": {
            "inputs": [
                {
                    "field": "wordpress_url",
                    "type": "string",
                    "value": "",
                    "label": "Wordpress URL",
                    "placeholder": "test.wordpress.com",
                    "helper_text": "Wordpress domain URL",
                    "agent_field_type": "static",
                },
                {
                    "field": "post_title",
                    "type": "string",
                    "value": "",
                    "label": "Post Title",
                    "placeholder": "An overview of Generative AI",
                    "helper_text": "The title of the post",
                },
                {
                    "field": "post_content",
                    "type": "string",
                    "value": "",
                    "label": "Post Content",
                    "placeholder": "This is an overview...",
                    "helper_text": "The content of the post",
                },
            ],
            "outputs": [
                {
                    "field": "post_url",
                    "type": "string",
                    "helper_text": "URL of the created WordPress post",
                }
            ],
            "name": "create_post",
            "task_name": "tasks.wordpress.create_post",
            "description": "Create post on Wordpress site",
            "label": "Post to Wordpress",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        post_content: str = "",
        post_title: str = "",
        wordpress_url: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_wordpress",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if wordpress_url is not None:
            self.inputs["wordpress_url"] = wordpress_url
        if post_title is not None:
            self.inputs["post_title"] = post_title
        if post_content is not None:
            self.inputs["post_content"] = post_content
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationWordpressNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_linkedin")
class IntegrationLinkedinNode(Node):
    """
    Linkedin

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_text_share
        post_text: Content you wanted to post on your LinkedIn

    ## Outputs
    ### create_text_share
        output: URL of the created LinkedIn post
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Linkedin>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "create_text_share": {
            "inputs": [
                {
                    "field": "post_text",
                    "type": "string",
                    "value": "",
                    "label": "Post Text",
                    "placeholder": "“I just got a new job!”",
                    "helper_text": "Content you wanted to post on your LinkedIn",
                }
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "URL of the created LinkedIn post",
                }
            ],
            "name": "create_text_share",
            "task_name": "tasks.linkedin.create_text_share",
            "description": "Create text post on LinkedIn",
            "label": "Post to LinkedIn",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        post_text: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_linkedin",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if post_text is not None:
            self.inputs["post_text"] = post_text
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationLinkedinNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_calendar")
class IntegrationGoogleCalendarNode(Node):
    """
    Google Calendar

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'new_event'
        all_day_event: Toggle to set the event as an all-day event
        attendees: Email IDs of attendees (comma separated)
        calendar: Select the calendar to add the new event to
        description: The description of the event
        duration: The duration of the event (positive integer). Default: 30 (in minutes)
        event_name: The name of the calendar event
        location: Physical location or the meeting location (like Zoom)
        start_datetime: The start time of the calendar event (format: YYYY-MM-DD for full day event or YYYY-MM-DDTHH:MM:SS for specific time)
    ### When action = 'check_availability'
        calendar: Select the calendar to add the new event to
        end_date_and_time: The last date and end time for everyday to look for availability
        slot_duration: The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)
        start_date_and_time: The first date and start time for everyday to look for availability
        timezone: IANA Time Zone code (e.g., US/Eastern)
    ### When action = 'read_event'
        calendar: Select the calendar to add the new event to
        event_id: The ID of the event to read
    ### When action = 'get_events'
        calendar: Select the calendar to add the new event to
        query: Return only events that contain these keywords
        use_date: Toggle to use dates
    ### When action = 'update_event'
        calendar: Select the calendar to add the new event to
        end_time: New end time for the event (RFC3339 format)
        event_id: The ID of the event to read
        send_notifications: Whether to send notifications about the changes
        send_updates: Whether to send notifications about the update to attendees
        start_time: New start time for the event (RFC3339 format)
        update_attendees: New attendee list (comma-separated emails)
        update_color_id: New color ID for the event (1-11)
        update_description: New description for the event
        update_guests_can_invite_others: Whether guests can invite other attendees
        update_guests_can_modify: Whether guests can modify the event
        update_guests_can_see_other_guests: Whether guests can see other attendees
        update_location: New location for the event
        update_max_attendees: Maximum number of attendees
        update_show_me_as: How to show the time slot (opaque=busy, transparent=free)
        update_summary: New title/summary for the event
        update_visibility: New visibility setting for the event
    ### When action = 'delete_event'
        calendar: Select the calendar to add the new event to
        event_id: The ID of the event to read
        send_updates: Whether to send notifications about the update to attendees
    ### When action = 'get_events' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'get_events' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'get_events' and use_date = False
        num_messages: Specify the last n numbers of events
    ### When action = 'get_events' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_event'
        attendees: List of attendee email addresses
        creator: The creator's email address
        description: The description of the event
        end_time: The end time of the event
        event_id: The ID of the event
        location: The location of the event
        organizer: The organizer's email address
        raw_data: Raw event data from Google Calendar
        start_time: The start time of the event
        status: The status of the event
        summary: The title/summary of the event
    ### When action = 'get_events'
        attendees: List of event attendees
        details: List of event details
        end_times: List of event end times
        event_ids: List of event IDs
        locations: List of event locations
        organizers: List of event organizers
        start_times: List of event start times
        summaries: List of event summaries
    ### When action = 'update_event'
        attendees: List of updated attendee email addresses
        creator: The creator's email address
        description: The updated description of the event
        end_time: The updated end time of the event
        event_id: The ID of the updated event
        location: The updated location of the event
        organizer: The organizer's email address
        raw_data: Raw updated event data from Google Calendar
        start_time: The updated start time of the event
        status: The status of the event
        summary: The updated title/summary of the event
    ### When action = 'delete_event'
        event_id: The ID of the deleted event
        message: Success message
        success: Whether the deletion was successful
    ### When action = 'new_event'
        output: Calendar event link
    ### When action = 'check_availability'
        output: List of available time slots
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Calendar>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_event**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to add the new event to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "event_name",
                    "type": "string",
                    "value": "",
                    "label": "Event Name",
                    "placeholder": "Meeting with John Doe",
                    "helper_text": "The name of the calendar event",
                    "order": 4,
                },
                {
                    "field": "all_day_event",
                    "type": "bool",
                    "value": False,
                    "label": "All Day Event",
                    "helper_text": "Toggle to set the event as an all-day event",
                    "order": 5,
                },
                {
                    "field": "start_datetime",
                    "type": "timestamp",
                    "value": -1,
                    "label": "Start Datetime",
                    "placeholder": "2024-06-24 (full day event) or 2024-06-24T19:00:00",
                    "helper_text": "The start time of the calendar event (format: YYYY-MM-DD for full day event or YYYY-MM-DDTHH:MM:SS for specific time)",
                    "order": 6,
                },
                {
                    "field": "duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of the event (positive integer). Default: 30 (in minutes)",
                    "order": 7,
                },
                {
                    "field": "attendees",
                    "type": "string",
                    "value": "",
                    "label": "Attendees",
                    "placeholder": "abc@example.com,xyz@example.com,",
                    "helper_text": "Email IDs of attendees (comma separated)",
                    "order": 8,
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "800 Howard St., San Francisco, CA 94103",
                    "helper_text": "Physical location or the meeting location (like Zoom)",
                    "order": 9,
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "placeholder": "Monthly sync",
                    "helper_text": "The description of the event",
                    "order": 10,
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Calendar event link",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "new_event",
            "task_name": "tasks.google_calendar.create_event",
            "description": "Create a new event",
            "label": "New Event",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "event_name",
                "all_day_event",
                "start_datetime",
                "duration",
                "attendees",
                "location",
                "description",
            ],
        },
        "check_availability**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to check availability",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "start_date_and_time",
                    "type": "timestamp",
                    "value": -1,
                    "label": "Start Date & Start Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The first date and start time for everyday to look for availability",
                    "order": 4,
                },
                {
                    "field": "end_date_and_time",
                    "type": "timestamp",
                    "value": -1,
                    "label": "End Date & End Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The last date and end time for everyday to look for availability",
                    "order": 5,
                },
                {
                    "field": "slot_duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Slot Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)",
                    "order": 6,
                },
                {
                    "field": "timezone",
                    "type": "enum<string>",
                    "value": "US/Eastern",
                    "label": "Timezone",
                    "placeholder": "US/Eastern",
                    "helper_text": "IANA Time Zone code (e.g., US/Eastern)",
                    "component": {"type": "dropdown", "referenced_options": "timezone"},
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of available time slots",
                }
            ],
            "variant": "common_integration_nodes",
            "name": "check_availability",
            "task_name": "tasks.google_calendar.check_availability",
            "description": "Check Google calendar availability",
            "label": "Check Availability",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "start_date_and_time",
                "end_date_and_time",
                "slot_duration",
                "timezone",
            ],
        },
        "read_event**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to read the event from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "event_id",
                    "type": "string",
                    "value": "",
                    "label": "Event ID",
                    "placeholder": "Event ID from Google Calendar",
                    "helper_text": "The ID of the event to read",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "event_id",
                    "type": "string",
                    "helper_text": "The ID of the event",
                },
                {
                    "field": "summary",
                    "type": "string",
                    "helper_text": "The title/summary of the event",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "The description of the event",
                },
                {
                    "field": "location",
                    "type": "string",
                    "helper_text": "The location of the event",
                },
                {
                    "field": "start_time",
                    "type": "timestamp",
                    "helper_text": "The start time of the event",
                },
                {
                    "field": "end_time",
                    "type": "timestamp",
                    "helper_text": "The end time of the event",
                },
                {
                    "field": "organizer",
                    "type": "string",
                    "helper_text": "The organizer's email address",
                },
                {
                    "field": "creator",
                    "type": "string",
                    "helper_text": "The creator's email address",
                },
                {
                    "field": "attendees",
                    "type": "vec<string>",
                    "helper_text": "List of attendee email addresses",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "The status of the event",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw event data from Google Calendar",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_event",
            "hidden": True,
            "task_name": "tasks.google_calendar.read_event",
            "description": "Read a Google calendar event",
            "label": "Read Event",
            "inputs_sort_order": ["integration", "action", "calendar", "event_id"],
        },
        "get_events**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to read events from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "helper_text": "Return only events that contain these keywords",
                    "placeholder": "Keywords to filter events",
                },
            ],
            "outputs": [
                {
                    "field": "event_ids",
                    "type": "vec<string>",
                    "helper_text": "List of event IDs",
                },
                {
                    "field": "summaries",
                    "type": "vec<string>",
                    "helper_text": "List of event summaries",
                },
                {
                    "field": "start_times",
                    "type": "vec<string>",
                    "helper_text": "List of event start times",
                },
                {
                    "field": "end_times",
                    "type": "vec<string>",
                    "helper_text": "List of event end times",
                },
                {
                    "field": "locations",
                    "type": "vec<string>",
                    "helper_text": "List of event locations",
                },
                {
                    "field": "organizers",
                    "type": "vec<string>",
                    "helper_text": "List of event organizers",
                },
                {
                    "field": "attendees",
                    "type": "vec<vec<string>>",
                    "helper_text": "List of event attendees",
                },
                {
                    "field": "details",
                    "type": "vec<string>",
                    "helper_text": "List of event details",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_events",
            "task_name": "tasks.google_calendar.get_events",
            "description": "Get events from Google Calendar",
            "label": "Get Events",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
            ],
        },
        "get_events**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Events",
                    "helper_text": "Specify the last n numbers of events",
                }
            ],
            "outputs": [],
        },
        "get_events**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_events**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "hidden": True,
                    "label": "Date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_events**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "label": "Exact date",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "update_event**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar containing the event to update",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "event_id",
                    "type": "string",
                    "value": "",
                    "label": "Event ID",
                    "placeholder": "Event ID from Google Calendar",
                    "helper_text": "The ID of the event to update",
                    "order": 4,
                },
                {
                    "field": "update_summary",
                    "type": "string",
                    "value": "",
                    "label": "Update Summary",
                    "placeholder": "New event title",
                    "helper_text": "New title/summary for the event",
                    "order": 5,
                },
                {
                    "field": "update_description",
                    "type": "string",
                    "value": "",
                    "label": "Update Description",
                    "placeholder": "New event description",
                    "helper_text": "New description for the event",
                    "order": 6,
                },
                {
                    "field": "update_location",
                    "type": "string",
                    "value": "",
                    "label": "Update Location",
                    "placeholder": "New event location",
                    "helper_text": "New location for the event",
                    "order": 7,
                },
                {
                    "field": "start_time",
                    "type": "timestamp",
                    "value": -1,
                    "label": "Start Time",
                    "placeholder": "2024-06-24T19:00:00",
                    "helper_text": "New start time for the event (RFC3339 format)",
                    "order": 8,
                },
                {
                    "field": "end_time",
                    "type": "timestamp",
                    "value": -1,
                    "label": "End Time",
                    "placeholder": "2024-06-24T20:00:00",
                    "helper_text": "New end time for the event (RFC3339 format)",
                    "order": 9,
                },
                {
                    "field": "update_attendees",
                    "type": "string",
                    "value": "",
                    "label": "Update Attendees",
                    "placeholder": "email1@example.com,email2@example.com",
                    "helper_text": "New attendee list (comma-separated emails)",
                    "order": 10,
                },
                {
                    "field": "update_visibility",
                    "type": "string",
                    "value": "",
                    "label": "Update Visibility",
                    "helper_text": "New visibility setting for the event",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Default", "value": "default"},
                            {"label": "Public", "value": "public"},
                            {"label": "Private", "value": "private"},
                        ],
                    },
                    "order": 11,
                },
                {
                    "field": "update_color_id",
                    "type": "string",
                    "value": "",
                    "label": "Update Color ID",
                    "placeholder": "1-11",
                    "helper_text": "New color ID for the event (1-11)",
                    "order": 12,
                },
                {
                    "field": "update_guests_can_invite_others",
                    "type": "bool",
                    "value": False,
                    "label": "Guests Can Invite Others",
                    "helper_text": "Whether guests can invite other attendees",
                    "order": 13,
                },
                {
                    "field": "update_guests_can_modify",
                    "type": "bool",
                    "value": False,
                    "label": "Guests Can Modify",
                    "helper_text": "Whether guests can modify the event",
                    "order": 14,
                },
                {
                    "field": "update_guests_can_see_other_guests",
                    "type": "bool",
                    "value": False,
                    "label": "Guests Can See Other Guests",
                    "helper_text": "Whether guests can see other attendees",
                    "order": 15,
                },
                {
                    "field": "update_show_me_as",
                    "type": "string",
                    "value": "",
                    "label": "Show Me As",
                    "helper_text": "How to show the time slot (opaque=busy, transparent=free)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Opaque", "value": "opaque"},
                            {"label": "Transparent", "value": "transparent"},
                        ],
                    },
                    "order": 16,
                },
                {
                    "field": "update_max_attendees",
                    "type": "int32",
                    "value": 0,
                    "label": "Max Attendees",
                    "placeholder": "0",
                    "helper_text": "Maximum number of attendees",
                    "order": 17,
                },
                {
                    "field": "send_updates",
                    "type": "string",
                    "value": "",
                    "label": "Send Updates",
                    "helper_text": "Whether to send notifications about the update to attendees",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "All", "value": "all"},
                            {"label": "External Only", "value": "externalOnly"},
                            {"label": "None", "value": "none"},
                        ],
                    },
                    "order": 18,
                },
                {
                    "field": "send_notifications",
                    "type": "bool",
                    "value": False,
                    "label": "Send Notifications",
                    "helper_text": "Whether to send notifications about the changes",
                    "order": 19,
                },
            ],
            "outputs": [
                {
                    "field": "event_id",
                    "type": "string",
                    "helper_text": "The ID of the updated event",
                },
                {
                    "field": "summary",
                    "type": "string",
                    "helper_text": "The updated title/summary of the event",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "The updated description of the event",
                },
                {
                    "field": "location",
                    "type": "string",
                    "helper_text": "The updated location of the event",
                },
                {
                    "field": "start_time",
                    "type": "timestamp",
                    "helper_text": "The updated start time of the event",
                },
                {
                    "field": "end_time",
                    "type": "timestamp",
                    "helper_text": "The updated end time of the event",
                },
                {
                    "field": "organizer",
                    "type": "string",
                    "helper_text": "The organizer's email address",
                },
                {
                    "field": "creator",
                    "type": "string",
                    "helper_text": "The creator's email address",
                },
                {
                    "field": "attendees",
                    "type": "vec<string>",
                    "helper_text": "List of updated attendee email addresses",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "The status of the event",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw updated event data from Google Calendar",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_event",
            "hidden": True,
            "task_name": "tasks.google_calendar.update_event",
            "description": "Update a Google calendar event",
            "label": "Update Event",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "event_id",
                "update_summary",
                "update_description",
                "update_location",
                "start_time",
                "end_time",
                "update_attendees",
                "update_visibility",
                "update_color_id",
                "update_guests_can_invite_others",
                "update_guests_can_modify",
                "update_guests_can_see_other_guests",
                "update_show_me_as",
                "update_max_attendees",
                "send_updates",
                "send_notifications",
            ],
        },
        "delete_event**(*)**(*)": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to delete the event from",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "event_id",
                    "type": "string",
                    "value": "",
                    "label": "Event ID",
                    "placeholder": "Event ID from Google Calendar",
                    "helper_text": "The ID of the event to delete",
                    "order": 4,
                },
                {
                    "field": "send_updates",
                    "type": "string",
                    "value": "none",
                    "placeholder": "None",
                    "label": "Send Updates",
                    "helper_text": "Whether to send notifications about the deletion to attendees",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "All", "value": "all"},
                            {"label": "External Only", "value": "externalOnly"},
                            {"label": "None", "value": "none"},
                        ],
                    },
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "event_id",
                    "type": "string",
                    "helper_text": "The ID of the deleted event",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "delete_event",
            "hidden": True,
            "task_name": "tasks.google_calendar.delete_event",
            "description": "Delete a Google calendar event",
            "label": "Delete Event",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "event_id",
                "send_updates",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        all_day_event: bool = False,
        attendees: str = "",
        calendar: Optional[str] = None,
        description: str = "",
        duration: int = 30,
        end_date_and_time: Any = -1,
        end_time: Any = -1,
        event_id: str = "",
        event_name: str = "",
        exact_date: Any = {"start": "", "end": ""},
        location: str = "",
        num_messages: int = 10,
        query: str = "",
        send_notifications: bool = False,
        send_updates: str = "",
        slot_duration: int = 30,
        start_date_and_time: Any = -1,
        start_datetime: Any = -1,
        start_time: Any = -1,
        timezone: str = "US/Eastern",
        update_attendees: str = "",
        update_color_id: str = "",
        update_description: str = "",
        update_guests_can_invite_others: bool = False,
        update_guests_can_modify: bool = False,
        update_guests_can_see_other_guests: bool = False,
        update_location: str = "",
        update_max_attendees: int = 0,
        update_show_me_as: str = "",
        update_summary: str = "",
        update_visibility: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_calendar",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if calendar is not None:
            self.inputs["calendar"] = calendar
        if event_name is not None:
            self.inputs["event_name"] = event_name
        if all_day_event is not None:
            self.inputs["all_day_event"] = all_day_event
        if start_datetime is not None:
            self.inputs["start_datetime"] = start_datetime
        if duration is not None:
            self.inputs["duration"] = duration
        if attendees is not None:
            self.inputs["attendees"] = attendees
        if location is not None:
            self.inputs["location"] = location
        if description is not None:
            self.inputs["description"] = description
        if start_date_and_time is not None:
            self.inputs["start_date_and_time"] = start_date_and_time
        if end_date_and_time is not None:
            self.inputs["end_date_and_time"] = end_date_and_time
        if slot_duration is not None:
            self.inputs["slot_duration"] = slot_duration
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if event_id is not None:
            self.inputs["event_id"] = event_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if query is not None:
            self.inputs["query"] = query
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if update_summary is not None:
            self.inputs["update_summary"] = update_summary
        if update_description is not None:
            self.inputs["update_description"] = update_description
        if update_location is not None:
            self.inputs["update_location"] = update_location
        if start_time is not None:
            self.inputs["start_time"] = start_time
        if end_time is not None:
            self.inputs["end_time"] = end_time
        if update_attendees is not None:
            self.inputs["update_attendees"] = update_attendees
        if update_visibility is not None:
            self.inputs["update_visibility"] = update_visibility
        if update_color_id is not None:
            self.inputs["update_color_id"] = update_color_id
        if update_guests_can_invite_others is not None:
            self.inputs["update_guests_can_invite_others"] = (
                update_guests_can_invite_others
            )
        if update_guests_can_modify is not None:
            self.inputs["update_guests_can_modify"] = update_guests_can_modify
        if update_guests_can_see_other_guests is not None:
            self.inputs["update_guests_can_see_other_guests"] = (
                update_guests_can_see_other_guests
            )
        if update_show_me_as is not None:
            self.inputs["update_show_me_as"] = update_show_me_as
        if update_max_attendees is not None:
            self.inputs["update_max_attendees"] = update_max_attendees
        if send_updates is not None:
            self.inputs["send_updates"] = send_updates
        if send_notifications is not None:
            self.inputs["send_notifications"] = send_notifications
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleCalendarNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_microsoft_calendar")
class IntegrationMicrosoftCalendarNode(Node):
    """
    Microsoft Calendar

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### new_event
        all_day_event: Toggle to set the event as an all-day event
        attendees: Email IDs of attendees (comma separated)
        body: Description or agenda of the event
        calendar: Select the calendar to add the new event to
        duration: The duration of the event in minutes. Default: 30 (in minutes)
        location: The location of the meeting
        start_datetime: The start date and time of the calendar event (format: YYYY-MM-DDTHH:MM:SS)
        subject: Name/Subject of the calendar event
    ### check_availability
        end_date_and_time: The last date and end time for everyday to look for availability
        slot_duration: The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)
        start_date_and_time: The first date and start time for everyday to look for availability
        timezone: IANA Time Zone code (e.g., US/Eastern)

    ## Outputs
    ### new_event
        output: Calendar event link
    ### check_availability
        output: List of available time slots with start and end datetimes
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Microsoft Calendar>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "new_event": {
            "inputs": [
                {
                    "field": "calendar",
                    "type": "string",
                    "label": "Calendar",
                    "helper_text": "Select the calendar to add the new event to",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=calendar&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Sprint planning",
                    "helper_text": "Name/Subject of the calendar event",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "This meeting is to discuss...",
                    "helper_text": "Description or agenda of the event",
                },
                {
                    "field": "start_datetime",
                    "type": "timestamp",
                    "value": "",
                    "label": "Start Datetime",
                    "placeholder": "2024-06-24T19:00:00",
                    "helper_text": "The start date and time of the calendar event (format: YYYY-MM-DDTHH:MM:SS)",
                },
                {
                    "field": "all_day_event",
                    "type": "bool",
                    "value": False,
                    "label": "All Day Event",
                    "helper_text": "Toggle to set the event as an all-day event",
                },
                {
                    "field": "duration",
                    "type": "int32",
                    "value": 30,
                    "label": "Duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of the event in minutes. Default: 30 (in minutes)",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "800 Howard St., San Francisco, CA 94103",
                    "helper_text": "The location of the meeting",
                },
                {
                    "field": "attendees",
                    "type": "string",
                    "value": "",
                    "label": "Attendees",
                    "placeholder": "abc@example.com,xyz@example.com",
                    "helper_text": "Email IDs of attendees (comma separated)",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Calendar event link",
                }
            ],
            "name": "new_event",
            "task_name": "tasks.microsoft_calendar.create_event",
            "description": "Create a new calendar event",
            "label": "New Event",
            "inputs_sort_order": [
                "integration",
                "action",
                "calendar",
                "subject",
                "body",
                "all_day_event",
                "start_datetime",
                "duration",
                "location",
                "attendees",
            ],
        },
        "check_availability": {
            "inputs": [
                {
                    "field": "start_date_and_time",
                    "type": "timestamp",
                    "value": "",
                    "label": "Start Date & Start Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The first date and start time for everyday to look for availability",
                },
                {
                    "field": "end_date_and_time",
                    "type": "timestamp",
                    "value": "",
                    "label": "End Date & End Work Time",
                    "placeholder": "2024-06-24",
                    "helper_text": "The last date and end time for everyday to look for availability",
                },
                {
                    "field": "slot_duration",
                    "type": "int32",
                    "value": "",
                    "label": "Slot duration",
                    "placeholder": "30 minutes",
                    "helper_text": "The duration of an individual slot to look for (in minutes). Default: 30 (in minutes)",
                },
                {
                    "field": "timezone",
                    "type": "enum<string>",
                    "value": "US/Eastern",
                    "label": "Timezone",
                    "placeholder": "US/Eastern",
                    "helper_text": "IANA Time Zone code (e.g., US/Eastern)",
                    "component": {"type": "dropdown", "referenced_options": "timezone"},
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "List of available time slots with start and end datetimes",
                }
            ],
            "name": "check_availability",
            "task_name": "tasks.microsoft_calendar.check_availability",
            "description": "Check Microsoft calendar availability",
            "label": "Check Availability",
            "inputs_sort_order": [
                "integration",
                "action",
                "timezone",
                "start_date_and_time",
                "end_date_and_time",
                "slot_duration",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        all_day_event: bool = False,
        attendees: str = "",
        body: str = "",
        calendar: Optional[str] = None,
        duration: int = 30,
        end_date_and_time: Any = None,
        location: str = "",
        slot_duration: int = None,
        start_date_and_time: Any = None,
        start_datetime: Any = None,
        subject: str = "",
        timezone: str = "US/Eastern",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_microsoft_calendar",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if calendar is not None:
            self.inputs["calendar"] = calendar
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if start_datetime is not None:
            self.inputs["start_datetime"] = start_datetime
        if all_day_event is not None:
            self.inputs["all_day_event"] = all_day_event
        if duration is not None:
            self.inputs["duration"] = duration
        if location is not None:
            self.inputs["location"] = location
        if attendees is not None:
            self.inputs["attendees"] = attendees
        if start_date_and_time is not None:
            self.inputs["start_date_and_time"] = start_date_and_time
        if end_date_and_time is not None:
            self.inputs["end_date_and_time"] = end_date_and_time
        if slot_duration is not None:
            self.inputs["slot_duration"] = slot_duration
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMicrosoftCalendarNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_mailgun")
class IntegrationMailgunNode(Node):
    """
    Mailgun

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### send_mail
        bcc_recipients: The email(s) of the recipient(s) you want to BCC the email to
        body: The body (message) of the email
        cc_recipients: The email(s) of the recipient(s) you want to CC the email to
        domain: Your Mailgun domain
        from_email: The email of the sender of the email
        from_name: The name of the sender of the email
        recipients: The email of the recipient you want to send the email to
        subject: The subject of the email
    ### add_contact_to_mailing_list
        email: The email of the contact to be added to the list
        list_name: The list the contact will be added to
        name: The name of contact to be added to the list

    ## Outputs
    ### send_mail
        output: Status of the email sending operation
    ### add_contact_to_mailing_list
        output: Status of the contact addition operation
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Mailgun>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "send_mail": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "label": "Domain",
                    "agent_field_type": "static",
                    "helper_text": "Your Mailgun domain",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=domain_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "subject",
                    "type": "string",
                    "value": "",
                    "label": "Subject",
                    "placeholder": "Important: Your Account Update",
                    "helper_text": "The subject of the email",
                },
                {
                    "field": "body",
                    "type": "string",
                    "value": "",
                    "label": "Body",
                    "placeholder": "Dear valued customer...",
                    "helper_text": "The body (message) of the email",
                },
                {
                    "field": "from_name",
                    "type": "string",
                    "value": "",
                    "label": "The name of the sender",
                    "placeholder": "John Smith",
                    "helper_text": "The name of the sender of the email",
                },
                {
                    "field": "from_email",
                    "type": "string",
                    "value": "",
                    "label": "The Email of the sender",
                    "placeholder": "john@company.com",
                    "helper_text": "The email of the sender of the email",
                },
                {
                    "field": "recipients",
                    "type": "string",
                    "value": "",
                    "label": "Recipients email address",
                    "placeholder": "recipient@example.com",
                    "helper_text": "The email of the recipient you want to send the email to",
                },
                {
                    "field": "cc_recipients",
                    "type": "string",
                    "value": "",
                    "label": "CC Recipients email address",
                    "placeholder": "cc1@example.com, cc2@example.com",
                    "helper_text": "The email(s) of the recipient(s) you want to CC the email to",
                },
                {
                    "field": "bcc_recipients",
                    "type": "string",
                    "value": "",
                    "label": "BCC Recipients email address",
                    "placeholder": "bcc1@example.com, bcc2@example.com",
                    "helper_text": "The email(s) of the recipient(s) you want to BCC the email to",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Status of the email sending operation",
                }
            ],
            "name": "send_mail",
            "task_name": "tasks.mailgun.send_mail",
            "description": "Send mail ",
            "label": "Send mail",
        },
        "add_contact_to_mailing_list": {
            "inputs": [
                {
                    "field": "list_name",
                    "type": "string",
                    "value": "",
                    "label": "Name of the mailing list",
                    "placeholder": "newsletter-subscribers",
                    "helper_text": "The list the contact will be added to",
                    "agent_field_type": "static",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name of the contact to add",
                    "placeholder": "John Smith",
                    "helper_text": "The name of contact to be added to the list",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email of the contact to add",
                    "placeholder": "john@example.com",
                    "helper_text": "The email of the contact to be added to the list",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "string",
                    "helper_text": "Status of the contact addition operation",
                }
            ],
            "name": "add_contact_to_mailing_list",
            "task_name": "tasks.mailgun.add_contact_to_mailing_list",
            "description": "Adds a contact to a Mailgun Mailing list",
            "label": "Add Contact to Mailing List",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        bcc_recipients: str = "",
        body: str = "",
        cc_recipients: str = "",
        domain: Optional[str] = None,
        email: str = "",
        from_email: str = "",
        from_name: str = "",
        list_name: str = "",
        name: str = "",
        recipients: str = "",
        subject: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_mailgun",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if domain is not None:
            self.inputs["domain"] = domain
        if subject is not None:
            self.inputs["subject"] = subject
        if body is not None:
            self.inputs["body"] = body
        if from_name is not None:
            self.inputs["from_name"] = from_name
        if from_email is not None:
            self.inputs["from_email"] = from_email
        if recipients is not None:
            self.inputs["recipients"] = recipients
        if cc_recipients is not None:
            self.inputs["cc_recipients"] = cc_recipients
        if bcc_recipients is not None:
            self.inputs["bcc_recipients"] = bcc_recipients
        if list_name is not None:
            self.inputs["list_name"] = list_name
        if name is not None:
            self.inputs["name"] = name
        if email is not None:
            self.inputs["email"] = email
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMailgunNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_slides")
class IntegrationGoogleSlidesNode(Node):
    """
    Google Slides

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### replace_text
        contains_text: The text to search for and replace
        match_case: Whether to match case when searching
        presentation_id: Select a presentation to read
        replace_text: The text to replace with
    ### read_thumbnail
        mime_type: Format of the thumbnail
        page_object_id: The object ID of the page/slide to read
        presentation_id: Select a presentation to read
        thumbnail_size: Size of the thumbnail
    ### read_page
        page_object_id: The object ID of the page/slide to read
        presentation_id: Select a presentation to read
    ### read_presentation
        presentation_id: Select a presentation to read
    ### get_slides
        presentation_id: Select a presentation to read
    ### create_presentation
        title: Title for the new presentation (defaults to 'Untitled Presentation')

    ## Outputs
    ### read_thumbnail
        file: The thumbnail image
        height: Height of the thumbnail
        page_id: The ID of the page
        presentation_id: The ID of the presentation
        raw_data: Raw API response data
        thumbnail_url: URL of the thumbnail image
        width: Width of the thumbnail
    ### read_page
        layout_properties: The layout properties
        notes_properties: The notes properties
        page_element_info: Information about page elements
        page_elements: The elements on the page
        page_id: The ID of the page
        presentation_id: The ID of the presentation
        raw_data: Raw API response data
        slide_content: The content of the slide
        slide_properties: The slide properties
        slide_title: The title of the slide
    ### read_presentation
        layouts: The layout slides
        locale: The locale of the presentation
        masters: The master slides
        page_size: The page size settings
        presentation_id: The ID of the presentation
        raw_data: Raw API response data
        slide_contents: The contents of the slides
        slide_info: Information about each slide
        slide_titles: The titles of the slides
        slides: The slides in the presentation
        title: The title of the presentation
    ### replace_text
        occurrences_changed: Number of occurrences that were replaced
        presentation_id: The ID of the presentation
        raw_data: Raw API response data
        replacement_text: The replacement text
        search_text: The text that was searched for
    ### create_presentation
        page_size: The page size settings of the presentation
        presentation_id: The ID of the created presentation
        raw_data: Raw API response data
        slides: The slides in the presentation
        title: The title of the presentation
    ### get_slides
        presentation_id: The ID of the presentation
        raw_data: Raw API response data
        slide_ids: The IDs of all slides
        slide_indexes: The indexes of all slides
        slides: All slides in the presentation
        total_slides: Total number of slides
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Slides>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "create_presentation": {
            "inputs": [
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Title",
                    "helper_text": "Title for the new presentation (defaults to 'Untitled Presentation')",
                    "placeholder": "Enter presentation title",
                }
            ],
            "outputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "helper_text": "The ID of the created presentation",
                },
                {
                    "field": "title",
                    "type": "string",
                    "helper_text": "The title of the presentation",
                },
                {
                    "field": "page_size",
                    "type": "string",
                    "helper_text": "The page size settings of the presentation",
                },
                {
                    "field": "slides",
                    "type": "vec<string>",
                    "helper_text": "The slides in the presentation",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "create_presentation",
            "task_name": "tasks.google_slides.create_presentation",
            "description": "Create a new Google Slides presentation",
            "label": "Create Presentation",
            "inputs_sort_order": ["integration", "action", "title"],
        },
        "read_presentation": {
            "inputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Presentation",
                    "helper_text": "Select a presentation to read",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "helper_text": "The ID of the presentation",
                },
                {
                    "field": "title",
                    "type": "string",
                    "helper_text": "The title of the presentation",
                },
                {
                    "field": "page_size",
                    "type": "string",
                    "helper_text": "The page size settings",
                },
                {
                    "field": "slides",
                    "type": "vec<string>",
                    "helper_text": "The slides in the presentation",
                },
                {
                    "field": "slide_titles",
                    "type": "vec<string>",
                    "helper_text": "The titles of the slides",
                },
                {
                    "field": "slide_contents",
                    "type": "vec<string>",
                    "helper_text": "The contents of the slides",
                },
                {
                    "field": "masters",
                    "type": "vec<string>",
                    "helper_text": "The master slides",
                },
                {
                    "field": "layouts",
                    "type": "vec<string>",
                    "helper_text": "The layout slides",
                },
                {
                    "field": "locale",
                    "type": "string",
                    "helper_text": "The locale of the presentation",
                },
                {
                    "field": "slide_info",
                    "type": "vec<string>",
                    "helper_text": "Information about each slide",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "read_presentation",
            "task_name": "tasks.google_slides.read_presentation",
            "description": "Read a Google Slides presentation",
            "label": "Read Presentation",
            "inputs_sort_order": ["integration", "action", "presentation_id"],
        },
        "get_slides": {
            "inputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Presentation",
                    "helper_text": "Select a presentation",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "helper_text": "The ID of the presentation",
                },
                {
                    "field": "slides",
                    "type": "vec<string>",
                    "helper_text": "All slides in the presentation",
                },
                {
                    "field": "slide_ids",
                    "type": "vec<string>",
                    "helper_text": "The IDs of all slides",
                },
                {
                    "field": "slide_indexes",
                    "type": "vec<string>",
                    "helper_text": "The indexes of all slides",
                },
                {
                    "field": "total_slides",
                    "type": "string",
                    "helper_text": "Total number of slides",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_slides",
            "task_name": "tasks.google_slides.get_slides",
            "description": "Get all slides from a Google Slides presentation",
            "label": "Get Slides",
            "inputs_sort_order": ["integration", "action", "presentation_id"],
        },
        "read_page": {
            "inputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Presentation",
                    "helper_text": "Select a presentation",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "page_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Page Object ID",
                    "helper_text": "The object ID of the page/slide to read",
                    "placeholder": "Enter page object ID",
                },
            ],
            "outputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "helper_text": "The ID of the presentation",
                },
                {
                    "field": "page_id",
                    "type": "string",
                    "helper_text": "The ID of the page",
                },
                {
                    "field": "slide_title",
                    "type": "string",
                    "helper_text": "The title of the slide",
                },
                {
                    "field": "slide_content",
                    "type": "string",
                    "helper_text": "The content of the slide",
                },
                {
                    "field": "slide_properties",
                    "type": "string",
                    "helper_text": "The slide properties",
                },
                {
                    "field": "layout_properties",
                    "type": "string",
                    "helper_text": "The layout properties",
                },
                {
                    "field": "notes_properties",
                    "type": "string",
                    "helper_text": "The notes properties",
                },
                {
                    "field": "page_elements",
                    "type": "vec<string>",
                    "helper_text": "The elements on the page",
                },
                {
                    "field": "page_element_info",
                    "type": "vec<string>",
                    "helper_text": "Information about page elements",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "read_page",
            "task_name": "tasks.google_slides.read_page",
            "description": "Read a specific page from a Google Slides presentation",
            "label": "Read Page",
            "inputs_sort_order": [
                "integration",
                "action",
                "presentation_id",
                "page_object_id",
            ],
        },
        "read_thumbnail": {
            "inputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Presentation",
                    "helper_text": "Select a presentation",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "page_object_id",
                    "type": "string",
                    "value": "",
                    "label": "Page Object ID",
                    "helper_text": "The object ID of the page/slide",
                    "placeholder": "Enter page object ID",
                },
                {
                    "field": "thumbnail_size",
                    "type": "string",
                    "value": "MEDIUM",
                    "label": "Thumbnail Size",
                    "helper_text": "Size of the thumbnail",
                    "placeholder": "MEDIUM",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"value": "SMALL", "label": "SMALL"},
                            {"value": "MEDIUM", "label": "MEDIUM"},
                            {"value": "LARGE", "label": "LARGE"},
                        ],
                    },
                },
                {
                    "field": "mime_type",
                    "type": "string",
                    "value": "PNG",
                    "label": "MIME Type",
                    "helper_text": "Format of the thumbnail",
                    "placeholder": "PNG",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"value": "PNG", "label": "PNG"},
                            {"value": "JPG", "label": "JPG"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "helper_text": "The ID of the presentation",
                },
                {
                    "field": "page_id",
                    "type": "string",
                    "helper_text": "The ID of the page",
                },
                {"field": "file", "type": "file", "helper_text": "The thumbnail image"},
                {
                    "field": "thumbnail_url",
                    "type": "string",
                    "helper_text": "URL of the thumbnail image",
                },
                {
                    "field": "width",
                    "type": "string",
                    "helper_text": "Width of the thumbnail",
                },
                {
                    "field": "height",
                    "type": "string",
                    "helper_text": "Height of the thumbnail",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "read_thumbnail",
            "task_name": "tasks.google_slides.read_thumbnail",
            "description": "Get a thumbnail image of a slide",
            "label": "Read Thumbnail",
            "inputs_sort_order": [
                "integration",
                "action",
                "presentation_id",
                "page_object_id",
                "thumbnail_size",
                "mime_type",
            ],
        },
        "replace_text": {
            "inputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Presentation",
                    "helper_text": "Select a presentation",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "contains_text",
                    "type": "string",
                    "value": "",
                    "label": "Search Text",
                    "helper_text": "The text to search for and replace",
                    "placeholder": "Enter text to find",
                },
                {
                    "field": "replace_text",
                    "type": "string",
                    "value": "",
                    "label": "Replace Text",
                    "helper_text": "The text to replace with",
                    "placeholder": "Enter replacement text",
                },
                {
                    "field": "match_case",
                    "type": "bool",
                    "value": False,
                    "label": "Match Case",
                    "helper_text": "Whether to match case when searching",
                },
            ],
            "outputs": [
                {
                    "field": "presentation_id",
                    "type": "string",
                    "helper_text": "The ID of the presentation",
                },
                {
                    "field": "search_text",
                    "type": "string",
                    "helper_text": "The text that was searched for",
                },
                {
                    "field": "replacement_text",
                    "type": "string",
                    "helper_text": "The replacement text",
                },
                {
                    "field": "occurrences_changed",
                    "type": "string",
                    "helper_text": "Number of occurrences that were replaced",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "replace_text",
            "task_name": "tasks.google_slides.replace_text",
            "description": "Replace all occurrences of text in a presentation",
            "label": "Replace Text",
            "inputs_sort_order": [
                "integration",
                "action",
                "presentation_id",
                "contains_text",
                "replace_text",
                "match_case",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        contains_text: str = "",
        match_case: bool = False,
        mime_type: str = "PNG",
        page_object_id: str = "",
        presentation_id: str = "",
        replace_text: str = "",
        thumbnail_size: str = "MEDIUM",
        title: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_slides",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if title is not None:
            self.inputs["title"] = title
        if presentation_id is not None:
            self.inputs["presentation_id"] = presentation_id
        if page_object_id is not None:
            self.inputs["page_object_id"] = page_object_id
        if thumbnail_size is not None:
            self.inputs["thumbnail_size"] = thumbnail_size
        if mime_type is not None:
            self.inputs["mime_type"] = mime_type
        if contains_text is not None:
            self.inputs["contains_text"] = contains_text
        if replace_text is not None:
            self.inputs["replace_text"] = replace_text
        if match_case is not None:
            self.inputs["match_case"] = match_case
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleSlidesNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_workspace_admin")
class IntegrationGoogleWorkspaceAdminNode(Node):
    """
    Google Workspace Admin

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### update_chromeos_device
        annotated_asset_id: The new annotated asset ID
        annotated_location: The new annotated location
        annotated_user: The new annotated user
        device_id: The unique identifier of the ChromeOS device
        notes: Filter by device notes
        org_unit_path: Filter by organizational unit path
    ### get_chromeos_devices
        asset_id: Filter by asset ID
        ethernet_mac: Filter by Ethernet MAC address (no colons)
        include_child_orgunits: Include devices from child organizational units
        location: Filter by annotated location
        max_results: Maximum number of results to return (1-200)
        notes: Filter by device notes
        order_by: Field to order results by
        org_unit_path: Filter by organizational unit path
        projection: What subset of fields to fetch
        query: Raw query string for advanced filtering
        register_date: Filter by registration date (YYYY-MM-DD)
        serial_number: Filter by serial number (partial search, min 3 chars)
        sort_order: Sort order for results
        status: Filter by device status
        sync_date: Filter by last sync date (YYYY-MM-DD)
        user: Filter by annotated user
        wifi_mac: Filter by WiFi MAC address (no colons)
    ### create_user
        change_password_at_next_login: Force user to change password on next login
        first_name: The first name of the user
        last_name: The last name of the user
        org_unit_path: Filter by organizational unit path
        password: The password for the user
        primary_email: The primary email address of the user
    ### update_user
        change_password_at_next_login: Force user to change password on next login
        first_name: The first name of the user
        last_name: The last name of the user
        org_unit_path: Filter by organizational unit path
        password: The password for the user
        primary_email: The primary email address of the user
        suspended: Whether to suspend the user
        user_id: The unique identifier or email of the user to delete
    ### change_chromeos_device_status
        deprovision_reason: Provide a reason for deprovisioning (only required if the Device Action is set to 'Deprovision')
        device_action: The action to perform on the device
        device_id: The unique identifier of the ChromeOS device
    ### create_group
        description: The description of the group
        group_email: The email address of the group
        group_name: The name of the group
    ### update_group
        description: The description of the group
        group_email: The email address of the group
        group_id: The unique identifier or email of the group
        group_name: The name of the group
    ### read_chromeos_device
        device_id: The unique identifier of the ChromeOS device
        projection: What subset of fields to fetch
    ### get_users
        domain: The domain name to filter users
        email: Search by email address
        email_prefix: Search by email prefix (e.g., admin*)
        family_name: Search by last name
        given_name: Search by first name
        is_admin: Filter by admin status
        is_archived: Filter by archived status
        is_delegated_admin: Filter by delegated admin status
        is_suspended: Filter by suspension status
        max_results: Maximum number of results to return (1-200)
        name: Search by name (given name, family name, or email)
        order_by: Field to order results by
        org_unit_path: Filter by organizational unit path
        projection: What subset of fields to fetch
        query: Raw query string for advanced filtering
        show_deleted: Include deleted users in results
        sort_order: Sort order for results
        view_type: View type for results
    ### get_groups
        domain: The domain name to filter users
        max_results: Maximum number of results to return (1-200)
        order_by: Field to order results by
        query: Raw query string for advanced filtering
        search_group_email: Search by group email
        search_group_name: Search by group name
        sort_order: Sort order for results
        user_key: Filter groups by user membership
    ### add_user_to_group
        group_id: The unique identifier or email of the group
        role: The role of the user in the group
        user_id: The unique identifier or email of the user to delete
    ### remove_user_from_group
        group_id: The unique identifier or email of the group
        user_id: The unique identifier or email of the user to delete
    ### delete_group
        group_id: The unique identifier or email of the group
    ### read_group
        group_id: The unique identifier or email of the group
    ### read_user
        projection: What subset of fields to fetch
        user_id: The unique identifier or email of the user to delete
    ### delete_user
        user_id: The unique identifier or email of the user to delete

    ## Outputs
    ### read_group
        admin_created: Whether the group was created by an admin
        description: The description of the group
        direct_members_count: The number of direct members in the group
        group_email: The email address of the group
        group_id: The unique identifier of the group
        group_name: The name of the group
        raw_data: Raw API response data
    ### update_chromeos_device
        annotated_asset_id: The annotated asset ID of the device
        annotated_location: The annotated location of the device
        annotated_user: The annotated user of the device
        device_id: The unique identifier of the device
        notes: The notes of the device
        org_unit_path: The organizational unit path of the device
        raw_data: Raw API response data
        serial_number: The serial number of the device
        status: The status of the device
    ### read_chromeos_device
        annotated_location: The annotated location of the device
        annotated_user: The annotated user of the device
        device_id: The unique identifier of the device
        last_sync: The last sync time of the device
        model: The model of the device
        org_unit_path: The organizational unit path of the device
        os_version: The OS version of the device
        raw_data: Raw API response data
        serial_number: The serial number of the device
        status: The status of the device
    ### read_user
        creation_time: The creation time of the user
        first_name: The first name of the user
        full_name: The full name of the user
        is_admin: Whether the user is an admin
        last_login_time: The last login time of the user
        last_name: The last name of the user
        org_unit_path: The organizational unit path of the user
        primary_email: The primary email address of the user
        raw_data: Raw API response data
        suspended: Whether the user is suspended
        user_id: The unique identifier of the user
    ### create_group
        description: The description of the created group
        direct_members_count: The number of direct members in the group
        group_email: The email address of the created group
        group_id: The unique identifier of the created group
        group_name: The name of the created group
        raw_data: Raw API response data
    ### update_group
        description: The description of the updated group
        direct_members_count: The number of direct members in the group
        group_email: The email address of the updated group
        group_id: The unique identifier of the updated group
        group_name: The name of the updated group
        raw_data: Raw API response data
    ### change_chromeos_device_status
        device_action: The action performed
        device_id: The ID of the device
        raw_data: Raw API response data
        success: Whether the operation was successful
    ### get_chromeos_devices
        device_ids: List of device IDs
        models: List of device models
        org_unit_paths: List of organizational unit paths
        raw_data: Raw API response data
        serial_numbers: List of serial numbers
        statuses: List of device statuses
    ### add_user_to_group
        email: The email address of the user
        group_id: The ID of the group
        raw_data: Raw API response data
        role: The role assigned to the user
        success: Whether the operation was successful
        user_id: The ID of the user
    ### create_user
        first_name: The first name of the created user
        full_name: The full name of the created user
        is_admin: Whether the user is an admin
        last_name: The last name of the created user
        org_unit_path: The organizational unit path of the user
        primary_email: The primary email address of the created user
        raw_data: Raw API response data
        suspended: Whether the user is suspended
        user_id: The unique identifier of the created user
    ### update_user
        first_name: The first name of the updated user
        full_name: The full name of the updated user
        is_admin: Whether the user is an admin
        last_name: The last name of the updated user
        org_unit_path: The organizational unit path of the user
        primary_email: The primary email address of the updated user
        raw_data: Raw API response data
        suspended: Whether the user is suspended
        user_id: The unique identifier of the updated user
    ### get_groups
        group_emails: List of group email addresses
        group_ids: List of group IDs
        group_names: List of group names
        raw_data: Raw API response data
    ### remove_user_from_group
        group_id: The ID of the group
        message: Success message
        success: Whether the operation was successful
        user_id: The ID of the user
    ### delete_group
        group_id: The ID of the deleted group
        message: Success message
        success: Whether the operation was successful
    ### delete_user
        message: Success message
        success: Whether the operation was successful
        user_id: The ID of the deleted user
    ### get_users
        raw_data: Raw API response data
        user_emails: List of user email addresses
        user_ids: List of user IDs
        user_names: List of user names
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Workspace Admin>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "read_chromeos_device": {
            "inputs": [
                {
                    "field": "device_id",
                    "type": "string",
                    "value": "",
                    "label": "Device ID",
                    "helper_text": "The unique identifier of the ChromeOS device",
                    "placeholder": "device-12345",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "value": "basic",
                    "placeholder": "Basic",
                    "label": "Projection",
                    "helper_text": "What subset of fields to fetch",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Basic", "value": "basic"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "device_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the device",
                },
                {
                    "field": "serial_number",
                    "type": "string",
                    "helper_text": "The serial number of the device",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "The status of the device",
                },
                {
                    "field": "last_sync",
                    "type": "timestamp",
                    "helper_text": "The last sync time of the device",
                },
                {
                    "field": "model",
                    "type": "string",
                    "helper_text": "The model of the device",
                },
                {
                    "field": "os_version",
                    "type": "string",
                    "helper_text": "The OS version of the device",
                },
                {
                    "field": "annotated_user",
                    "type": "string",
                    "helper_text": "The annotated user of the device",
                },
                {
                    "field": "annotated_location",
                    "type": "string",
                    "helper_text": "The annotated location of the device",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "helper_text": "The organizational unit path of the device",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "read_chromeos_device",
            "task_name": "tasks.google_workspace_admin.read_chromeos_device",
            "description": "Read details of a specific ChromeOS device",
            "label": "Read ChromeOS Device",
            "inputs_sort_order": ["integration", "action", "device_id", "projection"],
            "required": ["device_id"],
        },
        "get_chromeos_devices": {
            "inputs": [
                {
                    "field": "max_results",
                    "type": "int32",
                    "value": 10,
                    "label": "Max Results",
                    "helper_text": "Maximum number of results to return (1-200)",
                    "placeholder": "10",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "value": "basic",
                    "placeholder": "Basic",
                    "label": "Projection",
                    "helper_text": "What subset of fields to fetch",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Basic", "value": "basic"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "include_child_orgunits",
                    "type": "bool",
                    "value": False,
                    "label": "Include Child OrgUnits",
                    "helper_text": "Include devices from child organizational units",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "value": "",
                    "label": "Organization Unit Path",
                    "helper_text": "Filter by organizational unit path",
                    "placeholder": "/Sales/Marketing",
                },
                {
                    "field": "serial_number",
                    "type": "string",
                    "value": "",
                    "label": "Serial Number",
                    "helper_text": "Filter by serial number (partial search, min 3 chars)",
                    "placeholder": "ABC123",
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "",
                    "label": "Status",
                    "helper_text": "Filter by device status",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Provisioned", "value": "provisioned"},
                            {"label": "Disabled", "value": "disabled"},
                            {"label": "Deprovisioned", "value": "deprovisioned"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "user",
                    "type": "string",
                    "value": "",
                    "label": "User",
                    "helper_text": "Filter by annotated user",
                    "placeholder": "john.doe@company.com",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "helper_text": "Filter by annotated location",
                    "placeholder": "Building A, Floor 2",
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "label": "Notes",
                    "helper_text": "Filter by device notes",
                    "placeholder": "Assigned to marketing",
                },
                {
                    "field": "asset_id",
                    "type": "string",
                    "value": "",
                    "label": "Asset ID",
                    "helper_text": "Filter by asset ID",
                    "placeholder": "ASSET-123",
                },
                {
                    "field": "wifi_mac",
                    "type": "string",
                    "value": "",
                    "label": "WiFi MAC Address",
                    "helper_text": "Filter by WiFi MAC address (no colons)",
                    "placeholder": "00aabbccddee",
                },
                {
                    "field": "ethernet_mac",
                    "type": "string",
                    "value": "",
                    "label": "Ethernet MAC Address",
                    "helper_text": "Filter by Ethernet MAC address (no colons)",
                    "placeholder": "00aabbccddee",
                },
                {
                    "field": "register_date",
                    "type": "string",
                    "value": "",
                    "label": "Register Date",
                    "helper_text": "Filter by registration date (YYYY-MM-DD)",
                    "placeholder": "2023-01-01",
                },
                {
                    "field": "sync_date",
                    "type": "string",
                    "value": "",
                    "label": "Sync Date",
                    "helper_text": "Filter by last sync date (YYYY-MM-DD)",
                    "placeholder": "2023-01-01",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Raw Query",
                    "helper_text": "Raw query string for advanced filtering",
                    "placeholder": "id:ABC123 status:provisioned",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "label": "Order By",
                    "helper_text": "Field to order results by",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {
                                "label": "Annotated Location",
                                "value": "annotatedLocation",
                            },
                            {"label": "Annotated User", "value": "annotatedUser"},
                            {"label": "Last Sync", "value": "lastSync"},
                            {"label": "Notes", "value": "notes"},
                            {"label": "Serial Number", "value": "serialNumber"},
                            {"label": "Status", "value": "status"},
                            {"label": "Support End Date", "value": "supportEndDate"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "helper_text": "Sort order for results",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Ascending", "value": "ascending"},
                            {"label": "Descending", "value": "descending"},
                        ],
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "device_ids",
                    "type": "vec<string>",
                    "helper_text": "List of device IDs",
                },
                {
                    "field": "serial_numbers",
                    "type": "vec<string>",
                    "helper_text": "List of serial numbers",
                },
                {
                    "field": "statuses",
                    "type": "vec<string>",
                    "helper_text": "List of device statuses",
                },
                {
                    "field": "models",
                    "type": "vec<string>",
                    "helper_text": "List of device models",
                },
                {
                    "field": "org_unit_paths",
                    "type": "vec<string>",
                    "helper_text": "List of organizational unit paths",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_chromeos_devices",
            "task_name": "tasks.google_workspace_admin.get_chromeos_devices",
            "description": "Get a list of ChromeOS devices with optional filtering",
            "label": "Get ChromeOS Devices",
            "inputs_sort_order": [
                "integration",
                "action",
                "max_results",
                "projection",
                "include_child_orgunits",
                "org_unit_path",
                "serial_number",
                "status",
                "user",
                "location",
                "notes",
                "asset_id",
                "wifi_mac",
                "ethernet_mac",
                "register_date",
                "sync_date",
                "query",
                "order_by",
                "sort_order",
            ],
            "required": ["max_results"],
        },
        "update_chromeos_device": {
            "inputs": [
                {
                    "field": "device_id",
                    "type": "string",
                    "value": "",
                    "label": "Device ID",
                    "helper_text": "The unique identifier of the ChromeOS device",
                    "placeholder": "device-12345",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "value": "",
                    "label": "Organization Unit Path",
                    "helper_text": "The new organizational unit path",
                    "placeholder": "/Sales/Marketing",
                },
                {
                    "field": "annotated_user",
                    "type": "string",
                    "value": "",
                    "label": "Annotated User",
                    "helper_text": "The new annotated user",
                    "placeholder": "john.doe@company.com",
                },
                {
                    "field": "annotated_location",
                    "type": "string",
                    "value": "",
                    "label": "Annotated Location",
                    "helper_text": "The new annotated location",
                    "placeholder": "Building A, Floor 2",
                },
                {
                    "field": "annotated_asset_id",
                    "type": "string",
                    "value": "",
                    "label": "Annotated Asset ID",
                    "helper_text": "The new annotated asset ID",
                    "placeholder": "ASSET-123",
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "label": "Notes",
                    "helper_text": "The new notes for the device",
                    "placeholder": "Assigned to marketing team",
                },
            ],
            "outputs": [
                {
                    "field": "device_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the device",
                },
                {
                    "field": "serial_number",
                    "type": "string",
                    "helper_text": "The serial number of the device",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "The status of the device",
                },
                {
                    "field": "annotated_user",
                    "type": "string",
                    "helper_text": "The annotated user of the device",
                },
                {
                    "field": "annotated_location",
                    "type": "string",
                    "helper_text": "The annotated location of the device",
                },
                {
                    "field": "annotated_asset_id",
                    "type": "string",
                    "helper_text": "The annotated asset ID of the device",
                },
                {
                    "field": "notes",
                    "type": "string",
                    "helper_text": "The notes of the device",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "helper_text": "The organizational unit path of the device",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "update_chromeos_device",
            "task_name": "tasks.google_workspace_admin.update_chromeos_device",
            "description": "Update a ChromeOS device",
            "label": "Update ChromeOS Device",
            "inputs_sort_order": [
                "integration",
                "action",
                "device_id",
                "org_unit_path",
                "annotated_user",
                "annotated_location",
                "annotated_asset_id",
                "notes",
            ],
            "required": ["device_id"],
        },
        "change_chromeos_device_status": {
            "inputs": [
                {
                    "field": "device_id",
                    "type": "string",
                    "value": "",
                    "label": "Device ID",
                    "helper_text": "The unique identifier of the ChromeOS device",
                    "placeholder": "device-12345",
                },
                {
                    "field": "device_action",
                    "type": "string",
                    "value": "",
                    "label": "Device Action",
                    "helper_text": "The action to perform on the device",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Disable", "value": "disable"},
                            {"label": "Re-enable", "value": "reenable"},
                            {"label": "Deprovision", "value": "deprovision"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "deprovision_reason",
                    "type": "string",
                    "value": "",
                    "label": "Deprovision Reason",
                    "helper_text": "Provide a reason for deprovisioning (only required if the Device Action is set to 'Deprovision')",
                    "placeholder": "Device lost or stolen",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "device_id",
                    "type": "string",
                    "helper_text": "The ID of the device",
                },
                {
                    "field": "device_action",
                    "type": "string",
                    "helper_text": "The action performed",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "change_chromeos_device_status",
            "task_name": "tasks.google_workspace_admin.change_chromeos_device_status",
            "description": "Change the status of a ChromeOS device",
            "label": "Change ChromeOS Device Status",
            "inputs_sort_order": [
                "integration",
                "action",
                "device_id",
                "device_action",
                "deprovision_reason",
            ],
            "required": ["device_id", "device_action"],
        },
        "create_user": {
            "inputs": [
                {
                    "field": "primary_email",
                    "type": "string",
                    "value": "",
                    "label": "Primary Email",
                    "helper_text": "The primary email address of the user",
                    "placeholder": "user@company.com",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "helper_text": "The first name of the user",
                    "placeholder": "John",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "helper_text": "The last name of the user",
                    "placeholder": "Doe",
                },
                {
                    "field": "password",
                    "type": "string",
                    "value": "",
                    "label": "Password",
                    "helper_text": "The password for the user",
                    "placeholder": "SecurePassword123!",
                },
                {
                    "field": "change_password_at_next_login",
                    "type": "bool",
                    "value": False,
                    "label": "Change Password at Next Login",
                    "helper_text": "Force user to change password on next login",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "value": "",
                    "label": "Organization Unit Path",
                    "helper_text": "The organizational unit path for the user",
                    "placeholder": "/Sales/Marketing",
                },
            ],
            "outputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the created user",
                },
                {
                    "field": "primary_email",
                    "type": "string",
                    "helper_text": "The primary email address of the created user",
                },
                {
                    "field": "full_name",
                    "type": "string",
                    "helper_text": "The full name of the created user",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "The first name of the created user",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "The last name of the created user",
                },
                {
                    "field": "is_admin",
                    "type": "bool",
                    "helper_text": "Whether the user is an admin",
                },
                {
                    "field": "suspended",
                    "type": "bool",
                    "helper_text": "Whether the user is suspended",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "helper_text": "The organizational unit path of the user",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "create_user",
            "task_name": "tasks.google_workspace_admin.create_user",
            "description": "Create a new user in Google Workspace",
            "label": "Create User",
            "inputs_sort_order": [
                "integration",
                "action",
                "primary_email",
                "first_name",
                "last_name",
                "password",
                "change_password_at_next_login",
                "org_unit_path",
            ],
            "required": ["primary_email", "first_name", "last_name", "password"],
        },
        "delete_user": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "label": "User ID",
                    "helper_text": "The unique identifier or email of the user to delete",
                    "placeholder": "user@company.com",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "The ID of the deleted user",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
            ],
            "name": "delete_user",
            "task_name": "tasks.google_workspace_admin.delete_user",
            "description": "Delete a user from Google Workspace",
            "label": "Delete User",
            "inputs_sort_order": ["integration", "action", "user_id"],
            "required": ["user_id"],
        },
        "read_user": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "label": "User ID",
                    "helper_text": "The unique identifier or email of the user to read",
                    "placeholder": "user@company.com",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "value": "basic",
                    "placeholder": "Basic",
                    "label": "Projection",
                    "helper_text": "What subset of fields to fetch",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Basic", "value": "basic"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the user",
                },
                {
                    "field": "primary_email",
                    "type": "string",
                    "helper_text": "The primary email address of the user",
                },
                {
                    "field": "full_name",
                    "type": "string",
                    "helper_text": "The full name of the user",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "The first name of the user",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "The last name of the user",
                },
                {
                    "field": "is_admin",
                    "type": "bool",
                    "helper_text": "Whether the user is an admin",
                },
                {
                    "field": "suspended",
                    "type": "bool",
                    "helper_text": "Whether the user is suspended",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "helper_text": "The organizational unit path of the user",
                },
                {
                    "field": "last_login_time",
                    "type": "timestamp",
                    "helper_text": "The last login time of the user",
                },
                {
                    "field": "creation_time",
                    "type": "timestamp",
                    "helper_text": "The creation time of the user",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "read_user",
            "task_name": "tasks.google_workspace_admin.read_user",
            "description": "Read details of a specific user",
            "label": "Read User",
            "inputs_sort_order": ["integration", "action", "user_id", "projection"],
            "required": ["user_id"],
        },
        "get_users": {
            "inputs": [
                {
                    "field": "max_results",
                    "type": "int32",
                    "value": 10,
                    "label": "Max Results",
                    "helper_text": "Maximum number of results to return",
                    "placeholder": "10",
                },
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "helper_text": "The domain name to filter users",
                    "placeholder": "company.com",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Name",
                    "helper_text": "Search by name (given name, family name, or email)",
                    "placeholder": "John Doe",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "helper_text": "Search by email address",
                    "placeholder": "user@company.com",
                },
                {
                    "field": "email_prefix",
                    "type": "string",
                    "value": "",
                    "label": "Email Prefix",
                    "helper_text": "Search by email prefix (e.g., admin*)",
                    "placeholder": "admin",
                },
                {
                    "field": "given_name",
                    "type": "string",
                    "value": "",
                    "label": "Given Name",
                    "helper_text": "Search by first name",
                    "placeholder": "John",
                },
                {
                    "field": "family_name",
                    "type": "string",
                    "value": "",
                    "label": "Family Name",
                    "helper_text": "Search by last name",
                    "placeholder": "Doe",
                },
                {
                    "field": "is_admin",
                    "type": "bool",
                    "value": False,
                    "label": "Is Admin",
                    "helper_text": "Filter by admin status",
                },
                {
                    "field": "is_delegated_admin",
                    "type": "bool",
                    "value": False,
                    "label": "Is Delegated Admin",
                    "helper_text": "Filter by delegated admin status",
                },
                {
                    "field": "is_suspended",
                    "type": "bool",
                    "value": False,
                    "label": "Is Suspended",
                    "helper_text": "Filter by suspension status",
                },
                {
                    "field": "is_archived",
                    "type": "bool",
                    "value": False,
                    "label": "Is Archived",
                    "helper_text": "Filter by archived status",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "value": "",
                    "label": "Organization Unit Path",
                    "helper_text": "Filter by organizational unit path",
                    "placeholder": "/Sales/Marketing",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Raw Query",
                    "helper_text": "Raw query string for advanced filtering",
                    "placeholder": "name:John orgUnitPath:/Sales",
                },
                {
                    "field": "show_deleted",
                    "type": "bool",
                    "value": False,
                    "label": "Show Deleted",
                    "helper_text": "Include deleted users in results",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "value": "basic",
                    "placeholder": "Basic",
                    "label": "Projection",
                    "helper_text": "What subset of fields to fetch",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Basic", "value": "basic"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "label": "Order By",
                    "helper_text": "Field to order results by",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Email", "value": "email"},
                            {"label": "Given Name", "value": "givenName"},
                            {"label": "Family Name", "value": "familyName"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "helper_text": "Sort order for results",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Ascending", "value": "ascending"},
                            {"label": "Descending", "value": "descending"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "view_type",
                    "type": "string",
                    "value": "",
                    "label": "View Type",
                    "helper_text": "View type for results",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Admin View", "value": "admin_view"},
                            {"label": "Domain Public", "value": "domain_public"},
                        ],
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "user_ids",
                    "type": "vec<string>",
                    "helper_text": "List of user IDs",
                },
                {
                    "field": "user_emails",
                    "type": "vec<string>",
                    "helper_text": "List of user email addresses",
                },
                {
                    "field": "user_names",
                    "type": "vec<string>",
                    "helper_text": "List of user names",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_users",
            "task_name": "tasks.google_workspace_admin.get_users",
            "description": "Get a list of users with optional filtering",
            "label": "Get Users",
            "inputs_sort_order": [
                "integration",
                "action",
                "max_results",
                "domain",
                "name",
                "email",
                "email_prefix",
                "given_name",
                "family_name",
                "is_admin",
                "is_delegated_admin",
                "is_suspended",
                "is_archived",
                "org_unit_path",
                "query",
                "show_deleted",
                "projection",
                "order_by",
                "sort_order",
                "view_type",
            ],
            "required": ["max_results"],
        },
        "update_user": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "label": "User ID",
                    "helper_text": "The unique identifier or email of the user to update",
                    "placeholder": "user@company.com",
                },
                {
                    "field": "primary_email",
                    "type": "string",
                    "value": "",
                    "label": "Primary Email",
                    "helper_text": "The new primary email address",
                    "placeholder": "newuser@company.com",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "helper_text": "The new first name",
                    "placeholder": "John",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "helper_text": "The new last name",
                    "placeholder": "Doe",
                },
                {
                    "field": "suspended",
                    "type": "bool",
                    "value": False,
                    "label": "Suspended",
                    "helper_text": "Whether to suspend the user",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "value": "",
                    "label": "Organization Unit Path",
                    "helper_text": "The new organizational unit path",
                    "placeholder": "/Sales/Marketing",
                },
                {
                    "field": "password",
                    "type": "string",
                    "value": "",
                    "label": "Password",
                    "helper_text": "The new password for the user",
                    "placeholder": "NewSecurePassword123!",
                },
                {
                    "field": "change_password_at_next_login",
                    "type": "bool",
                    "value": False,
                    "label": "Change Password at Next Login",
                    "helper_text": "Force user to change password on next login",
                },
            ],
            "outputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the updated user",
                },
                {
                    "field": "primary_email",
                    "type": "string",
                    "helper_text": "The primary email address of the updated user",
                },
                {
                    "field": "full_name",
                    "type": "string",
                    "helper_text": "The full name of the updated user",
                },
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "The first name of the updated user",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "The last name of the updated user",
                },
                {
                    "field": "is_admin",
                    "type": "bool",
                    "helper_text": "Whether the user is an admin",
                },
                {
                    "field": "suspended",
                    "type": "bool",
                    "helper_text": "Whether the user is suspended",
                },
                {
                    "field": "org_unit_path",
                    "type": "string",
                    "helper_text": "The organizational unit path of the user",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "update_user",
            "task_name": "tasks.google_workspace_admin.update_user",
            "description": "Update an existing user",
            "label": "Update User",
            "inputs_sort_order": [
                "integration",
                "action",
                "user_id",
                "primary_email",
                "first_name",
                "last_name",
                "suspended",
                "org_unit_path",
                "password",
                "change_password_at_next_login",
            ],
            "required": ["user_id"],
        },
        "add_user_to_group": {
            "inputs": [
                {
                    "field": "group_id",
                    "type": "string",
                    "value": "",
                    "label": "Group ID",
                    "helper_text": "The unique identifier or email of the group",
                    "placeholder": "group@company.com",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "label": "User ID",
                    "helper_text": "The unique identifier or email of the user",
                    "placeholder": "user@company.com",
                },
                {
                    "field": "role",
                    "type": "string",
                    "value": "member",
                    "label": "Role",
                    "helper_text": "The role of the user in the group",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Member", "value": "member"},
                            {"label": "Manager", "value": "manager"},
                            {"label": "Owner", "value": "owner"},
                        ],
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "The ID of the user",
                },
                {
                    "field": "group_id",
                    "type": "string",
                    "helper_text": "The ID of the group",
                },
                {
                    "field": "role",
                    "type": "string",
                    "helper_text": "The role assigned to the user",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "The email address of the user",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "add_user_to_group",
            "task_name": "tasks.google_workspace_admin.add_user_to_group",
            "description": "Add a user to a group",
            "label": "Add User to Group",
            "inputs_sort_order": [
                "integration",
                "action",
                "group_id",
                "user_id",
                "role",
            ],
            "required": ["group_id", "user_id"],
        },
        "remove_user_from_group": {
            "inputs": [
                {
                    "field": "group_id",
                    "type": "string",
                    "value": "",
                    "label": "Group ID",
                    "helper_text": "The unique identifier or email of the group",
                    "placeholder": "group@company.com",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "label": "User ID",
                    "helper_text": "The unique identifier or email of the user",
                    "placeholder": "user@company.com",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "The ID of the user",
                },
                {
                    "field": "group_id",
                    "type": "string",
                    "helper_text": "The ID of the group",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
            ],
            "name": "remove_user_from_group",
            "task_name": "tasks.google_workspace_admin.remove_user_from_group",
            "description": "Remove a user from a group",
            "label": "Remove User from Group",
            "inputs_sort_order": ["integration", "action", "group_id", "user_id"],
            "required": ["group_id", "user_id"],
        },
        "create_group": {
            "inputs": [
                {
                    "field": "group_email",
                    "type": "string",
                    "value": "",
                    "label": "Group Email",
                    "helper_text": "The email address of the group",
                    "placeholder": "team@company.com",
                },
                {
                    "field": "group_name",
                    "type": "string",
                    "value": "",
                    "label": "Group Name",
                    "helper_text": "The name of the group",
                    "placeholder": "Marketing Team",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "The description of the group",
                    "placeholder": "Marketing team for product campaigns",
                },
            ],
            "outputs": [
                {
                    "field": "group_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the created group",
                },
                {
                    "field": "group_email",
                    "type": "string",
                    "helper_text": "The email address of the created group",
                },
                {
                    "field": "group_name",
                    "type": "string",
                    "helper_text": "The name of the created group",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "The description of the created group",
                },
                {
                    "field": "direct_members_count",
                    "type": "string",
                    "helper_text": "The number of direct members in the group",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "create_group",
            "task_name": "tasks.google_workspace_admin.create_group",
            "description": "Create a new group in Google Workspace",
            "label": "Create Group",
            "inputs_sort_order": [
                "integration",
                "action",
                "group_email",
                "group_name",
                "description",
            ],
            "required": ["group_email", "group_name"],
        },
        "delete_group": {
            "inputs": [
                {
                    "field": "group_id",
                    "type": "string",
                    "value": "",
                    "label": "Group ID",
                    "helper_text": "The unique identifier or email of the group to delete",
                    "placeholder": "group@company.com",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "group_id",
                    "type": "string",
                    "helper_text": "The ID of the deleted group",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
            ],
            "name": "delete_group",
            "task_name": "tasks.google_workspace_admin.delete_group",
            "description": "Delete a group from Google Workspace",
            "label": "Delete Group",
            "inputs_sort_order": ["integration", "action", "group_id"],
            "required": ["group_id"],
        },
        "read_group": {
            "inputs": [
                {
                    "field": "group_id",
                    "type": "string",
                    "value": "",
                    "label": "Group ID",
                    "helper_text": "The unique identifier or email of the group to read",
                    "placeholder": "group@company.com",
                }
            ],
            "outputs": [
                {
                    "field": "group_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the group",
                },
                {
                    "field": "group_email",
                    "type": "string",
                    "helper_text": "The email address of the group",
                },
                {
                    "field": "group_name",
                    "type": "string",
                    "helper_text": "The name of the group",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "The description of the group",
                },
                {
                    "field": "direct_members_count",
                    "type": "string",
                    "helper_text": "The number of direct members in the group",
                },
                {
                    "field": "admin_created",
                    "type": "bool",
                    "helper_text": "Whether the group was created by an admin",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "read_group",
            "task_name": "tasks.google_workspace_admin.read_group",
            "description": "Read details of a specific group",
            "label": "Read Group",
            "inputs_sort_order": ["integration", "action", "group_id"],
            "required": ["group_id"],
        },
        "get_groups": {
            "inputs": [
                {
                    "field": "max_results",
                    "type": "int32",
                    "value": 10,
                    "label": "Max Results",
                    "helper_text": "Maximum number of results to return (1-200)",
                    "placeholder": "10",
                },
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "helper_text": "The domain name to filter groups",
                    "placeholder": "company.com",
                },
                {
                    "field": "user_key",
                    "type": "string",
                    "value": "",
                    "label": "User Key",
                    "helper_text": "Filter groups by user membership",
                    "placeholder": "user@company.com",
                },
                {
                    "field": "search_group_name",
                    "type": "string",
                    "value": "",
                    "label": "Group Name",
                    "helper_text": "Search by group name",
                    "placeholder": "Marketing Team",
                },
                {
                    "field": "search_group_email",
                    "type": "string",
                    "value": "",
                    "label": "Group Email",
                    "helper_text": "Search by group email",
                    "placeholder": "team@company.com",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Raw Query",
                    "helper_text": "Raw query string for advanced filtering",
                    "placeholder": "name:Marketing email:team@company.com",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "label": "Order By",
                    "helper_text": "Field to order results by",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Email", "value": "email"},
                            {"label": "Name", "value": "name"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "sort_order",
                    "type": "string",
                    "value": "",
                    "label": "Sort Order",
                    "helper_text": "Sort order for results",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Ascending", "value": "ascending"},
                            {"label": "Descending", "value": "descending"},
                        ],
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "group_ids",
                    "type": "vec<string>",
                    "helper_text": "List of group IDs",
                },
                {
                    "field": "group_emails",
                    "type": "vec<string>",
                    "helper_text": "List of group email addresses",
                },
                {
                    "field": "group_names",
                    "type": "vec<string>",
                    "helper_text": "List of group names",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_groups",
            "task_name": "tasks.google_workspace_admin.get_groups",
            "description": "Get a list of groups with optional filtering",
            "label": "Get Groups",
            "inputs_sort_order": [
                "integration",
                "action",
                "max_results",
                "domain",
                "user_key",
                "search_group_name",
                "search_group_email",
                "query",
                "order_by",
                "sort_order",
            ],
            "required": ["max_results"],
        },
        "update_group": {
            "inputs": [
                {
                    "field": "group_id",
                    "type": "string",
                    "value": "",
                    "label": "Group ID",
                    "helper_text": "The unique identifier or email of the group to update",
                    "placeholder": "group@company.com",
                },
                {
                    "field": "group_email",
                    "type": "string",
                    "value": "",
                    "label": "Group Email",
                    "helper_text": "The new email address of the group",
                    "placeholder": "newteam@company.com",
                },
                {
                    "field": "group_name",
                    "type": "string",
                    "value": "",
                    "label": "Group Name",
                    "helper_text": "The new name of the group",
                    "placeholder": "New Marketing Team",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "The new description of the group",
                    "placeholder": "Updated marketing team description",
                },
            ],
            "outputs": [
                {
                    "field": "group_id",
                    "type": "string",
                    "helper_text": "The unique identifier of the updated group",
                },
                {
                    "field": "group_email",
                    "type": "string",
                    "helper_text": "The email address of the updated group",
                },
                {
                    "field": "group_name",
                    "type": "string",
                    "helper_text": "The name of the updated group",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "The description of the updated group",
                },
                {
                    "field": "direct_members_count",
                    "type": "string",
                    "helper_text": "The number of direct members in the group",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "update_group",
            "task_name": "tasks.google_workspace_admin.update_group",
            "description": "Update an existing group",
            "label": "Update Group",
            "inputs_sort_order": [
                "integration",
                "action",
                "group_id",
                "group_email",
                "group_name",
                "description",
            ],
            "required": ["group_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        annotated_asset_id: str = "",
        annotated_location: str = "",
        annotated_user: str = "",
        asset_id: str = "",
        change_password_at_next_login: bool = False,
        deprovision_reason: str = "",
        description: str = "",
        device_action: str = "",
        device_id: str = "",
        domain: str = "",
        email: str = "",
        email_prefix: str = "",
        ethernet_mac: str = "",
        family_name: str = "",
        first_name: str = "",
        given_name: str = "",
        group_email: str = "",
        group_id: str = "",
        group_name: str = "",
        include_child_orgunits: bool = False,
        is_admin: bool = False,
        is_archived: bool = False,
        is_delegated_admin: bool = False,
        is_suspended: bool = False,
        last_name: str = "",
        location: str = "",
        max_results: int = 10,
        name: str = "",
        notes: str = "",
        order_by: str = "",
        org_unit_path: str = "",
        password: str = "",
        primary_email: str = "",
        projection: str = "basic",
        query: str = "",
        register_date: str = "",
        role: str = "member",
        search_group_email: str = "",
        search_group_name: str = "",
        serial_number: str = "",
        show_deleted: bool = False,
        sort_order: str = "",
        status: str = "",
        suspended: bool = False,
        sync_date: str = "",
        user: str = "",
        user_id: str = "",
        user_key: str = "",
        view_type: str = "",
        wifi_mac: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_workspace_admin",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if device_id is not None:
            self.inputs["device_id"] = device_id
        if projection is not None:
            self.inputs["projection"] = projection
        if max_results is not None:
            self.inputs["max_results"] = max_results
        if include_child_orgunits is not None:
            self.inputs["include_child_orgunits"] = include_child_orgunits
        if org_unit_path is not None:
            self.inputs["org_unit_path"] = org_unit_path
        if serial_number is not None:
            self.inputs["serial_number"] = serial_number
        if status is not None:
            self.inputs["status"] = status
        if user is not None:
            self.inputs["user"] = user
        if location is not None:
            self.inputs["location"] = location
        if notes is not None:
            self.inputs["notes"] = notes
        if asset_id is not None:
            self.inputs["asset_id"] = asset_id
        if wifi_mac is not None:
            self.inputs["wifi_mac"] = wifi_mac
        if ethernet_mac is not None:
            self.inputs["ethernet_mac"] = ethernet_mac
        if register_date is not None:
            self.inputs["register_date"] = register_date
        if sync_date is not None:
            self.inputs["sync_date"] = sync_date
        if query is not None:
            self.inputs["query"] = query
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if sort_order is not None:
            self.inputs["sort_order"] = sort_order
        if annotated_user is not None:
            self.inputs["annotated_user"] = annotated_user
        if annotated_location is not None:
            self.inputs["annotated_location"] = annotated_location
        if annotated_asset_id is not None:
            self.inputs["annotated_asset_id"] = annotated_asset_id
        if device_action is not None:
            self.inputs["device_action"] = device_action
        if deprovision_reason is not None:
            self.inputs["deprovision_reason"] = deprovision_reason
        if primary_email is not None:
            self.inputs["primary_email"] = primary_email
        if first_name is not None:
            self.inputs["first_name"] = first_name
        if last_name is not None:
            self.inputs["last_name"] = last_name
        if password is not None:
            self.inputs["password"] = password
        if change_password_at_next_login is not None:
            self.inputs["change_password_at_next_login"] = change_password_at_next_login
        if user_id is not None:
            self.inputs["user_id"] = user_id
        if domain is not None:
            self.inputs["domain"] = domain
        if name is not None:
            self.inputs["name"] = name
        if email is not None:
            self.inputs["email"] = email
        if email_prefix is not None:
            self.inputs["email_prefix"] = email_prefix
        if given_name is not None:
            self.inputs["given_name"] = given_name
        if family_name is not None:
            self.inputs["family_name"] = family_name
        if is_admin is not None:
            self.inputs["is_admin"] = is_admin
        if is_delegated_admin is not None:
            self.inputs["is_delegated_admin"] = is_delegated_admin
        if is_suspended is not None:
            self.inputs["is_suspended"] = is_suspended
        if is_archived is not None:
            self.inputs["is_archived"] = is_archived
        if show_deleted is not None:
            self.inputs["show_deleted"] = show_deleted
        if view_type is not None:
            self.inputs["view_type"] = view_type
        if suspended is not None:
            self.inputs["suspended"] = suspended
        if group_id is not None:
            self.inputs["group_id"] = group_id
        if role is not None:
            self.inputs["role"] = role
        if group_email is not None:
            self.inputs["group_email"] = group_email
        if group_name is not None:
            self.inputs["group_name"] = group_name
        if description is not None:
            self.inputs["description"] = description
        if user_key is not None:
            self.inputs["user_key"] = user_key
        if search_group_name is not None:
            self.inputs["search_group_name"] = search_group_name
        if search_group_email is not None:
            self.inputs["search_group_email"] = search_group_email
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleWorkspaceAdminNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_cloud_storage")
class IntegrationGoogleCloudStorageNode(Node):
    """
    Google Cloud Storage

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### read_object
        alt: Alternative representation (json for metadata, media for content)
        bucket_name: Enter the name of the bucket to create
        download_content: Download file content instead of metadata
        encryption_key: Customer-supplied encryption key (base64 encoded)
        encryption_key_sha: SHA256 hash of the encryption key (base64 encoded)
        generation: Specify object generation for versioned buckets
        object_name: Enter the name for the object
        project_id: Select your Google Cloud Project
        projection: Select the level of detail to return
    ### create_bucket
        bucket_name: Enter the name of the bucket to create
        cors: Cross-Origin Resource Sharing configuration (JSON format)
        lifecycle: Object lifecycle management rules (JSON format)
        location: Enter the location for the bucket (e.g., US, EU, ASIA)
        project_id: Select your Google Cloud Project
        storage_class: Select the storage class for the bucket
        uniform_bucket_level_access: Enable uniform bucket-level access
        versioning: Enable object versioning for this bucket
    ### read_bucket
        bucket_name: Enter the name of the bucket to create
        project_id: Select your Google Cloud Project
        projection: Select the level of detail to return
    ### update_bucket
        bucket_name: Enter the name of the bucket to create
        cors: Cross-Origin Resource Sharing configuration (JSON format)
        encryption: Default encryption configuration (JSON format)
        labels: Labels to apply to the bucket (JSON format)
        lifecycle: Object lifecycle management rules (JSON format)
        logging: Access logging configuration (JSON format)
        project_id: Select your Google Cloud Project
        storage_class: Select the storage class for the bucket
        versioning: Enable object versioning for this bucket
        website: Static website hosting configuration (JSON format)
    ### delete_bucket
        bucket_name: Enter the name of the bucket to create
        project_id: Select your Google Cloud Project
    ### create_object
        bucket_name: Enter the name of the bucket to create
        cache_control: Cache control directives
        content_disposition: How the object should be displayed
        content_encoding: Content encoding of the object
        content_language: Language of the content
        file: Select a file to upload
        metadata: Custom metadata for the object (JSON format)
        object_name: Enter the name for the object
        project_id: Select your Google Cloud Project
    ### get_objects
        bucket_name: Enter the name of the bucket to create
        delimiter: Delimiter for directory-like listing
        include_versions: Include all versions of objects
        limit: Maximum number of buckets to return
        prefix: Filter results to buckets whose names begin with this prefix
        project_id: Select your Google Cloud Project
        projection: Select the level of detail to return
    ### update_object
        bucket_name: Enter the name of the bucket to create
        cache_control: Cache control directives
        content_disposition: How the object should be displayed
        content_encoding: Content encoding of the object
        content_language: Language of the content
        content_type: MIME type of the object
        generation: Specify object generation for versioned buckets
        metadata: Custom metadata for the object (JSON format)
        object_name: Enter the name for the object
        project_id: Select your Google Cloud Project
    ### delete_object
        bucket_name: Enter the name of the bucket to create
        generation: Specify object generation for versioned buckets
        object_name: Enter the name for the object
        project_id: Select your Google Cloud Project
    ### get_buckets
        limit: Maximum number of buckets to return
        prefix: Filter results to buckets whose names begin with this prefix
        project_id: Select your Google Cloud Project
        projection: Select the level of detail to return

    ## Outputs
    ### create_object
        bucket: The bucket containing the object
        content_type: The content type of the object
        generation: The generation of the object
        md5_hash: The MD5 hash of the object
        media_link: The download URL for the object
        metageneration: The metageneration of the object
        object_id: The unique ID of the created object
        object_name: The name of the created object
        raw_data: The raw API response data
        self_link: The URI of the object
        size: The size of the object in bytes
        storage_class: The storage class of the object
        time_created: The creation time of the object
        updated: The last update time of the object
    ### read_object
        bucket: The bucket containing the object
        content_type: The content type of the object
        crc32c: The CRC32C checksum of the object
        etag: The ETag of the object
        file: The downloaded file (when download_content is true)
        file_name: Name of the downloaded file (when download_content is true)
        generation: The generation of the object
        md5_hash: The MD5 hash of the object
        media_link: The download URL for the object
        metadata: Custom metadata of the object
        metageneration: The metageneration of the object
        object_id: The unique ID of the object
        object_name: The name of the object
        raw_data: The raw API response data
        self_link: The URI of the object
        size: The size of the object in bytes
        storage_class: The storage class of the object
        time_created: The creation time of the object
        updated: The last update time of the object
    ### update_object
        bucket: The bucket containing the object
        content_type: The content type of the object
        generation: The generation of the object
        md5_hash: The MD5 hash of the object
        metadata: Custom metadata of the object
        metageneration: The metageneration of the object
        object_id: The unique ID of the object
        object_name: The name of the object
        raw_data: The raw API response data
        size: The size of the object in bytes
        storage_class: The storage class of the object
        time_created: The creation time of the object
        updated: The last update time of the object
    ### create_bucket
        bucket_id: The unique ID of the created bucket
        bucket_name: The name of the created bucket
        location: The location of the bucket
        project_number: The project number associated with the bucket
        raw_data: The raw API response data
        storage_class: The storage class of the bucket
        time_created: The creation time of the bucket
        updated: The last update time of the bucket
    ### read_bucket
        bucket_id: The unique ID of the bucket
        bucket_name: The name of the bucket
        etag: The ETag of the bucket
        location: The location of the bucket
        metageneration: The metageneration of the bucket
        project_number: The project number associated with the bucket
        raw_data: The raw API response data
        storage_class: The storage class of the bucket
        time_created: The creation time of the bucket
        updated: The last update time of the bucket
    ### update_bucket
        bucket_id: The unique ID of the bucket
        bucket_name: The name of the bucket
        location: The location of the bucket
        project_number: The project number associated with the bucket
        raw_data: The raw API response data
        storage_class: The storage class of the bucket
        time_created: The creation time of the bucket
        updated: The last update time of the bucket
    ### get_buckets
        bucket_ids: List of bucket IDs
        bucket_names: List of bucket names
        buckets: List of bucket objects
        locations: List of bucket locations
        raw_data: The raw API response data
        storage_classes: List of bucket storage classes
    ### get_objects
        content_types: List of object content types
        object_names: List of object names
        object_sizes: List of object sizes
        objects: List of object metadata
        prefixes: List of prefixes (for directory-like listing)
        raw_data: The raw API response data
        time_created: List of object creation times
        updated: List of object update times
    ### delete_bucket
        message: Success or error message
        success: Whether the deletion was successful
    ### delete_object
        message: Success or error message
        success: Whether the deletion was successful
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Cloud Storage>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "create_bucket": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "value": "",
                    "label": "Bucket Name",
                    "helper_text": "Enter the name of the bucket to create",
                    "placeholder": "my-storage-bucket",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "helper_text": "Enter the location for the bucket (e.g., US, EU, ASIA)",
                    "placeholder": "US",
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "label": "Storage Class",
                    "helper_text": "Select the storage class for the bucket",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Standard", "value": "STANDARD"},
                            {"label": "Nearline", "value": "NEARLINE"},
                            {"label": "Coldline", "value": "COLDLINE"},
                            {"label": "Archive", "value": "ARCHIVE"},
                        ],
                    },
                    "value": "STANDARD",
                },
                {
                    "field": "uniform_bucket_level_access",
                    "type": "bool",
                    "label": "Uniform Bucket Level Access",
                    "helper_text": "Enable uniform bucket-level access",
                    "value": False,
                },
                {
                    "field": "cors",
                    "type": "string",
                    "value": "",
                    "label": "CORS Configuration",
                    "helper_text": "Cross-Origin Resource Sharing configuration (JSON format)",
                    "placeholder": '[{"origin": ["*"], "method": ["GET"], ...}]',
                },
                {
                    "field": "lifecycle",
                    "type": "string",
                    "value": "",
                    "label": "Lifecycle Configuration",
                    "helper_text": "Object lifecycle management rules (JSON format)",
                    "placeholder": '{"rule": [{"action": {"type": "Delete"}, ...]}',
                },
                {
                    "field": "versioning",
                    "type": "bool",
                    "value": False,
                    "label": "Enable Versioning",
                    "helper_text": "Enable object versioning for this bucket",
                },
            ],
            "outputs": [
                {
                    "field": "bucket_id",
                    "type": "string",
                    "helper_text": "The unique ID of the created bucket",
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "helper_text": "The name of the created bucket",
                },
                {
                    "field": "location",
                    "type": "string",
                    "helper_text": "The location of the bucket",
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "helper_text": "The storage class of the bucket",
                },
                {
                    "field": "time_created",
                    "type": "timestamp",
                    "helper_text": "The creation time of the bucket",
                },
                {
                    "field": "updated",
                    "type": "timestamp",
                    "helper_text": "The last update time of the bucket",
                },
                {
                    "field": "project_number",
                    "type": "string",
                    "helper_text": "The project number associated with the bucket",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "create_bucket",
            "task_name": "tasks.google_cloud_storage.create_bucket",
            "description": "Creates a new bucket in Google Cloud Storage",
            "label": "Create Bucket",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "bucket_name",
                "location",
                "storage_class",
                "uniform_bucket_level_access",
                "cors",
                "lifecycle",
                "versioning",
            ],
            "required": ["project_id", "bucket_name", "storage_class"],
        },
        "read_bucket": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket to read",
                    "placeholder": "Select a bucket",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&project={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "projection",
                    "type": "string",
                    "label": "Projection",
                    "helper_text": "Select the level of detail to return",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "No ACL", "value": "noAcl"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "value": "noAcl",
                },
            ],
            "outputs": [
                {
                    "field": "bucket_id",
                    "type": "string",
                    "helper_text": "The unique ID of the bucket",
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "helper_text": "The name of the bucket",
                },
                {
                    "field": "location",
                    "type": "string",
                    "helper_text": "The location of the bucket",
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "helper_text": "The storage class of the bucket",
                },
                {
                    "field": "time_created",
                    "type": "timestamp",
                    "helper_text": "The creation time of the bucket",
                },
                {
                    "field": "updated",
                    "type": "timestamp",
                    "helper_text": "The last update time of the bucket",
                },
                {
                    "field": "project_number",
                    "type": "string",
                    "helper_text": "The project number associated with the bucket",
                },
                {
                    "field": "metageneration",
                    "type": "string",
                    "helper_text": "The metageneration of the bucket",
                },
                {
                    "field": "etag",
                    "type": "string",
                    "helper_text": "The ETag of the bucket",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "read_bucket",
            "task_name": "tasks.google_cloud_storage.read_bucket",
            "description": "Gets metadata for a specific bucket",
            "label": "Read Bucket",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "bucket_name",
                "projection",
            ],
            "required": ["project_id", "bucket_name"],
        },
        "get_buckets": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Maximum number of buckets to return",
                    "placeholder": "10",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "label": "Projection",
                    "helper_text": "Select the level of detail to return",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "No ACL", "value": "noAcl"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "value": "noAcl",
                },
                {
                    "field": "prefix",
                    "type": "string",
                    "value": "",
                    "label": "Prefix",
                    "helper_text": "Filter results to buckets whose names begin with this prefix",
                    "placeholder": "backup-",
                },
            ],
            "outputs": [
                {
                    "field": "buckets",
                    "type": "string",
                    "helper_text": "List of bucket objects",
                },
                {
                    "field": "bucket_names",
                    "type": "vec<string>",
                    "helper_text": "List of bucket names",
                },
                {
                    "field": "bucket_ids",
                    "type": "vec<string>",
                    "helper_text": "List of bucket IDs",
                },
                {
                    "field": "locations",
                    "type": "vec<string>",
                    "helper_text": "List of bucket locations",
                },
                {
                    "field": "storage_classes",
                    "type": "vec<string>",
                    "helper_text": "List of bucket storage classes",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "get_buckets",
            "task_name": "tasks.google_cloud_storage.get_buckets",
            "description": "Retrieves a list of buckets for a project",
            "label": "Get Buckets",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "limit",
                "projection",
                "prefix",
            ],
            "required": ["project_id", "limit"],
        },
        "update_bucket": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket to update",
                    "placeholder": "Select a bucket",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&project={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "label": "Storage Class",
                    "helper_text": "Select the new storage class for the bucket",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Standard", "value": "STANDARD"},
                            {"label": "Nearline", "value": "NEARLINE"},
                            {"label": "Coldline", "value": "COLDLINE"},
                            {"label": "Archive", "value": "ARCHIVE"},
                        ],
                    },
                    "value": "STANDARD",
                },
                {
                    "field": "labels",
                    "type": "string",
                    "value": "",
                    "label": "Labels",
                    "helper_text": "Labels to apply to the bucket (JSON format)",
                    "placeholder": '{"key": "value"}',
                },
                {
                    "field": "cors",
                    "type": "string",
                    "value": "",
                    "label": "CORS Configuration",
                    "helper_text": "Cross-Origin Resource Sharing configuration (JSON format)",
                    "placeholder": '[{"origin": ["*"], "method": ["GET"], ...}]',
                },
                {
                    "field": "lifecycle",
                    "type": "string",
                    "value": "",
                    "label": "Lifecycle Configuration",
                    "helper_text": "Object lifecycle management rules (JSON format)",
                    "placeholder": '{"rule": [{"action": {"type": "Delete"}, ...}]}',
                },
                {
                    "field": "versioning",
                    "type": "bool",
                    "value": False,
                    "label": "Enable Versioning",
                    "helper_text": "Enable object versioning for this bucket",
                },
                {
                    "field": "website",
                    "type": "string",
                    "value": "",
                    "label": "Website Configuration",
                    "helper_text": "Static website hosting configuration (JSON format)",
                    "placeholder": '{"mainPageSuffix": "index.html", ...}',
                },
                {
                    "field": "logging",
                    "type": "string",
                    "value": "",
                    "label": "Logging Configuration",
                    "helper_text": "Access logging configuration (JSON format)",
                    "placeholder": '{"logBucket": "my-log-bucket", ...}',
                },
                {
                    "field": "encryption",
                    "type": "string",
                    "value": "",
                    "label": "Encryption Configuration",
                    "helper_text": "Default encryption configuration (JSON format)",
                    "placeholder": '{"defaultKmsKeyName": "projects/my-project/.../my-key"}',
                },
            ],
            "outputs": [
                {
                    "field": "bucket_id",
                    "type": "string",
                    "helper_text": "The unique ID of the bucket",
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "helper_text": "The name of the bucket",
                },
                {
                    "field": "location",
                    "type": "string",
                    "helper_text": "The location of the bucket",
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "helper_text": "The storage class of the bucket",
                },
                {
                    "field": "time_created",
                    "type": "timestamp",
                    "helper_text": "The creation time of the bucket",
                },
                {
                    "field": "updated",
                    "type": "timestamp",
                    "helper_text": "The last update time of the bucket",
                },
                {
                    "field": "project_number",
                    "type": "string",
                    "helper_text": "The project number associated with the bucket",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "update_bucket",
            "task_name": "tasks.google_cloud_storage.update_bucket",
            "description": "Updates bucket metadata",
            "label": "Update Bucket",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "bucket_name",
                "storage_class",
                "labels",
                "cors",
                "lifecycle",
                "versioning",
                "website",
                "logging",
                "encryption",
            ],
            "required": ["bucket_name"],
        },
        "delete_bucket": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket to delete",
                    "placeholder": "Select a bucket",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&project={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
            ],
            "name": "delete_bucket",
            "task_name": "tasks.google_cloud_storage.delete_bucket",
            "description": "Deletes a bucket from Google Cloud Storage",
            "label": "Delete Bucket",
            "input_sort_order": ["action", "integration", "project_id", "bucket_name"],
            "required": ["project_id", "bucket_name"],
        },
        "create_object": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket",
                    "placeholder": "Select a bucket",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&project={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "object_name",
                    "type": "string",
                    "value": "",
                    "label": "Object Name",
                    "helper_text": "Enter the name for the object",
                    "placeholder": "folder/subfolder/file.txt",
                },
                {
                    "field": "file",
                    "type": "file",
                    "label": "File",
                    "helper_text": "Select a file to upload",
                    "value": "",
                },
                {
                    "field": "cache_control",
                    "type": "string",
                    "value": "",
                    "label": "Cache Control",
                    "helper_text": "Cache control directives",
                    "placeholder": "max-age=3600, public",
                },
                {
                    "field": "content_disposition",
                    "type": "string",
                    "value": "",
                    "label": "Content Disposition",
                    "helper_text": "How the object should be displayed",
                    "placeholder": "attachment; filename=example.pdf",
                },
                {
                    "field": "content_encoding",
                    "type": "string",
                    "value": "",
                    "label": "Content Encoding",
                    "helper_text": "Content encoding of the object",
                    "placeholder": "gzip",
                },
                {
                    "field": "content_language",
                    "type": "string",
                    "value": "",
                    "label": "Content Language",
                    "helper_text": "Language of the content",
                    "placeholder": "en-US",
                },
                {
                    "field": "metadata",
                    "type": "string",
                    "value": "",
                    "label": "Custom Metadata",
                    "helper_text": "Custom metadata for the object (JSON format)",
                    "placeholder": '{"key": "value"}',
                },
            ],
            "outputs": [
                {
                    "field": "object_id",
                    "type": "string",
                    "helper_text": "The unique ID of the created object",
                },
                {
                    "field": "object_name",
                    "type": "string",
                    "helper_text": "The name of the created object",
                },
                {
                    "field": "bucket",
                    "type": "string",
                    "helper_text": "The bucket containing the object",
                },
                {
                    "field": "generation",
                    "type": "string",
                    "helper_text": "The generation of the object",
                },
                {
                    "field": "metageneration",
                    "type": "string",
                    "helper_text": "The metageneration of the object",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "The content type of the object",
                },
                {
                    "field": "time_created",
                    "type": "timestamp",
                    "helper_text": "The creation time of the object",
                },
                {
                    "field": "updated",
                    "type": "timestamp",
                    "helper_text": "The last update time of the object",
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "helper_text": "The storage class of the object",
                },
                {
                    "field": "size",
                    "type": "string",
                    "helper_text": "The size of the object in bytes",
                },
                {
                    "field": "md5_hash",
                    "type": "string",
                    "helper_text": "The MD5 hash of the object",
                },
                {
                    "field": "media_link",
                    "type": "string",
                    "helper_text": "The download URL for the object",
                },
                {
                    "field": "self_link",
                    "type": "string",
                    "helper_text": "The URI of the object",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "create_object",
            "task_name": "tasks.google_cloud_storage.create_object",
            "description": "Creates/uploads a new object to Google Cloud Storage",
            "label": "Create Object",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "bucket_name",
                "object_name",
                "file",
                "cache_control",
                "content_disposition",
                "content_encoding",
                "content_language",
                "metadata",
            ],
            "required": ["project_id", "bucket_name", "object_name", "file"],
        },
        "read_object": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket",
                    "placeholder": "Select a bucket",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&project={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "object_name",
                    "type": "string",
                    "label": "Object Name",
                    "helper_text": "Enter the name of the object to read",
                    "placeholder": "folder/subfolder/file.txt",
                },
                {
                    "field": "download_content",
                    "type": "bool",
                    "label": "Download Content",
                    "helper_text": "Download file content instead of metadata",
                    "value": False,
                },
                {
                    "field": "generation",
                    "type": "int32",
                    "value": 0,
                    "label": "Generation",
                    "helper_text": "Specify object generation for versioned buckets",
                    "placeholder": "1234567890",
                },
                {
                    "field": "projection",
                    "type": "string",
                    "label": "Projection",
                    "helper_text": "Select the level of detail to return",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "No ACL", "value": "noAcl"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "value": "noAcl",
                },
                {
                    "field": "alt",
                    "type": "string",
                    "value": "",
                    "label": "Alt Parameter",
                    "helper_text": "Alternative representation (json for metadata, media for content)",
                    "placeholder": "json",
                },
                {
                    "field": "encryption_key",
                    "type": "string",
                    "value": "",
                    "label": "Encryption Key",
                    "helper_text": "Customer-supplied encryption key (base64 encoded)",
                    "placeholder": "",
                },
                {
                    "field": "encryption_key_sha",
                    "type": "string",
                    "value": "",
                    "label": "Encryption Key SHA256",
                    "helper_text": "SHA256 hash of the encryption key (base64 encoded)",
                    "placeholder": "",
                },
            ],
            "outputs": [
                {
                    "field": "file",
                    "type": "file",
                    "helper_text": "The downloaded file (when download_content is true)",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the downloaded file (when download_content is true)",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "The content type of the object",
                },
                {
                    "field": "object_id",
                    "type": "string",
                    "helper_text": "The unique ID of the object",
                },
                {
                    "field": "object_name",
                    "type": "string",
                    "helper_text": "The name of the object",
                },
                {
                    "field": "bucket",
                    "type": "string",
                    "helper_text": "The bucket containing the object",
                },
                {
                    "field": "generation",
                    "type": "string",
                    "helper_text": "The generation of the object",
                },
                {
                    "field": "metageneration",
                    "type": "string",
                    "helper_text": "The metageneration of the object",
                },
                {
                    "field": "time_created",
                    "type": "timestamp",
                    "helper_text": "The creation time of the object",
                },
                {
                    "field": "updated",
                    "type": "timestamp",
                    "helper_text": "The last update time of the object",
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "helper_text": "The storage class of the object",
                },
                {
                    "field": "size",
                    "type": "string",
                    "helper_text": "The size of the object in bytes",
                },
                {
                    "field": "md5_hash",
                    "type": "string",
                    "helper_text": "The MD5 hash of the object",
                },
                {
                    "field": "crc32c",
                    "type": "string",
                    "helper_text": "The CRC32C checksum of the object",
                },
                {
                    "field": "etag",
                    "type": "string",
                    "helper_text": "The ETag of the object",
                },
                {
                    "field": "media_link",
                    "type": "string",
                    "helper_text": "The download URL for the object",
                },
                {
                    "field": "self_link",
                    "type": "string",
                    "helper_text": "The URI of the object",
                },
                {
                    "field": "metadata",
                    "type": "string",
                    "helper_text": "Custom metadata of the object",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "read_object",
            "task_name": "tasks.google_cloud_storage.read_object",
            "description": "Gets object data or metadata",
            "label": "Read Object",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "bucket_name",
                "object_name",
                "download_content",
                "generation",
                "projection",
                "alt",
                "encryption_key",
                "encryption_key_sha256",
            ],
            "required": ["project_id", "bucket_name", "object_name"],
        },
        "get_objects": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket",
                    "placeholder": "Select a bucket",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&project={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "projection",
                    "type": "string",
                    "label": "Projection",
                    "helper_text": "Select the level of detail to return",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "No ACL", "value": "noAcl"},
                            {"label": "Full", "value": "full"},
                        ],
                    },
                    "value": "noAcl",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Maximum number of objects to return",
                    "placeholder": "10",
                },
                {
                    "field": "prefix",
                    "type": "string",
                    "value": "",
                    "label": "Prefix",
                    "helper_text": "Filter results to objects whose names begin with this prefix",
                    "placeholder": "images/",
                },
                {
                    "field": "delimiter",
                    "type": "string",
                    "value": "",
                    "label": "Delimiter",
                    "helper_text": "Delimiter for directory-like listing",
                    "placeholder": "/",
                },
                {
                    "field": "include_versions",
                    "type": "bool",
                    "label": "Include Versions",
                    "helper_text": "Include all versions of objects",
                    "value": False,
                },
            ],
            "outputs": [
                {
                    "field": "objects",
                    "type": "string",
                    "helper_text": "List of object metadata",
                },
                {
                    "field": "object_names",
                    "type": "vec<string>",
                    "helper_text": "List of object names",
                },
                {
                    "field": "object_sizes",
                    "type": "vec<string>",
                    "helper_text": "List of object sizes",
                },
                {
                    "field": "content_types",
                    "type": "vec<string>",
                    "helper_text": "List of object content types",
                },
                {
                    "field": "time_created",
                    "type": "vec<timestamp>",
                    "helper_text": "List of object creation times",
                },
                {
                    "field": "updated",
                    "type": "vec<timestamp>",
                    "helper_text": "List of object update times",
                },
                {
                    "field": "prefixes",
                    "type": "vec<string>",
                    "helper_text": "List of prefixes (for directory-like listing)",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "get_objects",
            "task_name": "tasks.google_cloud_storage.get_objects",
            "description": "Retrieves a list of objects in a bucket",
            "label": "Get Objects",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "bucket_name",
                "projection",
                "limit",
                "prefix",
                "delimiter",
                "include_versions",
            ],
            "required": ["project_id", "bucket_name", "limit"],
        },
        "update_object": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket",
                    "placeholder": "Select a bucket",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&project={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "object_name",
                    "type": "string",
                    "label": "Object Name",
                    "helper_text": "Enter the name of the object to update",
                    "placeholder": "folder/subfolder/file.txt",
                },
                {
                    "field": "metadata",
                    "type": "string",
                    "value": "",
                    "label": "Custom Metadata",
                    "helper_text": "Custom metadata for the object (JSON format)",
                    "placeholder": '{"key": "value"}',
                },
                {
                    "field": "cache_control",
                    "type": "string",
                    "value": "",
                    "label": "Cache Control",
                    "helper_text": "Cache control directives",
                    "placeholder": "max-age=3600, public",
                },
                {
                    "field": "content_disposition",
                    "type": "string",
                    "value": "",
                    "label": "Content Disposition",
                    "helper_text": "How the object should be displayed",
                    "placeholder": "attachment; filename=example.pdf",
                },
                {
                    "field": "content_encoding",
                    "type": "string",
                    "value": "",
                    "label": "Content Encoding",
                    "helper_text": "Content encoding of the object",
                    "placeholder": "gzip",
                },
                {
                    "field": "content_language",
                    "type": "string",
                    "value": "",
                    "label": "Content Language",
                    "helper_text": "Language of the content",
                    "placeholder": "en-US",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "value": "",
                    "label": "Content Type",
                    "helper_text": "MIME type of the object",
                    "placeholder": "image/png",
                },
                {
                    "field": "generation",
                    "type": "int32",
                    "value": 0,
                    "label": "Generation",
                    "helper_text": "Specify object generation for versioned buckets",
                    "placeholder": "1234567890",
                },
            ],
            "outputs": [
                {
                    "field": "object_id",
                    "type": "string",
                    "helper_text": "The unique ID of the object",
                },
                {
                    "field": "object_name",
                    "type": "string",
                    "helper_text": "The name of the object",
                },
                {
                    "field": "bucket",
                    "type": "string",
                    "helper_text": "The bucket containing the object",
                },
                {
                    "field": "generation",
                    "type": "string",
                    "helper_text": "The generation of the object",
                },
                {
                    "field": "metageneration",
                    "type": "string",
                    "helper_text": "The metageneration of the object",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "The content type of the object",
                },
                {
                    "field": "time_created",
                    "type": "timestamp",
                    "helper_text": "The creation time of the object",
                },
                {
                    "field": "updated",
                    "type": "timestamp",
                    "helper_text": "The last update time of the object",
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "helper_text": "The storage class of the object",
                },
                {
                    "field": "size",
                    "type": "string",
                    "helper_text": "The size of the object in bytes",
                },
                {
                    "field": "md5_hash",
                    "type": "string",
                    "helper_text": "The MD5 hash of the object",
                },
                {
                    "field": "metadata",
                    "type": "string",
                    "helper_text": "Custom metadata of the object",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "update_object",
            "task_name": "tasks.google_cloud_storage.update_object",
            "description": "Updates object metadata",
            "label": "Update Object",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "bucket_name",
                "object_name",
                "metadata",
                "cache_control",
                "content_disposition",
                "content_encoding",
                "content_language",
                "content_type",
                "generation",
            ],
            "required": ["project_id", "bucket_name", "object_name"],
        },
        "delete_object": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "label": "Project",
                    "helper_text": "Select your Google Cloud Project",
                    "placeholder": "Select a project",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket",
                    "placeholder": "Select a bucket",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bucket&project={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "object_name",
                    "type": "string",
                    "label": "Object Name",
                    "helper_text": "Enter the name of the object to delete",
                    "placeholder": "folder/subfolder/file.txt",
                },
                {
                    "field": "generation",
                    "type": "int32",
                    "value": 0,
                    "label": "Generation",
                    "helper_text": "Specify object generation for versioned buckets",
                    "placeholder": "1234567890",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
            ],
            "name": "delete_object",
            "task_name": "tasks.google_cloud_storage.delete_object",
            "description": "Deletes an object from Google Cloud Storage",
            "label": "Delete Object",
            "input_sort_order": [
                "action",
                "integration",
                "project_id",
                "bucket_name",
                "object_name",
                "generation",
            ],
            "required": ["project_id", "bucket_name", "object_name"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        alt: str = "",
        bucket_name: str = "",
        cache_control: str = "",
        content_disposition: str = "",
        content_encoding: str = "",
        content_language: str = "",
        content_type: str = "",
        cors: str = "",
        delimiter: str = "",
        download_content: bool = False,
        encryption: str = "",
        encryption_key: str = "",
        encryption_key_sha: str = "",
        file: str = "",
        generation: int = 0,
        include_versions: bool = False,
        labels: str = "",
        lifecycle: str = "",
        limit: int = 10,
        location: str = "",
        logging: str = "",
        metadata: str = "",
        object_name: str = "",
        prefix: str = "",
        project_id: Optional[str] = None,
        projection: str = "noAcl",
        storage_class: str = "STANDARD",
        uniform_bucket_level_access: bool = False,
        versioning: bool = False,
        website: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_cloud_storage",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if project_id is not None:
            self.inputs["project_id"] = project_id
        if bucket_name is not None:
            self.inputs["bucket_name"] = bucket_name
        if location is not None:
            self.inputs["location"] = location
        if storage_class is not None:
            self.inputs["storage_class"] = storage_class
        if uniform_bucket_level_access is not None:
            self.inputs["uniform_bucket_level_access"] = uniform_bucket_level_access
        if cors is not None:
            self.inputs["cors"] = cors
        if lifecycle is not None:
            self.inputs["lifecycle"] = lifecycle
        if versioning is not None:
            self.inputs["versioning"] = versioning
        if projection is not None:
            self.inputs["projection"] = projection
        if limit is not None:
            self.inputs["limit"] = limit
        if prefix is not None:
            self.inputs["prefix"] = prefix
        if labels is not None:
            self.inputs["labels"] = labels
        if website is not None:
            self.inputs["website"] = website
        if logging is not None:
            self.inputs["logging"] = logging
        if encryption is not None:
            self.inputs["encryption"] = encryption
        if object_name is not None:
            self.inputs["object_name"] = object_name
        if file is not None:
            self.inputs["file"] = file
        if cache_control is not None:
            self.inputs["cache_control"] = cache_control
        if content_disposition is not None:
            self.inputs["content_disposition"] = content_disposition
        if content_encoding is not None:
            self.inputs["content_encoding"] = content_encoding
        if content_language is not None:
            self.inputs["content_language"] = content_language
        if metadata is not None:
            self.inputs["metadata"] = metadata
        if download_content is not None:
            self.inputs["download_content"] = download_content
        if generation is not None:
            self.inputs["generation"] = generation
        if alt is not None:
            self.inputs["alt"] = alt
        if encryption_key is not None:
            self.inputs["encryption_key"] = encryption_key
        if encryption_key_sha is not None:
            self.inputs["encryption_key_sha"] = encryption_key_sha
        if delimiter is not None:
            self.inputs["delimiter"] = delimiter
        if include_versions is not None:
            self.inputs["include_versions"] = include_versions
        if content_type is not None:
            self.inputs["content_type"] = content_type
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleCloudStorageNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_firebase_realtime_db")
class IntegrationGoogleFirebaseRealtimeDbNode(Node):
    """
    Google Firebase Realtime DB

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_record
        data: The data to write (JSON format)
        database_url: Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)
        path: The path where you want to create/write data
    ### push_to_list
        data: The data to write (JSON format)
        database_url: Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)
        path: The path where you want to create/write data
    ### read_record
        database_url: Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)
        path: The path where you want to create/write data
    ### update_record
        database_url: Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)
        path: The path where you want to create/write data
        update_data: The fields to update (JSON format)
    ### delete_record
        database_url: Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)
        path: The path where you want to create/write data

    ## Outputs
    ### create_record
        data: The data that was written
        message: Status message
        path: The path where data was written
        raw_data: Raw response from Firebase
        success: Whether the operation was successful
    ### read_record
        data: The data read from the Realtime DB
        item_count: Number of items if data is a collection
        keys: List of keys if data is an object
        path: The path that was read
        raw_data: Raw response from Firebase
    ### push_to_list
        full_path: The full path including the generated key
        generated_key: The auto-generated key for the new item
        message: Status message
        path: The path where data was pushed
        pushed_data: The data that was pushed
        raw_data: Raw response from Firebase
        success: Whether the operation was successful
    ### update_record
        message: Status message
        path: The path that was updated
        raw_data: Raw response from Firebase
        response: Response from Firebase
        success: Whether the operation was successful
        updated_fields: The fields that were updated
    ### delete_record
        message: Status message
        path: The path that was deleted
        success: Whether the operation was successful
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Firebase Realtime DB>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "create_record": {
            "inputs": [
                {
                    "field": "database_url",
                    "type": "string",
                    "value": "",
                    "label": "Database URL",
                    "placeholder": "https://your-project-id-default-rtdb.firebaseio.com",
                    "helper_text": "Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)",
                },
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "label": "Path",
                    "placeholder": "/users/123",
                    "helper_text": "The path where you want to create/write data",
                },
                {
                    "field": "data",
                    "type": "string",
                    "value": "",
                    "label": "Data",
                    "placeholder": '{"name": "John", "age": 30}',
                    "helper_text": "The data to write (JSON format)",
                },
            ],
            "outputs": [
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "The path where data was written",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The data that was written",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Firebase",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "name": "create_record",
            "task_name": "tasks.google_firebase_realtime_db.create_record",
            "description": "Write data to Firebase Realtime Database",
            "label": "Create/Write Data",
            "inputs_sort_order": [
                "integration",
                "action",
                "database_url",
                "path",
                "data",
            ],
            "required": ["database_url", "path", "data"],
        },
        "read_record": {
            "inputs": [
                {
                    "field": "database_url",
                    "type": "string",
                    "value": "",
                    "label": "Database URL",
                    "placeholder": "https://your-project-id-default-rtdb.firebaseio.com",
                    "helper_text": "Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)",
                },
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "label": "Path",
                    "placeholder": "/users/123/name",
                    "helper_text": "The path to the data you want to read",
                },
            ],
            "outputs": [
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "The path that was read",
                },
                {
                    "field": "data",
                    "type": "string",
                    "helper_text": "The data read from the Realtime DB",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Firebase",
                },
                {
                    "field": "keys",
                    "type": "vec<string>",
                    "helper_text": "List of keys if data is an object",
                },
                {
                    "field": "item_count",
                    "type": "string",
                    "helper_text": "Number of items if data is a collection",
                },
            ],
            "name": "read_record",
            "task_name": "tasks.google_firebase_realtime_db.read_record",
            "description": "Read data from Google Firebase Realtime DB",
            "label": "Read Data",
            "inputs_sort_order": ["integration", "action", "database_url", "path"],
            "required": ["database_url", "path"],
        },
        "update_record": {
            "inputs": [
                {
                    "field": "database_url",
                    "type": "string",
                    "value": "",
                    "label": "Database URL",
                    "placeholder": "https://your-project-id-default-rtdb.firebaseio.com",
                    "helper_text": "Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)",
                },
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "label": "Path",
                    "placeholder": "/users/123",
                    "helper_text": "The path to the data you want to update",
                },
                {
                    "field": "update_data",
                    "type": "string",
                    "value": "",
                    "label": "Update Data",
                    "placeholder": '{"age": 31, "city": "New York"}',
                    "helper_text": "The fields to update (JSON format)",
                },
            ],
            "outputs": [
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "The path that was updated",
                },
                {
                    "field": "updated_fields",
                    "type": "string",
                    "helper_text": "The fields that were updated",
                },
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "Response from Firebase",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Firebase",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "name": "update_record",
            "task_name": "tasks.google_firebase_realtime_db.update_record",
            "description": "Update specific fields in Firebase Realtime Database",
            "label": "Update Data",
            "inputs_sort_order": [
                "integration",
                "action",
                "database_url",
                "path",
                "update_data",
            ],
            "required": ["database_url", "path", "update_data"],
        },
        "delete_record": {
            "inputs": [
                {
                    "field": "database_url",
                    "type": "string",
                    "value": "",
                    "label": "Database URL",
                    "placeholder": "https://your-project-id-default-rtdb.firebaseio.com",
                    "helper_text": "Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)",
                },
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "label": "Path",
                    "placeholder": "/users/123",
                    "helper_text": "The path to the data you want to delete",
                },
            ],
            "outputs": [
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "The path that was deleted",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "name": "delete_record",
            "task_name": "tasks.google_firebase_realtime_db.delete_record",
            "description": "Delete data from Firebase Realtime Database",
            "label": "Delete Data",
            "inputs_sort_order": ["integration", "action", "database_url", "path"],
            "required": ["database_url", "path"],
        },
        "push_to_list": {
            "inputs": [
                {
                    "field": "database_url",
                    "type": "string",
                    "value": "",
                    "label": "Database URL",
                    "placeholder": "https://your-project-id-default-rtdb.firebaseio.com",
                    "helper_text": "Your Firebase Realtime Database URL (e.g., https://your-project-id-default-rtdb.firebaseio.com)",
                },
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "label": "Path",
                    "placeholder": "/messages",
                    "helper_text": "The path to the list where you want to push data",
                },
                {
                    "field": "data",
                    "type": "string",
                    "value": "",
                    "label": "Data",
                    "placeholder": '{"text": "Hello", "timestamp": 1234567890}',
                    "helper_text": "The data to push to the list (JSON format)",
                },
            ],
            "outputs": [
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "The path where data was pushed",
                },
                {
                    "field": "pushed_data",
                    "type": "string",
                    "helper_text": "The data that was pushed",
                },
                {
                    "field": "generated_key",
                    "type": "string",
                    "helper_text": "The auto-generated key for the new item",
                },
                {
                    "field": "full_path",
                    "type": "string",
                    "helper_text": "The full path including the generated key",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response from Firebase",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "name": "push_to_list",
            "task_name": "tasks.google_firebase_realtime_db.push_to_list",
            "description": "Push data to a list in Firebase Realtime Database with auto-generated key",
            "label": "Push to List",
            "inputs_sort_order": [
                "integration",
                "action",
                "database_url",
                "path",
                "data",
            ],
            "required": ["database_url", "path", "data"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        data: str = "",
        database_url: str = "",
        path: str = "",
        update_data: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_firebase_realtime_db",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if database_url is not None:
            self.inputs["database_url"] = database_url
        if path is not None:
            self.inputs["path"] = path
        if data is not None:
            self.inputs["data"] = data
        if update_data is not None:
            self.inputs["update_data"] = update_data
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleFirebaseRealtimeDbNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_cloud_firestore")
class IntegrationGoogleCloudFirestoreNode(Node):
    """
    Google Cloud Firestore

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_document
        collection: The collection name where the document will be created
        database: The Firestore database name. Leave as (default) for the default database
        document_id: Optional document ID. If not provided, Firestore will generate one automatically
        fields: JSON object containing the document fields
        project_id: The Google Cloud project ID
    ### upsert_document
        collection: The collection name where the document will be created
        database: The Firestore database name. Leave as (default) for the default database
        fields: JSON object containing the document fields
        project_id: The Google Cloud project ID
        update_key: The field name in the document that contains the document ID
    ### delete_document
        collection: The collection name where the document will be created
        database: The Firestore database name. Leave as (default) for the default database
        document_id: Optional document ID. If not provided, Firestore will generate one automatically
        project_id: The Google Cloud project ID
    ### read_document
        collection: The collection name where the document will be created
        database: The Firestore database name. Leave as (default) for the default database
        document_id: Optional document ID. If not provided, Firestore will generate one automatically
        project_id: The Google Cloud project ID
    ### get_documents
        collection: The collection name where the document will be created
        database: The Firestore database name. Leave as (default) for the default database
        limit: Maximum number of documents to retrieve
        project_id: The Google Cloud project ID
    ### query_documents
        database: The Firestore database name. Leave as (default) for the default database
        project_id: The Google Cloud project ID
        query: Firestore query in JSON format
    ### get_collections
        database: The Firestore database name. Leave as (default) for the default database
        limit: Maximum number of documents to retrieve
        project_id: The Google Cloud project ID

    ## Outputs
    ### get_collections
        collection_count: Number of collections retrieved
        collection_ids: List of collection IDs
        collections: Array of collection information in JSON format
        raw_data: The raw data returned from the API
    ### create_document
        create_time: Timestamp when the document was created
        document_id: The ID of the created document
        document_name: The full resource name of the created document
        fields: The document fields in JSON format
        raw_data: The raw data returned from the API
        update_time: Timestamp when the document was last updated
    ### read_document
        create_time: Timestamp when the document was created
        document_id: The ID of the document
        document_name: The full resource name of the document
        fields: The document fields in JSON format
        raw_data: The raw data returned from the API
        update_time: Timestamp when the document was last updated
    ### get_documents
        create_times: List of timestamps when the documents were created
        document_count: Number of documents retrieved
        document_ids: List of document IDs
        document_names: List of document names
        documents: Array of documents in JSON format
        raw_data: The raw data returned from the API
        update_times: List of timestamps when the documents were last updated
    ### query_documents
        create_times: List of timestamps when the documents were created
        document_count: Number of documents that match the query
        document_ids: List of matching document IDs
        document_names: List of document names
        documents: Array of matching documents in JSON format
        raw_data: The raw data returned from the API
        update_times: List of timestamps when the documents were last updated
    ### delete_document
        deleted_at: Timestamp when the document was deleted
        document_id: The ID of the deleted document
        raw_data: The raw data returned from the API
        success: Whether the deletion was successful
    ### upsert_document
        document_id: The ID of the upserted document
        fields: The document fields in JSON format
        raw_data: The raw data returned from the API
        update_time: Timestamp when the document was last updated
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Cloud Firestore>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "create_document": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "my-project-123",
                    "helper_text": "The Google Cloud project ID",
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "(default)",
                    "label": "Database",
                    "placeholder": "(default)",
                    "helper_text": "The Firestore database name. Leave as (default) for the default database",
                },
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "placeholder": "users",
                    "helper_text": "The collection name where the document will be created",
                },
                {
                    "field": "document_id",
                    "type": "string",
                    "value": "",
                    "label": "Document ID",
                    "placeholder": "user123",
                    "helper_text": "Optional document ID. If not provided, Firestore will generate one automatically",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Document Fields",
                    "placeholder": '{"name": "John Doe", "age": 30}',
                    "helper_text": "JSON object containing the document fields",
                },
            ],
            "outputs": [
                {
                    "field": "document_id",
                    "type": "string",
                    "helper_text": "The ID of the created document",
                },
                {
                    "field": "document_name",
                    "type": "string",
                    "helper_text": "The full resource name of the created document",
                },
                {
                    "field": "create_time",
                    "type": "timestamp",
                    "helper_text": "Timestamp when the document was created",
                },
                {
                    "field": "update_time",
                    "type": "timestamp",
                    "helper_text": "Timestamp when the document was last updated",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "helper_text": "The document fields in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw data returned from the API",
                },
            ],
            "name": "create_document",
            "task_name": "tasks.google_cloud_firestore.create_document",
            "description": "Create a new document in Google Cloud Firestore",
            "label": "Create Document",
            "input_sort_order": [
                "integration",
                "action",
                "project_id",
                "collection",
                "fields",
            ],
        },
        "upsert_document": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "my-project-123",
                    "helper_text": "The Google Cloud project ID",
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "(default)",
                    "label": "Database",
                    "placeholder": "(default)",
                    "helper_text": "The Firestore database name. Leave as (default) for the default database",
                },
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "placeholder": "users",
                    "helper_text": "The collection name where the document exists or will be created",
                },
                {
                    "field": "update_key",
                    "type": "string",
                    "value": "",
                    "label": "Update Key",
                    "placeholder": "user_id",
                    "helper_text": "The field name in the document that contains the document ID",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Document Fields",
                    "placeholder": '{"user_id": "user123", "name": "John Doe", "age": 30}',
                    "helper_text": "JSON object containing the document fields. Must include the update key field",
                },
            ],
            "outputs": [
                {
                    "field": "document_id",
                    "type": "string",
                    "helper_text": "The ID of the upserted document",
                },
                {
                    "field": "update_time",
                    "type": "timestamp",
                    "helper_text": "Timestamp when the document was last updated",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "helper_text": "The document fields in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw data returned from the API",
                },
            ],
            "name": "upsert_document",
            "task_name": "tasks.google_cloud_firestore.upsert_document",
            "description": "Update an existing document or create it if it doesn't exist",
            "label": "Upsert Document",
            "input_sort_order": [
                "integration",
                "action",
                "project_id",
                "collection",
                "update_key",
                "fields",
            ],
        },
        "delete_document": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "my-project-123",
                    "helper_text": "The Google Cloud project ID",
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "(default)",
                    "label": "Database",
                    "placeholder": "(default)",
                    "helper_text": "The Firestore database name. Leave as (default) for the default database",
                },
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "placeholder": "users",
                    "helper_text": "The collection name containing the document to delete",
                },
                {
                    "field": "document_id",
                    "type": "string",
                    "value": "",
                    "label": "Document ID",
                    "placeholder": "user123",
                    "helper_text": "The ID of the document to delete",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "document_id",
                    "type": "string",
                    "helper_text": "The ID of the deleted document",
                },
                {
                    "field": "deleted_at",
                    "type": "timestamp",
                    "helper_text": "Timestamp when the document was deleted",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw data returned from the API",
                },
            ],
            "name": "delete_document",
            "task_name": "tasks.google_cloud_firestore.delete_document",
            "description": "Delete a document from Google Cloud Firestore",
            "label": "Delete Document",
            "input_sort_order": [
                "integration",
                "action",
                "project_id",
                "collection",
                "document_id",
            ],
            "required": ["document_id"],
        },
        "read_document": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "my-project-123",
                    "helper_text": "The Google Cloud project ID",
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "(default)",
                    "label": "Database",
                    "placeholder": "(default)",
                    "helper_text": "The Firestore database name. Leave as (default) for the default database",
                },
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "placeholder": "users",
                    "helper_text": "The collection name containing the document to read",
                },
                {
                    "field": "document_id",
                    "type": "string",
                    "value": "",
                    "label": "Document ID",
                    "placeholder": "user123",
                    "helper_text": "The ID of the document to read",
                },
            ],
            "outputs": [
                {
                    "field": "document_id",
                    "type": "string",
                    "helper_text": "The ID of the document",
                },
                {
                    "field": "document_name",
                    "type": "string",
                    "helper_text": "The full resource name of the document",
                },
                {
                    "field": "create_time",
                    "type": "timestamp",
                    "helper_text": "Timestamp when the document was created",
                },
                {
                    "field": "update_time",
                    "type": "timestamp",
                    "helper_text": "Timestamp when the document was last updated",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "helper_text": "The document fields in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw data returned from the API",
                },
            ],
            "name": "read_document",
            "task_name": "tasks.google_cloud_firestore.read_document",
            "description": "Read a single document from Google Cloud Firestore",
            "label": "Read Document",
            "input_sort_order": [
                "integration",
                "action",
                "project_id",
                "collection",
                "document_id",
            ],
            "required": ["document_id"],
        },
        "get_documents": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "my-project-123",
                    "helper_text": "The Google Cloud project ID",
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "(default)",
                    "label": "Database",
                    "placeholder": "(default)",
                    "helper_text": "The Firestore database name. Leave as (default) for the default database",
                },
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "placeholder": "users",
                    "helper_text": "The collection name to retrieve documents from",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of documents to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "documents",
                    "type": "string",
                    "helper_text": "Array of documents in JSON format",
                },
                {
                    "field": "document_ids",
                    "type": "vec<string>",
                    "helper_text": "List of document IDs",
                },
                {
                    "field": "document_names",
                    "type": "vec<string>",
                    "helper_text": "List of document names",
                },
                {
                    "field": "create_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of timestamps when the documents were created",
                },
                {
                    "field": "update_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of timestamps when the documents were last updated",
                },
                {
                    "field": "document_count",
                    "type": "int32",
                    "helper_text": "Number of documents retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw data returned from the API",
                },
            ],
            "name": "get_documents",
            "task_name": "tasks.google_cloud_firestore.get_documents",
            "description": "Get multiple documents from a collection",
            "label": "Get Documents",
            "input_sort_order": [
                "integration",
                "action",
                "project_id",
                "collection",
                "limit",
            ],
        },
        "query_documents": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "my-project-123",
                    "helper_text": "The Google Cloud project ID",
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "(default)",
                    "label": "Database",
                    "placeholder": "(default)",
                    "helper_text": "The Firestore database name. Leave as (default) for the default database",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query JSON",
                    "placeholder": '{"from":[{"collectionId":"users"}]}',
                    "helper_text": "Firestore query in JSON format",
                },
            ],
            "outputs": [
                {
                    "field": "documents",
                    "type": "string",
                    "helper_text": "Array of matching documents in JSON format",
                },
                {
                    "field": "document_ids",
                    "type": "vec<string>",
                    "helper_text": "List of matching document IDs",
                },
                {
                    "field": "document_names",
                    "type": "vec<string>",
                    "helper_text": "List of document names",
                },
                {
                    "field": "create_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of timestamps when the documents were created",
                },
                {
                    "field": "update_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of timestamps when the documents were last updated",
                },
                {
                    "field": "document_count",
                    "type": "int32",
                    "helper_text": "Number of documents that match the query",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw data returned from the API",
                },
            ],
            "name": "query_documents",
            "task_name": "tasks.google_cloud_firestore.query_documents",
            "description": "Query documents using Firestore structured query",
            "label": "Query Documents",
            "input_sort_order": ["integration", "action", "project_id", "query"],
        },
        "get_collections": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "label": "Project ID",
                    "placeholder": "my-project-123",
                    "helper_text": "The Google Cloud project ID",
                },
                {
                    "field": "database",
                    "type": "string",
                    "value": "(default)",
                    "label": "Database",
                    "placeholder": "(default)",
                    "helper_text": "The Firestore database name. Leave as (default) for the default database",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of collections to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "collections",
                    "type": "string",
                    "helper_text": "Array of collection information in JSON format",
                },
                {
                    "field": "collection_ids",
                    "type": "vec<string>",
                    "helper_text": "List of collection IDs",
                },
                {
                    "field": "collection_count",
                    "type": "int32",
                    "helper_text": "Number of collections retrieved",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw data returned from the API",
                },
            ],
            "name": "get_collections",
            "task_name": "tasks.google_cloud_firestore.get_collections",
            "description": "List all collections in the database",
            "label": "Get Collections",
            "input_sort_order": ["integration", "action", "project_id", "limit"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        collection: str = "",
        database: str = "(default)",
        document_id: str = "",
        fields: str = "",
        limit: int = 10,
        project_id: str = "",
        query: str = "",
        update_key: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_cloud_firestore",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if project_id is not None:
            self.inputs["project_id"] = project_id
        if database is not None:
            self.inputs["database"] = database
        if collection is not None:
            self.inputs["collection"] = collection
        if document_id is not None:
            self.inputs["document_id"] = document_id
        if fields is not None:
            self.inputs["fields"] = fields
        if update_key is not None:
            self.inputs["update_key"] = update_key
        if limit is not None:
            self.inputs["limit"] = limit
        if query is not None:
            self.inputs["query"] = query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleCloudFirestoreNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_perspective")
class IntegrationGooglePerspectiveNode(Node):
    """
    Google Perspective

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### analyze_comment
        comment: The text content to analyze for various attributes
        language: Language code (e.g., en, es, fr). Leave empty for auto-detection
        requested_attributes: Select which attribute to analyze
        score_threshold: Optional threshold (0-1) to filter results. Only scores above this value will be flagged

    ## Outputs
    ### analyze_comment
        attribute_scores: JSON object containing scores for requested attribute
        detected_languages: Languages detected in the comment
        raw_response: Complete API response as JSON string
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Perspective>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "analyze_comment": {
            "inputs": [
                {
                    "field": "comment",
                    "type": "string",
                    "value": "",
                    "label": "Comment",
                    "placeholder": "This is a comment to analyze",
                    "helper_text": "The text content to analyze for various attributes",
                },
                {
                    "field": "requested_attributes",
                    "type": "string",
                    "value": "TOXICITY",
                    "label": "Attributes to Analyze",
                    "placeholder": "TOXICITY,INSULT,THREAT",
                    "helper_text": "Select which attribute to analyze",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Toxicity", "value": "TOXICITY"},
                            {"label": "Severe Toxicity", "value": "SEVERE_TOXICITY"},
                            {"label": "Identity Attack", "value": "IDENTITY_ATTACK"},
                            {"label": "Insult", "value": "INSULT"},
                            {"label": "Profanity", "value": "PROFANITY"},
                            {"label": "Threat", "value": "THREAT"},
                            {
                                "label": "Sexually Explicit",
                                "value": "SEXUALLY_EXPLICIT",
                            },
                            {"label": "Flirtation", "value": "FLIRTATION"},
                        ],
                    },
                },
                {
                    "field": "language",
                    "type": "string",
                    "value": "",
                    "label": "Language",
                    "placeholder": "en",
                    "helper_text": "Language code (e.g., en, es, fr). Leave empty for auto-detection",
                },
                {
                    "field": "score_threshold",
                    "type": "float",
                    "value": "",
                    "label": "Score Threshold",
                    "placeholder": "0.7",
                    "helper_text": "Optional threshold (0-1) to filter results. Only scores above this value will be flagged",
                },
            ],
            "outputs": [
                {
                    "field": "attribute_scores",
                    "type": "string",
                    "helper_text": "JSON object containing scores for requested attribute",
                },
                {
                    "field": "detected_languages",
                    "type": "vec<string>",
                    "helper_text": "Languages detected in the comment",
                },
                {
                    "field": "raw_response",
                    "type": "string",
                    "helper_text": "Complete API response as JSON string",
                },
            ],
            "name": "analyze_comment",
            "task_name": "tasks.google_perspective.analyze_comment",
            "description": "Analyze a comment for toxicity, threats, insults, and other attributes using Google Perspective API",
            "label": "Analyze Comment",
            "inputs_sort_order": [
                "comment",
                "requested_attributes",
                "language",
                "score_threshold",
            ],
            "required": ["comment", "requested_attributes"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        comment: str = "",
        language: str = "",
        requested_attributes: str = "TOXICITY",
        score_threshold: Any = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_perspective",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if comment is not None:
            self.inputs["comment"] = comment
        if requested_attributes is not None:
            self.inputs["requested_attributes"] = requested_attributes
        if language is not None:
            self.inputs["language"] = language
        if score_threshold is not None:
            self.inputs["score_threshold"] = score_threshold
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGooglePerspectiveNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_microsoft")
class IntegrationMicrosoftNode(Node):
    """
    Microsoft One Drive

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### create_file
        content_type: MIME type of the file
        file_content: Content of the file
        file_name: Name of the file to create
        folder_id: ID of the folder where the file will be created
    ### copy_file
        destination_folder_id: Select the destination folder
        file_id: Select the file to read from OneDrive
        new_name: New name for the copied file (optional)
    ### create_file_share_link
        expiration_date: Expiration date for the link (ISO 8601)
        item_id: Select the folder within your OneDrive to add the file
        link_scope: Scope of link
        link_type: Type of link
        password: Password for the link (optional)
    ### create_folder_share_link
        expiration_date: Expiration date for the link (ISO 8601)
        item_id: Select the folder within your OneDrive to add the file
        link_scope: Scope of link
        link_type: Type of link
        password: Password for the link (optional)
    ### add_file
        file: Select or Upload a file
        item_id: Select the folder within your OneDrive to add the file
    ### read_file
        file_id: Select the file to read from OneDrive
    ### delete_file
        file_id: Select the file to read from OneDrive
    ### rename_file
        file_id: Select the file to read from OneDrive
        file_name: Name of the file to create
    ### read_folder
        folder_id: ID of the folder where the file will be created
    ### delete_folder
        folder_id: ID of the folder where the file will be created
    ### rename_folder
        folder_id: ID of the folder where the file will be created
        folder_name: Name of the folder to create
    ### create_folder
        folder_name: Name of the folder to create
        parent_folder_id: Select the parent folder
    ### get_files
        limit: Maximum number of files to return
        search_query: Search query to filter files
        skip_token: Token for pagination
    ### get_folders
        limit: Maximum number of files to return
        order_by: Sort order
        parent_folder_id: Select the parent folder
        skip_token: Token for pagination

    ## Outputs
    ### read_folder
        child_count: Number of items in the folder
        created_at: Creation timestamp
        folder_id: ID of the folder
        folder_name: Name of the folder
        folder_path: Full path of the folder
        folder_url: Web URL of the folder
        modified_at: Last modification timestamp
        raw_data: Complete response from the API
    ### get_folders
        child_counts: Array of child counts
        created_dates: Array of creation dates
        folder_ids: Array of folder IDs
        folder_names: Array of folder names
        folder_paths: Array of folder paths
        folder_urls: Array of folder URLs
        modified_dates: Array of modification dates
        next_link: URL for next page of results
        raw_data: Complete response from the API
    ### create_file
        created_at: Creation timestamp
        file_id: ID of the created file
        file_name: Name of the created file
        file_path: Full path of the file
        file_url: Web URL of the file
        raw_data: Complete response from the API
    ### read_file
        created_at: Creation timestamp
        download_url: Direct download URL
        file: File object
        file_id: ID of the file
        file_name: Name of the file
        file_size: Size of the file in bytes
        file_url: Web URL of the file
        mime_type: MIME type of the file
        modified_at: Last modification timestamp
        raw_data: Complete response from the API
    ### create_folder
        created_at: Creation timestamp
        folder_id: ID of the created folder
        folder_name: Name of the folder
        folder_path: Full path of the folder
        folder_url: Web URL of the folder
        raw_data: Complete response from the API
    ### get_files
        created_dates: Array of creation dates
        file_ids: Array of file IDs
        file_names: Array of file names
        file_paths: Array of file paths
        file_sizes: Array of file sizes
        file_urls: Array of file URLs
        mime_types: Array of MIME types
        modified_dates: Array of modification dates
        next_link: URL for next page of results
        raw_data: Complete response from the API
    ### create_file_share_link
        expiration_date: When the link expires
        permissions: Permissions granted by the link
        raw_data: Complete response from the API
        share_id: ID of the share
        share_link: The sharing link URL
    ### create_folder_share_link
        expiration_date: When the link expires
        permissions: Permissions granted by the link
        raw_data: Complete response from the API
        share_id: ID of the share
        share_link: The sharing link URL
    ### rename_file
        file_id: ID of the file
        file_name: Name of the file
        file_path: Full path of the file
        file_url: Web URL of the file
        modified_at: Last modification timestamp
        raw_data: Complete response from the API
    ### rename_folder
        folder_id: ID of the folder
        folder_name: Updated name of the folder
        folder_url: Web URL of the folder
        modified_at: Last modification timestamp
        raw_data: Complete response from the API
    ### delete_file
        message: Status message
        success: Whether the deletion was successful
    ### copy_file
        message: Status message
        success: Whether the copy was successful
    ### delete_folder
        message: Status message
        success: Whether the deletion was successful
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Microsoft>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "add_file": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder within your OneDrive to add the file",
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "label": "File",
                    "placeholder": "Select a file",
                    "helper_text": "Select or Upload a file",
                    "order": 4,
                },
            ],
            "outputs": [],
            "name": "add_file",
            "task_name": "tasks.microsoft.add_file",
            "description": "Add file to OneDrive",
            "label": "Add File",
            "inputs_sort_order": ["integration", "action", "item_id", "file"],
        },
        "create_file": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the folder where the file will be created",
                    "hidden": True,
                    "label": "Folder ID",
                    "placeholder": "root",
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the file to create",
                    "label": "File Name",
                    "placeholder": "document.txt",
                    "order": 4,
                },
                {
                    "field": "file_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content of the file",
                    "label": "File Content",
                    "placeholder": "File content here",
                    "order": 5,
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "value": "text/plain",
                    "helper_text": "MIME type of the file",
                    "label": "Content Type",
                    "placeholder": "text/plain",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the created file",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the created file",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "Web URL of the file",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Full path of the file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "create_file",
            "task_name": "tasks.microsoft.create_file",
            "description": "Create a new file in OneDrive",
            "label": "Create File",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "file_name",
                "file_content",
                "content_type",
            ],
        },
        "read_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to read from OneDrive",
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {"field": "file", "type": "file", "helper_text": "File object"},
                {"field": "file_id", "type": "string", "helper_text": "ID of the file"},
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the file in bytes",
                },
                {
                    "field": "mime_type",
                    "type": "string",
                    "helper_text": "MIME type of the file",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "Last modification timestamp",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "Web URL of the file",
                },
                {
                    "field": "download_url",
                    "type": "string",
                    "helper_text": "Direct download URL",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "read_file",
            "task_name": "tasks.microsoft.read_file",
            "description": "Read file from OneDrive",
            "label": "Read File",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
        "delete_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to delete from OneDrive",
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "name": "delete_file",
            "task_name": "tasks.microsoft.delete_file",
            "description": "Delete a file from OneDrive",
            "label": "Delete File",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
        "get_files": {
            "inputs": [
                {
                    "field": "search_query",
                    "type": "string",
                    "value": "",
                    "helper_text": "Search query to filter files",
                    "label": "Search Query",
                    "placeholder": "document",
                    "order": 3,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of files to return",
                    "label": "Limit",
                    "order": 4,
                },
                {
                    "field": "skip_token",
                    "type": "string",
                    "value": "",
                    "helper_text": "Token for pagination",
                    "label": "Skip Token",
                    "placeholder": "pagination_token",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "file_ids",
                    "type": "vec<string>",
                    "helper_text": "Array of file IDs",
                },
                {
                    "field": "file_names",
                    "type": "vec<string>",
                    "helper_text": "Array of file names",
                },
                {
                    "field": "file_urls",
                    "type": "vec<string>",
                    "helper_text": "Array of file URLs",
                },
                {
                    "field": "file_sizes",
                    "type": "vec<string>",
                    "helper_text": "Array of file sizes",
                },
                {
                    "field": "mime_types",
                    "type": "vec<string>",
                    "helper_text": "Array of MIME types",
                },
                {
                    "field": "created_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "Array of creation dates",
                },
                {
                    "field": "modified_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "Array of modification dates",
                },
                {
                    "field": "file_paths",
                    "type": "vec<string>",
                    "helper_text": "Array of file paths",
                },
                {
                    "field": "next_link",
                    "type": "string",
                    "helper_text": "URL for next page of results",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_files",
            "task_name": "tasks.microsoft.get_files",
            "description": "List files in a folder or search for files",
            "label": "Get Files",
            "inputs_sort_order": [
                "integration",
                "action",
                "search_query",
                "limit",
                "skip_token",
            ],
        },
        "copy_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the file to copy",
                    "label": "File",
                    "hidden": True,
                    "placeholder": "abc123",
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "destination_folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the destination folder",
                    "hidden": True,
                    "label": "Destination Folder",
                    "placeholder": "def456",
                    "order": 4,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "new_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the copied file (optional)",
                    "label": "New Name",
                    "placeholder": "copy_of_file.txt",
                    "order": 5,
                },
            ],
            "outputs": [
                {"field": "message", "type": "string", "helper_text": "Status message"},
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the copy was successful",
                },
            ],
            "name": "copy_file",
            "task_name": "tasks.microsoft.copy_file",
            "description": "Copy a file to another location",
            "label": "Copy File",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "destination_folder_id",
                "new_name",
            ],
        },
        "rename_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the file to rename",
                    "label": "File",
                    "placeholder": "abc123",
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the file",
                    "label": "File Name",
                    "placeholder": "renamed_file.txt",
                    "order": 4,
                },
            ],
            "outputs": [
                {"field": "file_id", "type": "string", "helper_text": "ID of the file"},
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the file",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "Web URL of the file",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "Last modification timestamp",
                },
                {
                    "field": "file_path",
                    "type": "string",
                    "helper_text": "Full path of the file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "rename_file",
            "task_name": "tasks.microsoft.rename_file",
            "description": "Rename a file in OneDrive",
            "label": "Rename File",
            "inputs_sort_order": ["integration", "action", "file_id", "file_name"],
        },
        "create_file_share_link": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the file",
                    "label": "File",
                    "placeholder": "abc123",
                    "hidden": True,
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "link_type",
                    "type": "string",
                    "value": "",
                    "helper_text": "Type of link",
                    "label": "Link Type",
                    "placeholder": "view or edit or embed",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "View", "value": "view"},
                            {"label": "Edit", "value": "edit"},
                            {"label": "Embed", "value": "embed"},
                        ],
                    },
                    "order": 4,
                },
                {
                    "field": "link_scope",
                    "type": "string",
                    "value": "",
                    "helper_text": "Scope of link",
                    "label": "Link Scope",
                    "placeholder": "anonymous or organization",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Any One", "value": "anonymous"},
                            {"label": "Within Organization", "value": "organization"},
                        ],
                    },
                    "order": 5,
                },
                {
                    "field": "password",
                    "type": "string",
                    "value": "",
                    "helper_text": "Password for the link (optional)",
                    "label": "Password",
                    "placeholder": "optional_password",
                    "order": 6,
                },
                {
                    "field": "expiration_date",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Expiration date for the link (ISO 8601)",
                    "label": "Expiration Date",
                    "placeholder": "2024-12-31T23:59:59Z",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "share_link",
                    "type": "string",
                    "helper_text": "The sharing link URL",
                },
                {
                    "field": "share_id",
                    "type": "string",
                    "helper_text": "ID of the share",
                },
                {
                    "field": "permissions",
                    "type": "vec<string>",
                    "helper_text": "Permissions granted by the link",
                },
                {
                    "field": "expiration_date",
                    "type": "timestamp",
                    "helper_text": "When the link expires",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "create_file_share_link",
            "task_name": "tasks.microsoft.create_share_link",
            "description": "Create a sharing link for a file",
            "label": "Create File Share Link",
            "inputs_sort_order": [
                "integration",
                "action",
                "item_id",
                "link_type",
                "link_scope",
                "password",
                "expiration_date",
            ],
        },
        "create_folder": {
            "inputs": [
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the parent folder",
                    "label": "Parent Folder",
                    "placeholder": "",
                    "hidden": True,
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the folder to create",
                    "label": "Folder Name",
                    "placeholder": "New Folder",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the created folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the folder",
                },
                {
                    "field": "folder_url",
                    "type": "string",
                    "helper_text": "Web URL of the folder",
                },
                {
                    "field": "folder_path",
                    "type": "string",
                    "helper_text": "Full path of the folder",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "create_folder",
            "task_name": "tasks.microsoft.create_folder",
            "description": "Create a new folder in OneDrive",
            "label": "Create Folder",
            "inputs_sort_order": [
                "integration",
                "action",
                "parent_folder_id",
                "folder_name",
            ],
        },
        "read_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the folder",
                    "label": "Folder",
                    "placeholder": "abc123",
                    "hidden": True,
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the folder",
                },
                {
                    "field": "folder_url",
                    "type": "string",
                    "helper_text": "Web URL of the folder",
                },
                {
                    "field": "folder_path",
                    "type": "string",
                    "helper_text": "Full path of the folder",
                },
                {
                    "field": "child_count",
                    "type": "string",
                    "helper_text": "Number of items in the folder",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "Last modification timestamp",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "read_folder",
            "task_name": "tasks.microsoft.read_folder",
            "description": "Get folder information",
            "label": "Read Folder",
            "inputs_sort_order": ["integration", "action", "folder_id"],
        },
        "delete_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the folder to delete",
                    "label": "Folder",
                    "placeholder": "abc123",
                    "hidden": True,
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "name": "delete_folder",
            "task_name": "tasks.microsoft.delete_folder",
            "description": "Delete a folder and all its contents",
            "label": "Delete Folder",
            "inputs_sort_order": ["integration", "action", "folder_id"],
        },
        "get_folders": {
            "inputs": [
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the parent folder",
                    "label": "Parent Folder",
                    "placeholder": "root",
                    "hidden": True,
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "name",
                    "helper_text": "Sort order",
                    "label": "Order By",
                    "placeholder": "name",
                    "order": 4,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of folders to return",
                    "label": "Limit",
                    "order": 5,
                },
                {
                    "field": "skip_token",
                    "type": "string",
                    "value": "",
                    "helper_text": "Token for pagination",
                    "label": "Skip Token",
                    "placeholder": "pagination_token",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "folder_ids",
                    "type": "vec<string>",
                    "helper_text": "Array of folder IDs",
                },
                {
                    "field": "folder_names",
                    "type": "vec<string>",
                    "helper_text": "Array of folder names",
                },
                {
                    "field": "folder_urls",
                    "type": "vec<string>",
                    "helper_text": "Array of folder URLs",
                },
                {
                    "field": "folder_paths",
                    "type": "vec<string>",
                    "helper_text": "Array of folder paths",
                },
                {
                    "field": "created_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "Array of creation dates",
                },
                {
                    "field": "modified_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "Array of modification dates",
                },
                {
                    "field": "child_counts",
                    "type": "vec<string>",
                    "helper_text": "Array of child counts",
                },
                {
                    "field": "next_link",
                    "type": "string",
                    "helper_text": "URL for next page of results",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "get_folders",
            "task_name": "tasks.microsoft.get_folders",
            "description": "List folders in a parent folder",
            "label": "Get Folders",
            "inputs_sort_order": [
                "integration",
                "action",
                "parent_folder_id",
                "order_by",
                "limit",
                "skip_token",
            ],
        },
        "rename_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the folder to rename",
                    "label": "Folder",
                    "placeholder": "abc123",
                    "order": 3,
                    "hidden": True,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the folder",
                    "label": "Folder Name",
                    "placeholder": "Renamed Folder",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Updated name of the folder",
                },
                {
                    "field": "folder_url",
                    "type": "string",
                    "helper_text": "Web URL of the folder",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "Last modification timestamp",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "rename_folder",
            "task_name": "tasks.microsoft.rename_folder",
            "description": "Rename a folder in OneDrive",
            "label": "Rename Folder",
            "inputs_sort_order": ["integration", "action", "folder_id", "folder_name"],
        },
        "create_folder_share_link": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the folder",
                    "label": "Folder",
                    "placeholder": "abc123",
                    "hidden": True,
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "link_type",
                    "type": "string",
                    "value": "",
                    "helper_text": "Type of link",
                    "label": "Link Type",
                    "placeholder": "view or edit or embed",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "View", "value": "view"},
                            {"label": "Edit", "value": "edit"},
                            {"label": "Embed", "value": "embed"},
                        ],
                    },
                    "order": 4,
                },
                {
                    "field": "link_scope",
                    "type": "string",
                    "value": "",
                    "helper_text": "Scope of link",
                    "label": "Link Scope",
                    "placeholder": "anonymous or organization",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Any One", "value": "anonymous"},
                            {"label": "Within Organization", "value": "organization"},
                        ],
                    },
                    "order": 5,
                },
                {
                    "field": "password",
                    "type": "string",
                    "value": "",
                    "helper_text": "Password for the link (optional)",
                    "label": "Password",
                    "placeholder": "optional_password",
                    "order": 6,
                },
                {
                    "field": "expiration_date",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Expiration date for the link (ISO 8601)",
                    "label": "Expiration Date",
                    "placeholder": "2024-12-31T23:59:59Z",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "share_link",
                    "type": "string",
                    "helper_text": "The sharing link URL",
                },
                {
                    "field": "share_id",
                    "type": "string",
                    "helper_text": "ID of the share",
                },
                {
                    "field": "permissions",
                    "type": "vec<string>",
                    "helper_text": "Permissions granted by the link",
                },
                {
                    "field": "expiration_date",
                    "type": "timestamp",
                    "helper_text": "When the link expires",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete response from the API",
                },
            ],
            "name": "create_folder_share_link",
            "task_name": "tasks.microsoft.create_share_link",
            "description": "Create a sharing link for a folder",
            "label": "Create Folder Share Link",
            "inputs_sort_order": [
                "integration",
                "action",
                "item_id",
                "link_type",
                "link_scope",
                "password",
                "expiration_date",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        content_type: str = "text/plain",
        destination_folder_id: str = "",
        expiration_date: Any = None,
        file: str = "",
        file_content: str = "",
        file_id: Optional[str] = None,
        file_name: str = "",
        folder_id: str = "",
        folder_name: str = "",
        item_id: Optional[str] = None,
        limit: int = 10,
        link_scope: str = "",
        link_type: str = "",
        new_name: str = "",
        order_by: str = "name",
        parent_folder_id: str = "",
        password: str = "",
        search_query: str = "",
        skip_token: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_microsoft",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if file is not None:
            self.inputs["file"] = file
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if file_name is not None:
            self.inputs["file_name"] = file_name
        if file_content is not None:
            self.inputs["file_content"] = file_content
        if content_type is not None:
            self.inputs["content_type"] = content_type
        if file_id is not None:
            self.inputs["file_id"] = file_id
        if search_query is not None:
            self.inputs["search_query"] = search_query
        if limit is not None:
            self.inputs["limit"] = limit
        if skip_token is not None:
            self.inputs["skip_token"] = skip_token
        if destination_folder_id is not None:
            self.inputs["destination_folder_id"] = destination_folder_id
        if new_name is not None:
            self.inputs["new_name"] = new_name
        if link_type is not None:
            self.inputs["link_type"] = link_type
        if link_scope is not None:
            self.inputs["link_scope"] = link_scope
        if password is not None:
            self.inputs["password"] = password
        if expiration_date is not None:
            self.inputs["expiration_date"] = expiration_date
        if parent_folder_id is not None:
            self.inputs["parent_folder_id"] = parent_folder_id
        if folder_name is not None:
            self.inputs["folder_name"] = folder_name
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationMicrosoftNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_typeform")
class IntegrationTypeformNode(Node):
    """
    Typeform

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### get_responses
        form_id: Select the form from which to get the responses
        number_of_responses: The number of responses to fetch

    ## Outputs
    ### get_responses
        list_of_responses: The responses in list format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Typeform>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_responses": {
            "inputs": [
                {
                    "field": "form_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Form",
                    "helper_text": "Select the form from which to get the responses",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "number_of_responses",
                    "type": "string",
                    "value": "",
                    "label": "Number of responses",
                    "placeholder": "5",
                    "helper_text": "The number of responses to fetch",
                },
            ],
            "outputs": [
                {
                    "field": "list_of_responses",
                    "type": "vec<string>",
                    "helper_text": "The responses in list format",
                }
            ],
            "name": "get_responses",
            "task_name": "tasks.typeform.get_responses",
            "description": "Get Form Responses From Typeform",
            "label": "Get Form Responses",
            "variant": "common_integration_file_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        form_id: str = "",
        number_of_responses: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_typeform",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if form_id is not None:
            self.inputs["form_id"] = form_id
        if number_of_responses is not None:
            self.inputs["number_of_responses"] = number_of_responses
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationTypeformNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_box")
class IntegrationBoxNode(Node):
    """
    Box

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### share_file
        access: Access level for the shared link
        can_download: Whether users can download the file
        can_preview: Whether users can preview the file
        file_id: Select the file to copy
    ### share_folder
        access: Access level for the shared link
        can_download: Whether users can download the file
        can_preview: Whether users can preview the file
        folder_id: Select the Folder to upload files to
    ### update_folder
        description: Description for the folder (optional)
        folder_id: Select the Folder to upload files to
        new_name: Name for the copied file (optional)
    ### copy_file
        destination_folder_id: Select the destination folder
        file_id: Select the file to copy
        new_name: Name for the copied file (optional)
    ### search_files
        file_extensions: Filter by file extensions (optional)
        folder_id: Select the Folder to upload files to
        limit: Maximum number of results to return (default: 10)
        query: Search query to find files
    ### delete_file
        file_id: Select the file to copy
    ### download_file
        file_id: Select the file to copy
    ### read_file
        file_id: Select the file to copy
    ### upload_files
        files: The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.)
        folder_id: Select the Folder to upload files to
    ### read_folder
        folder_id: Select the Folder to upload files to
    ### delete_folder
        folder_id: Select the Folder to upload files to
        recursive: Delete folder and all its contents (use with caution)
    ### create_folder
        folder_name: Name of the folder to create
        parent_folder_id: Select the parent folder where the new folder will be created

    ## Outputs
    ### share_file
        access_level: Access level of the shared link
        permissions: Permissions for the shared link
        raw_data: Raw API response data from Box
        shared_link: The shared link URL
    ### share_folder
        access_level: Access level of the shared link
        permissions: Permissions for the shared link
        raw_data: Raw API response data from Box
        shared_link: The shared link URL
    ### read_file
        created_at: When the file was created
        file_id: ID of the file
        file_name: Name of the file
        file_size: Size of the file
        file_url: URL to access the file
        modified_at: When the file was last modified
        owner_email: Email of the file owner
        owner_name: Name of the file owner
        parent_folder_id: ID of the parent folder
        raw_data: Raw API response data from Box
    ### create_folder
        created_at: When the folder was created
        folder_id: ID of the created folder
        folder_name: Name of the created folder
        folder_url: URL to access the created folder
        raw_data: Raw API response data from Box
    ### read_folder
        created_at: When the folder was created
        folder_id: ID of the folder
        folder_name: Name of the folder
        folder_url: URL to access the folder
        item_count: Number of items in the folder
        modified_at: When the folder was last modified
        owner_email: Email of the folder owner
        owner_name: Name of the folder owner
        parent_folder_id: ID of the parent folder
        raw_data: Raw API response data from Box
    ### search_files
        created_dates: Array of file creation timestamps
        file_ids: Array of file IDs
        file_names: Array of file names
        file_types: Array of file types
        file_urls: Array of file URLs
        files: List of found files with detailed information (legacy format)
        modified_dates: Array of file modification timestamps
        owner_emails: Array of file owner emails
        owner_names: Array of file owner names
        parent_folder_ids: Array of parent folder IDs
        raw_data: Raw API response data from Box
        total_count: Total number of files found
    ### update_folder
        description: Description of the updated folder
        folder_id: ID of the updated folder
        folder_name: Name of the updated folder
        modified_at: When the folder was last modified
        raw_data: Raw API response data from Box
    ### download_file
        file_content: Downloaded file content
        file_name: Name of the downloaded file
        file_size: Size of the downloaded file
        raw_data: Raw API response data from Box
    ### copy_file
        file_id: ID of the copied file
        file_name: Name of the copied file
        file_url: URL to access the copied file
        raw_data: Raw API response data from Box
    ### delete_file
        message: Deletion result message
        raw_data: Raw API response data from Box
        success: Whether the file was successfully deleted
    ### delete_folder
        message: Deletion result message
        raw_data: Raw API response data from Box
        success: Whether the folder was successfully deleted
    ### upload_files
        raw_data: Raw API response data from Box
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Box>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "upload_files": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the Folder to upload files to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "files",
                    "type": "vec<file>",
                    "value": [""],
                    "label": "Files",
                    "placeholder": "Files",
                    "helper_text": "The number of files to be appended. Files will be appended in successive fashion (e.g., file-1 first, then file-2, etc.)",
                },
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                }
            ],
            "name": "upload_files",
            "task_name": "tasks.box.upload_files",
            "description": "Upload files to Box",
            "label": "Upload files",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "folder_id", "files"],
            "required": ["folder_id", "files"],
        },
        "copy_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to copy",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "destination_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Destination Folder",
                    "helper_text": "Select the destination folder",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "new_name",
                    "type": "string",
                    "value": "",
                    "label": "New Name (Optional)",
                    "placeholder": "Leave empty to keep original name",
                    "helper_text": "Name for the copied file (optional)",
                },
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the copied file",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the copied file",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL to access the copied file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "copy_file",
            "task_name": "tasks.box.copy_file",
            "description": "Copy a file to another location",
            "label": "Copy File",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "destination_folder_id",
                "new_name",
            ],
            "required": ["file_id", "destination_folder_id"],
        },
        "delete_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to delete",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the file was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Deletion result message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "delete_file",
            "task_name": "tasks.box.delete_file",
            "description": "Delete a file from Box",
            "label": "Delete File",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "file_id"],
            "required": ["file_id"],
        },
        "download_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to download",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "file_content",
                    "type": "file",
                    "helper_text": "Downloaded file content",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the downloaded file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the downloaded file",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "download_file",
            "task_name": "tasks.box.download_file",
            "description": "Download a file from Box",
            "label": "Download File",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "file_id"],
            "required": ["file_id"],
        },
        "read_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to read information about",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {"field": "file_id", "type": "string", "helper_text": "ID of the file"},
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the file",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the file was created",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "When the file was last modified",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL to access the file",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "helper_text": "ID of the parent folder",
                },
                {
                    "field": "owner_name",
                    "type": "string",
                    "helper_text": "Name of the file owner",
                },
                {
                    "field": "owner_email",
                    "type": "string",
                    "helper_text": "Email of the file owner",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "read_file",
            "task_name": "tasks.box.read_file",
            "description": "Read information about a file",
            "label": "Read File",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "file_id"],
            "required": ["file_id"],
        },
        "search_files": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "placeholder": "Enter search terms",
                    "helper_text": "Search query to find files",
                },
                {
                    "field": "file_extensions",
                    "type": "vec<string>",
                    "value": [],
                    "label": "File Extensions (Optional)",
                    "placeholder": "pdf,docx,txt",
                    "helper_text": "Filter by file extensions (optional)",
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Search in Folder (Optional)",
                    "helper_text": "Select folder to search in (optional - leave empty to search all)",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Maximum number of results to return (default: 10)",
                },
            ],
            "outputs": [
                {
                    "field": "file_ids",
                    "type": "vec<string>",
                    "helper_text": "Array of file IDs",
                },
                {
                    "field": "file_names",
                    "type": "vec<string>",
                    "helper_text": "Array of file names",
                },
                {
                    "field": "file_types",
                    "type": "vec<string>",
                    "helper_text": "Array of file types",
                },
                {
                    "field": "file_urls",
                    "type": "vec<string>",
                    "helper_text": "Array of file URLs",
                },
                {
                    "field": "parent_folder_ids",
                    "type": "vec<string>",
                    "helper_text": "Array of parent folder IDs",
                },
                {
                    "field": "owner_names",
                    "type": "vec<string>",
                    "helper_text": "Array of file owner names",
                },
                {
                    "field": "owner_emails",
                    "type": "vec<string>",
                    "helper_text": "Array of file owner emails",
                },
                {
                    "field": "created_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "Array of file creation timestamps",
                },
                {
                    "field": "modified_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "Array of file modification timestamps",
                },
                {
                    "field": "files",
                    "type": "vec<string>",
                    "helper_text": "List of found files with detailed information (legacy format)",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of files found",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "search_files",
            "task_name": "tasks.box.search_files",
            "description": "Search for files in Box",
            "label": "Search Files",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "query",
                "file_extensions",
                "folder_id",
                "limit",
            ],
            "required": ["query", "limit"],
        },
        "share_file": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to share",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "access",
                    "type": "string",
                    "value": "open",
                    "label": "Access Level",
                    "helper_text": "Access level for the shared link",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Open", "value": "open"},
                            {"label": "Company", "value": "company"},
                            {"label": "Collaborators", "value": "collaborators"},
                        ],
                    },
                },
                {
                    "field": "can_download",
                    "type": "bool",
                    "value": True,
                    "label": "Allow Download",
                    "helper_text": "Whether users can download the file",
                },
                {
                    "field": "can_preview",
                    "type": "bool",
                    "value": True,
                    "label": "Allow Preview",
                    "helper_text": "Whether users can preview the file",
                },
            ],
            "outputs": [
                {
                    "field": "shared_link",
                    "type": "string",
                    "helper_text": "The shared link URL",
                },
                {
                    "field": "access_level",
                    "type": "string",
                    "helper_text": "Access level of the shared link",
                },
                {
                    "field": "permissions",
                    "type": "string",
                    "helper_text": "Permissions for the shared link",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "share_file",
            "task_name": "tasks.box.share_file",
            "description": "Create a shared link for a file",
            "label": "Share File",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "access",
                "can_download",
                "can_preview",
            ],
            "required": ["file_id"],
        },
        "create_folder": {
            "inputs": [
                {
                    "field": "folder_name",
                    "type": "string",
                    "value": "",
                    "label": "Folder Name",
                    "placeholder": "My New Folder",
                    "helper_text": "Name of the folder to create",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Parent Folder",
                    "helper_text": "Select the parent folder where the new folder will be created",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the created folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the created folder",
                },
                {
                    "field": "folder_url",
                    "type": "string",
                    "helper_text": "URL to access the created folder",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the folder was created",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "create_folder",
            "task_name": "tasks.box.create_folder",
            "description": "Create a new folder in Box",
            "label": "Create Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "parent_folder_id",
                "folder_name",
            ],
            "required": ["folder_name", "parent_folder_id"],
        },
        "read_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder to read information about",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the folder",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "When the folder was created",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "When the folder was last modified",
                },
                {
                    "field": "folder_url",
                    "type": "string",
                    "helper_text": "URL to access the folder",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "helper_text": "ID of the parent folder",
                },
                {
                    "field": "item_count",
                    "type": "int32",
                    "helper_text": "Number of items in the folder",
                },
                {
                    "field": "owner_name",
                    "type": "string",
                    "helper_text": "Name of the folder owner",
                },
                {
                    "field": "owner_email",
                    "type": "string",
                    "helper_text": "Email of the folder owner",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "read_folder",
            "task_name": "tasks.box.read_folder",
            "description": "Read information about a folder",
            "label": "Read Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "folder_id"],
            "required": ["folder_id"],
        },
        "delete_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder to delete",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "label": "Delete Recursively",
                    "helper_text": "Delete folder and all its contents (use with caution)",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the folder was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Deletion result message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "delete_folder",
            "task_name": "tasks.box.delete_folder",
            "description": "Delete a folder from Box",
            "label": "Delete Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "folder_id", "recursive"],
            "required": ["folder_id"],
        },
        "share_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder to share",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "access",
                    "type": "string",
                    "value": "open",
                    "label": "Access Level",
                    "helper_text": "Access level for the shared link",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Open", "value": "open"},
                            {"label": "Company", "value": "company"},
                            {"label": "Collaborators", "value": "collaborators"},
                        ],
                    },
                },
                {
                    "field": "can_download",
                    "type": "bool",
                    "value": True,
                    "label": "Allow Download",
                    "helper_text": "Whether users can download files from the folder",
                },
                {
                    "field": "can_preview",
                    "type": "bool",
                    "value": True,
                    "label": "Allow Preview",
                    "helper_text": "Whether users can preview files in the folder",
                },
            ],
            "outputs": [
                {
                    "field": "shared_link",
                    "type": "string",
                    "helper_text": "The shared link URL",
                },
                {
                    "field": "access_level",
                    "type": "string",
                    "helper_text": "Access level of the shared link",
                },
                {
                    "field": "permissions",
                    "type": "string",
                    "helper_text": "Permissions for the shared link",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "share_folder",
            "task_name": "tasks.box.share_folder",
            "description": "Create a shared link for a folder",
            "label": "Share Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "access",
                "can_download",
                "can_preview",
            ],
            "required": ["folder_id"],
        },
        "update_folder": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder to update",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "new_name",
                    "type": "string",
                    "value": "",
                    "label": "New Name (Optional)",
                    "placeholder": "Leave empty to keep current name",
                    "helper_text": "New name for the folder (optional)",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description (Optional)",
                    "placeholder": "Folder description",
                    "helper_text": "Description for the folder (optional)",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the updated folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the updated folder",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Description of the updated folder",
                },
                {
                    "field": "modified_at",
                    "type": "timestamp",
                    "helper_text": "When the folder was last modified",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data from Box",
                },
            ],
            "name": "update_folder",
            "task_name": "tasks.box.update_folder",
            "description": "Update folder properties",
            "label": "Update Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "new_name",
                "description",
            ],
            "required": ["folder_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        access: str = "open",
        can_download: bool = True,
        can_preview: bool = True,
        description: str = "",
        destination_folder_id: str = "",
        file_extensions: List[str] = [],
        file_id: str = "",
        files: List[str] = [""],
        folder_id: str = "",
        folder_name: str = "",
        limit: int = 10,
        new_name: str = "",
        parent_folder_id: str = "",
        query: str = "",
        recursive: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_box",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if files is not None:
            self.inputs["files"] = files
        if file_id is not None:
            self.inputs["file_id"] = file_id
        if destination_folder_id is not None:
            self.inputs["destination_folder_id"] = destination_folder_id
        if new_name is not None:
            self.inputs["new_name"] = new_name
        if query is not None:
            self.inputs["query"] = query
        if file_extensions is not None:
            self.inputs["file_extensions"] = file_extensions
        if limit is not None:
            self.inputs["limit"] = limit
        if access is not None:
            self.inputs["access"] = access
        if can_download is not None:
            self.inputs["can_download"] = can_download
        if can_preview is not None:
            self.inputs["can_preview"] = can_preview
        if folder_name is not None:
            self.inputs["folder_name"] = folder_name
        if parent_folder_id is not None:
            self.inputs["parent_folder_id"] = parent_folder_id
        if recursive is not None:
            self.inputs["recursive"] = recursive
        if description is not None:
            self.inputs["description"] = description
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationBoxNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_drive")
class IntegrationGoogleDriveNode(Node):
    """
    Google Drive

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'update_file'
        change_file_content: Whether to update the file content
        content_type: MIME type of the file content
        description: Description for the file
        file_data: New file content (when changing content)
        file_id: Select the file to read
        file_name: New name for the file
        starred: Whether to star the file
        trashed: Whether to trash the file
    ### When action = 'create_shared_drive'
        color_rgb: Color for the shared drive (hex code)
        hidden: Whether the shared drive is hidden
        name: Name of the file to create
    ### When action = 'update_shared_drive'
        color_rgb: Color for the shared drive (hex code)
        drive_id: ID of the shared drive to search
        name: Name of the file to create
    ### When action = 'create_file_from_text'
        content: Text content for the file
        description: Description for the file
        name: Name of the file to create
        parent_folder_id: Select the folder to create the file in
    ### When action = 'copy_file'
        copy_requires_writer_permission: Whether the copy requires writer permission
        description: Description for the file
        file_id: Select the file to read
        name: Name of the file to create
        parent_folder_id: Select the folder to create the file in
        same_folder: Keep the copy in the same folder as the original
    ### When action = 'get_files'
        corpora: Scope to search in: 'user' (files owned/shared to user) or 'domain' (files shared to user's domain)
        drive_id: ID of the shared drive to search
        fields: Comma-separated list of fields to include in the response
        include_items_from_all_drives: Whether to include items from all drives, including shared drives
        include_labels: Comma-separated list of label IDs to include in the response
        include_permissions_for_view: Additional view's permissions to include (only 'published' supported)
        order_by: Sort order for files (e.g., 'folder,name,modifiedTime desc')
        query: Search query for filtering files (see Drive API documentation for syntax)
        spaces: Comma-separated list of spaces to search ('drive', 'appDataFolder')
        supports_all_drives: Whether the application supports both My Drives and shared drives
        use_date: Toggle to use dates
    ### When action = 'get_files' and use_date = True and use_exact_date = False
        date_range: The date_range input
    ### When action = 'delete_file'
        delete_permanently: Whether to delete the file permanently or move to trash
        file_id: Select the file to read
    ### When action = 'delete_folder'
        delete_permanently: Whether to delete the file permanently or move to trash
        folder_id: Select the folder within your Google Drive to save the file
    ### When action = 'create_folder'
        description: Description for the file
        folder_color: Color for the folder (hex code)
        name: Name of the file to create
        parent_folder_id: Select the folder to create the file in
    ### When action = 'share_file'
        domain: Domain for domain permissions
        email_address: Email address for user/group permissions
        email_message: Custom message for the notification email
        file_id: Select the file to read
        role: Role for the permission (reader, writer, commenter, owner)
        send_notification_email: Whether to send notification email
        type: Type of permission (user, group, domain, anyone)
    ### When action = 'share_folder'
        domain: Domain for domain permissions
        email_address: Email address for user/group permissions
        email_message: Custom message for the notification email
        folder_id: Select the folder within your Google Drive to save the file
        role: Role for the permission (reader, writer, commenter, owner)
        send_notification_email: Whether to send notification email
        type: Type of permission (user, group, domain, anyone)
    ### When action = 'read_file_url'
        drive_file_url: The URL of the drive file to read.
    ### When action = 'read_shared_drive'
        drive_id: ID of the shared drive to search
        use_domain_admin_access: Whether to use domain admin access
    ### When action = 'delete_shared_drive'
        drive_id: ID of the shared drive to search
    ### When action = 'get_files' and use_date = True and use_exact_date = True
        exact_date: The exact_date input
    ### When action = 'save_drive'
        file: Select or Upload a file
        folder_id: Select the folder within your Google Drive to save the file
    ### When action = 'read_drive'
        file_id: Select the file to read
    ### When action = 'move_file'
        file_id: Select the file to read
        parent_folder_id: Select the folder to create the file in
    ### When action = 'get_shared_drives'
        limit: Maximum number of shared drives to return (when not returning all)
        query: Search query for filtering files (see Drive API documentation for syntax)
        return_all: Whether to return all shared drives or limit the results
        use_domain_admin_access: Whether to use domain admin access
    ### When action = 'get_files' and use_date = False
        num_messages: Specify the number of files to fetch
    ### When action = 'get_files' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_shared_drive'
        capabilities: Capabilities of the shared drive
        color_rgb: Color of the shared drive
        created_time: Creation time of the shared drive
        drive_id: ID of the shared drive
        drive_name: Name of the shared drive
        hidden: Whether the shared drive is hidden
        message: Success or error message
        raw_data: Raw response data from Google Drive API
        restrictions: Restrictions of the shared drive
        success: Whether the operation was successful
    ### When action = 'update_shared_drive'
        color_rgb: Color of the updated shared drive
        drive_id: ID of the updated shared drive
        drive_name: Name of the updated shared drive
        message: Success or error message
        raw_data: Raw response data from Google Drive API
        success: Whether the operation was successful
    ### When action = 'copy_file'
        created_time: Creation time of the copied file
        file_id: ID of the copied file
        file_name: Name of the copied file
        file_url: URL of the copied file
        message: Success or error message
        raw_data: Raw response data from Google Drive API
        success: Whether the operation was successful
    ### When action = 'create_folder'
        created_time: Creation time of the folder
        folder_id: ID of the created folder
        folder_name: Name of the created folder
        folder_url: URL of the created folder
        message: Success or error message
        raw_data: Raw response data from Google Drive API
        success: Whether the operation was successful
    ### When action = 'create_shared_drive'
        created_time: Creation time of the shared drive
        drive_id: ID of the created shared drive
        drive_name: Name of the created shared drive
        message: Success or error message
        raw_data: Raw response data from Google Drive API
        success: Whether the operation was successful
    ### When action = 'share_file'
        display_name: Display name of the permission
        email_address: Email address of the permission
        file_id: ID of the shared file
        message: Success or error message
        permission_id: ID of the created permission
        raw_data: Raw response data from Google Drive API
        role: Role of the permission
        success: Whether the operation was successful
        type: Type of the permission
    ### When action = 'share_folder'
        display_name: Display name of the permission
        email_address: Email address of the permission
        folder_id: ID of the shared folder
        message: Success or error message
        permission_id: ID of the created permission
        raw_data: Raw response data from Google Drive API
        role: Role of the permission
        success: Whether the operation was successful
        type: Type of the permission
    ### When action = 'get_shared_drives'
        drive_colors: List of shared drive colors
        drive_created_times: List of shared drive creation times
        drive_hidden: List of shared drive hidden status
        drive_ids: List of shared drive IDs
        drive_names: List of shared drive names
        message: Success or error message
        raw_data: Raw response data from Google Drive API
        success: Whether the operation was successful
        total_count: Total number of shared drives retrieved
    ### When action = 'delete_shared_drive'
        drive_id: ID of the deleted shared drive
        message: Success or error message
        success: Whether the operation was successful
    ### When action = 'read_drive'
        file: Downloadable file
    ### When action = 'read_file_url'
        file: The file fetched from the URL.
    ### When action = 'create_file_from_text'
        file_id: ID of the created file
        file_name: Name of the created file
        message: Success or error message
        raw_data: Raw response data from Google Drive API
        success: Whether the operation was successful
    ### When action = 'move_file'
        file_id: ID of the moved file
        file_name: Name of the moved file
        file_url: URL of the moved file
        message: Success or error message
        parent_folders: List of parent folder IDs
        raw_data: Raw response data from Google Drive API
        success: Whether the operation was successful
    ### When action = 'update_file'
        file_id: ID of the updated file
        file_name: Name of the updated file
        file_url: URL of the updated file
        message: Success or error message
        mime_type: MIME type of the file
        modified_time: Last modified time
        raw_data: Raw response data from Google Drive API
        size: Size of the file
        success: Whether the operation was successful
    ### When action = 'delete_file'
        file_id: ID of the deleted file
        message: Success or error message
        success: Whether the operation was successful
    ### When action = 'get_files'
        files: The files of the retrieved files
    ### When action = 'delete_folder'
        folder_id: ID of the deleted folder
        message: Success or error message
        success: Whether the operation was successful
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Drive>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_file_nodes",
        },
        "create_file_from_text**(*)**(*)": {
            "inputs": [
                {
                    "field": "content",
                    "type": "string",
                    "value": "",
                    "label": "Content",
                    "helper_text": "Text content for the file",
                    "placeholder": "Enter text content",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "File Name",
                    "helper_text": "Name of the file to create",
                    "placeholder": "Enter file name",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Parent Folder",
                    "helper_text": "Select the folder to create the file in",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "Description for the file",
                    "placeholder": "Enter description",
                },
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the created file",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the created file",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "create_file_from_text",
            "hidden": True,
            "task_name": "tasks.google_drive.create_file_from_text",
            "description": "Create a file from text content",
            "label": "Create File from Text",
            "inputs_sort_order": [
                "integration",
                "action",
                "content",
                "name",
                "parent_folder_id",
                "description",
            ],
        },
        "save_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder within your Google Drive to save the file",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "label": "File",
                    "placeholder": "Select a file",
                    "helper_text": "Select or Upload a file",
                },
            ],
            "outputs": [],
            "name": "save_drive",
            "task_name": "tasks.google_drive.save_drive",
            "description": "Save a file to Google Drive",
            "label": "Save file",
            "inputs_sort_order": ["integration", "action", "folder_id", "file"],
        },
        "read_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to read",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "file",
                    "type": "file",
                    "label": "File",
                    "helper_text": "Downloadable file",
                }
            ],
            "name": "read_drive",
            "task_name": "tasks.google_drive.read_drive",
            "description": "Download a user-selected file from their Google Drive",
            "label": "Read file",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
        "read_file_url**(*)**(*)": {
            "inputs": [
                {
                    "field": "drive_file_url",
                    "type": "string",
                    "value": "",
                    "helper_text": "The URL of the drive file to read.",
                    "label": "File URL",
                    "placeholder": "Enter the URL of the drive file to read.",
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "file",
                    "type": "file",
                    "label": "File",
                    "helper_text": "The file fetched from the URL.",
                }
            ],
            "variant": "default_integration_nodes",
            "banner_text": 'Ensure that the Google Drive\'s permissions is set to "Anyone with the Link"',
            "name": "read_file_url",
            "task_name": "tasks.google_drive.read_file_url",
            "description": "Download the contents of a publicly accessible Google Drive file using its shared URL",
            "label": "Read file from URL",
            "inputs_sort_order": ["integration", "action", "drive_file_url"],
        },
        "get_files**(*)**(*)": {
            "inputs": [
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "order": 4,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "helper_text": "Search query for filtering files (see Drive API documentation for syntax)",
                    "placeholder": "",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "label": "Order By",
                    "helper_text": "Sort order for files (e.g., 'folder,name,modifiedTime desc')",
                    "placeholder": "",
                },
                {
                    "field": "corpora",
                    "type": "string",
                    "value": "",
                    "label": "Search Scope",
                    "helper_text": "Scope to search in: 'user' (files owned/shared to user) or 'domain' (files shared to user's domain)",
                    "placeholder": "Eg. User or Domain",
                },
                {
                    "field": "drive_id",
                    "type": "string",
                    "value": "",
                    "label": "Drive ID",
                    "helper_text": "ID of the shared drive to search",
                },
                {
                    "field": "fields",
                    "type": "string",
                    "value": "",
                    "label": "Fields to Include",
                    "helper_text": "Comma-separated list of fields to include in the response",
                    "placeholder": "Eg. name, id, size, etc.",
                },
                {
                    "field": "include_items_from_all_drives",
                    "type": "bool",
                    "value": True,
                    "label": "Include All Drives",
                    "helper_text": "Whether to include items from all drives, including shared drives",
                },
                {
                    "field": "include_labels",
                    "type": "string",
                    "value": "",
                    "label": "Include Labels",
                    "helper_text": "Comma-separated list of label IDs to include in the response",
                    "placeholder": "",
                },
                {
                    "field": "spaces",
                    "type": "string",
                    "value": "",
                    "label": "Spaces",
                    "helper_text": "Comma-separated list of spaces to search ('drive', 'appDataFolder')",
                    "placeholder": "Eg. drive, appDataFolder",
                },
                {
                    "field": "supports_all_drives",
                    "type": "bool",
                    "value": True,
                    "label": "Supports All Drives",
                    "helper_text": "Whether the application supports both My Drives and shared drives",
                    "placeholder": "",
                },
                {
                    "field": "include_permissions_for_view",
                    "type": "string",
                    "value": "",
                    "label": "Include Permissions View",
                    "helper_text": "Additional view's permissions to include (only 'published' supported)",
                    "placeholder": "",
                },
            ],
            "outputs": [
                {
                    "field": "files",
                    "type": "vec<file>",
                    "helper_text": "The files of the retrieved files",
                    "label": "Files",
                }
            ],
            "variant": "get_integration_nodes",
            "name": "get_files",
            "task_name": "tasks.google_drive.get_files",
            "description": "Search for and return a list of files from the user's Google Drive that match the specified filters",
            "label": "Get Files",
            "inputs_sort_order": [
                "integration",
                "action",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "query",
                "order_by",
                "corpora",
                "drive_id",
                "fields",
                "include_items_from_all_drives",
                "include_labels",
                "spaces",
                "supports_all_drives",
                "include_permissions_for_view",
            ],
        },
        "get_files**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Files",
                    "helper_text": "Specify the number of files to fetch",
                }
            ],
            "outputs": [],
        },
        "get_files**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_files**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_date_range": True,
                    "label": "Date range",
                    "component": {"type": "date_range"},
                    "order": 6,
                }
            ],
            "outputs": [],
        },
        "get_files**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_date_range": True,
                    "label": "Exact date",
                    "component": {"type": "date_range"},
                    "order": 7,
                }
            ],
            "outputs": [],
        },
        "copy_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to copy",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "New File Name",
                    "helper_text": "Name for the copied file (optional)",
                    "placeholder": "Enter new file name",
                },
                {
                    "field": "same_folder",
                    "type": "bool",
                    "value": False,
                    "label": "Same Folder",
                    "helper_text": "Keep the copy in the same folder as the original",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Parent Folder",
                    "helper_text": "Select the folder to copy the file to (if not same folder)",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "copy_requires_writer_permission",
                    "type": "bool",
                    "value": False,
                    "label": "Copy Requires Writer Permission",
                    "helper_text": "Whether the copy requires writer permission",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "Description for the copied file",
                    "placeholder": "Enter description",
                },
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the copied file",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the copied file",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the copied file",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the copied file",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "copy_file",
            "hidden": True,
            "task_name": "tasks.google_drive.copy_file",
            "description": "Copy a file in Google Drive",
            "label": "Copy File",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "name",
                "same_folder",
                "parent_folder_id",
                "copy_requires_writer_permission",
                "description",
            ],
        },
        "move_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to move",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Target Folder",
                    "helper_text": "Select the folder to move the file to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the moved file",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the moved file",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the moved file",
                },
                {
                    "field": "parent_folders",
                    "type": "vec<string>",
                    "helper_text": "List of parent folder IDs",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "move_file",
            "hidden": True,
            "task_name": "tasks.google_drive.move_file",
            "description": "Move a file to a different folder",
            "label": "Move File",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "parent_folder_id",
            ],
        },
        "share_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to share",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "role",
                    "type": "string",
                    "value": "",
                    "label": "Role",
                    "helper_text": "Role for the permission (reader, writer, commenter, owner)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Reader", "value": "reader"},
                            {"label": "Writer", "value": "writer"},
                            {"label": "Commenter", "value": "commenter"},
                            {"label": "Owner", "value": "owner"},
                        ],
                    },
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "",
                    "label": "Type",
                    "helper_text": "Type of permission (user, group, domain, anyone)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "User", "value": "user"},
                            {"label": "Group", "value": "group"},
                            {"label": "Domain", "value": "domain"},
                            {"label": "Anyone", "value": "anyone"},
                        ],
                    },
                },
                {
                    "field": "email_address",
                    "type": "string",
                    "value": "",
                    "label": "Email Address",
                    "helper_text": "Email address for user/group permissions",
                    "placeholder": "Enter email address",
                },
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "helper_text": "Domain for domain permissions",
                    "placeholder": "Enter domain",
                },
                {
                    "field": "send_notification_email",
                    "type": "bool",
                    "value": False,
                    "label": "Send Notification Email",
                    "helper_text": "Whether to send notification email",
                },
                {
                    "field": "email_message",
                    "type": "string",
                    "value": "",
                    "label": "Email Message",
                    "helper_text": "Custom message for the notification email",
                    "placeholder": "Enter custom message",
                },
            ],
            "outputs": [
                {
                    "field": "permission_id",
                    "type": "string",
                    "helper_text": "ID of the created permission",
                },
                {
                    "field": "role",
                    "type": "string",
                    "helper_text": "Role of the permission",
                },
                {
                    "field": "type",
                    "type": "string",
                    "helper_text": "Type of the permission",
                },
                {
                    "field": "email_address",
                    "type": "string",
                    "helper_text": "Email address of the permission",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "Display name of the permission",
                },
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the shared file",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "share_file",
            "hidden": True,
            "task_name": "tasks.google_drive.share_file",
            "description": "Share a file with users or groups",
            "label": "Share File",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "role",
                "type",
                "email_address",
                "domain",
                "send_notification_email",
                "email_message",
            ],
        },
        "update_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to update",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "value": "",
                    "label": "File Name",
                    "helper_text": "New name for the file",
                    "placeholder": "Enter new file name",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "New description for the file",
                    "placeholder": "Enter description",
                },
                {
                    "field": "starred",
                    "type": "bool",
                    "value": False,
                    "label": "Starred",
                    "helper_text": "Whether to star the file",
                },
                {
                    "field": "trashed",
                    "type": "bool",
                    "value": False,
                    "label": "Trashed",
                    "helper_text": "Whether to trash the file",
                },
                {
                    "field": "change_file_content",
                    "type": "bool",
                    "value": False,
                    "label": "Change File Content",
                    "helper_text": "Whether to update the file content",
                },
                {
                    "field": "file_data",
                    "type": "string",
                    "value": "",
                    "label": "File Data",
                    "helper_text": "New file content (when changing content)",
                    "placeholder": "Enter file content",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "value": "",
                    "label": "Content Type",
                    "helper_text": "MIME type of the file content",
                    "placeholder": "Enter MIME type (e.g., text/plain)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Text", "value": "text/plain"},
                            {"label": "HTML", "value": "text/html"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the updated file",
                },
                {
                    "field": "file_name",
                    "type": "string",
                    "helper_text": "Name of the updated file",
                },
                {
                    "field": "file_url",
                    "type": "string",
                    "helper_text": "URL of the updated file",
                },
                {
                    "field": "mime_type",
                    "type": "string",
                    "helper_text": "MIME type of the file",
                },
                {
                    "field": "modified_time",
                    "type": "timestamp",
                    "helper_text": "Last modified time",
                },
                {"field": "size", "type": "string", "helper_text": "Size of the file"},
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "update_file",
            "hidden": True,
            "task_name": "tasks.google_drive.update_file",
            "description": "Update file metadata and content",
            "label": "Update File",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "file_name",
                "description",
                "starred",
                "trashed",
                "change_file_content",
                "file_data",
                "content_type",
            ],
        },
        "delete_file**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select the file to delete",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "delete_permanently",
                    "type": "bool",
                    "value": False,
                    "label": "Delete Permanently",
                    "helper_text": "Whether to delete the file permanently or move to trash",
                },
            ],
            "outputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "helper_text": "ID of the deleted file",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
            ],
            "name": "delete_file",
            "hidden": True,
            "task_name": "tasks.google_drive.delete_file",
            "description": "Delete a file from Google Drive",
            "label": "Delete File",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "delete_permanently",
            ],
        },
        "create_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "Untitled",
                    "label": "Folder Name",
                    "helper_text": "Name of the folder to create",
                    "placeholder": "Enter folder name",
                },
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Parent Folder",
                    "helper_text": "Select the parent folder",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "label": "Description",
                    "helper_text": "Description for the folder",
                    "placeholder": "Enter description",
                },
                {
                    "field": "folder_color",
                    "type": "string",
                    "value": "",
                    "label": "Folder Color",
                    "helper_text": "Color for the folder (hex code)",
                    "placeholder": "Enter hex color (e.g., #FF0000)",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the created folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the created folder",
                },
                {
                    "field": "folder_url",
                    "type": "string",
                    "helper_text": "URL of the created folder",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the folder",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "create_folder",
            "hidden": True,
            "task_name": "tasks.google_drive.create_folder",
            "description": "Create a new folder in Google Drive",
            "label": "Create Folder",
            "inputs_sort_order": [
                "integration",
                "action",
                "name",
                "parent_folder_id",
                "description",
                "folder_color",
            ],
        },
        "delete_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder to delete",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "delete_permanently",
                    "type": "bool",
                    "value": False,
                    "label": "Delete Permanently",
                    "helper_text": "Whether to delete the folder permanently or move to trash",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the deleted folder",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
            ],
            "name": "delete_folder",
            "hidden": True,
            "task_name": "tasks.google_drive.delete_folder",
            "description": "Delete a folder from Google Drive",
            "label": "Delete Folder",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "delete_permanently",
            ],
        },
        "share_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Folder",
                    "helper_text": "Select the folder to share",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "role",
                    "type": "string",
                    "value": "",
                    "label": "Role",
                    "helper_text": "Role for the permission (reader, writer, commenter, owner)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Reader", "value": "reader"},
                            {"label": "Writer", "value": "writer"},
                            {"label": "Commenter", "value": "commenter"},
                            {"label": "Owner", "value": "owner"},
                        ],
                    },
                },
                {
                    "field": "type",
                    "type": "string",
                    "value": "",
                    "label": "Type",
                    "helper_text": "Type of permission (user, group, domain, anyone)",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "User", "value": "user"},
                            {"label": "Group", "value": "group"},
                            {"label": "Domain", "value": "domain"},
                            {"label": "Anyone", "value": "anyone"},
                        ],
                    },
                },
                {
                    "field": "email_address",
                    "type": "string",
                    "value": "",
                    "label": "Email Address",
                    "helper_text": "Email address for user/group permissions",
                    "placeholder": "Enter email address",
                },
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "helper_text": "Domain for domain permissions",
                    "placeholder": "Enter domain",
                },
                {
                    "field": "send_notification_email",
                    "type": "bool",
                    "value": False,
                    "label": "Send Notification Email",
                    "helper_text": "Whether to send notification email",
                },
                {
                    "field": "email_message",
                    "type": "string",
                    "value": "",
                    "label": "Email Message",
                    "helper_text": "Custom message for the notification email",
                    "placeholder": "Enter custom message",
                },
            ],
            "outputs": [
                {
                    "field": "permission_id",
                    "type": "string",
                    "helper_text": "ID of the created permission",
                },
                {
                    "field": "role",
                    "type": "string",
                    "helper_text": "Role of the permission",
                },
                {
                    "field": "type",
                    "type": "string",
                    "helper_text": "Type of the permission",
                },
                {
                    "field": "email_address",
                    "type": "string",
                    "helper_text": "Email address of the permission",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "Display name of the permission",
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the shared folder",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "share_folder",
            "hidden": True,
            "task_name": "tasks.google_drive.share_folder",
            "description": "Share a folder with users or groups",
            "label": "Share Folder",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "role",
                "type",
                "email_address",
                "domain",
                "send_notification_email",
                "email_message",
            ],
        },
        "create_shared_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Drive Name",
                    "helper_text": "Name of the shared drive to create",
                    "placeholder": "Enter shared drive name",
                },
                {
                    "field": "color_rgb",
                    "type": "string",
                    "value": "",
                    "label": "Color RGB",
                    "helper_text": "Color for the shared drive (hex code)",
                    "placeholder": "Enter hex color (e.g., #FF0000)",
                },
                {
                    "field": "hidden",
                    "type": "bool",
                    "value": False,
                    "label": "Hidden",
                    "helper_text": "Whether the shared drive is hidden",
                },
            ],
            "outputs": [
                {
                    "field": "drive_id",
                    "type": "string",
                    "helper_text": "ID of the created shared drive",
                },
                {
                    "field": "drive_name",
                    "type": "string",
                    "helper_text": "Name of the created shared drive",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the shared drive",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "create_shared_drive",
            "variant": "default_integration_nodes",
            "hidden": True,
            "task_name": "tasks.google_drive.create_shared_drive",
            "description": "Create a new shared drive",
            "label": "Create Shared Drive",
            "inputs_sort_order": [
                "integration",
                "action",
                "name",
                "color_rgb",
                "hidden",
            ],
        },
        "read_shared_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "drive_id",
                    "type": "string",
                    "value": "",
                    "label": "Drive ID",
                    "helper_text": "ID of the shared drive to read",
                    "placeholder": "Enter shared drive ID",
                },
                {
                    "field": "use_domain_admin_access",
                    "type": "bool",
                    "value": False,
                    "label": "Use Domain Admin Access",
                    "helper_text": "Whether to use domain admin access",
                },
            ],
            "outputs": [
                {
                    "field": "drive_id",
                    "type": "string",
                    "helper_text": "ID of the shared drive",
                },
                {
                    "field": "drive_name",
                    "type": "string",
                    "helper_text": "Name of the shared drive",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the shared drive",
                },
                {
                    "field": "capabilities",
                    "type": "string",
                    "helper_text": "Capabilities of the shared drive",
                },
                {
                    "field": "restrictions",
                    "type": "string",
                    "helper_text": "Restrictions of the shared drive",
                },
                {
                    "field": "color_rgb",
                    "type": "string",
                    "helper_text": "Color of the shared drive",
                },
                {
                    "field": "hidden",
                    "type": "bool",
                    "helper_text": "Whether the shared drive is hidden",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "read_shared_drive",
            "variant": "default_integration_nodes",
            "hidden": True,
            "task_name": "tasks.google_drive.read_shared_drive",
            "description": "Read shared drive information",
            "label": "Read Shared Drive",
            "inputs_sort_order": [
                "integration",
                "action",
                "drive_id",
                "use_domain_admin_access",
            ],
        },
        "get_shared_drives**(*)**(*)": {
            "inputs": [
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "Whether to return all shared drives or limit the results",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "helper_text": "Maximum number of shared drives to return (when not returning all)",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "helper_text": "Search query to filter shared drives",
                    "placeholder": "Enter search query",
                },
                {
                    "field": "use_domain_admin_access",
                    "type": "bool",
                    "value": False,
                    "label": "Use Domain Admin Access",
                    "helper_text": "Whether to use domain admin access",
                },
            ],
            "outputs": [
                {
                    "field": "drive_ids",
                    "type": "vec<string>",
                    "helper_text": "List of shared drive IDs",
                },
                {
                    "field": "drive_names",
                    "type": "vec<string>",
                    "helper_text": "List of shared drive names",
                },
                {
                    "field": "drive_created_times",
                    "type": "vec<string>",
                    "helper_text": "List of shared drive creation times",
                },
                {
                    "field": "drive_colors",
                    "type": "vec<string>",
                    "helper_text": "List of shared drive colors",
                },
                {
                    "field": "drive_hidden",
                    "type": "vec<string>",
                    "helper_text": "List of shared drive hidden status",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of shared drives retrieved",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "get_shared_drives",
            "variant": "default_integration_nodes",
            "hidden": True,
            "task_name": "tasks.google_drive.get_shared_drives",
            "description": "Get a list of shared drives",
            "label": "Get Shared Drives",
            "inputs_sort_order": [
                "integration",
                "action",
                "return_all",
                "limit",
                "query",
                "use_domain_admin_access",
            ],
        },
        "update_shared_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "drive_id",
                    "type": "string",
                    "value": "",
                    "label": "Drive ID",
                    "helper_text": "ID of the shared drive to update",
                    "placeholder": "Enter shared drive ID",
                },
                {
                    "field": "name",
                    "type": "string",
                    "value": "",
                    "label": "Drive Name",
                    "helper_text": "New name for the shared drive",
                    "placeholder": "Enter new drive name",
                },
                {
                    "field": "color_rgb",
                    "type": "string",
                    "value": "",
                    "label": "Color RGB",
                    "helper_text": "New color for the shared drive (hex code)",
                    "placeholder": "Enter hex color (e.g., #FF0000)",
                },
            ],
            "outputs": [
                {
                    "field": "drive_id",
                    "type": "string",
                    "helper_text": "ID of the updated shared drive",
                },
                {
                    "field": "drive_name",
                    "type": "string",
                    "helper_text": "Name of the updated shared drive",
                },
                {
                    "field": "color_rgb",
                    "type": "string",
                    "helper_text": "Color of the updated shared drive",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data from Google Drive API",
                },
            ],
            "name": "update_shared_drive",
            "variant": "default_integration_nodes",
            "hidden": True,
            "task_name": "tasks.google_drive.update_shared_drive",
            "description": "Update shared drive properties",
            "label": "Update Shared Drive",
            "inputs_sort_order": [
                "integration",
                "action",
                "drive_id",
                "name",
                "color_rgb",
            ],
        },
        "delete_shared_drive**(*)**(*)": {
            "inputs": [
                {
                    "field": "drive_id",
                    "type": "string",
                    "value": "",
                    "label": "Drive ID",
                    "helper_text": "ID of the shared drive to delete",
                    "placeholder": "Enter shared drive ID",
                }
            ],
            "outputs": [
                {
                    "field": "drive_id",
                    "type": "string",
                    "helper_text": "ID of the deleted shared drive",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the operation was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
            ],
            "name": "delete_shared_drive",
            "variant": "default_integration_nodes",
            "hidden": True,
            "task_name": "tasks.google_drive.delete_shared_drive",
            "description": "Delete a shared drive",
            "label": "Delete Shared Drive",
            "inputs_sort_order": ["integration", "action", "drive_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        change_file_content: bool = False,
        color_rgb: str = "",
        content: str = "",
        content_type: str = "",
        copy_requires_writer_permission: bool = False,
        corpora: str = "",
        delete_permanently: bool = False,
        description: str = "",
        domain: str = "",
        drive_file_url: str = "",
        drive_id: str = "",
        email_address: str = "",
        email_message: str = "",
        exact_date: Any = {"start": "", "end": ""},
        fields: str = "",
        file: str = "",
        file_data: str = "",
        file_id: str = "",
        file_name: str = "",
        folder_color: str = "",
        folder_id: str = "",
        hidden: bool = False,
        include_items_from_all_drives: bool = True,
        include_labels: str = "",
        include_permissions_for_view: str = "",
        limit: int = 10,
        name: str = "",
        num_messages: int = 10,
        order_by: str = "",
        parent_folder_id: str = "",
        query: str = "",
        return_all: bool = False,
        role: str = "",
        same_folder: bool = False,
        send_notification_email: bool = False,
        spaces: str = "",
        starred: bool = False,
        supports_all_drives: bool = True,
        trashed: bool = False,
        type: str = "",
        use_domain_admin_access: bool = False,
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_drive",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if content is not None:
            self.inputs["content"] = content
        if name is not None:
            self.inputs["name"] = name
        if parent_folder_id is not None:
            self.inputs["parent_folder_id"] = parent_folder_id
        if description is not None:
            self.inputs["description"] = description
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if file is not None:
            self.inputs["file"] = file
        if file_id is not None:
            self.inputs["file_id"] = file_id
        if drive_file_url is not None:
            self.inputs["drive_file_url"] = drive_file_url
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if query is not None:
            self.inputs["query"] = query
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if corpora is not None:
            self.inputs["corpora"] = corpora
        if drive_id is not None:
            self.inputs["drive_id"] = drive_id
        if fields is not None:
            self.inputs["fields"] = fields
        if include_items_from_all_drives is not None:
            self.inputs["include_items_from_all_drives"] = include_items_from_all_drives
        if include_labels is not None:
            self.inputs["include_labels"] = include_labels
        if spaces is not None:
            self.inputs["spaces"] = spaces
        if supports_all_drives is not None:
            self.inputs["supports_all_drives"] = supports_all_drives
        if include_permissions_for_view is not None:
            self.inputs["include_permissions_for_view"] = include_permissions_for_view
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if same_folder is not None:
            self.inputs["same_folder"] = same_folder
        if copy_requires_writer_permission is not None:
            self.inputs["copy_requires_writer_permission"] = (
                copy_requires_writer_permission
            )
        if role is not None:
            self.inputs["role"] = role
        if type is not None:
            self.inputs["type"] = type
        if email_address is not None:
            self.inputs["email_address"] = email_address
        if domain is not None:
            self.inputs["domain"] = domain
        if send_notification_email is not None:
            self.inputs["send_notification_email"] = send_notification_email
        if email_message is not None:
            self.inputs["email_message"] = email_message
        if file_name is not None:
            self.inputs["file_name"] = file_name
        if starred is not None:
            self.inputs["starred"] = starred
        if trashed is not None:
            self.inputs["trashed"] = trashed
        if change_file_content is not None:
            self.inputs["change_file_content"] = change_file_content
        if file_data is not None:
            self.inputs["file_data"] = file_data
        if content_type is not None:
            self.inputs["content_type"] = content_type
        if delete_permanently is not None:
            self.inputs["delete_permanently"] = delete_permanently
        if folder_color is not None:
            self.inputs["folder_color"] = folder_color
        if color_rgb is not None:
            self.inputs["color_rgb"] = color_rgb
        if hidden is not None:
            self.inputs["hidden"] = hidden
        if use_domain_admin_access is not None:
            self.inputs["use_domain_admin_access"] = use_domain_admin_access
        if return_all is not None:
            self.inputs["return_all"] = return_all
        if limit is not None:
            self.inputs["limit"] = limit
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleDriveNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_sheets")
class IntegrationGoogleSheetsNode(Node):
    """
    Google Sheets

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: The integration input
    ### When action = 'write_to_sheet' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'write_list_to_column' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'update_rows' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'extract_to_table'
        add_columns_manually: Add data points for some columns manually instead of having them extracted by the AI model.
        additional_context: Additional context for the AI model to extract the table.
        extract_multiple_rows: If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.
        model: The model to use for the Google Sheets integration
        provider: The provider to use for the Google Sheets integration
        sheet_id: Select the Sheet to read from
        text_for_extraction: The text to extract the table from
    ### When action = 'create_spreadsheet'
        auto_recalc: Frequency at which formulas should automatically recalculate
        locale: Locale (e.g., en_US)
        sheets: Comma (,) separated list of sheet names
        title: Title/name of the new sheet
    ### When action = 'update_rows'
        condition: Conditional Operator
        sheet_id: Select the Sheet to read from
    ### When action = 'create_sheet'
        hidden: Whether the sheet should be hidden
        index: Position index of the sheet (0 for end)
        right_to_left: Whether the sheet is RTL instead of LTR
        sheet_id_number: Specific sheet ID number (must be unique, 0 for auto-generate)
        spreadsheet_id: Select the Spreadsheet to create sheet in
        tab_color: Hex color code for sheet tab (e.g., #ff0000)
        title: Title/name of the new sheet
    ### When action = 'clear_sheet'
        keep_first_row: Whether to preserve the first row (only for whole sheet clearing)
        range: Custom range to clear (required for specific range)
        sheet_id: Select the Sheet to read from
    ### When action = 'extract_to_table' and add_columns_manually = True
        manual_columns: Pass in data to column names manually.
    ### When action = 'delete_rows_columns'
        num_columns: Number of columns to delete (required when deleting columns)
        num_rows: Number of rows to delete (required when deleting rows)
        sheet_id: Select the Sheet to read from
        start_column: Starting column letter (required when deleting columns)
        start_row: Starting row number (required when deleting rows)
    ### When action = 'read_sheet'
        sheet_id: Select the Sheet to read from
    ### When action = 'read_sheet_url'
        sheet_id: Select the Sheet to read from
        sheet_url: Enter the URL of your Google Spreadsheet
    ### When action = 'write_to_sheet'
        sheet_id: Select the Sheet to read from
    ### When action = 'write_list_to_column'
        sheet_id: Select the Sheet to read from
    ### When action = 'delete_sheet'
        sheet_id: Select the Sheet to read from
    ### When action = 'delete_spreadsheet'
        spreadsheet_id: Select the Spreadsheet to create sheet in

    ## Outputs
    ### When action = 'read_sheet' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.outputs]: The [<A>.outputs] output
    ### When action = 'read_sheet_url' and endpoint_1 = '[endpoint_1.<B>]'
        [<B>.outputs]: The [<B>.outputs] output
    ### When action = 'clear_sheet'
        cleared_range: The range that was cleared
        keep_first_row: Whether first row was preserved
        raw_data: Raw API response data
        sheet_name: Name of the sheet
        spreadsheet_id: ID of the spreadsheet
        status: Operation status
    ### When action = 'delete_spreadsheet'
        deleted_id: ID of the deleted spreadsheet
        raw_data: Raw API response data
        status: Operation status
    ### When action = 'delete_sheet'
        deleted_sheet_id: ID of the deleted sheet
        raw_data: Raw API response data
        spreadsheet_id: ID of the parent spreadsheet
        status: Operation status
    ### When action = 'delete_rows_columns'
        deleted_types: Type of deletion performed (rows or columns)
        end_index: Ending index (0-based)
        raw_data: Raw API response data
        sheet_id: ID of the sheet
        spreadsheet_id: ID of the spreadsheet
        start_index: Starting index (0-based)
        status: Operation status
    ### When action = 'create_sheet'
        raw_data: Raw API response data
        sheet_id: ID of the created sheet
        sheet_index: Index position of the sheet
        sheet_title: Title of the created sheet
        spreadsheet_id: ID of the parent spreadsheet
        status: Operation status
    ### When action = 'create_spreadsheet'
        raw_data: Raw API response data including all spreadsheet details
        spreadsheet_id: ID of the created spreadsheet
        spreadsheet_url: URL of the created spreadsheet
        status: Operation status
        title: Title of the spreadsheet
    ### When action = 'extract_to_table'
        table: The table extracted from the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Google Sheets>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_sheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "spreadsheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "agent_field_type": "static",
                    "label": "Spreadsheet",
                    "helper_text": "Select the Spreadsheet to create sheet in",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Sheet Title",
                    "helper_text": "Title/name of the new sheet",
                    "placeholder": "My New Sheet",
                },
                {
                    "field": "hidden",
                    "type": "bool",
                    "value": False,
                    "label": "Hidden",
                    "helper_text": "Whether the sheet should be hidden",
                },
                {
                    "field": "right_to_left",
                    "type": "bool",
                    "value": False,
                    "label": "Right to Left",
                    "helper_text": "Whether the sheet is RTL instead of LTR",
                },
                {
                    "field": "sheet_id_number",
                    "type": "int32",
                    "value": 0,
                    "label": "Sheet ID Number",
                    "helper_text": "Specific sheet ID number (must be unique, 0 for auto-generate)",
                    "placeholder": "0",
                },
                {
                    "field": "index",
                    "type": "int32",
                    "value": 0,
                    "label": "Index",
                    "helper_text": "Position index of the sheet (0 for end)",
                    "placeholder": "0",
                },
                {
                    "field": "tab_color",
                    "type": "string",
                    "value": "",
                    "label": "Tab Color",
                    "helper_text": "Hex color code for sheet tab (e.g., #ff0000)",
                    "placeholder": "#ff0000",
                },
            ],
            "outputs": [
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Operation status",
                },
                {
                    "field": "sheet_id",
                    "type": "int32",
                    "helper_text": "ID of the created sheet",
                },
                {
                    "field": "sheet_title",
                    "type": "string",
                    "helper_text": "Title of the created sheet",
                },
                {
                    "field": "sheet_index",
                    "type": "int32",
                    "helper_text": "Index position of the sheet",
                },
                {
                    "field": "spreadsheet_id",
                    "type": "string",
                    "helper_text": "ID of the parent spreadsheet",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "create_sheet",
            "task_name": "tasks.google_sheets.create_sheet",
            "description": "Create a new sheet in a spreadsheet",
            "label": "Create Sheet",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "spreadsheet_id",
                "title",
                "hidden",
                "right_to_left",
                "sheet_id_number",
                "index",
                "tab_color",
            ],
        },
        "read_sheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [],
            "name": "read_sheet",
            "task_name": "tasks.google_sheets.read_sheet",
            "description": "Read specified columns from the selected sheet",
            "label": "Read from Sheet",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_id"],
        },
        "read_sheet**(*)**[endpoint_0.<A>]**(*)": {
            "inputs": [],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        },
        "read_sheet_url**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_url",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "label": "Workbook URL",
                    "helper_text": "Enter the URL of your Google Spreadsheet",
                    "order": 3,
                },
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations/item/{inputs.integration.object_id}?field=read_sheet_url&parent_id={inputs.sheet_url}"
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [],
            "banner_text": 'Ensure that the Google Sheet\'s permissions is set to "Anyone with the Link"',
            "name": "read_sheet_url",
            "task_name": "tasks.google_sheets.read_sheet_url",
            "description": "Read specified columns from the provided sheet URL",
            "label": "Read from Sheet URL",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_url", "sheet_id"],
        },
        "read_sheet_url**(*)**(*)**[endpoint_1.<B>]": {
            "inputs": [],
            "outputs": [{"field": "[<B>.outputs]", "type": ""}],
        },
        "write_to_sheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [],
            "name": "write_to_sheet",
            "task_name": "tasks.google_sheets.write_to_sheet",
            "description": "Add a new row in the selected sheet",
            "label": "Add New Row",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_id"],
        },
        "write_to_sheet**(*)**[endpoint_0.<A>]**(*)": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "write_list_to_column**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "agent_field_type": "static",
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [],
            "name": "write_list_to_column",
            "task_name": "tasks.google_sheets.write_list_to_column",
            "description": "Fill specified columns with the input values (inputs can be list)",
            "label": "Column List Writer",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_id"],
        },
        "write_list_to_column**(*)**[endpoint_0.<A>]**(*)": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "update_rows**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "agent_field_type": "static",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "condition",
                    "type": "string",
                    "value": "",
                    "label": "Conditional Operator",
                    "placeholder": "",
                    "helper_text": "Conditional Operator",
                },
            ],
            "outputs": [],
            "name": "update_rows",
            "task_name": "tasks.google_sheets.update_rows",
            "description": "Update the rows matching the specified search values",
            "label": "Update Rows",
            "operation": "update",
            "variant": "google_sheet",
            "inputs_sort_order": ["integration", "action", "sheet_id", "condition"],
        },
        "update_rows**(*)**[endpoint_0.<A>]**(*)": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "extract_to_table**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to read from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "provider",
                    "type": "enum<string>",
                    "value": "openai",
                    "label": "Provider",
                    "placeholder": "OpenAI",
                    "helper_text": "The provider to use for the Google Sheets integration",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "OpenAI", "value": "openai"},
                            {"label": "Anthropic", "value": "anthropic"},
                            {"label": "Cohere", "value": "cohere"},
                            {"label": "Perplexity", "value": "perplexity"},
                            {"label": "Google", "value": "google"},
                            {"label": "Open Source", "value": "together"},
                            {"label": "AWS", "value": "bedrock"},
                            {"label": "Azure", "value": "azure"},
                            {"label": "xAI", "value": "xai"},
                            {"label": "Custom", "value": "custom"},
                        ],
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "gpt-4o",
                    "label": "Model",
                    "placeholder": "GPT-4o",
                    "helper_text": "The model to use for the Google Sheets integration",
                    "component": {
                        "type": "dropdown",
                        "referenced_options": "llm_models",
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "text_for_extraction",
                    "type": "string",
                    "value": "",
                    "label": "Text for Extraction",
                    "placeholder": "Extract the table from the following text",
                    "helper_text": "The text to extract the table from",
                },
                {
                    "field": "extract_multiple_rows",
                    "type": "bool",
                    "value": True,
                    "label": "Extract Multiple Rows",
                    "helper_text": "If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.",
                },
                {
                    "field": "add_columns_manually",
                    "type": "bool",
                    "value": False,
                    "label": "Add Columns Manually",
                    "helper_text": "Add data points for some columns manually instead of having them extracted by the AI model.",
                },
                {
                    "field": "additional_context",
                    "type": "string",
                    "value": "",
                    "label": "Additional Context",
                    "placeholder": "Additional context for the AI model to extract the table.",
                    "helper_text": "Additional context for the AI model to extract the table.",
                },
            ],
            "outputs": [
                {
                    "field": "table",
                    "type": "file",
                    "helper_text": "The table extracted from the text",
                }
            ],
            "name": "extract_to_table",
            "task_name": "tasks.google_sheets.extract_to_table",
            "description": "Extract data from text to a table with AI",
            "label": "Extract to Table",
            "variant": "google_sheet",
            "inputs_sort_order": [
                "integration",
                "action",
                "sheet_id",
                "text_for_extraction",
                "additional_context",
                "extract_multiple_rows",
                "add_columns_manually",
                "manual_columns",
                "provider",
                "model",
            ],
        },
        "extract_to_table**false**(*)**(*)": {"inputs": [], "outputs": []},
        "extract_to_table**true**(*)**(*)": {
            "inputs": [
                {
                    "field": "manual_columns",
                    "type": "vec<Dict[str, Any]>",
                    "value": [],
                    "label": "Manual Columns",
                    "placeholder": "Manual Columns",
                    "helper_text": "Pass in data to column names manually.",
                    "component": {"type": "table"},
                }
            ],
            "outputs": [],
        },
        "delete_rows_columns**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to delete rows/columns from",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "start_row",
                    "type": "int32",
                    "value": "",
                    "label": "Start Row",
                    "helper_text": "Starting row number (required when deleting rows)",
                    "placeholder": "1",
                },
                {
                    "field": "num_rows",
                    "type": "int32",
                    "value": "",
                    "label": "Number of Rows",
                    "helper_text": "Number of rows to delete (required when deleting rows)",
                    "placeholder": "1",
                },
                {
                    "field": "start_column",
                    "type": "string",
                    "value": "",
                    "label": "Start Column",
                    "helper_text": "Starting column letter (required when deleting columns)",
                    "placeholder": "A",
                },
                {
                    "field": "num_columns",
                    "type": "int32",
                    "value": "",
                    "label": "Number of Columns",
                    "helper_text": "Number of columns to delete (required when deleting columns)",
                    "placeholder": "1",
                },
            ],
            "outputs": [
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Operation status",
                },
                {
                    "field": "start_index",
                    "type": "int32",
                    "helper_text": "Starting index (0-based)",
                },
                {
                    "field": "end_index",
                    "type": "int32",
                    "helper_text": "Ending index (0-based)",
                },
                {
                    "field": "deleted_types",
                    "type": "vec<string>",
                    "helper_text": "Type of deletion performed (rows or columns)",
                },
                {
                    "field": "spreadsheet_id",
                    "type": "string",
                    "helper_text": "ID of the spreadsheet",
                },
                {
                    "field": "sheet_id",
                    "type": "string",
                    "helper_text": "ID of the sheet",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "delete_rows_columns",
            "task_name": "tasks.google_sheets.delete_rows_columns",
            "description": "Delete rows and columns from a spreadsheet",
            "label": "Delete Rows and Columns",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "sheet_id",
                "start_row",
                "num_rows",
                "start_column",
                "num_columns",
            ],
        },
        "clear_sheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to clear",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "keep_first_row",
                    "type": "bool",
                    "value": False,
                    "label": "Keep First Row",
                    "helper_text": "Whether to preserve the first row (only for whole sheet clearing)",
                },
                {
                    "field": "range",
                    "type": "string",
                    "value": "",
                    "label": "Range",
                    "helper_text": "Custom range to clear (required for specific range)",
                    "placeholder": "A1:B10",
                },
            ],
            "outputs": [
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Operation status",
                },
                {
                    "field": "cleared_range",
                    "type": "string",
                    "helper_text": "The range that was cleared",
                },
                {
                    "field": "keep_first_row",
                    "type": "bool",
                    "helper_text": "Whether first row was preserved",
                },
                {
                    "field": "spreadsheet_id",
                    "type": "string",
                    "helper_text": "ID of the spreadsheet",
                },
                {
                    "field": "sheet_name",
                    "type": "string",
                    "helper_text": "Name of the sheet",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "clear_sheet",
            "task_name": "tasks.google_sheets.clear_sheet",
            "description": "Clear a sheet from a spreadsheet",
            "label": "Clear Sheet",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "sheet_id",
                "keep_first_row",
                "range",
            ],
        },
        "delete_sheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "sheet_id",
                    "type": "string",
                    "value": "",
                    "agent_field_type": "static",
                    "hidden": True,
                    "label": "Sheet",
                    "helper_text": "Select the Sheet to delete",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                }
            ],
            "outputs": [
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Operation status",
                },
                {
                    "field": "deleted_sheet_id",
                    "type": "string",
                    "helper_text": "ID of the deleted sheet",
                },
                {
                    "field": "spreadsheet_id",
                    "type": "string",
                    "helper_text": "ID of the parent spreadsheet",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "delete_sheet",
            "task_name": "tasks.google_sheets.delete_sheet",
            "description": "Delete a sheet from a spreadsheet",
            "label": "Delete Sheet",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "sheet_id"],
        },
        "create_spreadsheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "label": "Spreadsheet Title",
                    "helper_text": "Title of the new spreadsheet",
                    "placeholder": "My New Spreadsheet",
                },
                {
                    "field": "locale",
                    "type": "string",
                    "value": "",
                    "label": "Locale",
                    "helper_text": "Locale (e.g., en_US)",
                    "placeholder": "en_US",
                },
                {
                    "field": "auto_recalc",
                    "type": "enum<string>",
                    "value": "ON_CHANGE",
                    "label": "Auto Recalculation",
                    "helper_text": "Frequency at which formulas should automatically recalculate",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "On Change", "value": "ON_CHANGE"},
                            {"label": "Every Minute", "value": "MINUTE"},
                            {"label": "Every Hour", "value": "HOUR"},
                        ],
                    },
                },
                {
                    "field": "sheets",
                    "type": "string",
                    "value": "",
                    "label": "Initial Sheets",
                    "helper_text": "Comma (,) separated list of sheet names",
                    "placeholder": "Sheet1, Sheet2, Sheet3",
                },
            ],
            "outputs": [
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Operation status",
                },
                {
                    "field": "spreadsheet_id",
                    "type": "string",
                    "helper_text": "ID of the created spreadsheet",
                },
                {
                    "field": "spreadsheet_url",
                    "type": "string",
                    "helper_text": "URL of the created spreadsheet",
                },
                {
                    "field": "title",
                    "type": "string",
                    "helper_text": "Title of the spreadsheet",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data including all spreadsheet details",
                },
            ],
            "name": "create_spreadsheet",
            "task_name": "tasks.google_sheets.create_spreadsheet",
            "description": "Create a new spreadsheet",
            "label": "Create Spreadsheet",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "title",
                "locale",
                "auto_recalc",
                "sheets",
            ],
        },
        "delete_spreadsheet**(*)**(*)**(*)": {
            "inputs": [
                {
                    "field": "spreadsheet_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "label": "Spreadsheet",
                    "helper_text": "Select the Spreadsheet to delete",
                    "placeholder": "Select Spreadsheet",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                }
            ],
            "outputs": [
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Operation status",
                },
                {
                    "field": "deleted_id",
                    "type": "string",
                    "helper_text": "ID of the deleted spreadsheet",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "delete_spreadsheet",
            "task_name": "tasks.google_sheets.delete_spreadsheet",
            "description": "Delete a spreadsheet",
            "label": "Delete Spreadsheet",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "spreadsheet_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "add_columns_manually", "endpoint_0", "endpoint_1"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        add_columns_manually: bool = False,
        additional_context: str = "",
        auto_recalc: str = "ON_CHANGE",
        condition: str = "",
        extract_multiple_rows: bool = True,
        hidden: bool = False,
        index: int = 0,
        keep_first_row: bool = False,
        locale: str = "",
        manual_columns: List[Any] = [],
        model: str = "gpt-4o",
        num_columns: int = None,
        num_rows: int = None,
        provider: str = "openai",
        range: str = "",
        right_to_left: bool = False,
        sheet_id: str = "",
        sheet_id_number: int = 0,
        sheet_url: str = "",
        sheets: str = "",
        spreadsheet_id: str = "",
        start_column: str = "",
        start_row: int = None,
        tab_color: str = "",
        text_for_extraction: str = "",
        title: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["add_columns_manually"] = add_columns_manually

        super().__init__(
            node_type="integration_google_sheets",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if spreadsheet_id is not None:
            self.inputs["spreadsheet_id"] = spreadsheet_id
        if title is not None:
            self.inputs["title"] = title
        if hidden is not None:
            self.inputs["hidden"] = hidden
        if right_to_left is not None:
            self.inputs["right_to_left"] = right_to_left
        if sheet_id_number is not None:
            self.inputs["sheet_id_number"] = sheet_id_number
        if index is not None:
            self.inputs["index"] = index
        if tab_color is not None:
            self.inputs["tab_color"] = tab_color
        if sheet_id is not None:
            self.inputs["sheet_id"] = sheet_id
        if sheet_url is not None:
            self.inputs["sheet_url"] = sheet_url
        if condition is not None:
            self.inputs["condition"] = condition
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if text_for_extraction is not None:
            self.inputs["text_for_extraction"] = text_for_extraction
        if extract_multiple_rows is not None:
            self.inputs["extract_multiple_rows"] = extract_multiple_rows
        if add_columns_manually is not None:
            self.inputs["add_columns_manually"] = add_columns_manually
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if manual_columns is not None:
            self.inputs["manual_columns"] = manual_columns
        if start_row is not None:
            self.inputs["start_row"] = start_row
        if num_rows is not None:
            self.inputs["num_rows"] = num_rows
        if start_column is not None:
            self.inputs["start_column"] = start_column
        if num_columns is not None:
            self.inputs["num_columns"] = num_columns
        if keep_first_row is not None:
            self.inputs["keep_first_row"] = keep_first_row
        if range is not None:
            self.inputs["range"] = range
        if locale is not None:
            self.inputs["locale"] = locale
        if auto_recalc is not None:
            self.inputs["auto_recalc"] = auto_recalc
        if sheets is not None:
            self.inputs["sheets"] = sheets
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleSheetsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_analytics")
class IntegrationGoogleAnalyticsNode(Node):
    """
    Google Analytics

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your Google Analytics account
    ### When action = 'read_ga4_report'
        currency_code: Currency code for monetary metrics
        dimensions: Comma-separated list of dimensions (e.g., date,country)
        keep_empty_rows: Include rows with all zero metrics
        metric_aggregations: List of metric aggregations to apply
        metrics: Comma-separated list of metrics (e.g., totalUsers,sessions)
        order_by: Order by configuration for results
        property_id: Enter the GA4 property
        return_all: Return all results instead of limiting
        return_property_quota: Return property quota usage
        simple: Return simplified output format
        use_date: Toggle to use dates
    ### When action = 'read_ga4_report' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'read_ga4_report' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_ga4_report' and use_date = False
        num_messages: Specify the number of results to fetch
    ### When action = 'read_ga4_report' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_ga4_report'
        raw_data: Raw response data
        row_count: Total number of rows returned
        rows: Report data rows
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your Google Analytics account",
            "value": None,
            "type": "integration<Google Analytics>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "read_ga4_report**(*)**(*)": {
            "inputs": [
                {
                    "field": "property_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Enter the GA4 property",
                    "label": "Property",
                    "placeholder": "Enter the GA4 property",
                },
                {
                    "field": "metrics",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of metrics (e.g., totalUsers,sessions)",
                    "label": "Metrics",
                    "placeholder": "totalUsers,sessions,screenPageViews",
                },
                {
                    "field": "dimensions",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of dimensions (e.g., date,country)",
                    "label": "Dimensions",
                    "placeholder": "date,country,deviceCategory",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Return all results instead of limiting",
                    "label": "Return All Results",
                },
                {
                    "field": "simple",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Return simplified output format",
                    "label": "Simple Output",
                },
                {
                    "field": "keep_empty_rows",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include rows with all zero metrics",
                    "label": "Keep Empty Rows",
                },
                {
                    "field": "currency_code",
                    "type": "string",
                    "value": "USD",
                    "helper_text": "Currency code for monetary metrics",
                    "label": "Currency Code",
                    "placeholder": "USD",
                },
                {
                    "field": "return_property_quota",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Return property quota usage",
                    "label": "Return Property Quota",
                },
                {
                    "field": "metric_aggregations",
                    "type": "string",
                    "value": "",
                    "helper_text": "List of metric aggregations to apply",
                    "label": "Metric Aggregations",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Total", "value": "TOTAL"},
                            {"label": "Minimum", "value": "MINIMUM"},
                            {"label": "Maximum", "value": "MAXIMUM"},
                        ],
                    },
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "placeholder": "metric:totalUsers desc",
                    "helper_text": "Order by configuration for results",
                    "label": "Order By",
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                    "hidden": True,
                },
            ],
            "outputs": [
                {
                    "field": "rows",
                    "type": "vec<string>",
                    "helper_text": "Report data rows",
                },
                {
                    "field": "row_count",
                    "type": "int32",
                    "helper_text": "Total number of rows returned",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_ga4_report",
            "task_name": "tasks.google_analytics.read_ga4_report",
            "description": "Get analytics report from Google Analytics 4",
            "label": "Get GA4 Report",
            "inputs_sort_order": [
                "integration",
                "action",
                "property_id",
                "metrics",
                "dimensions",
                "return_all",
                "simple",
                "keep_empty_rows",
                "currency_code",
                "return_property_quota",
                "metric_aggregations",
                "order_by",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
            ],
        },
        "read_ga4_report**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Results",
                    "helper_text": "Specify the number of results to fetch",
                    "hidden": True,
                }
            ],
            "outputs": [],
        },
        "read_ga4_report**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                    "hidden": True,
                }
            ],
            "outputs": [],
        },
        "read_ga4_report**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "read_ga4_report**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        currency_code: str = "USD",
        dimensions: str = "",
        exact_date: Any = {"start": "", "end": ""},
        keep_empty_rows: bool = False,
        metric_aggregations: str = "",
        metrics: str = "",
        num_messages: int = 10,
        order_by: str = "",
        property_id: str = "",
        return_all: bool = False,
        return_property_quota: bool = False,
        simple: bool = True,
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_analytics",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if property_id is not None:
            self.inputs["property_id"] = property_id
        if metrics is not None:
            self.inputs["metrics"] = metrics
        if dimensions is not None:
            self.inputs["dimensions"] = dimensions
        if return_all is not None:
            self.inputs["return_all"] = return_all
        if simple is not None:
            self.inputs["simple"] = simple
        if keep_empty_rows is not None:
            self.inputs["keep_empty_rows"] = keep_empty_rows
        if currency_code is not None:
            self.inputs["currency_code"] = currency_code
        if return_property_quota is not None:
            self.inputs["return_property_quota"] = return_property_quota
        if metric_aggregations is not None:
            self.inputs["metric_aggregations"] = metric_aggregations
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleAnalyticsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_airtable")
class IntegrationAirtableNode(Node):
    """
    Airtable

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: The integration input
    ### When action = 'new_record' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'write_list_to_column' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'update_records' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'read_row'
        base_id: Name of the Airtable base
        record_id: ID of the record to retrieve
        table_id: Name of the table in the selected base
    ### When action = 'read_table'
        base_id: Name of the Airtable base
        table_id: Name of the table in the selected base
    ### When action = 'new_record'
        base_id: Name of the Airtable base
        table_id: Name of the table in the selected base
    ### When action = 'write_list_to_column'
        base_id: Name of the Airtable base
        table_id: Name of the table in the selected base
    ### When action = 'search_records'
        base_id: Name of the Airtable base
        filter_formula: Airtable formula to filter records (optional)
        limit: Maximum number of records to return (0 for all)
        table_id: Name of the table in the selected base
    ### When action = 'update_records'
        base_id: Name of the Airtable base
        condition: Conditional Operator
        table_id: Name of the table in the selected base
    ### When action = 'delete_record'
        base_id: Name of the Airtable base
        record_id: ID of the record to retrieve
        table_id: Name of the table in the selected base
    ### When action = 'get_table_schema'
        base_id: Name of the Airtable base

    ## Outputs
    ### When action = 'read_table' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.outputs]: The [<A>.outputs] output
    ### When action = 'get_bases'
        base_ids: List of base IDs
        base_names: List of base names
        permission_levels: List of permission levels for each base
        raw_data: Raw API response
    ### When action = 'get_table_schema'
        column_headers: List of Column Headers
        raw_data: Raw API response
        table_ids: List of table IDs
        table_names: List of table names
    ### When action = 'read_row'
        created_time: Record creation timestamp
        fields: List of fields
        fields_data: List of fields data
        raw_data: Raw API response
        record_id: ID of the record
    ### When action = 'delete_record'
        deleted: Whether the record was deleted
        deleted_id: ID of the deleted record
        raw_data: Raw API response
    ### When action = 'read_table'
        raw_data: Raw API response
    ### When action = 'new_record'
        raw_data: Raw API response
    ### When action = 'write_list_to_column'
        raw_data: Raw API response
    ### When action = 'search_records'
        raw_data: Raw API response
        record_count: Total number of records found
        record_ids: List of record IDs
    ### When action = 'update_records'
        raw_data: The raw_data output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Airtable>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "variant": "common_integration_nodes",
        },
        "read_row**(*)": {
            "inputs": [
                {
                    "field": "base_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Base",
                    "placeholder": "My Base",
                    "helper_text": "Name of the Airtable base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=base_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Table",
                    "placeholder": "My Table",
                    "helper_text": "Name of the table in the selected base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_id&base_id={inputs.base_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "record_id",
                    "type": "string",
                    "value": "",
                    "label": "Record ID",
                    "placeholder": "recJByvZjXEVabcde",
                    "helper_text": "ID of the record to retrieve",
                },
            ],
            "outputs": [
                {
                    "field": "record_id",
                    "type": "string",
                    "helper_text": "ID of the record",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Record creation timestamp",
                },
                {
                    "field": "fields",
                    "type": "vec<string>",
                    "helper_text": "List of fields",
                },
                {
                    "field": "fields_data",
                    "type": "vec<string>",
                    "helper_text": "List of fields data",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response",
                },
            ],
            "name": "read_row",
            "task_name": "tasks.airtable.read_row",
            "description": "Retrieve a specific record from a table",
            "label": "Read Row",
            "inputs_sort_order": [
                "integration",
                "action",
                "base_id",
                "table_id",
                "record_id",
            ],
        },
        "read_table**(*)": {
            "inputs": [
                {
                    "field": "base_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Base",
                    "placeholder": "My Base",
                    "helper_text": "Name of the Airtable base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=base_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Table",
                    "placeholder": "My Table",
                    "helper_text": "Name of the table in the selected base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_id&base_id={inputs.base_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response",
                }
            ],
            "name": "read_table",
            "task_name": "tasks.airtable.read_table",
            "description": "Read specified columns from the selected table",
            "label": "Read Table",
            "inputs_sort_order": ["integration", "action", "base_id", "table_id"],
        },
        "read_table**[endpoint_0.<A>]": {
            "inputs": [],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        },
        "new_record**(*)": {
            "inputs": [
                {
                    "field": "base_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Base",
                    "placeholder": "My Base",
                    "helper_text": "Name of the Airtable base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=base_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Table",
                    "placeholder": "My Table",
                    "helper_text": "Name of the table in the selected base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_id&base_id={inputs.base_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response",
                }
            ],
            "name": "new_record",
            "task_name": "tasks.airtable.write_to_table",
            "description": "Add new record in an Airtable database",
            "label": "Add New Record",
            "inputs_sort_order": ["integration", "action", "base_id", "table_id"],
        },
        "new_record**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "write_list_to_column**(*)": {
            "inputs": [
                {
                    "field": "base_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Base",
                    "placeholder": "My Base",
                    "helper_text": "Name of the Airtable base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=base_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Table",
                    "placeholder": "My Table",
                    "helper_text": "Name of the table in the selected base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_id&base_id={inputs.base_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response",
                }
            ],
            "name": "write_list_to_column",
            "task_name": "tasks.airtable.write_list_to_column",
            "description": "Fill specified columns empty cells with the input values (inputs can be list)",
            "label": "Column List Writer",
            "inputs_sort_order": ["integration", "action", "base_id", "table_id"],
        },
        "write_list_to_column**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "search_records**(*)": {
            "inputs": [
                {
                    "field": "base_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Base",
                    "placeholder": "My Base",
                    "helper_text": "Name of the Airtable base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=base_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Table",
                    "placeholder": "My Table",
                    "helper_text": "Name of the table in the selected base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_id&base_id={inputs.base_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "filter_formula",
                    "type": "string",
                    "value": "",
                    "label": "Filter Formula",
                    "placeholder": "NOT({Status} = 'Done')",
                    "helper_text": "Airtable formula to filter records (optional)",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of records to return (0 for all)",
                },
            ],
            "outputs": [
                {
                    "field": "record_ids",
                    "type": "vec<string>",
                    "helper_text": "List of record IDs",
                },
                {
                    "field": "record_count",
                    "type": "int32",
                    "helper_text": "Total number of records found",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response",
                },
            ],
            "name": "search_records",
            "task_name": "tasks.airtable.search_records",
            "description": "Search for records in a table or list all records",
            "label": "Search Records",
            "inputs_sort_order": [
                "integration",
                "action",
                "base_id",
                "table_id",
                "filter_formula",
                "limit",
            ],
            "required": ["limit"],
        },
        "update_records**(*)": {
            "inputs": [
                {
                    "field": "base_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Base",
                    "placeholder": "My Base",
                    "helper_text": "Name of the Airtable base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=base_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Table",
                    "placeholder": "My Table",
                    "helper_text": "Name of the table in the selected base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_id&base_id={inputs.base_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "condition",
                    "type": "string",
                    "value": "",
                    "label": "Conditional Operator",
                    "placeholder": "",
                    "helper_text": "Conditional Operator",
                },
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "description": "Raw API response",
                }
            ],
            "name": "update_records",
            "task_name": "tasks.airtable.update_records",
            "description": "Update the records matching the specified search values in a table",
            "label": "Update Records",
            "operation": "update",
            "inputs_sort_order": [
                "integration",
                "action",
                "base_id",
                "table_id",
                "condition",
            ],
        },
        "update_records**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "delete_record**(*)": {
            "inputs": [
                {
                    "field": "base_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Base",
                    "placeholder": "My Base",
                    "helper_text": "Name of the Airtable base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=base_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Table",
                    "placeholder": "My Table",
                    "helper_text": "Name of the table in the selected base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_id&base_id={inputs.base_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "record_id",
                    "type": "string",
                    "value": "",
                    "label": "Record ID",
                    "placeholder": "recJByvZjXEVabcde",
                    "helper_text": "ID of the record to delete",
                },
            ],
            "outputs": [
                {
                    "field": "deleted",
                    "type": "bool",
                    "helper_text": "Whether the record was deleted",
                },
                {
                    "field": "deleted_id",
                    "type": "string",
                    "helper_text": "ID of the deleted record",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response",
                },
            ],
            "name": "delete_record",
            "task_name": "tasks.airtable.delete_record",
            "description": "Delete a specific record from a table",
            "label": "Delete Record",
            "inputs_sort_order": [
                "integration",
                "action",
                "base_id",
                "table_id",
                "record_id",
            ],
        },
        "get_bases**(*)": {
            "inputs": [],
            "outputs": [
                {
                    "field": "base_ids",
                    "type": "vec<string>",
                    "helper_text": "List of base IDs",
                },
                {
                    "field": "base_names",
                    "type": "vec<string>",
                    "helper_text": "List of base names",
                },
                {
                    "field": "permission_levels",
                    "type": "vec<string>",
                    "helper_text": "List of permission levels for each base",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response",
                },
            ],
            "name": "get_bases",
            "task_name": "tasks.airtable.get_bases",
            "description": "List all accessible Airtable bases",
            "label": "Get Bases",
            "inputs_sort_order": ["integration", "action"],
        },
        "get_table_schema**(*)": {
            "inputs": [
                {
                    "field": "base_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Base",
                    "placeholder": "My Base",
                    "helper_text": "Name of the Airtable base",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=base_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "table_ids",
                    "type": "vec<string>",
                    "helper_text": "List of table IDs",
                },
                {
                    "field": "table_names",
                    "type": "vec<string>",
                    "helper_text": "List of table names",
                },
                {
                    "field": "column_headers",
                    "type": "vec<vec<string>>",
                    "helper_text": "List of Column Headers",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response",
                },
            ],
            "name": "get_table_schema",
            "task_name": "tasks.airtable.get_table_schema",
            "description": "Get the schema of tables in a base",
            "label": "Get Table Schema",
            "inputs_sort_order": ["integration", "action", "base_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "endpoint_0"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        base_id: str = "",
        condition: str = "",
        filter_formula: str = "",
        limit: int = 10,
        record_id: str = "",
        table_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_airtable",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if base_id is not None:
            self.inputs["base_id"] = base_id
        if table_id is not None:
            self.inputs["table_id"] = table_id
        if record_id is not None:
            self.inputs["record_id"] = record_id
        if filter_formula is not None:
            self.inputs["filter_formula"] = filter_formula
        if limit is not None:
            self.inputs["limit"] = limit
        if condition is not None:
            self.inputs["condition"] = condition
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationAirtableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_notion")
class IntegrationNotionNode(Node):
    """
    Notion

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'update_database' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'create_new_page' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'create_new_block' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'write_to_database' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'update_database_page'
        archived: Whether to archive the page
        page_id: Select the page to archive
        properties: JSON object containing properties to update
    ### When action = 'get_child_blocks'
        block_id: The ID of the parent block to get children from
        limit: Maximum number of databases to return
        return_all: If true, returns all databases regardless of limit
    ### When action = 'update_database'
        condition: Conditional Operator
        item_id: Select Notion Database
    ### When action = 'get_database_pages'
        database_id: Select Notion Database
        limit: Maximum number of databases to return
        return_all: If true, returns all databases regardless of limit
    ### When action = 'read_database'
        item_id: Select Notion Database
    ### When action = 'read_page'
        item_id: Select Notion Database
    ### When action = 'create_new_page'
        item_id: Select Notion Database
    ### When action = 'create_new_block'
        item_id: Select Notion Database
    ### When action = 'write_to_database'
        item_id: Select Notion Database
    ### When action = 'get_databases'
        limit: Maximum number of databases to return
        return_all: If true, returns all databases regardless of limit
    ### When action = 'search_databases'
        limit: Maximum number of databases to return
        return_all: If true, returns all databases regardless of limit
        text: Text to search for in database names and content
    ### When action = 'search_pages'
        limit: Maximum number of databases to return
        return_all: If true, returns all databases regardless of limit
        text: Text to search for in database names and content
    ### When action = 'get_users'
        limit: Maximum number of databases to return
        return_all: If true, returns all databases regardless of limit
    ### When action = 'archive_page'
        page_id: Select the page to archive
    ### When action = 'read_database_page'
        page_id: Select the page to archive
    ### When action = 'read_user'
        user_id: The ID of the user to read

    ## Outputs
    ### When action = 'read_database' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.outputs]: The [<A>.outputs] output
    ### When action = 'read_page' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.outputs]: The [<A>.outputs] output
    ### When action = 'archive_page'
        archive_status: Archive operation status message
        archived: Archive status of the page
        last_edited_time: Last edited time of the page
        page_id: ID of the archived page
        page_url: URL of the archived page
        raw_data: Raw API response data
    ### When action = 'read_database_page'
        archived: Archive status of the page
        created_time: Creation time of the page
        last_edited_time: Last edited time of the page
        page_id: ID of the database page
        page_url: URL of the database page
        properties: Page properties as JSON string
        raw_data: Raw API response data
    ### When action = 'read_user'
        avatar_url: URL of the user's avatar image
        raw_data: Raw API response data
        user_email: Email address of the user
        user_id: ID of the user
        user_name: Name of the user
        user_type: Type of user account
    ### When action = 'get_users'
        avatar_urls: List of user avatar URLs
        raw_data: Raw API response data
        user_emails: List of user email addresses
        user_ids: List of user IDs
        user_names: List of user names
        user_types: List of user account types
    ### When action = 'get_child_blocks'
        block_contents: List of child block contents
        block_created_times: List of block creation times
        block_has_children: List indicating if blocks have children
        block_ids: List of child block IDs
        block_last_edited_times: List of block last edited times
        block_types: List of child block types
        raw_data: Raw API response data
    ### When action = 'get_databases'
        database_created_at: List of database creation timestamps
        database_created_by: List of database creators
        database_ids: List of database IDs
        database_names: List of database names
        database_titles: List of database titles
        database_urls: List of database URLs
        raw_data: Raw API response data
    ### When action = 'search_databases'
        database_created_at: List of matching database creation timestamps
        database_created_by: List of matching database creators
        database_ids: List of matching database IDs
        database_names: List of matching database names
        database_titles: List of matching database titles
        database_urls: List of matching database URLs
        raw_data: Raw API response data
    ### When action = 'update_database_page'
        last_edited_time: Last edited time after update
        page_id: ID of the updated database page
        page_url: URL of the updated database page
        raw_data: Raw API response data
        update_status: Update operation status message
    ### When action = 'search_pages'
        page_archived: List indicating if pages are archived
        page_created_times: List of page creation times
        page_ids: List of matching page IDs
        page_last_edited_times: List of page last edited times
        page_titles: List of matching page titles
        page_urls: List of matching page URLs
        raw_data: Raw API response data
    ### When action = 'get_database_pages'
        page_archived: List indicating if pages are archived
        page_created_times: List of page creation times
        page_ids: List of database page IDs
        page_last_edited_times: List of page last edited times
        page_titles: List of database page titles
        page_urls: List of database page URLs
        raw_data: Raw API response data
    ### When action = 'read_database'
        raw_data: Raw API response data
    ### When action = 'update_database'
        raw_data: Raw API response data
    ### When action = 'read_page'
        raw_data: Raw API response data
    ### When action = 'create_new_page'
        raw_data: Raw API response data
    ### When action = 'create_new_block'
        raw_data: Raw API response data
    ### When action = 'write_to_database'
        raw_data: Raw API response data
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Notion>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "read_database**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                }
            ],
            "name": "read_database",
            "task_name": "tasks.notion.read_database",
            "description": "Read pages from a Notion database",
            "label": "Database Reader",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "read_database**[endpoint_0.<A>]": {
            "inputs": [],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        },
        "update_database**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "condition",
                    "type": "string",
                    "value": "",
                    "label": "Conditional Operator",
                    "placeholder": "",
                    "helper_text": "Conditional Operator",
                },
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                }
            ],
            "name": "update_database",
            "task_name": "tasks.notion.update_database",
            "description": "Update a Notion database",
            "label": "Database Updater",
            "operation": "update",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id", "condition"],
        },
        "update_database**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "get_databases**(*)": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of databases to return",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "If true, returns all databases regardless of limit",
                },
            ],
            "outputs": [
                {
                    "field": "database_names",
                    "type": "vec<string>",
                    "helper_text": "List of database names",
                },
                {
                    "field": "database_ids",
                    "type": "vec<string>",
                    "helper_text": "List of database IDs",
                },
                {
                    "field": "database_urls",
                    "type": "vec<string>",
                    "helper_text": "List of database URLs",
                },
                {
                    "field": "database_titles",
                    "type": "vec<string>",
                    "helper_text": "List of database titles",
                },
                {
                    "field": "database_created_by",
                    "type": "vec<string>",
                    "helper_text": "List of database creators",
                },
                {
                    "field": "database_created_at",
                    "type": "vec<timestamp>",
                    "helper_text": "List of database creation timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_databases",
            "task_name": "tasks.notion.get_databases",
            "description": "Get multiple databases from Notion",
            "label": "Get Databases",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "limit", "return_all"],
        },
        "search_databases**(*)": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Search Text",
                    "placeholder": "Enter search text",
                    "helper_text": "Text to search for in database names and content",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of databases to return",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "If true, returns all matching databases regardless of limit",
                },
            ],
            "outputs": [
                {
                    "field": "database_names",
                    "type": "vec<string>",
                    "helper_text": "List of matching database names",
                },
                {
                    "field": "database_ids",
                    "type": "vec<string>",
                    "helper_text": "List of matching database IDs",
                },
                {
                    "field": "database_urls",
                    "type": "vec<string>",
                    "helper_text": "List of matching database URLs",
                },
                {
                    "field": "database_titles",
                    "type": "vec<string>",
                    "helper_text": "List of matching database titles",
                },
                {
                    "field": "database_created_by",
                    "type": "vec<string>",
                    "helper_text": "List of matching database creators",
                },
                {
                    "field": "database_created_at",
                    "type": "vec<timestamp>",
                    "helper_text": "List of matching database creation timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "search_databases",
            "task_name": "tasks.notion.search_databases",
            "description": "Search for databases in Notion workspace",
            "label": "Search Databases",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "text",
                "limit",
                "return_all",
            ],
        },
        "read_page**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a page",
                    "helper_text": "Select the page to read",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                }
            ],
            "name": "read_page",
            "task_name": "tasks.notion.read_page",
            "description": "Read an existing Notion page",
            "label": "Read Notion page",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "read_page**[endpoint_0.<A>]": {
            "inputs": [],
            "outputs": [{"field": "[<A>.outputs]", "type": ""}],
        },
        "create_new_page**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a Page",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                }
            ],
            "name": "create_new_page",
            "task_name": "tasks.notion.create_new_page",
            "description": "Create a new page on an existing Notion page",
            "label": "Create New Page",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "create_new_page**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "search_pages**(*)": {
            "inputs": [
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Search Text",
                    "placeholder": "Enter search text",
                    "helper_text": "Text to search for in page content",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of pages to return",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "If true, returns all matching pages regardless of limit",
                },
            ],
            "outputs": [
                {
                    "field": "page_ids",
                    "type": "vec<string>",
                    "helper_text": "List of matching page IDs",
                },
                {
                    "field": "page_urls",
                    "type": "vec<string>",
                    "helper_text": "List of matching page URLs",
                },
                {
                    "field": "page_titles",
                    "type": "vec<string>",
                    "helper_text": "List of matching page titles",
                },
                {
                    "field": "page_created_times",
                    "type": "vec<string>",
                    "helper_text": "List of page creation times",
                },
                {
                    "field": "page_last_edited_times",
                    "type": "vec<string>",
                    "helper_text": "List of page last edited times",
                },
                {
                    "field": "page_archived",
                    "type": "vec<bool>",
                    "helper_text": "List indicating if pages are archived",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "search_pages",
            "task_name": "tasks.notion.search_pages",
            "description": "Search for pages in Notion workspace",
            "label": "Search Pages",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "text",
                "limit",
                "return_all",
            ],
        },
        "archive_page**(*)": {
            "inputs": [
                {
                    "field": "page_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a page",
                    "helper_text": "Select the page to archive",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "page_id",
                    "type": "string",
                    "helper_text": "ID of the archived page",
                },
                {
                    "field": "page_url",
                    "type": "string",
                    "helper_text": "URL of the archived page",
                },
                {
                    "field": "archived",
                    "type": "bool",
                    "helper_text": "Archive status of the page",
                },
                {
                    "field": "last_edited_time",
                    "type": "string",
                    "helper_text": "Last edited time of the page",
                },
                {
                    "field": "archive_status",
                    "type": "string",
                    "helper_text": "Archive operation status message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "archive_page",
            "task_name": "tasks.notion.archive_page",
            "description": "Archive a page in Notion",
            "label": "Archive Page",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "page_id"],
        },
        "create_new_block**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Page",
                    "placeholder": "Choose a Page",
                    "helper_text": "Select Notion Page",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=page&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                }
            ],
            "name": "create_new_block",
            "task_name": "tasks.notion.create_new_block",
            "description": "Write to an existing Notion page",
            "label": "Create New Block",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "create_new_block**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "get_child_blocks**(*)": {
            "inputs": [
                {
                    "field": "block_id",
                    "type": "string",
                    "value": "",
                    "label": "Block ID",
                    "placeholder": "Enter block ID",
                    "helper_text": "The ID of the parent block to get children from",
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of child blocks to return",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "If true, returns all child blocks regardless of limit",
                },
            ],
            "outputs": [
                {
                    "field": "block_ids",
                    "type": "vec<string>",
                    "helper_text": "List of child block IDs",
                },
                {
                    "field": "block_types",
                    "type": "vec<string>",
                    "helper_text": "List of child block types",
                },
                {
                    "field": "block_contents",
                    "type": "vec<string>",
                    "helper_text": "List of child block contents",
                },
                {
                    "field": "block_created_times",
                    "type": "vec<string>",
                    "helper_text": "List of block creation times",
                },
                {
                    "field": "block_last_edited_times",
                    "type": "vec<string>",
                    "helper_text": "List of block last edited times",
                },
                {
                    "field": "block_has_children",
                    "type": "vec<bool>",
                    "helper_text": "List indicating if blocks have children",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_child_blocks",
            "task_name": "tasks.notion.get_child_blocks",
            "description": "Get child blocks from a parent block",
            "label": "Get Child Blocks",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "block_id",
                "limit",
                "return_all",
            ],
            "required": ["block_id"],
        },
        "read_database_page**(*)": {
            "inputs": [
                {
                    "field": "page_id",
                    "type": "string",
                    "value": "",
                    "label": "Page ID",
                    "placeholder": "Enter page ID",
                    "helper_text": "The ID of the database page to read",
                }
            ],
            "outputs": [
                {
                    "field": "page_id",
                    "type": "string",
                    "helper_text": "ID of the database page",
                },
                {
                    "field": "page_url",
                    "type": "string",
                    "helper_text": "URL of the database page",
                },
                {
                    "field": "created_time",
                    "type": "string",
                    "helper_text": "Creation time of the page",
                },
                {
                    "field": "last_edited_time",
                    "type": "string",
                    "helper_text": "Last edited time of the page",
                },
                {
                    "field": "archived",
                    "type": "bool",
                    "helper_text": "Archive status of the page",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "helper_text": "Page properties as JSON string",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "read_database_page",
            "task_name": "tasks.notion.read_database_page",
            "description": "Read a single database page from Notion",
            "label": "Read Database Page",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "page_id"],
        },
        "write_to_database**(*)": {
            "inputs": [
                {
                    "field": "item_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                }
            ],
            "name": "write_to_database",
            "task_name": "tasks.notion.write_to_database",
            "description": "Add a page to an existing Notion database",
            "label": "Write to Database",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "item_id"],
        },
        "write_to_database**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "get_database_pages**(*)": {
            "inputs": [
                {
                    "field": "database_id",
                    "type": "string",
                    "agent_field_type": "static",
                    "disable_conversion": True,
                    "value": "",
                    "label": "Database",
                    "placeholder": "Choose a database",
                    "helper_text": "Select Notion Database",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=database&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of pages to return",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "If true, returns all pages regardless of limit",
                },
            ],
            "outputs": [
                {
                    "field": "page_ids",
                    "type": "vec<string>",
                    "helper_text": "List of database page IDs",
                },
                {
                    "field": "page_urls",
                    "type": "vec<string>",
                    "helper_text": "List of database page URLs",
                },
                {
                    "field": "page_titles",
                    "type": "vec<string>",
                    "helper_text": "List of database page titles",
                },
                {
                    "field": "page_created_times",
                    "type": "vec<string>",
                    "helper_text": "List of page creation times",
                },
                {
                    "field": "page_last_edited_times",
                    "type": "vec<string>",
                    "helper_text": "List of page last edited times",
                },
                {
                    "field": "page_archived",
                    "type": "vec<bool>",
                    "helper_text": "List indicating if pages are archived",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_database_pages",
            "task_name": "tasks.notion.get_database_pages",
            "description": "Get multiple pages from a database",
            "label": "Get Database Pages",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "database_id",
                "limit",
                "return_all",
            ],
        },
        "update_database_page**(*)": {
            "inputs": [
                {
                    "field": "page_id",
                    "type": "string",
                    "value": "",
                    "label": "Page ID",
                    "placeholder": "Enter page ID",
                    "helper_text": "The ID of the database page to update",
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "placeholder": "Enter properties JSON",
                    "helper_text": "JSON object containing properties to update",
                },
                {
                    "field": "archived",
                    "type": "bool",
                    "value": False,
                    "label": "Archived",
                    "helper_text": "Whether to archive the page",
                },
            ],
            "outputs": [
                {
                    "field": "page_id",
                    "type": "string",
                    "helper_text": "ID of the updated database page",
                },
                {
                    "field": "page_url",
                    "type": "string",
                    "helper_text": "URL of the updated database page",
                },
                {
                    "field": "last_edited_time",
                    "type": "string",
                    "helper_text": "Last edited time after update",
                },
                {
                    "field": "update_status",
                    "type": "string",
                    "helper_text": "Update operation status message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "update_database_page",
            "task_name": "tasks.notion.update_database_page",
            "description": "Update a database page in Notion",
            "label": "Update Database Page",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "page_id",
                "properties",
                "archived",
            ],
            "required": ["properties"],
        },
        "read_user**(*)": {
            "inputs": [
                {
                    "field": "user_id",
                    "type": "string",
                    "value": "",
                    "label": "User ID",
                    "placeholder": "Enter user ID",
                    "helper_text": "The ID of the user to read",
                }
            ],
            "outputs": [
                {"field": "user_id", "type": "string", "helper_text": "ID of the user"},
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Name of the user",
                },
                {
                    "field": "user_email",
                    "type": "string",
                    "helper_text": "Email address of the user",
                },
                {
                    "field": "user_type",
                    "type": "string",
                    "helper_text": "Type of user account",
                },
                {
                    "field": "avatar_url",
                    "type": "string",
                    "helper_text": "URL of the user's avatar image",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "read_user",
            "task_name": "tasks.notion.read_user",
            "description": "Read a specific user from Notion",
            "label": "Read User",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "user_id"],
        },
        "get_users**(*)": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "label": "Limit",
                    "placeholder": "10",
                    "helper_text": "Maximum number of users to return",
                },
                {
                    "field": "return_all",
                    "type": "bool",
                    "value": False,
                    "label": "Return All",
                    "helper_text": "If true, returns all users regardless of limit",
                },
            ],
            "outputs": [
                {
                    "field": "user_ids",
                    "type": "vec<string>",
                    "helper_text": "List of user IDs",
                },
                {
                    "field": "user_names",
                    "type": "vec<string>",
                    "helper_text": "List of user names",
                },
                {
                    "field": "user_emails",
                    "type": "vec<string>",
                    "helper_text": "List of user email addresses",
                },
                {
                    "field": "user_types",
                    "type": "vec<string>",
                    "helper_text": "List of user account types",
                },
                {
                    "field": "avatar_urls",
                    "type": "vec<string>",
                    "helper_text": "List of user avatar URLs",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data",
                },
            ],
            "name": "get_users",
            "task_name": "tasks.notion.get_users",
            "description": "Get multiple users from Notion",
            "label": "Get Users",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "limit", "return_all"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "endpoint_0"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        archived: bool = False,
        block_id: str = "",
        condition: str = "",
        database_id: str = "",
        item_id: str = "",
        limit: int = 10,
        page_id: str = "",
        properties: str = "",
        return_all: bool = False,
        text: str = "",
        user_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_notion",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if condition is not None:
            self.inputs["condition"] = condition
        if limit is not None:
            self.inputs["limit"] = limit
        if return_all is not None:
            self.inputs["return_all"] = return_all
        if text is not None:
            self.inputs["text"] = text
        if page_id is not None:
            self.inputs["page_id"] = page_id
        if block_id is not None:
            self.inputs["block_id"] = block_id
        if database_id is not None:
            self.inputs["database_id"] = database_id
        if properties is not None:
            self.inputs["properties"] = properties
        if archived is not None:
            self.inputs["archived"] = archived
        if user_id is not None:
            self.inputs["user_id"] = user_id
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationNotionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_databricks")
class IntegrationDatabricksNode(Node):
    """
    Databricks

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'insert_row' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'create_cluster'
        autotermination_minutes: Auto-termination time in minutes ( Set to 0 to disable auto-termination )
        cluster_name: Name of the cluster
        enable_elastic_disk: Enable elastic disk for the cluster
        node_type_id: Node type for cluster instances
        num_workers: Number of worker nodes
        spark_version: Spark version for the cluster
    ### When action = 'insert_row'
        catalog_name: Select the name of the Catalog
        schema_name: Select the name of the Schema
        table_name: Select the name of Table to insert the row
        warehouse_id: Select the ID of the Warehouse to perform the action
    ### When action = 'execute_query'
        catalog_name: Select the name of the Catalog
        on_wait_timeout: Action to take when timeout is reached
        query: SQL query to execute against the Databricks SQL Warehouse
        schema_name: Select the name of the Schema
        wait_timeout: Timeout for waiting for query completion (e.g., 30s, 1m, 5m)
        warehouse_id: Select the ID of the Warehouse to perform the action
    ### When action = 'delete_cluster'
        cluster_id: ID of the cluster to delete
    ### When action = 'read_cluster'
        cluster_id: ID of the cluster to delete
    ### When action = 'create_job'
        cluster_id: ID of the cluster to delete
        job_name: Name of the job
        max_concurrent_runs: Maximum number of concurrent runs
        notebook_path: Path to the notebook
        timeout_seconds: Timeout in seconds
    ### When action = 'upload_file'
        file: File to upload
        overwrite: Overwrite existing file
        path: Path of the directory to create
    ### When action = 'get_clusters'
        num_messages: Maximum number of clusters to retrieve
    ### When action = 'get_groups'
        num_messages: Maximum number of clusters to retrieve
    ### When action = 'create_directory'
        path: Path of the directory to create
    ### When action = 'get_directory_contents'
        path: Path of the directory to create
    ### When action = 'delete_file'
        path: Path of the directory to create
    ### When action = 'delete_directory'
        path: Path of the directory to create
        recursive: Delete directory recursively

    ## Outputs
    ### When action = 'get_clusters'
        cluster_details: Complete cluster details in JSON format
        cluster_ids: List of cluster IDs
        cluster_names: List of cluster names
        cluster_states: List of cluster states
        creator_user_names: List of cluster creator usernames
        raw_data: Raw response data in JSON format
        spark_versions: List of spark versions
    ### When action = 'create_cluster'
        cluster_id: ID of the created cluster
        cluster_name: Name of the created cluster
        creator_user_name: Username of the cluster creator
        raw_data: Complete cluster details in JSON format
        spark_version: Spark version of the cluster
        state: Current state of the cluster
    ### When action = 'delete_cluster'
        cluster_id: ID of the deleted cluster
        message: Status message
        success: Whether the deletion was successful
    ### When action = 'read_cluster'
        cluster_id: ID of the cluster
        cluster_name: Name of the cluster
        creator_user_name: Username of the cluster creator
        node_type_id: Node type of the cluster
        num_workers: Number of workers in the cluster
        raw_data: Complete cluster details in JSON format
        spark_version: Spark version of the cluster
        start_time: Start time of the cluster
        state: Current state of the cluster
        terminated_time: Termination time of the cluster
    ### When action = 'execute_query'
        column_names: Names of the columns in the result set
        column_types: Data types of the columns in the result set
        data: Query results as array of rows
        manifest: Query manifest information in JSON format
        raw_response: Complete API response in JSON format
        result: Complete result data in JSON format
        row_count: Number of rows returned by the query
        statement_id: ID of the executed statement
        status: Status of the query execution
    ### When action = 'create_job'
        created_time: Creation time of the job
        creator_user_name: Username of the job creator
        job_id: ID of the created job
        job_name: Name of the created job
        raw_data: Complete job details in JSON format
    ### When action = 'get_directory_contents'
        file_details: Complete file details in JSON format
        file_names: List of file names
        file_paths: List of file paths
        file_sizes: List of file sizes
        file_types: List of file types (file/directory)
        modification_times: List of modification times
        raw_data: Raw response data in JSON format
    ### When action = 'upload_file'
        file_size: Size of the uploaded file
        message: Status message
        path: Path of the uploaded file
        success: Whether the upload was successful
    ### When action = 'get_groups'
        group_details: Complete group details in JSON format
        group_ids: List of group IDs
        group_names: List of group names
        member_counts: List of member counts for each group
        raw_data: Raw response data in JSON format
    ### When action = 'create_directory'
        message: Status message
        path: Path of the created directory
        success: Whether the creation was successful
    ### When action = 'delete_file'
        message: Status message
        path: Path of the deleted file
        success: Whether the deletion was successful
    ### When action = 'delete_directory'
        message: Status message
        path: Path of the deleted directory
        success: Whether the deletion was successful
    ### When action = 'insert_row'
        operation_status: Status of the insert operation
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Databricks>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "insert_row**(*)": {
            "inputs": [
                {
                    "field": "warehouse_id",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "agent_field_type": "static",
                    "placeholder": "Select Warehouse",
                    "helper_text": "Select the ID of the Warehouse to perform the action",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "catalog_name",
                    "type": "string",
                    "value": "",
                    "label": "Catalog",
                    "agent_field_type": "static",
                    "placeholder": "Select Catalog",
                    "helper_text": "Select the name of the Catalog",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=catalog_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema_name",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "agent_field_type": "static",
                    "placeholder": "Select Schema",
                    "helper_text": "Select the name of the Schema",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema_name&catalog_name={inputs.catalog_name}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "table_name",
                    "type": "string",
                    "value": "",
                    "label": "Table",
                    "agent_field_type": "static",
                    "placeholder": "Select Table",
                    "helper_text": "Select the name of Table to insert the row",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=table_name&catalog_name={inputs.catalog_name}&schema_name={inputs.schema_name}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "operation_status",
                    "type": "string",
                    "helper_text": "Status of the insert operation",
                }
            ],
            "name": "insert_row",
            "task_name": "tasks.databricks.insert_row",
            "description": "Insert a new row into a Databricks Table",
            "label": "Insert A Row",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "warehouse_id",
                "catalog_name",
                "schema_name",
                "table_name",
            ],
            "required": ["warehouse_id", "catalog_name", "schema_name", "table_name"],
        },
        "insert_row**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
        "execute_query**(*)": {
            "inputs": [
                {
                    "field": "warehouse_id",
                    "type": "string",
                    "value": "",
                    "label": "Warehouse",
                    "agent_field_type": "static",
                    "placeholder": "Select Warehouse",
                    "helper_text": "Select the ID of the Warehouse to execute the query",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=warehouse_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "catalog_name",
                    "type": "string",
                    "value": "",
                    "label": "Catalog",
                    "agent_field_type": "static",
                    "placeholder": "Select Catalog",
                    "helper_text": "Optional: Select the catalog name",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=catalog_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "schema_name",
                    "type": "string",
                    "value": "",
                    "label": "Schema",
                    "agent_field_type": "static",
                    "placeholder": "Select Schema",
                    "helper_text": "Optional: Select the schema name",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=schema_name&catalog_name={inputs.catalog_name}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "SQL Query",
                    "placeholder": "SELECT * FROM my_table LIMIT 10",
                    "helper_text": "SQL query to execute against the Databricks SQL Warehouse",
                },
                {
                    "field": "wait_timeout",
                    "type": "string",
                    "value": "50s",
                    "label": "Wait Timeout",
                    "placeholder": "50s",
                    "helper_text": "Timeout for waiting for query completion (e.g., 30s, 1m, 5m)",
                },
                {
                    "field": "on_wait_timeout",
                    "type": "enum<string>",
                    "value": "CONTINUE",
                    "label": "On Wait Timeout",
                    "helper_text": "Action to take when timeout is reached",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Continue", "value": "CONTINUE"},
                            {"label": "Cancel", "value": "CANCEL"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "statement_id",
                    "type": "string",
                    "helper_text": "ID of the executed statement",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the query execution",
                },
                {
                    "field": "column_names",
                    "type": "vec<string>",
                    "helper_text": "Names of the columns in the result set",
                },
                {
                    "field": "column_types",
                    "type": "vec<string>",
                    "helper_text": "Data types of the columns in the result set",
                },
                {
                    "field": "data",
                    "type": "vec<vec<any>>",
                    "helper_text": "Query results as array of rows",
                },
                {
                    "field": "row_count",
                    "type": "int32",
                    "helper_text": "Number of rows returned by the query",
                },
                {
                    "field": "result",
                    "type": "string",
                    "helper_text": "Complete result data in JSON format",
                },
                {
                    "field": "manifest",
                    "type": "string",
                    "helper_text": "Query manifest information in JSON format",
                },
                {
                    "field": "raw_response",
                    "type": "string",
                    "helper_text": "Complete API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "execute_query",
            "task_name": "tasks.databricks.execute_query",
            "description": "Execute SQL queries against Databricks SQL Warehouses",
            "label": "Execute SQL Query",
            "inputs_sort_order": [
                "integration",
                "action",
                "warehouse_id",
                "query",
                "catalog_name_optional",
                "schema_name_optional",
                "wait_timeout",
                "on_wait_timeout",
            ],
        },
        "create_cluster**(*)": {
            "inputs": [
                {
                    "field": "cluster_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the cluster",
                    "label": "Cluster Name",
                    "placeholder": "my-cluster",
                },
                {
                    "field": "spark_version",
                    "type": "string",
                    "value": "",
                    "helper_text": "Spark version for the cluster",
                    "label": "Spark Version",
                    "placeholder": "13.3.x-scala2.12",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=spark_version&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "node_type_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Node type for cluster instances",
                    "label": "Node Type",
                    "placeholder": "i3.xlarge",
                },
                {
                    "field": "num_workers",
                    "type": "int32",
                    "value": 2,
                    "helper_text": "Number of worker nodes",
                    "label": "Number of Workers",
                    "placeholder": "2",
                },
                {
                    "field": "autotermination_minutes",
                    "type": "int32",
                    "value": 120,
                    "helper_text": "Auto-termination time in minutes ( Set to 0 to disable auto-termination )",
                    "label": "Auto-termination (minutes)",
                    "placeholder": "120",
                },
                {
                    "field": "enable_elastic_disk",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Enable elastic disk for the cluster",
                    "label": "Enable Elastic Disk",
                },
            ],
            "outputs": [
                {
                    "field": "cluster_id",
                    "type": "string",
                    "helper_text": "ID of the created cluster",
                },
                {
                    "field": "cluster_name",
                    "type": "string",
                    "helper_text": "Name of the created cluster",
                },
                {
                    "field": "state",
                    "type": "string",
                    "helper_text": "Current state of the cluster",
                },
                {
                    "field": "spark_version",
                    "type": "string",
                    "helper_text": "Spark version of the cluster",
                },
                {
                    "field": "creator_user_name",
                    "type": "string",
                    "helper_text": "Username of the cluster creator",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete cluster details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_cluster",
            "task_name": "tasks.databricks.create_cluster",
            "description": "Create a new Databricks cluster",
            "label": "Create Cluster",
            "inputs_sort_order": [
                "integration",
                "action",
                "cluster_name",
                "spark_version",
                "node_type_id",
                "num_workers",
                "autotermination_minutes",
                "enable_elastic_disk",
            ],
        },
        "delete_cluster**(*)": {
            "inputs": [
                {
                    "field": "cluster_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the cluster to delete",
                    "label": "Cluster ID",
                    "placeholder": "cluster-123",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=cluster_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
                {
                    "field": "cluster_id",
                    "type": "string",
                    "helper_text": "ID of the deleted cluster",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "delete_cluster",
            "task_name": "tasks.databricks.delete_cluster",
            "description": "Delete a Databricks cluster",
            "label": "Delete Cluster",
            "inputs_sort_order": ["integration", "action", "cluster_id"],
        },
        "get_clusters**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of clusters to retrieve",
                    "label": "Limit",
                    "placeholder": "10",
                }
            ],
            "outputs": [
                {
                    "field": "cluster_ids",
                    "type": "vec<string>",
                    "helper_text": "List of cluster IDs",
                },
                {
                    "field": "cluster_names",
                    "type": "vec<string>",
                    "helper_text": "List of cluster names",
                },
                {
                    "field": "cluster_states",
                    "type": "vec<string>",
                    "helper_text": "List of cluster states",
                },
                {
                    "field": "spark_versions",
                    "type": "vec<string>",
                    "helper_text": "List of spark versions",
                },
                {
                    "field": "creator_user_names",
                    "type": "vec<string>",
                    "helper_text": "List of cluster creator usernames",
                },
                {
                    "field": "cluster_details",
                    "type": "string",
                    "helper_text": "Complete cluster details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_clusters",
            "task_name": "tasks.databricks.get_clusters",
            "description": "Get a list of Databricks clusters",
            "label": "Get Clusters",
            "inputs_sort_order": ["integration", "action", "num_messages"],
        },
        "read_cluster**(*)": {
            "inputs": [
                {
                    "field": "cluster_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the cluster to read",
                    "label": "Cluster ID",
                    "placeholder": "cluster-123",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=cluster_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "cluster_id",
                    "type": "string",
                    "helper_text": "ID of the cluster",
                },
                {
                    "field": "cluster_name",
                    "type": "string",
                    "helper_text": "Name of the cluster",
                },
                {
                    "field": "state",
                    "type": "string",
                    "helper_text": "Current state of the cluster",
                },
                {
                    "field": "spark_version",
                    "type": "string",
                    "helper_text": "Spark version of the cluster",
                },
                {
                    "field": "node_type_id",
                    "type": "string",
                    "helper_text": "Node type of the cluster",
                },
                {
                    "field": "num_workers",
                    "type": "int32",
                    "helper_text": "Number of workers in the cluster",
                },
                {
                    "field": "creator_user_name",
                    "type": "string",
                    "helper_text": "Username of the cluster creator",
                },
                {
                    "field": "start_time",
                    "type": "string",
                    "helper_text": "Start time of the cluster",
                },
                {
                    "field": "terminated_time",
                    "type": "string",
                    "helper_text": "Termination time of the cluster",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete cluster details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_cluster",
            "task_name": "tasks.databricks.read_cluster",
            "description": "Read details of a specific Databricks cluster",
            "label": "Read Cluster",
            "inputs_sort_order": ["integration", "action", "cluster_id"],
        },
        "create_job**(*)": {
            "inputs": [
                {
                    "field": "job_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the job",
                    "label": "Job Name",
                    "placeholder": "my-job",
                },
                {
                    "field": "notebook_path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path to the notebook",
                    "label": "Notebook Path",
                    "placeholder": "/Users/user@company.com/my-notebook",
                },
                {
                    "field": "cluster_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the cluster to run the job on",
                    "label": "Cluster ID",
                    "placeholder": "cluster-123",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=cluster_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "max_concurrent_runs",
                    "type": "int32",
                    "value": 1,
                    "helper_text": "Maximum number of concurrent runs",
                    "label": "Max Concurrent Runs",
                    "placeholder": "1",
                },
                {
                    "field": "timeout_seconds",
                    "type": "int32",
                    "value": 3600,
                    "helper_text": "Timeout in seconds",
                    "label": "Timeout (seconds)",
                    "placeholder": "3600",
                },
            ],
            "outputs": [
                {
                    "field": "job_id",
                    "type": "string",
                    "helper_text": "ID of the created job",
                },
                {
                    "field": "job_name",
                    "type": "string",
                    "helper_text": "Name of the created job",
                },
                {
                    "field": "creator_user_name",
                    "type": "string",
                    "helper_text": "Username of the job creator",
                },
                {
                    "field": "created_time",
                    "type": "string",
                    "helper_text": "Creation time of the job",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Complete job details in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_job",
            "task_name": "tasks.databricks.create_job",
            "description": "Create a new Databricks job",
            "label": "Create Job",
            "inputs_sort_order": [
                "integration",
                "action",
                "job_name",
                "notebook_path",
                "cluster_id",
                "max_concurrent_runs",
                "timeout_seconds",
            ],
        },
        "create_directory**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the directory to create",
                    "label": "Directory Path",
                    "placeholder": "/my-directory",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the creation was successful",
                },
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "Path of the created directory",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "variant": "default_integration_nodes",
            "name": "create_directory",
            "task_name": "tasks.databricks.create_directory",
            "description": "Create a new directory in Databricks",
            "label": "Create Directory",
            "inputs_sort_order": ["integration", "action", "path"],
        },
        "upload_file**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path where the file should be uploaded",
                    "label": "File Path",
                    "placeholder": "/my-file.txt",
                },
                {
                    "field": "file",
                    "type": "file",
                    "value": "",
                    "helper_text": "File to upload",
                    "label": "File",
                },
                {
                    "field": "overwrite",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Overwrite existing file",
                    "label": "Overwrite",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the upload was successful",
                },
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "Path of the uploaded file",
                },
                {
                    "field": "file_size",
                    "type": "string",
                    "helper_text": "Size of the uploaded file",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "variant": "common_integration_nodes",
            "name": "upload_file",
            "task_name": "tasks.databricks.upload_file",
            "description": "Upload a file to Databricks",
            "label": "Upload File",
            "inputs_sort_order": ["integration", "action", "path", "file", "overwrite"],
        },
        "get_directory_contents**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the directory to list",
                    "label": "Directory Path",
                    "placeholder": "/my-directory",
                }
            ],
            "outputs": [
                {
                    "field": "file_names",
                    "type": "vec<string>",
                    "helper_text": "List of file names",
                },
                {
                    "field": "file_paths",
                    "type": "vec<string>",
                    "helper_text": "List of file paths",
                },
                {
                    "field": "file_sizes",
                    "type": "vec<string>",
                    "helper_text": "List of file sizes",
                },
                {
                    "field": "file_types",
                    "type": "vec<string>",
                    "helper_text": "List of file types (file/directory)",
                },
                {
                    "field": "modification_times",
                    "type": "vec<string>",
                    "helper_text": "List of modification times",
                },
                {
                    "field": "file_details",
                    "type": "string",
                    "helper_text": "Complete file details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_directory_contents",
            "task_name": "tasks.databricks.get_directory_contents",
            "description": "Get contents of a directory in Databricks",
            "label": "Get Directory Contents",
            "inputs_sort_order": ["integration", "action", "path"],
        },
        "delete_file**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the file to delete",
                    "label": "File Path",
                    "placeholder": "/my-file.txt",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "Path of the deleted file",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "variant": "default_integration_nodes",
            "name": "delete_file",
            "task_name": "tasks.databricks.delete_file",
            "description": "Delete a file from Databricks",
            "label": "Delete File",
            "inputs_sort_order": ["integration", "action", "path"],
        },
        "delete_directory**(*)": {
            "inputs": [
                {
                    "field": "path",
                    "type": "string",
                    "value": "",
                    "helper_text": "Path of the directory to delete",
                    "label": "Directory Path",
                    "placeholder": "/my-directory",
                },
                {
                    "field": "recursive",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Delete directory recursively",
                    "label": "Recursive",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "path",
                    "type": "string",
                    "helper_text": "Path of the deleted directory",
                },
                {"field": "message", "type": "string", "helper_text": "Status message"},
            ],
            "variant": "default_integration_nodes",
            "name": "delete_directory",
            "task_name": "tasks.databricks.delete_directory",
            "description": "Delete a directory from Databricks",
            "label": "Delete Directory",
            "inputs_sort_order": ["integration", "action", "path", "recursive"],
        },
        "get_groups**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of groups to retrieve",
                    "label": "Limit",
                    "placeholder": "10",
                }
            ],
            "outputs": [
                {
                    "field": "group_ids",
                    "type": "vec<string>",
                    "helper_text": "List of group IDs",
                },
                {
                    "field": "group_names",
                    "type": "vec<string>",
                    "helper_text": "List of group names",
                },
                {
                    "field": "member_counts",
                    "type": "vec<string>",
                    "helper_text": "List of member counts for each group",
                },
                {
                    "field": "group_details",
                    "type": "string",
                    "helper_text": "Complete group details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "name": "get_groups",
            "task_name": "tasks.databricks.get_groups",
            "description": "Get a list of Databricks groups",
            "label": "Get Groups",
            "inputs_sort_order": ["integration", "action", "num_messages"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "endpoint_0"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        autotermination_minutes: int = 120,
        catalog_name: str = "",
        cluster_id: str = "",
        cluster_name: str = "",
        enable_elastic_disk: bool = True,
        file: str = "",
        job_name: str = "",
        max_concurrent_runs: int = 1,
        node_type_id: str = "",
        notebook_path: str = "",
        num_messages: int = 10,
        num_workers: int = 2,
        on_wait_timeout: str = "CONTINUE",
        overwrite: bool = False,
        path: str = "",
        query: str = "",
        recursive: bool = False,
        schema_name: str = "",
        spark_version: str = "",
        table_name: str = "",
        timeout_seconds: int = 3600,
        wait_timeout: str = "50s",
        warehouse_id: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_databricks",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if warehouse_id is not None:
            self.inputs["warehouse_id"] = warehouse_id
        if catalog_name is not None:
            self.inputs["catalog_name"] = catalog_name
        if schema_name is not None:
            self.inputs["schema_name"] = schema_name
        if table_name is not None:
            self.inputs["table_name"] = table_name
        if query is not None:
            self.inputs["query"] = query
        if wait_timeout is not None:
            self.inputs["wait_timeout"] = wait_timeout
        if on_wait_timeout is not None:
            self.inputs["on_wait_timeout"] = on_wait_timeout
        if cluster_name is not None:
            self.inputs["cluster_name"] = cluster_name
        if spark_version is not None:
            self.inputs["spark_version"] = spark_version
        if node_type_id is not None:
            self.inputs["node_type_id"] = node_type_id
        if num_workers is not None:
            self.inputs["num_workers"] = num_workers
        if autotermination_minutes is not None:
            self.inputs["autotermination_minutes"] = autotermination_minutes
        if enable_elastic_disk is not None:
            self.inputs["enable_elastic_disk"] = enable_elastic_disk
        if cluster_id is not None:
            self.inputs["cluster_id"] = cluster_id
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if job_name is not None:
            self.inputs["job_name"] = job_name
        if notebook_path is not None:
            self.inputs["notebook_path"] = notebook_path
        if max_concurrent_runs is not None:
            self.inputs["max_concurrent_runs"] = max_concurrent_runs
        if timeout_seconds is not None:
            self.inputs["timeout_seconds"] = timeout_seconds
        if path is not None:
            self.inputs["path"] = path
        if file is not None:
            self.inputs["file"] = file
        if overwrite is not None:
            self.inputs["overwrite"] = overwrite
        if recursive is not None:
            self.inputs["recursive"] = recursive
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationDatabricksNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_weaviate")
class IntegrationWeaviateNode(Node):
    """
    Weaviate

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### query_weaviate
        collection: Select the Weaviate collection to query
        embedding_model: Select the embedding model to use to embed the query
        properties: Comma-separated list of keywords to use
        query: Natural Language Query

    ## Outputs
    ### Common Outputs
        output: Output of the Query. Example: “Salmon…”
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Weaviate>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output", "helper_text": "Output of the Query. Example: “Salmon…”"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "query_weaviate": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“Fish species in the South Pacific Ocean”",
                    "helper_text": "Natural Language Query",
                },
                {
                    "field": "embedding_model",
                    "type": "enum<string>",
                    "value": "",
                    "label": "Embedding Model",
                    "placeholder": "Select Embedding Model",
                    "helper_text": "Select the embedding model to use to embed the query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {
                                "label": "OpenAI Text Embedding 3 Small",
                                "value": "openai/text-embedding-3-small",
                            },
                            {
                                "label": "OpenAI Text Embedding 3 Large",
                                "value": "openai/text-embedding-3-large",
                            },
                            {
                                "label": "OpenAI Text Embedding Ada 002",
                                "value": "openai/text-embedding-ada-002",
                            },
                            {
                                "label": "Cohere Embed English v3.0",
                                "value": "cohere/embed-english-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual v3.0",
                                "value": "cohere/embed-multilingual-v3.0",
                            },
                            {
                                "label": "Cohere Embed English Light v3.0",
                                "value": "cohere/embed-english-light-v3.0",
                            },
                            {
                                "label": "Cohere Embed Multilingual Light v3.0",
                                "value": "cohere/embed-multilingual-light-v3.0",
                            },
                        ],
                    },
                },
                {
                    "field": "collection",
                    "type": "string",
                    "value": "",
                    "label": "Collection",
                    "placeholder": "Collection",
                    "helper_text": "Select the Weaviate collection to query",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=collection&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": False,
                            "supports_pagination": False,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "properties",
                    "type": "string",
                    "value": "",
                    "label": "Properties",
                    "placeholder": "Properties",
                    "helper_text": "Comma-separated list of keywords to use",
                },
            ],
            "outputs": [],
            "name": "query_weaviate",
            "task_name": "tasks.vectordbs.integrations.weaviate.query",
            "description": "Query Weaviate data",
            "label": "Query Weaviate",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        collection: str = "",
        embedding_model: str = "",
        properties: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_weaviate",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if collection is not None:
            self.inputs["collection"] = collection
        if properties is not None:
            self.inputs["properties"] = properties
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationWeaviateNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_bland_ai")
class IntegrationBlandAiNode(Node):
    """
    Bland AI

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### call_a_number
        first_sentence: The first sentence the AI should speak during the call
        model: LLM model that the AI should use
        pathway_id: This is the pathway ID for the pathway you have created on your dev portal.
        phone_number: The phone number of the contact you want to call
        task: The objective you want the AI to accomplish during the call
        temperature: A value between 0 and 1 that controls the randomness of the LLM. 0 will cause more deterministic outputs while 1 will cause more random
        transfer_number: A phone number that the agent can transfer to under specific conditions - such as being asked to speak to a human or supervisor
        wait_for_greeting: When checked, the agent will wait for the call recipient to speak first before responding

    ## Outputs
    ### Common Outputs
        answered_by: Possible values: Human: The call was answered by a human, Voicemail: The call was sent to voicemail, Unknown: There was not enough audio at the start of the call to make a determination, No-answer: The call was not answered, Null: Not enabled, or still processing the result
        transcript: The transcript of the call
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Bland AI>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "answered_by",
            "helper_text": "Possible values: Human: The call was answered by a human, Voicemail: The call was sent to voicemail, Unknown: There was not enough audio at the start of the call to make a determination, No-answer: The call was not answered, Null: Not enabled, or still processing the result",
        },
        {"field": "transcript", "helper_text": "The transcript of the call"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "call_a_number": {
            "inputs": [
                {
                    "field": "phone_number",
                    "type": "string",
                    "value": "",
                    "label": "Phone Number",
                    "placeholder": "+1 6173149183",
                    "helper_text": "The phone number of the contact you want to call",
                },
                {
                    "field": "task",
                    "type": "string",
                    "value": "",
                    "label": "Task",
                    "placeholder": "Get the user's name and email",
                    "helper_text": "The objective you want the AI to accomplish during the call",
                },
                {
                    "field": "first_sentence",
                    "type": "string",
                    "value": "",
                    "label": "Enter First Sentence (Optional)",
                    "placeholder": "Hello, this is...",
                    "helper_text": "The first sentence the AI should speak during the call",
                },
                {
                    "field": "model",
                    "type": "enum<string>",
                    "value": "enhanced",
                    "label": "Select Model",
                    "placeholder": "enhanced",
                    "helper_text": "LLM model that the AI should use",
                    "hidden": True,
                    "is_hidden_in_agent": True,
                    "agent_field_type": "static",
                    "disable_conversion": True,
                },
                {
                    "field": "pathway_id",
                    "type": "string",
                    "value": "",
                    "label": "Enter Pathway ID (Optional)",
                    "placeholder": "pathway_123",
                    "helper_text": "This is the pathway ID for the pathway you have created on your dev portal.",
                },
                {
                    "field": "temperature",
                    "type": "string",
                    "value": "",
                    "label": "Enter Temperature",
                    "placeholder": "0.7",
                    "helper_text": "A value between 0 and 1 that controls the randomness of the LLM. 0 will cause more deterministic outputs while 1 will cause more random",
                },
                {
                    "field": "transfer_number",
                    "type": "string",
                    "value": "",
                    "label": "Enter Transfer Number (Optional)",
                    "placeholder": "+12223334444",
                    "helper_text": "A phone number that the agent can transfer to under specific conditions - such as being asked to speak to a human or supervisor",
                },
                {
                    "field": "wait_for_greeting",
                    "type": "bool",
                    "value": False,
                    "label": "Select Wait for Greeting",
                    "placeholder": "false",
                    "helper_text": "When checked, the agent will wait for the call recipient to speak first before responding",
                },
            ],
            "outputs": [],
            "name": "call_a_number",
            "task_name": "tasks.bland_ai.call_a_number",
            "description": "Call a number using AI phone caller",
            "label": "Call a number",
            "variant": "bland_ai",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        first_sentence: str = "",
        model: str = "enhanced",
        pathway_id: str = "",
        phone_number: str = "",
        task: str = "",
        temperature: str = "",
        transfer_number: str = "",
        wait_for_greeting: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_bland_ai",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if phone_number is not None:
            self.inputs["phone_number"] = phone_number
        if task is not None:
            self.inputs["task"] = task
        if first_sentence is not None:
            self.inputs["first_sentence"] = first_sentence
        if model is not None:
            self.inputs["model"] = model
        if pathway_id is not None:
            self.inputs["pathway_id"] = pathway_id
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if transfer_number is not None:
            self.inputs["transfer_number"] = transfer_number
        if wait_for_greeting is not None:
            self.inputs["wait_for_greeting"] = wait_for_greeting
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationBlandAiNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_algolia")
class IntegrationAlgoliaNode(Node):
    """
    Algolia

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### search_index
        index: An index where the data used by Algolia is stored
        query: Keyword to be searched in the index
        return_mode: Choose between returning as chunks or JSON

    ## Outputs
    ### Common Outputs
        output: Search results from the Algolia index in the specified format
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Algolia>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "output",
            "helper_text": "Search results from the Algolia index in the specified format",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "search_index": {
            "inputs": [
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "“iPhone 16”",
                    "helper_text": "Keyword to be searched in the index",
                },
                {
                    "field": "index",
                    "type": "string",
                    "value": "",
                    "label": "Index",
                    "placeholder": "database",
                    "helper_text": "An index where the data used by Algolia is stored",
                },
                {
                    "field": "return_mode",
                    "type": "enum<string>",
                    "value": "json",
                    "label": "Return Mode",
                    "agent_field_type": "static",
                    "placeholder": "Choose between returning as chunks or JSON",
                    "helper_text": "Choose between returning as chunks or JSON",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "JSON", "value": "json"},
                            {"label": "Chunks", "value": "chunks"},
                        ],
                    },
                },
            ],
            "outputs": [],
            "name": "search_index",
            "task_name": "tasks.algolia.search_index",
            "description": "Query your Algolia index",
            "label": "Search Algolia index",
            "variant": "common_integration_nodes",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        index: str = "",
        query: str = "",
        return_mode: str = "json",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_algolia",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if query is not None:
            self.inputs["query"] = query
        if index is not None:
            self.inputs["index"] = index
        if return_mode is not None:
            self.inputs["return_mode"] = return_mode
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationAlgoliaNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_apollo")
class IntegrationApolloNode(Node):
    """
    Apollo

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### fetch_companies
        company_name: Name of the company to search
        keywords: Comma separated list of keywords the company should be associated with
        location: Location of the company headquarters
        max_size: Maximum number of employees in the company
        min_size: Minimum number of employees in the company
        num_results: Limit number of results
    ### enrich_contact
        company_name: Name of the company to search
        domain: Company domain
        first_name_input: Contact's first name
        last_name_input: Contact's last name
        linkedin_url_input: Contact's LinkedIn URL
    ### enrich_company
        domain: Company domain

    ## Outputs
    ### enrich_company
        annual_revenue: The company’s annual revenue e.g., 766400000000.0
        company_name: The company name e.g., Google
        country: The company’s headquartered country e.g., United States
        industry: The company’s industry e.g., information technology & services
        linkedin_url: The company’s Linkedin URL e.g., http://www.linkedin.com/company/google
        num_employees: The total number of employees e.g., 289000
        total_funding: The company’s total funding e.g., 3000000000000.0
        website: The company’s website e.g., http://www.google.com
    ### fetch_companies
        company_names: A list of company names e.g., ["VectorShift","VectorShift Studios"]
        domains: A list of domains e.g., ["vectorshift.ai","vectorshiftstudios.com"]
        linkedin_urls: A list of Linkedin URLs e.g., ["http://www.linkedin.com/company/vectorshift","http://www.linkedin.com/company/vectorshift-studios"]
        websites: A list of websites e.g., ["http://www.vectorshift.ai","http://www.vectorshiftstudios.com"]
    ### enrich_contact
        email: The person’s email address e.g., sundar@google.com
        first_name: The first name e.g., Sundar
        job_title: The person’s title e.g., CEO
        last_name: The last name e.g., Pichai
        linkedin_url: The person’s Linkedin e.g., https://www.linkedin.com/in/sundarpichai
        phone_number: The person’s phone number+10000000000
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Apollo>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "default_integration_nodes"},
        "fetch_companies": {
            "inputs": [
                {
                    "field": "company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "VectorShift",
                    "helper_text": "Name of the company to search",
                },
                {
                    "field": "keywords",
                    "type": "string",
                    "value": "",
                    "label": "Keywords",
                    "placeholder": "AI, automation",
                    "helper_text": "Comma separated list of keywords the company should be associated with",
                },
                {
                    "field": "min_size",
                    "type": "string",
                    "value": "",
                    "label": "Min Size",
                    "placeholder": "10",
                    "helper_text": "Minimum number of employees in the company",
                },
                {
                    "field": "max_size",
                    "type": "string",
                    "value": "",
                    "label": "Max Size",
                    "placeholder": "100",
                    "helper_text": "Maximum number of employees in the company",
                },
                {
                    "field": "location",
                    "type": "string",
                    "value": "",
                    "label": "Location",
                    "placeholder": "California, US",
                    "helper_text": "Location of the company headquarters",
                },
                {
                    "field": "num_results",
                    "type": "string",
                    "value": "",
                    "label": "Number of Results",
                    "placeholder": "10",
                    "helper_text": "Limit number of results",
                },
            ],
            "outputs": [
                {
                    "field": "company_names",
                    "type": "string",
                    "helper_text": 'A list of company names e.g., ["VectorShift","VectorShift Studios"]',
                },
                {
                    "field": "websites",
                    "type": "string",
                    "helper_text": 'A list of websites e.g., ["http://www.vectorshift.ai","http://www.vectorshiftstudios.com"]',
                },
                {
                    "field": "domains",
                    "type": "string",
                    "helper_text": 'A list of domains e.g., ["vectorshift.ai","vectorshiftstudios.com"]',
                },
                {
                    "field": "linkedin_urls",
                    "type": "string",
                    "helper_text": 'A list of Linkedin URLs e.g., ["http://www.linkedin.com/company/vectorshift","http://www.linkedin.com/company/vectorshift-studios"]',
                },
            ],
            "name": "fetch_companies",
            "task_name": "tasks.apollo.fetch_companies",
            "description": "Search for companies via Apollo api",
            "label": "Search Companies",
        },
        "enrich_company": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "google.com",
                    "helper_text": "Company domain",
                }
            ],
            "outputs": [
                {
                    "field": "company_name",
                    "type": "string",
                    "helper_text": "The company name e.g., Google",
                },
                {
                    "field": "country",
                    "type": "string",
                    "helper_text": "The company’s headquartered country e.g., United States",
                },
                {
                    "field": "website",
                    "type": "string",
                    "helper_text": "The company’s website e.g., http://www.google.com",
                },
                {
                    "field": "industry",
                    "type": "string",
                    "helper_text": "The company’s industry e.g., information technology & services",
                },
                {
                    "field": "annual_revenue",
                    "type": "string",
                    "helper_text": "The company’s annual revenue e.g., 766400000000.0",
                },
                {
                    "field": "total_funding",
                    "type": "string",
                    "helper_text": "The company’s total funding e.g., 3000000000000.0",
                },
                {
                    "field": "num_employees",
                    "type": "string",
                    "helper_text": "The total number of employees e.g., 289000",
                },
                {
                    "field": "linkedin_url",
                    "type": "string",
                    "helper_text": "The company’s Linkedin URL e.g., http://www.linkedin.com/company/google",
                },
            ],
            "name": "enrich_company",
            "task_name": "tasks.apollo.enrich_company",
            "description": "Enrich company information via Apollo api",
            "label": "Enrich Company Information",
        },
        "enrich_contact": {
            "inputs": [
                {
                    "field": "domain",
                    "type": "string",
                    "value": "",
                    "label": "Domain",
                    "placeholder": "google.com",
                    "helper_text": "Contact's company domain",
                },
                {
                    "field": "first_name_input",
                    "type": "string",
                    "value": "",
                    "label": "First Name",
                    "placeholder": "Sundar",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "last_name_input",
                    "type": "string",
                    "value": "",
                    "label": "Last Name",
                    "placeholder": "Pichai",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "company_name",
                    "type": "string",
                    "value": "",
                    "label": "Company Name",
                    "placeholder": "Google",
                    "helper_text": "Contact's company name",
                },
                {
                    "field": "linkedin_url_input",
                    "type": "string",
                    "value": "",
                    "label": "LinkedIn URL",
                    "placeholder": "https://www.linkedin.com/in/sundarpichai",
                    "helper_text": "Contact's LinkedIn URL",
                },
            ],
            "outputs": [
                {
                    "field": "first_name",
                    "type": "string",
                    "helper_text": "The first name e.g., Sundar",
                },
                {
                    "field": "last_name",
                    "type": "string",
                    "helper_text": "The last name e.g., Pichai",
                },
                {
                    "field": "job_title",
                    "type": "string",
                    "helper_text": "The person’s title e.g., CEO",
                },
                {
                    "field": "phone_number",
                    "type": "string",
                    "helper_text": "The person’s phone number+10000000000",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "The person’s email address e.g., sundar@google.com",
                },
                {
                    "field": "linkedin_url",
                    "type": "string",
                    "helper_text": "The person’s Linkedin e.g., https://www.linkedin.com/in/sundarpichai",
                },
            ],
            "name": "enrich_contact",
            "task_name": "tasks.apollo.enrich_contact",
            "description": "Enrich a contact via Apollo api",
            "label": "Enrich Contact Details",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        company_name: str = "",
        domain: str = "",
        first_name_input: str = "",
        keywords: str = "",
        last_name_input: str = "",
        linkedin_url_input: str = "",
        location: str = "",
        max_size: str = "",
        min_size: str = "",
        num_results: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_apollo",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if company_name is not None:
            self.inputs["company_name"] = company_name
        if keywords is not None:
            self.inputs["keywords"] = keywords
        if min_size is not None:
            self.inputs["min_size"] = min_size
        if max_size is not None:
            self.inputs["max_size"] = max_size
        if location is not None:
            self.inputs["location"] = location
        if num_results is not None:
            self.inputs["num_results"] = num_results
        if domain is not None:
            self.inputs["domain"] = domain
        if first_name_input is not None:
            self.inputs["first_name_input"] = first_name_input
        if last_name_input is not None:
            self.inputs["last_name_input"] = last_name_input
        if linkedin_url_input is not None:
            self.inputs["linkedin_url_input"] = linkedin_url_input
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationApolloNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_clickup")
class IntegrationClickupNode(Node):
    """
    ClickUp

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'get_tasks'
        archived: Include archived tasks
        assignees: Filter by assignee
        custom_fields: Custom field filters in JSON format: {"field_id": "value"}
        date_updated_gt: Tasks updated after this date (YYYY-MM-DD)
        date_updated_lt: Tasks updated before this date (YYYY-MM-DD)
        due_date_gt: Tasks due after this date (YYYY-MM-DD)
        due_date_lt: Tasks due before this date (YYYY-MM-DD)
        folder_id: The ID of the folder
        include_closed: Include closed tasks
        include_markdown_description: Include markdown description
        list_id: The ID of the list where task will be created
        order_by: Sort tasks by field (created, updated, due_date, etc.)
        reverse: Reverse the sort order
        space_id: The ID of the space
        statuses: Filter by specific task statuses
        subtasks: Include subtasks
        tags: Filter by tag names
        team_id: The ID of the team
        use_date: Toggle to use dates
    ### When action = 'create_comment'
        assign_user: User ID to assign to this comment
        comment_text: Content of the comment
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        notify_all: Notify all members when task is created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'get_time_entries'
        assignee: Filter by assignee user ID
        folder_id: The ID of the folder
        include_location_names: Include location names
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
        use_date: Toggle to use dates
    ### When action = 'delete_checklist'
        checklist_id: The ID of the checklist to delete
    ### When action = 'update_checklist'
        checklist_id: The ID of the checklist to delete
        update_checklist_name: New name for the checklist
        update_checklist_position: New position for the checklist
    ### When action = 'create_checklist_item'
        checklist_id: The ID of the checklist to delete
        checklist_item_assignee: User ID to assign to this checklist item
        checklist_item_name: Name of the checklist item
    ### When action = 'delete_checklist_item'
        checklist_id: The ID of the checklist to delete
        checklist_item_id: The ID of the checklist item to delete
    ### When action = 'update_checklist_item'
        checklist_id: The ID of the checklist to delete
        checklist_item_id: The ID of the checklist item to delete
        update_checklist_item_assignee: New assignee for the checklist item
        update_checklist_item_name: New name for the checklist item
        update_checklist_item_parent: New parent for the checklist item
        update_checklist_item_resolved: Mark checklist item as resolved
    ### When action = 'create_checklist'
        checklist_name: Name of the checklist
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'update_comment'
        comment_id: The ID of the comment to update
        update_comment_text: New content for the comment
    ### When action = 'delete_comment'
        comment_id: The ID of the comment to update
    ### When action = 'set_custom_field'
        custom_field_id: The ID of the custom field
        custom_field_value: The value to set for the custom field
        custom_task_ids: Use custom task IDs
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'get_task_members'
        custom_task_ids: Use custom task IDs
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'get_tasks' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_time_entries' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'create_task_dependency'
        depends_on_task_id: The ID of the task that this task depends on
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'delete_task_dependency'
        depends_on_task_id: The ID of the task that this task depends on
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'create_time_entry'
        duration_minutes: Duration in minutes
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        start_time: Start time for the time entry (RFC3339 format)
        task_id: The ID of the task to read
        team_id: The ID of the team
        time_entry_assignee: Assignee user ID for the time entry
        time_entry_billable: Mark time entry as billable
        time_entry_description: Description of the time entry
        time_entry_tags: Comma-separated list of tags or JSON objects
    ### When action = 'create_space'
        enable_custom_fields: Allow custom fields
        enable_dependency_warnings: Allow dependency warnings
        enable_incomplete_warnings: Allow incomplete warnings
        enable_priority: Allow priority
        enable_tags: Allow tags
        enable_time_tracking: Allow time tracking
        space_multiple_assignees: Allow multiple assignees
        space_name: Name of the space
        team_id: The ID of the team
    ### When action = 'get_tasks' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_time_entries' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'create_task'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        markdown_content: Task content in markdown format
        notify_all: Notify all members when task is created
        parent_id: ID of the parent task (for subtasks)
        space_id: The ID of the space
        task_assignees: List of assignee IDs
        task_description: Description of the task
        task_due_date: Due date for the task (timestamp)
        task_name: Name of the task
        task_priority: Priority of the task
        task_start_date: Start date for the task (timestamp)
        task_status: Status of the task
        task_tags: List of tags for the task
        team_id: The ID of the team
        time_estimate: Time estimate for the task in hours
    ### When action = 'update_task'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
        update_markdown_content: Task content in markdown format
        update_parent_id: New parent task ID (for subtasks)
        update_task_assignees: New list of assignee IDs
        update_task_description: New description for the task
        update_task_due_date: New due date for the task (timestamp)
        update_task_name: New name for the task
        update_task_priority: New priority for the task
        update_task_start_date: New start date for the task (timestamp)
        update_task_status: New status for the task
        update_task_tags: New list of tags for the task
        update_time_estimate: New time estimate for the task in hours
    ### When action = 'read_task'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'delete_task'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'get_comments'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'create_list'
        folder_id: The ID of the folder
        list_content: Description of the list
        list_name: Name of the list
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'update_list'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        team_id: The ID of the team
        update_list_assignee: New assignee for the list
        update_list_content: New description for the list
        update_list_due_date: New due date for the list (timestamp)
        update_list_name: New name for the list
        update_list_priority: New priority for the list
        update_list_status: New status for the list
    ### When action = 'read_list'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'get_lists'
        folder_id: The ID of the folder
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'delete_list'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'update_folder'
        folder_id: The ID of the folder
        space_id: The ID of the space
        team_id: The ID of the team
        update_folder_name: New name for the folder
    ### When action = 'read_folder'
        folder_id: The ID of the folder
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'delete_folder'
        folder_id: The ID of the folder
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'start_time_entry'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        task_id: The ID of the task to read
        team_id: The ID of the team
        time_entry_billable: Mark time entry as billable
        time_entry_description: Description of the time entry
    ### When action = 'add_task_tag'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        tag_name: Name of the tag
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'remove_task_tag'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        tag_name: Name of the tag
        task_id: The ID of the task to read
        team_id: The ID of the team
    ### When action = 'get_custom_fields'
        folder_id: The ID of the folder
        list_id: The ID of the list where task will be created
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'create_folder'
        folder_name: Name of the folder
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'read_time_entry'
        get_running: Get currently running time entry
        team_id: The ID of the team
        time_entry_id: The ID of the time entry to delete
    ### When action = 'create_goal'
        goal_color: Color for the goal
        goal_description: Description of the goal
        goal_due_date: Due date for the goal (YYYY-MM-DD or RFC3339)
        goal_multiple_owners: Allow multiple owners
        goal_name: Name of the goal
        goal_owners: Comma-separated list of owner user IDs
        team_id: The ID of the team
    ### When action = 'delete_goal'
        goal_id: The ID of the goal to delete
    ### When action = 'read_goal'
        goal_id: The ID of the goal to delete
    ### When action = 'update_goal'
        goal_id: The ID of the goal to delete
        update_goal_add_owners: Comma-separated list of owner user IDs to add
        update_goal_color: New color for the goal
        update_goal_description: New description for the goal
        update_goal_due_date: New due date for the goal (YYYY-MM-DD or RFC3339)
        update_goal_name: New name for the goal
        update_goal_remove_owners: Comma-separated list of owner user IDs to remove
    ### When action = 'create_goal_key_result'
        goal_id: The ID of the goal to delete
        key_result_list_ids: Comma-separated list of list IDs
        key_result_name: Name of the key result
        key_result_owners: Comma-separated list of owner user IDs
        key_result_steps_end: Target value for the key result
        key_result_steps_start: Starting value for the key result
        key_result_task_ids: Comma-separated list of task IDs
        key_result_type: Type of key result
        key_result_unit: Unit for the key result
    ### When action = 'get_goals'
        include_completed: Include completed goals
        team_id: The ID of the team
    ### When action = 'delete_goal_key_result'
        key_result_id: The ID of the key result to delete
    ### When action = 'update_goal_key_result'
        key_result_id: The ID of the key result to delete
        update_key_result_name: New name for the key result
        update_key_result_note: New note for the key result
        update_key_result_steps_current: Current progress value
        update_key_result_steps_end: New target value
        update_key_result_steps_start: New starting value
        update_key_result_unit: New unit for the key result
    ### When action = 'get_space_tags'
        limit: Maximum number of tags to fetch
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'get_list_members'
        list_id: The ID of the list where task will be created
    ### When action = 'add_task_to_list'
        list_id: The ID of the list where task will be created
        task_id: The ID of the task to read
    ### When action = 'remove_task_from_list'
        list_id: The ID of the list where task will be created
        task_id: The ID of the task to read
    ### When action = 'update_space_tag'
        new_tag_name: New name for the tag
        space_id: The ID of the space
        tag_background_color: Background color for the tag
        tag_foreground_color: Foreground color for the tag
        tag_name: Name of the tag
        team_id: The ID of the team
    ### When action = 'get_tasks' and use_date = False
        num_messages: Specify the number of tasks to fetch
    ### When action = 'get_time_entries' and use_date = False
        num_messages: Specify the number of tasks to fetch
    ### When action = 'get_folders'
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'read_space'
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'delete_space'
        space_id: The ID of the space
        team_id: The ID of the team
    ### When action = 'create_space_tag'
        space_id: The ID of the space
        tag_background_color: Background color for the tag
        tag_foreground_color: Foreground color for the tag
        tag_name: Name of the tag
        team_id: The ID of the team
    ### When action = 'delete_space_tag'
        space_id: The ID of the space
        tag_name: Name of the tag
        team_id: The ID of the team
    ### When action = 'add_time_entry_tag'
        tag_name: Name of the tag
        team_id: The ID of the team
        time_entry_id: The ID of the time entry to delete
    ### When action = 'remove_time_entry_tag'
        tag_name: Name of the tag
        team_id: The ID of the team
        time_entry_id: The ID of the time entry to delete
    ### When action = 'delete_time_entry'
        team_id: The ID of the team
        time_entry_id: The ID of the time entry to delete
    ### When action = 'stop_time_entry'
        team_id: The ID of the team
    ### When action = 'update_time_entry'
        team_id: The ID of the team
        time_entry_id: The ID of the time entry to delete
        update_time_entry_billable: Mark time entry as billable
        update_time_entry_description: New description for the time entry
        update_time_entry_duration_minutes: New duration in minutes
        update_time_entry_start: New start time (RFC3339 format)
        update_time_entry_task_id: New task ID for the time entry
    ### When action = 'get_time_entry_tags'
        team_id: The ID of the team
    ### When action = 'get_tasks' and use_date = True
        use_exact_date: Switch between exact date range and relative dates
    ### When action = 'get_time_entries' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_space'
        access: Whether the user has access to the space
        color: Color of the space
        features: Space features in JSON format
        raw_data: Raw API response data in JSON format
        space_details: Space details in JSON format
        space_id: ID of the space
        space_name: Name of the space
        statuses: Space statuses in JSON format
    ### When action = 'read_list'
        assignee: Assignee of the list
        due_date: Due date of the list
        folder: Folder information in JSON format
        list_details: List details in JSON format
        list_id: ID of the list
        list_name: Name of the list
        order_index: Order index of the list
        priority: Priority of the list
        raw_data: Raw API response data in JSON format
        space: Space information in JSON format
        start_date: Start date of the list
        status: Status of the list
        statuses: List of statuses in JSON format
        task_count: Number of tasks in the list
    ### When action = 'read_task'
        assignees: List of assignees for the task
        created_at: Creation timestamp of the task
        description: Description of the task
        due_date: Due date of the task
        priority: Priority of the task
        raw_data: Raw API response data in JSON format
        start_date: Start date of the task
        status: Status of the task
        tags: List of tags for the task
        task_details: Task details in JSON format
        task_id: ID of the task
        task_name: Name of the task
        task_url: URL of the task
        updated_at: Last update timestamp of the task
    ### When action = 'read_time_entry'
        billable: Whether the time entry is billable
        created_at: Creation timestamp of the time entry
        description: Description of the time entry
        duration: Duration of the time entry
        end: End time of the time entry
        raw_data: Raw API response data in JSON format
        source: Source of the time entry
        start: Start time of the time entry
        tags: Tags in JSON format
        task: Task information in JSON format
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the time entry
        user: User information in JSON format
    ### When action = 'create_checklist'
        checklist_details: Checklist details in JSON format
        checklist_id: ID of the created checklist
        checklist_name: Name of the created checklist
        raw_data: Raw API response data in JSON format
    ### When action = 'update_checklist'
        checklist_details: Checklist details in JSON format
        checklist_id: ID of the updated checklist
        checklist_name: Name of the updated checklist
        raw_data: Raw API response data in JSON format
    ### When action = 'create_checklist_item'
        checklist_details: Checklist details in JSON format
        checklist_id: ID of the checklist
        raw_data: Raw API response data in JSON format
    ### When action = 'update_checklist_item'
        checklist_details: Checklist details in JSON format
        checklist_id: ID of the checklist
        checklist_name: Name of the checklist
        raw_data: Raw API response data in JSON format
    ### When action = 'delete_checklist'
        checklist_id: ID of the deleted checklist
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the checklist was successfully deleted
    ### When action = 'delete_checklist_item'
        checklist_id: ID of the checklist
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the checklist item was successfully deleted
    ### When action = 'read_goal'
        color: Color of the goal
        created_at: Creation timestamp of the goal
        description: Description of the goal
        due_date: Due date of the goal
        folder_access: Whether the goal has folder access
        goal_details: Goal details in JSON format
        goal_id: ID of the goal
        goal_name: Name of the goal
        history: Goal history in JSON format
        key_results: Key results in JSON format
        multiple_owners: Whether the goal has multiple owners
        owners: Goal owners in JSON format
        percent_completed: Percentage of goal completion
        pretty_id: Pretty ID of the goal
        pretty_url: Pretty URL of the goal
        raw_data: Raw API response data in JSON format
        team_id: ID of the team
        updated_at: Update timestamp of the goal
    ### When action = 'get_comments'
        comment_created_dates: List of comment creation dates
        comment_details: Comments details in JSON format
        comment_ids: List of comment IDs
        comment_texts: List of comment texts
        comment_updated_dates: List of comment update dates
        comment_users: List of comment authors in JSON format
        raw_data: Raw API response data in JSON format
    ### When action = 'create_comment'
        comment_details: Comment details in JSON format
        comment_id: ID of the created comment
        comment_text: Text of the created comment
        created_at: Creation timestamp of the comment
        raw_data: Raw API response data in JSON format
        user: User who created the comment
    ### When action = 'update_comment'
        comment_details: Comment details in JSON format
        comment_id: ID of the updated comment
        comment_text: Text of the updated comment
        raw_data: Raw API response data in JSON format
        updated_at: Update timestamp of the comment
    ### When action = 'delete_comment'
        comment_id: ID of the deleted comment
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the comment was successfully deleted
    ### When action = 'create_task'
        created_at: Creation timestamp of the task
        raw_data: Raw API response data in JSON format
        status: Status of the created task
        task_details: Task details in JSON format
        task_id: ID of the created task
        task_name: Name of the created task
        task_url: URL of the created task
    ### When action = 'set_custom_field'
        custom_field_id: ID of the custom field
        custom_field_value: New value of the custom field
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the custom field was successfully set
        task_id: ID of the task
    ### When action = 'get_custom_fields'
        custom_field_ids: List of custom field IDs
        custom_field_names: List of custom field names
        custom_field_types: List of custom field types
        custom_fields_details: Custom fields details in JSON format
        raw_data: Raw API response data in JSON format
    ### When action = 'create_task_dependency'
        depends_on_task_id: ID of the task this depends on
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the dependency was successfully created
        task_id: ID of the dependent task
    ### When action = 'delete_task_dependency'
        depends_on_task_id: ID of the task this depends on
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the dependency was successfully deleted
        task_id: ID of the dependent task
    ### When action = 'create_folder'
        folder_details: Folder details in JSON format
        folder_id: ID of the created folder
        folder_name: Name of the created folder
        raw_data: Raw API response data in JSON format
    ### When action = 'update_folder'
        folder_details: Folder details in JSON format
        folder_id: ID of the updated folder
        folder_name: Name of the updated folder
        raw_data: Raw API response data in JSON format
    ### When action = 'read_folder'
        folder_details: Folder details in JSON format
        folder_id: ID of the folder
        folder_name: Name of the folder
        hidden: Whether the folder is hidden
        lists: Lists in the folder in JSON format
        order_index: Order index of the folder
        raw_data: Raw API response data in JSON format
        space: Space information in JSON format
        task_count: Number of tasks in the folder
    ### When action = 'get_folders'
        folder_details: Folders details in JSON format
        folder_hidden_states: List of folder hidden states
        folder_ids: List of folder IDs
        folder_lists: List of lists in JSON format
        folder_names: List of folder names
        folder_order_indexes: List of folder order indexes
        folder_spaces: List of spaces in JSON format
        folder_task_counts: List of task counts in JSON format
        raw_data: Raw API response data in JSON format
    ### When action = 'delete_folder'
        folder_id: ID of the deleted folder
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the folder was successfully deleted
    ### When action = 'get_goals'
        goal_colors: List of goal colors
        goal_created_dates: List of goal creation dates
        goal_descriptions: List of goal descriptions
        goal_details: Goals details in JSON format
        goal_due_dates: List of goal due dates
        goal_folder_access: List of folder access flags
        goal_ids: List of goal IDs
        goal_key_results: List of key results in JSON format
        goal_multiple_owners: List of multiple owners flags
        goal_names: List of goal names
        goal_owners: List of goal owners in JSON format
        goal_percent_completed: List of goal completion percentages
        goal_pretty_ids: List of goal pretty IDs
        goal_pretty_urls: List of goal pretty URLs
        goal_team_ids: List of team IDs
        goal_updated_dates: List of goal update dates
        raw_data: Raw API response data in JSON format
    ### When action = 'create_goal'
        goal_details: Goal details in JSON format
        goal_id: ID of the created goal
        goal_name: Name of the created goal
        raw_data: Raw API response data in JSON format
    ### When action = 'update_goal'
        goal_details: Goal details in JSON format
        goal_id: ID of the updated goal
        goal_name: Name of the updated goal
        raw_data: Raw API response data in JSON format
    ### When action = 'delete_goal'
        goal_id: ID of the deleted goal
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the goal was successfully deleted
    ### When action = 'create_goal_key_result'
        key_result_details: Key result details in JSON format
        key_result_id: ID of the created key result
        key_result_name: Name of the created key result
        raw_data: Raw API response data in JSON format
    ### When action = 'update_goal_key_result'
        key_result_details: Key result details in JSON format
        key_result_id: ID of the updated key result
        key_result_name: Name of the updated key result
        raw_data: Raw API response data in JSON format
    ### When action = 'delete_goal_key_result'
        key_result_id: ID of the deleted key result
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the key result was successfully deleted
    ### When action = 'get_lists'
        list_assignees: List of assignees in JSON format
        list_details: Lists details in JSON format
        list_due_dates: List of due dates
        list_folders: List of folders in JSON format
        list_ids: List of list IDs
        list_names: List of list names
        list_order_indexes: List of list order indexes
        list_priorities: List of priorities in JSON format
        list_spaces: List of spaces in JSON format
        list_start_dates: List of start dates
        list_status_arrays: List of status arrays in JSON format
        list_statuses: List of list statuses
        list_task_counts: List of task counts in JSON format
        raw_data: Raw API response data in JSON format
    ### When action = 'create_list'
        list_details: List details in JSON format
        list_id: ID of the created list
        list_name: Name of the created list
        raw_data: Raw API response data in JSON format
    ### When action = 'update_list'
        list_details: List details in JSON format
        list_id: ID of the updated list
        list_name: Name of the updated list
        raw_data: Raw API response data in JSON format
    ### When action = 'delete_list'
        list_id: ID of the deleted list
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the list was successfully deleted
    ### When action = 'add_task_to_list'
        list_id: ID of the list
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the task was successfully added to the list
        task_id: ID of the task
    ### When action = 'remove_task_from_list'
        list_id: ID of the list
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the task was successfully removed from the list
        task_id: ID of the task
    ### When action = 'get_list_members'
        member_details: Members details in JSON format
        member_emails: List of member emails
        member_ids: List of member user IDs
        member_names: List of member usernames
        raw_data: Raw API response data in JSON format
    ### When action = 'get_task_members'
        member_ids: List of member user IDs
        member_names: List of member usernames
        member_roles: List of member roles
        members_details: Members details in JSON format
        raw_data: Raw API response data in JSON format
    ### When action = 'delete_task'
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the task was successfully deleted
        task_id: ID of the deleted task
    ### When action = 'delete_space'
        message: Success message
        raw_data: Raw API response data in JSON format
        space_id: ID of the deleted space
        success: Whether the space was successfully deleted
    ### When action = 'delete_time_entry'
        message: Success message
        raw_data: Raw API response data in JSON format
        response_data: Response data from the API
        success: Whether the time entry was successfully deleted
        time_entry_id: ID of the deleted time entry
    ### When action = 'start_time_entry'
        message: Success message
        raw_data: Raw API response data in JSON format
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the started time entry
    ### When action = 'stop_time_entry'
        message: Success message
        raw_data: Raw API response data in JSON format
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the stopped time entry
    ### When action = 'create_space_tag'
        message: Success message
        raw_data: Raw API response data in JSON format
        space_id: ID of the space
        success: Whether the tag was successfully created
        tag_name: Name of the created tag
    ### When action = 'delete_space_tag'
        message: Success message
        raw_data: Raw API response data in JSON format
        space_id: ID of the space
        success: Whether the tag was successfully deleted
        tag_name: Name of the deleted tag
    ### When action = 'update_space_tag'
        message: Success message
        new_tag_name: New name of the tag
        old_tag_name: Previous name of the tag
        raw_data: Raw API response data in JSON format
        space_id: ID of the space
        success: Whether the tag was successfully updated
    ### When action = 'add_task_tag'
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the tag was successfully added
        tag_name: Name of the added tag
        task_id: ID of the task
    ### When action = 'remove_task_tag'
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the tag was successfully removed
        tag_name: Name of the removed tag
        task_id: ID of the task
    ### When action = 'add_time_entry_tag'
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the tag was successfully added
        tag_name: Name of the added tag
        time_entry_id: ID of the time entry
    ### When action = 'remove_time_entry_tag'
        message: Success message
        raw_data: Raw API response data in JSON format
        success: Whether the tag was successfully removed
        tag_name: Name of the removed tag
        time_entry_id: ID of the time entry
    ### When action = 'update_task'
        raw_data: Raw API response data in JSON format
        status: Status of the updated task
        task_details: Task details in JSON format
        task_id: ID of the updated task
        task_name: Name of the updated task
        task_url: URL of the updated task
        updated_at: Update timestamp of the task
    ### When action = 'get_tasks'
        raw_data: Raw API response data in JSON format
        task_assignees: Task assignees in JSON format
        task_created_dates: List of task creation dates
        task_descriptions: List of task descriptions
        task_details: Tasks details in JSON format
        task_due_dates: List of task due dates
        task_ids: List of task IDs
        task_names: List of task names
        task_priorities: Task priorities in JSON format
        task_start_dates: List of task start dates
        task_statuses: List of task statuses
        task_tags: Task tags in JSON format
        task_updated_dates: List of task update dates
        task_urls: List of task URLs
    ### When action = 'create_space'
        raw_data: Raw API response data in JSON format
        space_details: Space details in JSON format
        space_id: ID of the created space
        space_name: Name of the created space
    ### When action = 'create_time_entry'
        raw_data: Raw API response data in JSON format
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the created time entry
    ### When action = 'get_time_entries'
        raw_data: Raw API response data in JSON format
        time_entry_billables: List of billable flags
        time_entry_created_dates: List of creation dates
        time_entry_descriptions: List of descriptions
        time_entry_details: Time entries details in JSON format
        time_entry_durations: List of durations
        time_entry_ends: List of end times
        time_entry_ids: List of time entry IDs
        time_entry_sources: List of sources
        time_entry_starts: List of start times
        time_entry_tags: List of tags in JSON format
        time_entry_tasks: List of tasks in JSON format
        time_entry_users: List of users in JSON format
    ### When action = 'update_time_entry'
        raw_data: Raw API response data in JSON format
        time_entry_details: Time entry details in JSON format
        time_entry_id: ID of the updated time entry
    ### When action = 'get_space_tags'
        raw_data: Raw API response data in JSON format
        space_id: ID of the space
        tag_backgrounds: List of tag background colors
        tag_creators: List of tag creator IDs
        tag_details: Tags details in JSON format
        tag_foregrounds: List of tag foreground colors
        tag_names: List of tag names
    ### When action = 'get_time_entry_tags'
        raw_data: Raw API response data in JSON format
        tag_details: Time entry tags details in JSON format
        tag_names: List of time entry tag names
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Clickup>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_task**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list where task will be created",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_status",
                    "type": "string",
                    "value": "",
                    "helper_text": "Status of the task",
                    "label": "Status",
                    "placeholder": "to do",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=status&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "List of assignee IDs",
                    "label": "Assignees",
                    "placeholder": "User IDs",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_priority",
                    "type": "string",
                    "value": "3",
                    "helper_text": "Priority of the task",
                    "label": "Priority",
                    "placeholder": "Normal",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Urgent", "value": "1"},
                            {"label": "High", "value": "2"},
                            {"label": "Normal", "value": "3"},
                            {"label": "Low", "value": "4"},
                        ],
                    },
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the task",
                    "label": "Task Name",
                    "placeholder": "Complete project documentation",
                },
                {
                    "field": "task_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the task",
                    "label": "Task Description",
                    "placeholder": "Write comprehensive documentation for the project",
                },
                {
                    "field": "task_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "List of tags for the task",
                    "label": "Tags",
                    "placeholder": "Tags",
                },
                {
                    "field": "task_due_date",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Due date for the task (timestamp)",
                    "label": "Due Date",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "task_start_date",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Start date for the task (timestamp)",
                    "label": "Start Date",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "parent_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the parent task (for subtasks)",
                    "label": "Parent Task ID",
                    "placeholder": "Parent task ID",
                },
                {
                    "field": "time_estimate",
                    "type": "int32",
                    "value": "",
                    "helper_text": "Time estimate for the task in hours",
                    "label": "Time Estimate",
                    "placeholder": "2",
                },
                {
                    "field": "notify_all",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Notify all members when task is created",
                    "label": "Notify All",
                    "placeholder": "false",
                },
                {
                    "field": "markdown_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "Task content in markdown format",
                    "label": "Markdown Content",
                    "placeholder": "## Task Details\n- Item 1\n- Item 2",
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the created task",
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "Name of the created task",
                },
                {
                    "field": "task_url",
                    "type": "string",
                    "helper_text": "URL of the created task",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the created task",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp of the task",
                },
                {
                    "field": "task_details",
                    "type": "string",
                    "helper_text": "Task details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "create_task",
            "task_name": "tasks.clickup.create_task",
            "description": "Create a new task in ClickUp",
            "label": "Create Task",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_status",
                "task_assignees",
                "task_priority",
                "task_name",
                "task_description",
                "task_tags",
                "task_due_date",
                "task_start_date",
                "parent_id",
                "time_estimate",
                "notify_all",
                "markdown_content",
            ],
            "required": [
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_name",
                "task_description",
            ],
        },
        "update_task**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to read tasks from",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to read",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "update_task_status",
                    "type": "string",
                    "value": "",
                    "helper_text": "New status for the task",
                    "label": "Status",
                    "placeholder": "in progress",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=status&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "update_task_assignees",
                    "type": "string",
                    "value": "",
                    "helper_text": "New list of assignee IDs",
                    "label": "Assignees",
                    "placeholder": "User IDs",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "update_task_priority",
                    "type": "string",
                    "value": "3",
                    "helper_text": "New priority for the task",
                    "label": "Priority",
                    "placeholder": "Normal",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Urgent", "value": "1"},
                            {"label": "High", "value": "2"},
                            {"label": "Normal", "value": "3"},
                            {"label": "Low", "value": "4"},
                        ],
                    },
                },
                {
                    "field": "update_task_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the task",
                    "label": "Task Name",
                    "placeholder": "Updated task name",
                },
                {
                    "field": "update_task_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the task",
                    "label": "Task Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_task_due_date",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "New due date for the task (timestamp)",
                    "label": "Due Date",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "update_task_start_date",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "New start date for the task (timestamp)",
                    "label": "Start Date",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "update_task_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "New list of tags for the task",
                    "label": "Tags",
                    "placeholder": "Tags",
                },
                {
                    "field": "update_parent_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "New parent task ID (for subtasks)",
                    "label": "Parent Task ID",
                    "placeholder": "Parent task ID",
                },
                {
                    "field": "update_time_estimate",
                    "type": "int32",
                    "value": "",
                    "helper_text": "New time estimate for the task in hours",
                    "label": "Time Estimate",
                    "placeholder": "2",
                },
                {
                    "field": "update_markdown_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "Task content in markdown format",
                    "label": "Markdown Content",
                    "placeholder": "## Task Details\n- Item 1\n- Item 2",
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the updated task",
                },
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "Name of the updated task",
                },
                {
                    "field": "task_url",
                    "type": "string",
                    "helper_text": "URL of the updated task",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the updated task",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Update timestamp of the task",
                },
                {
                    "field": "task_details",
                    "type": "string",
                    "helper_text": "Task details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "update_task",
            "task_name": "tasks.clickup.update_task",
            "description": "Update an existing task in ClickUp",
            "label": "Update Task",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "update_task_status",
                "update_task_assignees",
                "update_task_priority",
                "update_task_name",
                "update_task_description",
                "update_task_due_date",
                "update_task_start_date",
                "update_task_tags",
                "update_parent_id",
                "update_time_estimate",
                "update_markdown_content",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id", "task_id"],
        },
        "read_task**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to read tasks from",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to read",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
            ],
            "outputs": [
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {
                    "field": "task_name",
                    "type": "string",
                    "helper_text": "Name of the task",
                },
                {
                    "field": "task_url",
                    "type": "string",
                    "helper_text": "URL of the task",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Description of the task",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the task",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp of the task",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Last update timestamp of the task",
                },
                {
                    "field": "assignees",
                    "type": "vec<string>",
                    "helper_text": "List of assignees for the task",
                },
                {
                    "field": "tags",
                    "type": "vec<string>",
                    "helper_text": "List of tags for the task",
                },
                {
                    "field": "priority",
                    "type": "string",
                    "helper_text": "Priority of the task",
                },
                {
                    "field": "due_date",
                    "type": "timestamp",
                    "helper_text": "Due date of the task",
                },
                {
                    "field": "start_date",
                    "type": "timestamp",
                    "helper_text": "Start date of the task",
                },
                {
                    "field": "task_details",
                    "type": "string",
                    "helper_text": "Task details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "read_task",
            "task_name": "tasks.clickup.read_task",
            "description": "Read details of an existing task in ClickUp",
            "label": "Read Task",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id", "task_id"],
        },
        "delete_task**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to delete tasks from",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to delete",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the deleted task",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_task",
            "task_name": "tasks.clickup.delete_task",
            "description": "Delete an existing task in ClickUp",
            "label": "Delete Task",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id", "task_id"],
        },
        "get_tasks**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "The ID of the list to get tasks from",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "archived",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Include archived tasks",
                    "label": "Include Archived",
                },
                {
                    "field": "include_markdown_description",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Include markdown description",
                    "label": "Include Markdown Description",
                },
                {
                    "field": "include_closed",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Include closed tasks",
                    "label": "Include Closed",
                },
                {
                    "field": "subtasks",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Include subtasks",
                    "label": "Include Subtasks",
                },
                {
                    "field": "reverse",
                    "type": "bool",
                    "value": False,
                    "hidden": True,
                    "helper_text": "Reverse the sort order",
                    "label": "Reverse Sort",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "",
                    "helper_text": "Sort tasks by field (created, updated, due_date, etc.)",
                    "label": "Order By",
                    "placeholder": "created",
                },
                {
                    "field": "statuses",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "helper_text": "Filter by specific task statuses",
                    "label": "Status",
                    "placeholder": "to do",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=status&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "assignees",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "helper_text": "Filter by assignee",
                    "label": "Assignees",
                    "placeholder": "User IDs",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by tag names",
                    "label": "Tags",
                    "placeholder": "Enter tag names",
                },
                {
                    "field": "due_date_gt",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Tasks due after this date (YYYY-MM-DD)",
                    "label": "Due Date After",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "due_date_lt",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Tasks due before this date (YYYY-MM-DD)",
                    "label": "Due Date Before",
                    "placeholder": "2024-12-31",
                },
                {
                    "field": "date_updated_gt",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Tasks updated after this date (YYYY-MM-DD)",
                    "label": "Updated After",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "date_updated_lt",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Tasks updated before this date (YYYY-MM-DD)",
                    "label": "Updated Before",
                    "placeholder": "2024-12-31",
                },
                {
                    "field": "custom_fields",
                    "type": "string",
                    "value": "",
                    "helper_text": 'Custom field filters in JSON format: {"field_id": "value"}',
                    "label": "Custom Fields",
                    "placeholder": '{"cf_123": "value"}',
                },
            ],
            "outputs": [
                {
                    "field": "task_ids",
                    "type": "vec<string>",
                    "helper_text": "List of task IDs",
                },
                {
                    "field": "task_names",
                    "type": "vec<string>",
                    "helper_text": "List of task names",
                },
                {
                    "field": "task_urls",
                    "type": "vec<string>",
                    "helper_text": "List of task URLs",
                },
                {
                    "field": "task_statuses",
                    "type": "vec<string>",
                    "helper_text": "List of task statuses",
                },
                {
                    "field": "task_details",
                    "type": "string",
                    "helper_text": "Tasks details in JSON format",
                },
                {
                    "field": "task_assignees",
                    "type": "string",
                    "helper_text": "Task assignees in JSON format",
                },
                {
                    "field": "task_tags",
                    "type": "string",
                    "helper_text": "Task tags in JSON format",
                },
                {
                    "field": "task_priorities",
                    "type": "string",
                    "helper_text": "Task priorities in JSON format",
                },
                {
                    "field": "task_due_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of task due dates",
                },
                {
                    "field": "task_start_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of task start dates",
                },
                {
                    "field": "task_created_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of task creation dates",
                },
                {
                    "field": "task_updated_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of task update dates",
                },
                {
                    "field": "task_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of task descriptions",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "variant": "get_integration_nodes",
            "name": "get_tasks",
            "task_name": "tasks.clickup.get_tasks",
            "description": "Get a list of tasks from ClickUp with advanced filtering options",
            "label": "Get Tasks",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "archived",
                "include_markdown_description",
                "include_closed",
                "subtasks",
                "reverse",
                "order_by",
                "statuses",
                "assignees",
                "tags",
                "due_date_gt",
                "due_date_lt",
                "date_updated_gt",
                "date_updated_lt",
                "custom_fields",
            ],
            "required": ["team_id"],
        },
        "get_tasks**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Tasks",
                    "helper_text": "Specify the number of tasks to fetch",
                }
            ],
            "outputs": [],
        },
        "get_tasks**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_tasks**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_tasks**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "create_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to read tasks from",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to add comment to",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "assign_user",
                    "type": "string",
                    "value": "",
                    "helper_text": "User ID to assign to this comment",
                    "label": "Assign User",
                    "placeholder": "123456",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "comment_text",
                    "type": "string",
                    "value": "",
                    "helper_text": "Content of the comment",
                    "label": "Comment Text",
                    "placeholder": "This is a comment on the task",
                },
                {
                    "field": "notify_all",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Notify all members",
                    "label": "Notify All",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the created comment",
                },
                {
                    "field": "comment_text",
                    "type": "string",
                    "helper_text": "Text of the created comment",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp of the comment",
                },
                {
                    "field": "user",
                    "type": "string",
                    "helper_text": "User who created the comment",
                },
                {
                    "field": "comment_details",
                    "type": "string",
                    "helper_text": "Comment details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_comment",
            "task_name": "tasks.clickup.create_comment",
            "description": "Create a new comment on a ClickUp task",
            "label": "Create Comment",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "assign_user",
                "comment_text",
                "notify_all",
            ],
            "required": [
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "comment_text",
            ],
        },
        "get_comments**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to read tasks from",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to get comments from",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "comment_ids",
                    "type": "vec<string>",
                    "helper_text": "List of comment IDs",
                },
                {
                    "field": "comment_texts",
                    "type": "vec<string>",
                    "helper_text": "List of comment texts",
                },
                {
                    "field": "comment_users",
                    "type": "string",
                    "helper_text": "List of comment authors in JSON format",
                },
                {
                    "field": "comment_created_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of comment creation dates",
                },
                {
                    "field": "comment_updated_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of comment update dates",
                },
                {
                    "field": "comment_details",
                    "type": "string",
                    "helper_text": "Comments details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_comments",
            "task_name": "tasks.clickup.get_comments",
            "description": "Get comments from a ClickUp task",
            "label": "Get Comments",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id", "task_id"],
        },
        "update_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the comment to update",
                    "label": "Comment ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_comment_text",
                    "type": "string",
                    "value": "",
                    "helper_text": "New content for the comment",
                    "label": "Comment Text",
                    "placeholder": "Updated comment text",
                },
            ],
            "outputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the updated comment",
                },
                {
                    "field": "comment_text",
                    "type": "string",
                    "helper_text": "Text of the updated comment",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Update timestamp of the comment",
                },
                {
                    "field": "comment_details",
                    "type": "string",
                    "helper_text": "Comment details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_comment",
            "task_name": "tasks.clickup.update_comment",
            "description": "Update an existing comment on a ClickUp task",
            "label": "Update Comment",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "comment_id",
                "update_comment_text",
            ],
            "required": ["comment_id", "update_comment_text"],
        },
        "delete_comment**(*)**(*)": {
            "inputs": [
                {
                    "field": "comment_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the comment to delete",
                    "label": "Comment ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the comment was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "comment_id",
                    "type": "string",
                    "helper_text": "ID of the deleted comment",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_comment",
            "task_name": "tasks.clickup.delete_comment",
            "description": "Delete an existing comment from a ClickUp task",
            "label": "Delete Comment",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "comment_id"],
            "required": ["comment_id"],
        },
        "create_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder where list will be created",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the list",
                    "label": "List Name",
                    "placeholder": "My New List",
                },
                {
                    "field": "list_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the list",
                    "label": "List Description",
                    "placeholder": "Description for the new list",
                },
            ],
            "outputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "helper_text": "ID of the created list",
                },
                {
                    "field": "list_name",
                    "type": "string",
                    "helper_text": "Name of the created list",
                },
                {
                    "field": "list_details",
                    "type": "string",
                    "helper_text": "List details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_list",
            "task_name": "tasks.clickup.create_list",
            "description": "Create a new list in ClickUp",
            "label": "Create List",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_name",
                "list_content",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_name"],
        },
        "update_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to update",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "update_list_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the list",
                    "label": "List Name",
                    "placeholder": "Updated list name",
                },
                {
                    "field": "update_list_content",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the list",
                    "label": "List Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_list_due_date",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "New due date for the list (timestamp)",
                    "label": "Due Date",
                    "placeholder": "2024-01-01",
                },
                {
                    "field": "update_list_priority",
                    "type": "string",
                    "value": "3",
                    "helper_text": "New priority for the list",
                    "label": "Priority",
                    "placeholder": "Normal",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Urgent", "value": "1"},
                            {"label": "High", "value": "2"},
                            {"label": "Normal", "value": "3"},
                            {"label": "Low", "value": "4"},
                        ],
                    },
                },
                {
                    "field": "update_list_assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "New assignee for the list",
                    "label": "Assignee",
                    "placeholder": "User ID",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=assignee&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "update_list_status",
                    "type": "string",
                    "value": "",
                    "helper_text": "New status for the list",
                    "label": "Status",
                    "placeholder": "active",
                },
            ],
            "outputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "helper_text": "ID of the updated list",
                },
                {
                    "field": "list_name",
                    "type": "string",
                    "helper_text": "Name of the updated list",
                },
                {
                    "field": "list_details",
                    "type": "string",
                    "helper_text": "List details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_list",
            "task_name": "tasks.clickup.update_list",
            "description": "Update an existing list in ClickUp",
            "label": "Update List",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "update_list_name",
                "update_list_content",
                "update_list_due_date",
                "update_list_priority",
                "update_list_assignee",
                "update_list_status",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id"],
        },
        "read_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to read",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {"field": "list_id", "type": "string", "helper_text": "ID of the list"},
                {
                    "field": "list_name",
                    "type": "string",
                    "helper_text": "Name of the list",
                },
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the list",
                },
                {
                    "field": "order_index",
                    "type": "int32",
                    "helper_text": "Order index of the list",
                },
                {
                    "field": "task_count",
                    "type": "string",
                    "helper_text": "Number of tasks in the list",
                },
                {
                    "field": "priority",
                    "type": "string",
                    "helper_text": "Priority of the list",
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "helper_text": "Assignee of the list",
                },
                {
                    "field": "due_date",
                    "type": "timestamp",
                    "helper_text": "Due date of the list",
                },
                {
                    "field": "start_date",
                    "type": "timestamp",
                    "helper_text": "Start date of the list",
                },
                {
                    "field": "folder",
                    "type": "string",
                    "helper_text": "Folder information in JSON format",
                },
                {
                    "field": "space",
                    "type": "string",
                    "helper_text": "Space information in JSON format",
                },
                {
                    "field": "statuses",
                    "type": "string",
                    "helper_text": "List of statuses in JSON format",
                },
                {
                    "field": "list_details",
                    "type": "string",
                    "helper_text": "List details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "read_list",
            "task_name": "tasks.clickup.read_list",
            "description": "Read details of an existing list in ClickUp",
            "label": "Read List",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id"],
        },
        "get_lists**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder to get lists from",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "list_ids",
                    "type": "vec<string>",
                    "helper_text": "List of list IDs",
                },
                {
                    "field": "list_names",
                    "type": "vec<string>",
                    "helper_text": "List of list names",
                },
                {
                    "field": "list_statuses",
                    "type": "vec<string>",
                    "helper_text": "List of list statuses",
                },
                {
                    "field": "list_order_indexes",
                    "type": "vec<int32>",
                    "helper_text": "List of list order indexes",
                },
                {
                    "field": "list_task_counts",
                    "type": "string",
                    "helper_text": "List of task counts in JSON format",
                },
                {
                    "field": "list_priorities",
                    "type": "string",
                    "helper_text": "List of priorities in JSON format",
                },
                {
                    "field": "list_assignees",
                    "type": "string",
                    "helper_text": "List of assignees in JSON format",
                },
                {
                    "field": "list_due_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of due dates",
                },
                {
                    "field": "list_start_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of start dates",
                },
                {
                    "field": "list_folders",
                    "type": "string",
                    "helper_text": "List of folders in JSON format",
                },
                {
                    "field": "list_spaces",
                    "type": "string",
                    "helper_text": "List of spaces in JSON format",
                },
                {
                    "field": "list_status_arrays",
                    "type": "string",
                    "helper_text": "List of status arrays in JSON format",
                },
                {
                    "field": "list_details",
                    "type": "string",
                    "helper_text": "Lists details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_lists",
            "task_name": "tasks.clickup.get_lists",
            "description": "Get a list of lists from ClickUp",
            "label": "Get Lists",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
            ],
            "required": ["team_id", "space_id", "folder_id"],
        },
        "delete_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to delete",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the list was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "helper_text": "ID of the deleted list",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_list",
            "task_name": "tasks.clickup.delete_list",
            "description": "Delete an existing list in ClickUp",
            "label": "Delete List",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id"],
        },
        "get_list_members**(*)**(*)": {
            "inputs": [
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to get members from",
                    "label": "List ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "member_ids",
                    "type": "vec<string>",
                    "helper_text": "List of member user IDs",
                },
                {
                    "field": "member_names",
                    "type": "vec<string>",
                    "helper_text": "List of member usernames",
                },
                {
                    "field": "member_emails",
                    "type": "vec<string>",
                    "helper_text": "List of member emails",
                },
                {
                    "field": "member_details",
                    "type": "string",
                    "helper_text": "Members details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_list_members",
            "task_name": "tasks.clickup.get_list_members",
            "description": "Get members who have access to a ClickUp list",
            "label": "Get List Members",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "list_id"],
            "required": ["list_id"],
        },
        "create_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space where folder will be created",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the folder",
                    "label": "Folder Name",
                    "placeholder": "My New Folder",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the created folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the created folder",
                },
                {
                    "field": "folder_details",
                    "type": "string",
                    "helper_text": "Folder details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_folder",
            "task_name": "tasks.clickup.create_folder",
            "description": "Create a new folder in ClickUp",
            "label": "Create Folder",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_name",
            ],
            "required": ["team_id", "space_id", "folder_name"],
        },
        "update_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder to update",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "update_folder_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the folder",
                    "label": "Folder Name",
                    "placeholder": "Updated folder name",
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the updated folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the updated folder",
                },
                {
                    "field": "folder_details",
                    "type": "string",
                    "helper_text": "Folder details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_folder",
            "task_name": "tasks.clickup.update_folder",
            "description": "Update an existing folder in ClickUp",
            "label": "Update Folder",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "update_folder_name",
            ],
            "required": ["team_id", "space_id", "folder_id", "update_folder_name"],
        },
        "read_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder to read",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the folder",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "Name of the folder",
                },
                {
                    "field": "order_index",
                    "type": "int32",
                    "helper_text": "Order index of the folder",
                },
                {
                    "field": "hidden",
                    "type": "bool",
                    "helper_text": "Whether the folder is hidden",
                },
                {
                    "field": "task_count",
                    "type": "string",
                    "helper_text": "Number of tasks in the folder",
                },
                {
                    "field": "space",
                    "type": "string",
                    "helper_text": "Space information in JSON format",
                },
                {
                    "field": "lists",
                    "type": "string",
                    "helper_text": "Lists in the folder in JSON format",
                },
                {
                    "field": "folder_details",
                    "type": "string",
                    "helper_text": "Folder details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "read_folder",
            "task_name": "tasks.clickup.read_folder",
            "description": "Read details of an existing folder in ClickUp",
            "label": "Read Folder",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
            ],
            "required": ["team_id", "space_id", "folder_id"],
        },
        "get_folders**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space to get folders from",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "folder_ids",
                    "type": "vec<string>",
                    "helper_text": "List of folder IDs",
                },
                {
                    "field": "folder_names",
                    "type": "vec<string>",
                    "helper_text": "List of folder names",
                },
                {
                    "field": "folder_order_indexes",
                    "type": "vec<int32>",
                    "helper_text": "List of folder order indexes",
                },
                {
                    "field": "folder_hidden_states",
                    "type": "vec<bool>",
                    "helper_text": "List of folder hidden states",
                },
                {
                    "field": "folder_task_counts",
                    "type": "string",
                    "helper_text": "List of task counts in JSON format",
                },
                {
                    "field": "folder_spaces",
                    "type": "string",
                    "helper_text": "List of spaces in JSON format",
                },
                {
                    "field": "folder_lists",
                    "type": "string",
                    "helper_text": "List of lists in JSON format",
                },
                {
                    "field": "folder_details",
                    "type": "string",
                    "helper_text": "Folders details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_folders",
            "task_name": "tasks.clickup.get_folders",
            "description": "Get a list of folders from ClickUp",
            "label": "Get Folders",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id", "space_id"],
            "required": ["team_id", "space_id"],
        },
        "delete_folder**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder to delete",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the folder was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "helper_text": "ID of the deleted folder",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_folder",
            "task_name": "tasks.clickup.delete_folder",
            "description": "Delete an existing folder in ClickUp",
            "label": "Delete Folder",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
            ],
            "required": ["team_id", "space_id", "folder_id"],
        },
        "create_space**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team where space will be created",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the space",
                    "label": "Space Name",
                    "placeholder": "My New Space",
                },
                {
                    "field": "space_multiple_assignees",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow multiple assignees",
                    "label": "Multiple Assignees",
                },
                {
                    "field": "enable_time_tracking",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow time tracking",
                    "label": "Time Tracking",
                },
                {
                    "field": "enable_priority",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow priority",
                    "label": "Priority",
                },
                {
                    "field": "enable_tags",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow tags",
                    "label": "Tags",
                },
                {
                    "field": "enable_custom_fields",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow custom fields",
                    "label": "Custom Fields",
                },
                {
                    "field": "enable_incomplete_warnings",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow incomplete warnings",
                    "label": "Incomplete Warnings",
                },
                {
                    "field": "enable_dependency_warnings",
                    "type": "bool",
                    "value": True,
                    "helper_text": "Allow dependency warnings",
                    "label": "Dependency Warnings",
                },
            ],
            "outputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the created space",
                },
                {
                    "field": "space_name",
                    "type": "string",
                    "helper_text": "Name of the created space",
                },
                {
                    "field": "space_details",
                    "type": "string",
                    "helper_text": "Space details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_space",
            "task_name": "tasks.clickup.create_space",
            "description": "Create a new space in ClickUp",
            "label": "Create Space",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_name",
                "space_multiple_assignees",
                "enable_time_tracking",
                "enable_priority",
                "enable_tags",
                "enable_custom_fields",
                "enable_incomplete_warnings",
                "enable_dependency_warnings",
            ],
            "required": ["team_id", "space_name"],
        },
        "read_space**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space to read",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
                {
                    "field": "space_name",
                    "type": "string",
                    "helper_text": "Name of the space",
                },
                {
                    "field": "color",
                    "type": "string",
                    "helper_text": "Color of the space",
                },
                {
                    "field": "access",
                    "type": "bool",
                    "helper_text": "Whether the user has access to the space",
                },
                {
                    "field": "statuses",
                    "type": "string",
                    "helper_text": "Space statuses in JSON format",
                },
                {
                    "field": "features",
                    "type": "string",
                    "helper_text": "Space features in JSON format",
                },
                {
                    "field": "space_details",
                    "type": "string",
                    "helper_text": "Space details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "read_space",
            "task_name": "tasks.clickup.read_space",
            "description": "Read details of an existing space in ClickUp",
            "label": "Read Space",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id", "space_id"],
            "required": ["team_id", "space_id"],
        },
        "delete_space**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space to delete",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the space was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the deleted space",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_space",
            "task_name": "tasks.clickup.delete_space",
            "description": "Delete an existing space in ClickUp",
            "label": "Delete Space",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id", "space_id"],
            "required": ["team_id", "space_id"],
        },
        "create_checklist**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to add checklist to",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to add checklist to",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "checklist_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the checklist",
                    "label": "Checklist Name",
                    "placeholder": "My Checklist",
                },
            ],
            "outputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the created checklist",
                },
                {
                    "field": "checklist_name",
                    "type": "string",
                    "helper_text": "Name of the created checklist",
                },
                {
                    "field": "checklist_details",
                    "type": "string",
                    "helper_text": "Checklist details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_checklist",
            "task_name": "tasks.clickup.create_checklist",
            "description": "Create a new checklist in a ClickUp task",
            "label": "Create Checklist",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "checklist_name",
            ],
            "required": [
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "checklist_name",
            ],
        },
        "delete_checklist**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist to delete",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the checklist was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the deleted checklist",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_checklist",
            "task_name": "tasks.clickup.delete_checklist",
            "description": "Delete an existing checklist in ClickUp",
            "label": "Delete Checklist",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "checklist_id"],
            "required": ["checklist_id"],
        },
        "update_checklist**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist to update",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_checklist_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the checklist",
                    "label": "Checklist Name",
                    "placeholder": "Updated checklist name",
                },
                {
                    "field": "update_checklist_position",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "New position for the checklist",
                    "label": "Position",
                    "placeholder": "0",
                },
            ],
            "outputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the updated checklist",
                },
                {
                    "field": "checklist_name",
                    "type": "string",
                    "helper_text": "Name of the updated checklist",
                },
                {
                    "field": "checklist_details",
                    "type": "string",
                    "helper_text": "Checklist details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_checklist",
            "task_name": "tasks.clickup.update_checklist",
            "description": "Update an existing checklist in ClickUp",
            "label": "Update Checklist",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "checklist_id",
                "update_checklist_name",
                "update_checklist_position",
            ],
            "required": ["checklist_id"],
        },
        "create_checklist_item**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist to add item to",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "checklist_item_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the checklist item",
                    "label": "Item Name",
                    "placeholder": "Checklist item name",
                },
                {
                    "field": "checklist_item_assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "User ID to assign to this checklist item",
                    "label": "Assignee",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the checklist",
                },
                {
                    "field": "checklist_details",
                    "type": "string",
                    "helper_text": "Checklist details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_checklist_item",
            "task_name": "tasks.clickup.create_checklist_item",
            "description": "Create a new item in a ClickUp checklist",
            "label": "Create Checklist Item",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "checklist_id",
                "checklist_item_name",
                "checklist_item_assignee",
            ],
            "required": ["checklist_id", "checklist_item_name"],
        },
        "delete_checklist_item**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "checklist_item_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist item to delete",
                    "label": "Checklist Item ID",
                    "placeholder": "item123",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the checklist item was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the checklist",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_checklist_item",
            "task_name": "tasks.clickup.delete_checklist_item",
            "description": "Delete an existing item from a ClickUp checklist",
            "label": "Delete Checklist Item",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "checklist_id",
                "checklist_item_id",
            ],
            "required": ["checklist_id", "checklist_item_id"],
        },
        "update_checklist_item**(*)**(*)": {
            "inputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist",
                    "label": "Checklist ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "checklist_item_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the checklist item to update",
                    "label": "Checklist Item ID",
                    "placeholder": "item123",
                },
                {
                    "field": "update_checklist_item_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the checklist item",
                    "label": "Item Name",
                    "placeholder": "Updated item name",
                },
                {
                    "field": "update_checklist_item_parent",
                    "type": "string",
                    "value": "",
                    "helper_text": "New parent for the checklist item",
                    "label": "Parent",
                    "placeholder": "parent123",
                },
                {
                    "field": "update_checklist_item_assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "New assignee for the checklist item",
                    "label": "Assignee",
                    "placeholder": "123456",
                },
                {
                    "field": "update_checklist_item_resolved",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark checklist item as resolved",
                    "label": "Resolved",
                },
            ],
            "outputs": [
                {
                    "field": "checklist_id",
                    "type": "string",
                    "helper_text": "ID of the checklist",
                },
                {
                    "field": "checklist_name",
                    "type": "string",
                    "helper_text": "Name of the checklist",
                },
                {
                    "field": "checklist_details",
                    "type": "string",
                    "helper_text": "Checklist details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_checklist_item",
            "task_name": "tasks.clickup.update_checklist_item",
            "description": "Update an existing item in a ClickUp checklist",
            "label": "Update Checklist Item",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "checklist_id",
                "checklist_item_id",
                "update_checklist_item_name",
                "update_checklist_item_parent",
                "update_checklist_item_assignee",
                "update_checklist_item_resolved",
            ],
            "required": ["checklist_id", "checklist_item_id"],
        },
        "create_goal**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "goal_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the goal",
                    "label": "Goal Name",
                    "placeholder": "Complete project by Q4",
                },
                {
                    "field": "goal_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the goal",
                    "label": "Goal Description",
                    "placeholder": "Complete the entire project with all deliverables",
                },
                {
                    "field": "goal_due_date",
                    "type": "string",
                    "value": "",
                    "helper_text": "Due date for the goal (YYYY-MM-DD or RFC3339)",
                    "label": "Due Date",
                    "placeholder": "2024-12-31",
                },
                {
                    "field": "goal_color",
                    "type": "string",
                    "value": "",
                    "helper_text": "Color for the goal",
                    "label": "Color",
                    "placeholder": "#ff0000",
                },
                {
                    "field": "goal_multiple_owners",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Allow multiple owners",
                    "label": "Multiple Owners",
                },
                {
                    "field": "goal_owners",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of owner user IDs",
                    "label": "Owners",
                    "placeholder": "123456,789012",
                },
            ],
            "outputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "helper_text": "ID of the created goal",
                },
                {
                    "field": "goal_name",
                    "type": "string",
                    "helper_text": "Name of the created goal",
                },
                {
                    "field": "goal_details",
                    "type": "string",
                    "helper_text": "Goal details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_goal",
            "task_name": "tasks.clickup.create_goal",
            "description": "Create a new goal in ClickUp",
            "label": "Create Goal",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "goal_name",
                "goal_description",
                "goal_due_date",
                "goal_color",
                "goal_multiple_owners",
                "goal_owners",
            ],
            "required": ["team_id", "goal_name"],
        },
        "delete_goal**(*)**(*)": {
            "inputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the goal to delete",
                    "label": "Goal ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the goal was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "goal_id",
                    "type": "string",
                    "helper_text": "ID of the deleted goal",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_goal",
            "task_name": "tasks.clickup.delete_goal",
            "description": "Delete an existing goal in ClickUp",
            "label": "Delete Goal",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "goal_id"],
            "required": ["goal_id"],
        },
        "read_goal**(*)**(*)": {
            "inputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the goal to read",
                    "label": "Goal ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {"field": "goal_id", "type": "string", "helper_text": "ID of the goal"},
                {
                    "field": "goal_name",
                    "type": "string",
                    "helper_text": "Name of the goal",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Description of the goal",
                },
                {"field": "team_id", "type": "string", "helper_text": "ID of the team"},
                {
                    "field": "color",
                    "type": "string",
                    "helper_text": "Color of the goal",
                },
                {
                    "field": "pretty_id",
                    "type": "string",
                    "helper_text": "Pretty ID of the goal",
                },
                {
                    "field": "pretty_url",
                    "type": "string",
                    "helper_text": "Pretty URL of the goal",
                },
                {
                    "field": "multiple_owners",
                    "type": "bool",
                    "helper_text": "Whether the goal has multiple owners",
                },
                {
                    "field": "folder_access",
                    "type": "bool",
                    "helper_text": "Whether the goal has folder access",
                },
                {
                    "field": "percent_completed",
                    "type": "int32",
                    "helper_text": "Percentage of goal completion",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp of the goal",
                },
                {
                    "field": "updated_at",
                    "type": "timestamp",
                    "helper_text": "Update timestamp of the goal",
                },
                {
                    "field": "due_date",
                    "type": "timestamp",
                    "helper_text": "Due date of the goal",
                },
                {
                    "field": "owners",
                    "type": "string",
                    "helper_text": "Goal owners in JSON format",
                },
                {
                    "field": "key_results",
                    "type": "string",
                    "helper_text": "Key results in JSON format",
                },
                {
                    "field": "history",
                    "type": "string",
                    "helper_text": "Goal history in JSON format",
                },
                {
                    "field": "goal_details",
                    "type": "string",
                    "helper_text": "Goal details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "read_goal",
            "task_name": "tasks.clickup.read_goal",
            "description": "Read details of an existing goal in ClickUp",
            "label": "Read Goal",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "goal_id"],
            "required": ["goal_id"],
        },
        "get_goals**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "include_completed",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include completed goals",
                    "label": "Include Completed",
                },
            ],
            "outputs": [
                {
                    "field": "goal_ids",
                    "type": "vec<string>",
                    "helper_text": "List of goal IDs",
                },
                {
                    "field": "goal_names",
                    "type": "vec<string>",
                    "helper_text": "List of goal names",
                },
                {
                    "field": "goal_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of goal descriptions",
                },
                {
                    "field": "goal_team_ids",
                    "type": "vec<string>",
                    "helper_text": "List of team IDs",
                },
                {
                    "field": "goal_colors",
                    "type": "vec<string>",
                    "helper_text": "List of goal colors",
                },
                {
                    "field": "goal_pretty_ids",
                    "type": "vec<string>",
                    "helper_text": "List of goal pretty IDs",
                },
                {
                    "field": "goal_pretty_urls",
                    "type": "vec<string>",
                    "helper_text": "List of goal pretty URLs",
                },
                {
                    "field": "goal_multiple_owners",
                    "type": "vec<bool>",
                    "helper_text": "List of multiple owners flags",
                },
                {
                    "field": "goal_folder_access",
                    "type": "vec<bool>",
                    "helper_text": "List of folder access flags",
                },
                {
                    "field": "goal_percent_completed",
                    "type": "vec<int32>",
                    "helper_text": "List of goal completion percentages",
                },
                {
                    "field": "goal_created_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of goal creation dates",
                },
                {
                    "field": "goal_updated_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of goal update dates",
                },
                {
                    "field": "goal_due_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of goal due dates",
                },
                {
                    "field": "goal_owners",
                    "type": "string",
                    "helper_text": "List of goal owners in JSON format",
                },
                {
                    "field": "goal_key_results",
                    "type": "string",
                    "helper_text": "List of key results in JSON format",
                },
                {
                    "field": "goal_details",
                    "type": "string",
                    "helper_text": "Goals details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_goals",
            "task_name": "tasks.clickup.get_goals",
            "description": "Get a list of goals from ClickUp",
            "label": "Get Goals",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "include_completed",
            ],
            "required": ["team_id"],
        },
        "update_goal**(*)**(*)": {
            "inputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the goal to update",
                    "label": "Goal ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_goal_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the goal",
                    "label": "Goal Name",
                    "placeholder": "Updated goal name",
                },
                {
                    "field": "update_goal_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the goal",
                    "label": "Goal Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_goal_due_date",
                    "type": "string",
                    "value": "",
                    "helper_text": "New due date for the goal (YYYY-MM-DD or RFC3339)",
                    "label": "Due Date",
                    "placeholder": "2024-12-31",
                },
                {
                    "field": "update_goal_color",
                    "type": "string",
                    "value": "",
                    "helper_text": "New color for the goal",
                    "label": "Color",
                    "placeholder": "#ff0000",
                },
                {
                    "field": "update_goal_add_owners",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of owner user IDs to add",
                    "label": "Add Owners",
                    "placeholder": "123456,789012",
                },
                {
                    "field": "update_goal_remove_owners",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of owner user IDs to remove",
                    "label": "Remove Owners",
                    "placeholder": "123456,789012",
                },
            ],
            "outputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "helper_text": "ID of the updated goal",
                },
                {
                    "field": "goal_name",
                    "type": "string",
                    "helper_text": "Name of the updated goal",
                },
                {
                    "field": "goal_details",
                    "type": "string",
                    "helper_text": "Goal details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_goal",
            "task_name": "tasks.clickup.update_goal",
            "description": "Update an existing goal in ClickUp",
            "label": "Update Goal",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "goal_id",
                "update_goal_name",
                "update_goal_description",
                "update_goal_due_date",
                "update_goal_color",
                "update_goal_add_owners",
                "update_goal_remove_owners",
            ],
            "required": ["goal_id"],
        },
        "create_goal_key_result**(*)**(*)": {
            "inputs": [
                {
                    "field": "goal_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the goal to add key result to",
                    "label": "Goal ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "key_result_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the key result",
                    "label": "Key Result Name",
                    "placeholder": "Increase revenue by 20%",
                },
                {
                    "field": "key_result_type",
                    "type": "string",
                    "value": "",
                    "helper_text": "Type of key result",
                    "label": "Type",
                    "placeholder": "percentage",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Number", "value": "number"},
                            {"label": "Currency", "value": "currency"},
                            {"label": "Boolean", "value": "boolean"},
                            {"label": "Percentage", "value": "percentage"},
                            {"label": "Automatic", "value": "automatic"},
                        ],
                    },
                },
                {
                    "field": "key_result_unit",
                    "type": "string",
                    "value": "",
                    "helper_text": "Unit for the key result",
                    "label": "Unit",
                    "placeholder": "%",
                },
                {
                    "field": "key_result_steps_start",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Starting value for the key result",
                    "label": "Start Value",
                    "placeholder": "0",
                },
                {
                    "field": "key_result_steps_end",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Target value for the key result",
                    "label": "Target Value",
                    "placeholder": "10",
                },
                {
                    "field": "key_result_task_ids",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of task IDs",
                    "label": "Task IDs",
                    "placeholder": "task1,task2",
                },
                {
                    "field": "key_result_list_ids",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of list IDs",
                    "label": "List IDs",
                    "placeholder": "list1,list2",
                },
                {
                    "field": "key_result_owners",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of owner user IDs",
                    "label": "Owners",
                    "placeholder": "123456,789012",
                },
            ],
            "outputs": [
                {
                    "field": "key_result_id",
                    "type": "string",
                    "helper_text": "ID of the created key result",
                },
                {
                    "field": "key_result_name",
                    "type": "string",
                    "helper_text": "Name of the created key result",
                },
                {
                    "field": "key_result_details",
                    "type": "string",
                    "helper_text": "Key result details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_goal_key_result",
            "task_name": "tasks.clickup.create_goal_key_result",
            "description": "Create a new key result for a goal in ClickUp",
            "label": "Create Goal Key Result",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "goal_id",
                "key_result_name",
                "key_result_type",
                "key_result_unit",
                "key_result_steps_start",
                "key_result_steps_end",
                "key_result_task_ids",
                "key_result_list_ids",
                "key_result_owners",
            ],
            "required": ["goal_id", "key_result_name"],
        },
        "delete_goal_key_result**(*)**(*)": {
            "inputs": [
                {
                    "field": "key_result_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the key result to delete",
                    "label": "Key Result ID",
                    "placeholder": "abc123def456",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the key result was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "key_result_id",
                    "type": "string",
                    "helper_text": "ID of the deleted key result",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_goal_key_result",
            "task_name": "tasks.clickup.delete_goal_key_result",
            "description": "Delete an existing key result in ClickUp",
            "label": "Delete Goal Key Result",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "key_result_id"],
            "required": ["key_result_id"],
        },
        "update_goal_key_result**(*)**(*)": {
            "inputs": [
                {
                    "field": "key_result_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the key result to update",
                    "label": "Key Result ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_key_result_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the key result",
                    "label": "Key Result Name",
                    "placeholder": "Updated key result name",
                },
                {
                    "field": "update_key_result_note",
                    "type": "string",
                    "value": "",
                    "helper_text": "New note for the key result",
                    "label": "Note",
                    "placeholder": "Updated note",
                },
                {
                    "field": "update_key_result_steps_current",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "Current progress value",
                    "label": "Current Value",
                    "placeholder": "50",
                },
                {
                    "field": "update_key_result_steps_start",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "New starting value",
                    "label": "Start Value",
                    "placeholder": "0",
                },
                {
                    "field": "update_key_result_steps_end",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "New target value",
                    "label": "Target Value",
                    "placeholder": "10",
                },
                {
                    "field": "update_key_result_unit",
                    "type": "string",
                    "value": "",
                    "helper_text": "New unit for the key result",
                    "label": "Unit",
                    "placeholder": "%",
                },
            ],
            "outputs": [
                {
                    "field": "key_result_id",
                    "type": "string",
                    "helper_text": "ID of the updated key result",
                },
                {
                    "field": "key_result_name",
                    "type": "string",
                    "helper_text": "Name of the updated key result",
                },
                {
                    "field": "key_result_details",
                    "type": "string",
                    "helper_text": "Key result details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_goal_key_result",
            "task_name": "tasks.clickup.update_goal_key_result",
            "description": "Update an existing key result in ClickUp",
            "label": "Update Goal Key Result",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "key_result_id",
                "update_key_result_name",
                "update_key_result_note",
                "update_key_result_steps_current",
                "update_key_result_steps_start",
                "update_key_result_steps_end",
                "update_key_result_unit",
            ],
            "required": ["key_result_id"],
        },
        "create_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "start_time",
                    "type": "string",
                    "value": "",
                    "helper_text": "Start time for the time entry (RFC3339 format)",
                    "label": "Start Time",
                    "placeholder": "2024-01-01T09:00:00Z",
                },
                {
                    "field": "duration_minutes",
                    "type": "int32",
                    "value": 60,
                    "helper_text": "Duration in minutes",
                    "label": "Duration (minutes)",
                    "placeholder": "60",
                },
                {
                    "field": "time_entry_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the time entry",
                    "label": "Description",
                    "placeholder": "Working on feature implementation",
                },
                {
                    "field": "time_entry_billable",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark time entry as billable",
                    "label": "Billable",
                },
                {
                    "field": "time_entry_assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "Assignee user ID for the time entry",
                    "label": "Assignee",
                    "placeholder": "123456",
                },
                {
                    "field": "time_entry_tags",
                    "type": "string",
                    "value": "",
                    "helper_text": "Comma-separated list of tags or JSON objects",
                    "label": "Tags",
                    "placeholder": "development,feature",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the created time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_time_entry",
            "task_name": "tasks.clickup.create_time_entry",
            "description": "Create a new time entry in ClickUp",
            "label": "Create Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "start_time",
                "duration_minutes",
                "time_entry_description",
                "time_entry_billable",
                "time_entry_assignee",
                "time_entry_tags",
            ],
            "required": [
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "start_time",
                "duration_minutes",
            ],
        },
        "delete_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the time entry to delete",
                    "label": "Time Entry ID",
                    "placeholder": "abc123def456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the time entry was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the deleted time entry",
                },
                {
                    "field": "response_data",
                    "type": "string",
                    "helper_text": "Response data from the API",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_time_entry",
            "task_name": "tasks.clickup.delete_time_entry",
            "description": "Delete an existing time entry in ClickUp",
            "label": "Delete Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id", "time_entry_id"],
            "required": ["team_id", "time_entry_id"],
        },
        "read_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the time entry to get (leave empty if getting running time entry)",
                    "label": "Time Entry ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "get_running",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Get currently running time entry",
                    "label": "Get Running Time Entry",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the time entry",
                },
                {
                    "field": "task",
                    "type": "string",
                    "helper_text": "Task information in JSON format",
                },
                {
                    "field": "user",
                    "type": "string",
                    "helper_text": "User information in JSON format",
                },
                {
                    "field": "billable",
                    "type": "bool",
                    "helper_text": "Whether the time entry is billable",
                },
                {
                    "field": "start",
                    "type": "timestamp",
                    "helper_text": "Start time of the time entry",
                },
                {
                    "field": "end",
                    "type": "timestamp",
                    "helper_text": "End time of the time entry",
                },
                {
                    "field": "duration",
                    "type": "string",
                    "helper_text": "Duration of the time entry",
                },
                {
                    "field": "description",
                    "type": "string",
                    "helper_text": "Description of the time entry",
                },
                {
                    "field": "tags",
                    "type": "string",
                    "helper_text": "Tags in JSON format",
                },
                {
                    "field": "source",
                    "type": "string",
                    "helper_text": "Source of the time entry",
                },
                {
                    "field": "created_at",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp of the time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "read_time_entry",
            "task_name": "tasks.clickup.read_time_entry",
            "description": "Read details of a time entry in ClickUp",
            "label": "Read Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "time_entry_id",
                "get_running",
            ],
            "required": ["team_id", "time_entry_id"],
        },
        "get_time_entries**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "assignee",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by assignee user ID",
                    "label": "Assignee",
                    "placeholder": "123456",
                },
                {
                    "field": "include_location_names",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include location names",
                    "label": "Include Location Names",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by space ID",
                    "label": "Space ID",
                    "placeholder": "space123",
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by folder ID",
                    "label": "Folder ID",
                    "placeholder": "folder123",
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by list ID",
                    "label": "List ID",
                    "placeholder": "list123",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter by task ID",
                    "label": "Task ID",
                    "placeholder": "task123",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_ids",
                    "type": "vec<string>",
                    "helper_text": "List of time entry IDs",
                },
                {
                    "field": "time_entry_tasks",
                    "type": "string",
                    "helper_text": "List of tasks in JSON format",
                },
                {
                    "field": "time_entry_users",
                    "type": "string",
                    "helper_text": "List of users in JSON format",
                },
                {
                    "field": "time_entry_billables",
                    "type": "vec<bool>",
                    "helper_text": "List of billable flags",
                },
                {
                    "field": "time_entry_starts",
                    "type": "vec<timestamp>",
                    "helper_text": "List of start times",
                },
                {
                    "field": "time_entry_ends",
                    "type": "vec<timestamp>",
                    "helper_text": "List of end times",
                },
                {
                    "field": "time_entry_durations",
                    "type": "vec<string>",
                    "helper_text": "List of durations",
                },
                {
                    "field": "time_entry_descriptions",
                    "type": "vec<string>",
                    "helper_text": "List of descriptions",
                },
                {
                    "field": "time_entry_tags",
                    "type": "string",
                    "helper_text": "List of tags in JSON format",
                },
                {
                    "field": "time_entry_sources",
                    "type": "vec<string>",
                    "helper_text": "List of sources",
                },
                {
                    "field": "time_entry_created_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of creation dates",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entries details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_time_entries",
            "task_name": "tasks.clickup.get_time_entries",
            "description": "Get a list of time entries from ClickUp",
            "label": "Get Time Entries",
            "variant": "get_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "assignee",
                "include_location_names",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
            ],
            "required": ["team_id", "num_messages"],
        },
        "get_time_entries**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Time Entries",
                    "helper_text": "Specify the number of time entries to fetch",
                }
            ],
            "outputs": [],
        },
        "get_time_entries**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_time_entries**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_time_entries**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "start_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "time_entry_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "Description of the time entry",
                    "label": "Description",
                    "placeholder": "Working on feature implementation",
                },
                {
                    "field": "time_entry_billable",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark time entry as billable",
                    "label": "Billable",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the started time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "start_time_entry",
            "task_name": "tasks.clickup.start_time_entry",
            "description": "Start a new time entry in ClickUp",
            "label": "Start Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "time_entry_description",
                "time_entry_billable",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id", "task_id"],
        },
        "stop_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the stopped time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "stop_time_entry",
            "task_name": "tasks.clickup.stop_time_entry",
            "description": "Stop the currently running time entry in ClickUp",
            "label": "Stop Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id"],
            "required": ["team_id"],
        },
        "update_time_entry**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the time entry to update",
                    "label": "Time Entry ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "update_time_entry_description",
                    "type": "string",
                    "value": "",
                    "helper_text": "New description for the time entry",
                    "label": "Description",
                    "placeholder": "Updated description",
                },
                {
                    "field": "update_time_entry_billable",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Mark time entry as billable",
                    "label": "Billable",
                },
                {
                    "field": "update_time_entry_start",
                    "type": "string",
                    "value": "",
                    "helper_text": "New start time (RFC3339 format)",
                    "label": "Start Time",
                    "placeholder": "2024-01-01T09:00:00Z",
                },
                {
                    "field": "update_time_entry_duration_minutes",
                    "type": "int32",
                    "value": 60,
                    "helper_text": "New duration in minutes",
                    "label": "Duration (minutes)",
                    "placeholder": "60",
                },
                {
                    "field": "update_time_entry_task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "New task ID for the time entry",
                    "label": "Task ID",
                    "placeholder": "task123",
                },
            ],
            "outputs": [
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the updated time entry",
                },
                {
                    "field": "time_entry_details",
                    "type": "string",
                    "helper_text": "Time entry details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_time_entry",
            "task_name": "tasks.clickup.update_time_entry",
            "description": "Update an existing time entry in ClickUp",
            "label": "Update Time Entry",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "time_entry_id",
                "update_time_entry_description",
                "update_time_entry_billable",
                "update_time_entry_start",
                "update_time_entry_duration_minutes",
                "update_time_entry_task_id",
            ],
            "required": ["team_id", "time_entry_id"],
        },
        "create_space_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag",
                    "label": "Tag Name",
                    "placeholder": "urgent",
                },
                {
                    "field": "tag_foreground_color",
                    "type": "string",
                    "value": "#000000",
                    "helper_text": "Foreground color for the tag",
                    "label": "Foreground Color",
                    "placeholder": "#000000",
                },
                {
                    "field": "tag_background_color",
                    "type": "string",
                    "value": "#ffffff",
                    "helper_text": "Background color for the tag",
                    "label": "Background Color",
                    "placeholder": "#ffffff",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully created",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the created tag",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_space_tag",
            "task_name": "tasks.clickup.create_space_tag",
            "description": "Create a new tag in a ClickUp space",
            "label": "Create Space Tag",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "tag_name",
                "tag_foreground_color",
                "tag_background_color",
            ],
            "required": ["team_id", "space_id", "tag_name"],
        },
        "delete_space_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag to delete",
                    "label": "Tag Name",
                    "placeholder": "urgent",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the deleted tag",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_space_tag",
            "task_name": "tasks.clickup.delete_space_tag",
            "description": "Delete an existing tag from a ClickUp space",
            "label": "Delete Space Tag",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "tag_name",
            ],
            "required": ["team_id", "space_id", "tag_name"],
        },
        "get_space_tags**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 10,
                    "helper_text": "Maximum number of tags to fetch",
                    "label": "Max Results",
                    "placeholder": "10",
                },
            ],
            "outputs": [
                {
                    "field": "tag_names",
                    "type": "vec<string>",
                    "helper_text": "List of tag names",
                },
                {
                    "field": "tag_foregrounds",
                    "type": "vec<string>",
                    "helper_text": "List of tag foreground colors",
                },
                {
                    "field": "tag_backgrounds",
                    "type": "vec<string>",
                    "helper_text": "List of tag background colors",
                },
                {
                    "field": "tag_creators",
                    "type": "vec<int32>",
                    "helper_text": "List of tag creator IDs",
                },
                {
                    "field": "tag_details",
                    "type": "string",
                    "helper_text": "Tags details in JSON format",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_space_tags",
            "task_name": "tasks.clickup.get_space_tags",
            "description": "Get a list of tags from a ClickUp space",
            "label": "Get Space Tags",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "limit",
            ],
            "required": ["team_id", "space_id", "limit"],
        },
        "update_space_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Current name of the tag to update",
                    "label": "Current Tag Name",
                    "placeholder": "urgent",
                },
                {
                    "field": "new_tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "New name for the tag",
                    "label": "New Tag Name",
                    "placeholder": "high-priority",
                },
                {
                    "field": "tag_foreground_color",
                    "type": "string",
                    "value": "#000000",
                    "helper_text": "New foreground color for the tag",
                    "label": "Foreground Color",
                    "placeholder": "#000000",
                },
                {
                    "field": "tag_background_color",
                    "type": "string",
                    "value": "#ffffff",
                    "helper_text": "New background color for the tag",
                    "label": "Background Color",
                    "placeholder": "#ffffff",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully updated",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "old_tag_name",
                    "type": "string",
                    "helper_text": "Previous name of the tag",
                },
                {
                    "field": "new_tag_name",
                    "type": "string",
                    "helper_text": "New name of the tag",
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "update_space_tag",
            "task_name": "tasks.clickup.update_space_tag",
            "description": "Update an existing tag in a ClickUp space",
            "label": "Update Space Tag",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "tag_name",
                "new_tag_name",
                "tag_foreground_color",
                "tag_background_color",
            ],
            "required": ["team_id", "space_id", "tag_name"],
        },
        "add_task_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag to add",
                    "label": "Tag Name",
                    "placeholder": "urgent",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully added",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the added tag",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "add_task_tag",
            "task_name": "tasks.clickup.add_task_tag",
            "description": "Add a tag to a ClickUp task",
            "label": "Add Task Tag",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "tag_name",
            ],
            "required": [
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "tag_name",
            ],
        },
        "remove_task_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag to remove",
                    "label": "Tag Name",
                    "placeholder": "urgent",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully removed",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the removed tag",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "remove_task_tag",
            "task_name": "tasks.clickup.remove_task_tag",
            "description": "Remove a tag from a ClickUp task",
            "label": "Remove Task Tag",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "tag_name",
            ],
            "required": [
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "tag_name",
            ],
        },
        "create_task_dependency**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task that depends on another",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "depends_on_task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task that this task depends on",
                    "label": "Depends On Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 8,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the dependency was successfully created",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the dependent task",
                },
                {
                    "field": "depends_on_task_id",
                    "type": "string",
                    "helper_text": "ID of the task this depends on",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "create_task_dependency",
            "task_name": "tasks.clickup.create_task_dependency",
            "description": "Create a dependency between two ClickUp tasks",
            "label": "Create Task Dependency",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "depends_on_task_id",
            ],
            "required": [
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "depends_on_task_id",
            ],
        },
        "delete_task_dependency**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task that depends on another",
                    "label": "Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 7,
                },
                {
                    "field": "depends_on_task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task that this task depends on",
                    "label": "Depends On Task",
                    "placeholder": "Select task",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=task_name&list={inputs.list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 8,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the dependency was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the dependent task",
                },
                {
                    "field": "depends_on_task_id",
                    "type": "string",
                    "helper_text": "ID of the task this depends on",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "delete_task_dependency",
            "task_name": "tasks.clickup.delete_task_dependency",
            "description": "Delete a dependency between two ClickUp tasks",
            "label": "Delete Task Dependency",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "depends_on_task_id",
            ],
            "required": [
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
                "task_id",
                "depends_on_task_id",
            ],
        },
        "add_task_to_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to add",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to add the task to",
                    "label": "List ID",
                    "placeholder": "123456789",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was successfully added to the list",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {"field": "list_id", "type": "string", "helper_text": "ID of the list"},
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "add_task_to_list",
            "task_name": "tasks.clickup.add_task_to_list",
            "description": "Add a task to an additional ClickUp list",
            "label": "Add Task to List",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_id", "list_id"],
            "required": ["task_id", "list_id"],
        },
        "remove_task_from_list**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to remove",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to remove the task from",
                    "label": "List ID",
                    "placeholder": "123456789",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was successfully removed from the list",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {"field": "list_id", "type": "string", "helper_text": "ID of the list"},
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "remove_task_from_list",
            "task_name": "tasks.clickup.remove_task_from_list",
            "description": "Remove a task from a ClickUp list",
            "label": "Remove Task from List",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_id", "list_id"],
            "required": ["task_id", "list_id"],
        },
        "get_custom_fields**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_name&team={inputs.team_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the folder",
                    "label": "Folder",
                    "placeholder": "Select folder",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=folder_name&space={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the list to get custom fields from",
                    "label": "List",
                    "placeholder": "Select list",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=list_name&folder={inputs.folder_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "custom_field_ids",
                    "type": "vec<string>",
                    "helper_text": "List of custom field IDs",
                },
                {
                    "field": "custom_field_names",
                    "type": "vec<string>",
                    "helper_text": "List of custom field names",
                },
                {
                    "field": "custom_field_types",
                    "type": "vec<string>",
                    "helper_text": "List of custom field types",
                },
                {
                    "field": "custom_fields_details",
                    "type": "string",
                    "helper_text": "Custom fields details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_custom_fields",
            "task_name": "tasks.clickup.get_custom_fields",
            "description": "Get custom fields available in a ClickUp list",
            "label": "Get Custom Fields",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "space_id",
                "folder_id",
                "list_id",
            ],
            "required": ["team_id", "space_id", "folder_id", "list_id"],
        },
        "set_custom_field**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "custom_field_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the custom field",
                    "label": "Custom Field ID",
                    "placeholder": "field123",
                },
                {
                    "field": "custom_field_value",
                    "type": "string",
                    "value": "",
                    "helper_text": "The value to set for the custom field",
                    "label": "Custom Field Value",
                    "placeholder": "New value",
                },
                {
                    "field": "custom_task_ids",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Use custom task IDs",
                    "label": "Custom Task IDs",
                },
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team (required if using custom task IDs)",
                    "label": "Team ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the custom field was successfully set",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {"field": "task_id", "type": "string", "helper_text": "ID of the task"},
                {
                    "field": "custom_field_id",
                    "type": "string",
                    "helper_text": "ID of the custom field",
                },
                {
                    "field": "custom_field_value",
                    "type": "string",
                    "helper_text": "New value of the custom field",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "set_custom_field",
            "task_name": "tasks.clickup.set_custom_field",
            "description": "Set a custom field value on a ClickUp task",
            "label": "Set Custom Field",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_id",
                "custom_field_id",
                "custom_field_value",
                "custom_task_ids",
                "team_id",
            ],
            "required": ["task_id", "custom_field_id", "custom_field_value"],
        },
        "get_task_members**(*)**(*)": {
            "inputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the task to get members from",
                    "label": "Task ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "custom_task_ids",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Use custom task IDs",
                    "label": "Custom Task IDs",
                },
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team (required if using custom task IDs)",
                    "label": "Team ID",
                    "placeholder": "123456",
                },
            ],
            "outputs": [
                {
                    "field": "member_ids",
                    "type": "vec<string>",
                    "helper_text": "List of member user IDs",
                },
                {
                    "field": "member_names",
                    "type": "vec<string>",
                    "helper_text": "List of member usernames",
                },
                {
                    "field": "member_roles",
                    "type": "vec<string>",
                    "helper_text": "List of member roles",
                },
                {
                    "field": "members_details",
                    "type": "string",
                    "helper_text": "Members details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_task_members",
            "task_name": "tasks.clickup.get_task_members",
            "description": "Get members associated with a ClickUp task",
            "label": "Get Task Members",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_id",
                "custom_task_ids",
                "team_id",
            ],
            "required": ["task_id"],
        },
        "add_time_entry_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the time entry",
                    "label": "Time Entry ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag to add",
                    "label": "Tag Name",
                    "placeholder": "billable",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully added",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the time entry",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the added tag",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "add_time_entry_tag",
            "task_name": "tasks.clickup.add_time_entry_tag",
            "description": "Add a tag to a ClickUp time entry",
            "label": "Add Time Entry Tag",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "time_entry_id",
                "tag_name",
            ],
            "required": ["team_id", "time_entry_id", "tag_name"],
        },
        "get_time_entry_tags**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "tag_names",
                    "type": "vec<string>",
                    "helper_text": "List of time entry tag names",
                },
                {
                    "field": "tag_details",
                    "type": "vec<string>",
                    "helper_text": "Time entry tags details in JSON format",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_time_entry_tags",
            "task_name": "tasks.clickup.get_time_entry_tags",
            "description": "Get available time entry tags in ClickUp",
            "label": "Get Time Entry Tags",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "team_id"],
            "required": ["team_id"],
        },
        "remove_time_entry_tag**(*)**(*)": {
            "inputs": [
                {
                    "field": "team_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the team",
                    "label": "Team",
                    "placeholder": "Select team",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=team_name&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the time entry",
                    "label": "Time Entry ID",
                    "placeholder": "abc123def456",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "value": "",
                    "helper_text": "Name of the tag to remove",
                    "label": "Tag Name",
                    "placeholder": "billable",
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the tag was successfully removed",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "time_entry_id",
                    "type": "string",
                    "helper_text": "ID of the time entry",
                },
                {
                    "field": "tag_name",
                    "type": "string",
                    "helper_text": "Name of the removed tag",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "remove_time_entry_tag",
            "task_name": "tasks.clickup.remove_time_entry_tag",
            "description": "Remove a tag from a ClickUp time entry",
            "label": "Remove Time Entry Tag",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "team_id",
                "time_entry_id",
                "tag_name",
            ],
            "required": ["team_id", "time_entry_id", "tag_name"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        archived: bool = False,
        assign_user: str = "",
        assignee: str = "",
        assignees: str = "",
        checklist_id: str = "",
        checklist_item_assignee: str = "",
        checklist_item_id: str = "",
        checklist_item_name: str = "",
        checklist_name: str = "",
        comment_id: str = "",
        comment_text: str = "",
        custom_field_id: str = "",
        custom_field_value: str = "",
        custom_fields: str = "",
        custom_task_ids: bool = False,
        date_updated_gt: Any = None,
        date_updated_lt: Any = None,
        depends_on_task_id: str = "",
        due_date_gt: Any = None,
        due_date_lt: Any = None,
        duration_minutes: int = 60,
        enable_custom_fields: bool = True,
        enable_dependency_warnings: bool = True,
        enable_incomplete_warnings: bool = True,
        enable_priority: bool = True,
        enable_tags: bool = True,
        enable_time_tracking: bool = True,
        exact_date: Any = {"start": "", "end": ""},
        folder_id: str = "",
        folder_name: str = "",
        get_running: bool = False,
        goal_color: str = "",
        goal_description: str = "",
        goal_due_date: str = "",
        goal_id: str = "",
        goal_multiple_owners: bool = False,
        goal_name: str = "",
        goal_owners: str = "",
        include_closed: bool = False,
        include_completed: bool = False,
        include_location_names: bool = False,
        include_markdown_description: bool = False,
        key_result_id: str = "",
        key_result_list_ids: str = "",
        key_result_name: str = "",
        key_result_owners: str = "",
        key_result_steps_end: int = 10,
        key_result_steps_start: int = 0,
        key_result_task_ids: str = "",
        key_result_type: str = "",
        key_result_unit: str = "",
        limit: int = 10,
        list_content: str = "",
        list_id: str = "",
        list_name: str = "",
        markdown_content: str = "",
        new_tag_name: str = "",
        notify_all: bool = False,
        num_messages: int = 10,
        order_by: str = "",
        parent_id: str = "",
        reverse: bool = False,
        space_id: str = "",
        space_multiple_assignees: bool = True,
        space_name: str = "",
        start_time: str = "",
        statuses: str = "",
        subtasks: bool = False,
        tag_background_color: str = "#ffffff",
        tag_foreground_color: str = "#000000",
        tag_name: str = "",
        tags: str = "",
        task_assignees: str = "",
        task_description: str = "",
        task_due_date: Any = None,
        task_id: str = "",
        task_name: str = "",
        task_priority: str = "3",
        task_start_date: Any = None,
        task_status: str = "",
        task_tags: str = "",
        team_id: str = "",
        time_entry_assignee: str = "",
        time_entry_billable: bool = False,
        time_entry_description: str = "",
        time_entry_id: str = "",
        time_entry_tags: str = "",
        time_estimate: int = None,
        update_checklist_item_assignee: str = "",
        update_checklist_item_name: str = "",
        update_checklist_item_parent: str = "",
        update_checklist_item_resolved: bool = False,
        update_checklist_name: str = "",
        update_checklist_position: int = 0,
        update_comment_text: str = "",
        update_folder_name: str = "",
        update_goal_add_owners: str = "",
        update_goal_color: str = "",
        update_goal_description: str = "",
        update_goal_due_date: str = "",
        update_goal_name: str = "",
        update_goal_remove_owners: str = "",
        update_key_result_name: str = "",
        update_key_result_note: str = "",
        update_key_result_steps_current: int = 0,
        update_key_result_steps_end: int = 10,
        update_key_result_steps_start: int = 0,
        update_key_result_unit: str = "",
        update_list_assignee: str = "",
        update_list_content: str = "",
        update_list_due_date: Any = None,
        update_list_name: str = "",
        update_list_priority: str = "3",
        update_list_status: str = "",
        update_markdown_content: str = "",
        update_parent_id: str = "",
        update_task_assignees: str = "",
        update_task_description: str = "",
        update_task_due_date: Any = None,
        update_task_name: str = "",
        update_task_priority: str = "3",
        update_task_start_date: Any = None,
        update_task_status: str = "",
        update_task_tags: str = "",
        update_time_entry_billable: bool = False,
        update_time_entry_description: str = "",
        update_time_entry_duration_minutes: int = 60,
        update_time_entry_start: str = "",
        update_time_entry_task_id: str = "",
        update_time_estimate: int = None,
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_clickup",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if team_id is not None:
            self.inputs["team_id"] = team_id
        if space_id is not None:
            self.inputs["space_id"] = space_id
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if list_id is not None:
            self.inputs["list_id"] = list_id
        if task_status is not None:
            self.inputs["task_status"] = task_status
        if task_assignees is not None:
            self.inputs["task_assignees"] = task_assignees
        if task_priority is not None:
            self.inputs["task_priority"] = task_priority
        if task_name is not None:
            self.inputs["task_name"] = task_name
        if task_description is not None:
            self.inputs["task_description"] = task_description
        if task_tags is not None:
            self.inputs["task_tags"] = task_tags
        if task_due_date is not None:
            self.inputs["task_due_date"] = task_due_date
        if task_start_date is not None:
            self.inputs["task_start_date"] = task_start_date
        if parent_id is not None:
            self.inputs["parent_id"] = parent_id
        if time_estimate is not None:
            self.inputs["time_estimate"] = time_estimate
        if notify_all is not None:
            self.inputs["notify_all"] = notify_all
        if markdown_content is not None:
            self.inputs["markdown_content"] = markdown_content
        if task_id is not None:
            self.inputs["task_id"] = task_id
        if update_task_status is not None:
            self.inputs["update_task_status"] = update_task_status
        if update_task_assignees is not None:
            self.inputs["update_task_assignees"] = update_task_assignees
        if update_task_priority is not None:
            self.inputs["update_task_priority"] = update_task_priority
        if update_task_name is not None:
            self.inputs["update_task_name"] = update_task_name
        if update_task_description is not None:
            self.inputs["update_task_description"] = update_task_description
        if update_task_due_date is not None:
            self.inputs["update_task_due_date"] = update_task_due_date
        if update_task_start_date is not None:
            self.inputs["update_task_start_date"] = update_task_start_date
        if update_task_tags is not None:
            self.inputs["update_task_tags"] = update_task_tags
        if update_parent_id is not None:
            self.inputs["update_parent_id"] = update_parent_id
        if update_time_estimate is not None:
            self.inputs["update_time_estimate"] = update_time_estimate
        if update_markdown_content is not None:
            self.inputs["update_markdown_content"] = update_markdown_content
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if archived is not None:
            self.inputs["archived"] = archived
        if include_markdown_description is not None:
            self.inputs["include_markdown_description"] = include_markdown_description
        if include_closed is not None:
            self.inputs["include_closed"] = include_closed
        if subtasks is not None:
            self.inputs["subtasks"] = subtasks
        if reverse is not None:
            self.inputs["reverse"] = reverse
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if statuses is not None:
            self.inputs["statuses"] = statuses
        if assignees is not None:
            self.inputs["assignees"] = assignees
        if tags is not None:
            self.inputs["tags"] = tags
        if due_date_gt is not None:
            self.inputs["due_date_gt"] = due_date_gt
        if due_date_lt is not None:
            self.inputs["due_date_lt"] = due_date_lt
        if date_updated_gt is not None:
            self.inputs["date_updated_gt"] = date_updated_gt
        if date_updated_lt is not None:
            self.inputs["date_updated_lt"] = date_updated_lt
        if custom_fields is not None:
            self.inputs["custom_fields"] = custom_fields
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if assign_user is not None:
            self.inputs["assign_user"] = assign_user
        if comment_text is not None:
            self.inputs["comment_text"] = comment_text
        if comment_id is not None:
            self.inputs["comment_id"] = comment_id
        if update_comment_text is not None:
            self.inputs["update_comment_text"] = update_comment_text
        if list_name is not None:
            self.inputs["list_name"] = list_name
        if list_content is not None:
            self.inputs["list_content"] = list_content
        if update_list_name is not None:
            self.inputs["update_list_name"] = update_list_name
        if update_list_content is not None:
            self.inputs["update_list_content"] = update_list_content
        if update_list_due_date is not None:
            self.inputs["update_list_due_date"] = update_list_due_date
        if update_list_priority is not None:
            self.inputs["update_list_priority"] = update_list_priority
        if update_list_assignee is not None:
            self.inputs["update_list_assignee"] = update_list_assignee
        if update_list_status is not None:
            self.inputs["update_list_status"] = update_list_status
        if folder_name is not None:
            self.inputs["folder_name"] = folder_name
        if update_folder_name is not None:
            self.inputs["update_folder_name"] = update_folder_name
        if space_name is not None:
            self.inputs["space_name"] = space_name
        if space_multiple_assignees is not None:
            self.inputs["space_multiple_assignees"] = space_multiple_assignees
        if enable_time_tracking is not None:
            self.inputs["enable_time_tracking"] = enable_time_tracking
        if enable_priority is not None:
            self.inputs["enable_priority"] = enable_priority
        if enable_tags is not None:
            self.inputs["enable_tags"] = enable_tags
        if enable_custom_fields is not None:
            self.inputs["enable_custom_fields"] = enable_custom_fields
        if enable_incomplete_warnings is not None:
            self.inputs["enable_incomplete_warnings"] = enable_incomplete_warnings
        if enable_dependency_warnings is not None:
            self.inputs["enable_dependency_warnings"] = enable_dependency_warnings
        if checklist_name is not None:
            self.inputs["checklist_name"] = checklist_name
        if checklist_id is not None:
            self.inputs["checklist_id"] = checklist_id
        if update_checklist_name is not None:
            self.inputs["update_checklist_name"] = update_checklist_name
        if update_checklist_position is not None:
            self.inputs["update_checklist_position"] = update_checklist_position
        if checklist_item_name is not None:
            self.inputs["checklist_item_name"] = checklist_item_name
        if checklist_item_assignee is not None:
            self.inputs["checklist_item_assignee"] = checklist_item_assignee
        if checklist_item_id is not None:
            self.inputs["checklist_item_id"] = checklist_item_id
        if update_checklist_item_name is not None:
            self.inputs["update_checklist_item_name"] = update_checklist_item_name
        if update_checklist_item_parent is not None:
            self.inputs["update_checklist_item_parent"] = update_checklist_item_parent
        if update_checklist_item_assignee is not None:
            self.inputs["update_checklist_item_assignee"] = (
                update_checklist_item_assignee
            )
        if update_checklist_item_resolved is not None:
            self.inputs["update_checklist_item_resolved"] = (
                update_checklist_item_resolved
            )
        if goal_name is not None:
            self.inputs["goal_name"] = goal_name
        if goal_description is not None:
            self.inputs["goal_description"] = goal_description
        if goal_due_date is not None:
            self.inputs["goal_due_date"] = goal_due_date
        if goal_color is not None:
            self.inputs["goal_color"] = goal_color
        if goal_multiple_owners is not None:
            self.inputs["goal_multiple_owners"] = goal_multiple_owners
        if goal_owners is not None:
            self.inputs["goal_owners"] = goal_owners
        if goal_id is not None:
            self.inputs["goal_id"] = goal_id
        if include_completed is not None:
            self.inputs["include_completed"] = include_completed
        if update_goal_name is not None:
            self.inputs["update_goal_name"] = update_goal_name
        if update_goal_description is not None:
            self.inputs["update_goal_description"] = update_goal_description
        if update_goal_due_date is not None:
            self.inputs["update_goal_due_date"] = update_goal_due_date
        if update_goal_color is not None:
            self.inputs["update_goal_color"] = update_goal_color
        if update_goal_add_owners is not None:
            self.inputs["update_goal_add_owners"] = update_goal_add_owners
        if update_goal_remove_owners is not None:
            self.inputs["update_goal_remove_owners"] = update_goal_remove_owners
        if key_result_name is not None:
            self.inputs["key_result_name"] = key_result_name
        if key_result_type is not None:
            self.inputs["key_result_type"] = key_result_type
        if key_result_unit is not None:
            self.inputs["key_result_unit"] = key_result_unit
        if key_result_steps_start is not None:
            self.inputs["key_result_steps_start"] = key_result_steps_start
        if key_result_steps_end is not None:
            self.inputs["key_result_steps_end"] = key_result_steps_end
        if key_result_task_ids is not None:
            self.inputs["key_result_task_ids"] = key_result_task_ids
        if key_result_list_ids is not None:
            self.inputs["key_result_list_ids"] = key_result_list_ids
        if key_result_owners is not None:
            self.inputs["key_result_owners"] = key_result_owners
        if key_result_id is not None:
            self.inputs["key_result_id"] = key_result_id
        if update_key_result_name is not None:
            self.inputs["update_key_result_name"] = update_key_result_name
        if update_key_result_note is not None:
            self.inputs["update_key_result_note"] = update_key_result_note
        if update_key_result_steps_current is not None:
            self.inputs["update_key_result_steps_current"] = (
                update_key_result_steps_current
            )
        if update_key_result_steps_start is not None:
            self.inputs["update_key_result_steps_start"] = update_key_result_steps_start
        if update_key_result_steps_end is not None:
            self.inputs["update_key_result_steps_end"] = update_key_result_steps_end
        if update_key_result_unit is not None:
            self.inputs["update_key_result_unit"] = update_key_result_unit
        if start_time is not None:
            self.inputs["start_time"] = start_time
        if duration_minutes is not None:
            self.inputs["duration_minutes"] = duration_minutes
        if time_entry_description is not None:
            self.inputs["time_entry_description"] = time_entry_description
        if time_entry_billable is not None:
            self.inputs["time_entry_billable"] = time_entry_billable
        if time_entry_assignee is not None:
            self.inputs["time_entry_assignee"] = time_entry_assignee
        if time_entry_tags is not None:
            self.inputs["time_entry_tags"] = time_entry_tags
        if time_entry_id is not None:
            self.inputs["time_entry_id"] = time_entry_id
        if get_running is not None:
            self.inputs["get_running"] = get_running
        if assignee is not None:
            self.inputs["assignee"] = assignee
        if include_location_names is not None:
            self.inputs["include_location_names"] = include_location_names
        if update_time_entry_description is not None:
            self.inputs["update_time_entry_description"] = update_time_entry_description
        if update_time_entry_billable is not None:
            self.inputs["update_time_entry_billable"] = update_time_entry_billable
        if update_time_entry_start is not None:
            self.inputs["update_time_entry_start"] = update_time_entry_start
        if update_time_entry_duration_minutes is not None:
            self.inputs["update_time_entry_duration_minutes"] = (
                update_time_entry_duration_minutes
            )
        if update_time_entry_task_id is not None:
            self.inputs["update_time_entry_task_id"] = update_time_entry_task_id
        if tag_name is not None:
            self.inputs["tag_name"] = tag_name
        if tag_foreground_color is not None:
            self.inputs["tag_foreground_color"] = tag_foreground_color
        if tag_background_color is not None:
            self.inputs["tag_background_color"] = tag_background_color
        if limit is not None:
            self.inputs["limit"] = limit
        if new_tag_name is not None:
            self.inputs["new_tag_name"] = new_tag_name
        if depends_on_task_id is not None:
            self.inputs["depends_on_task_id"] = depends_on_task_id
        if custom_field_id is not None:
            self.inputs["custom_field_id"] = custom_field_id
        if custom_field_value is not None:
            self.inputs["custom_field_value"] = custom_field_value
        if custom_task_ids is not None:
            self.inputs["custom_task_ids"] = custom_task_ids
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationClickupNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_ads")
class IntegrationGoogleAdsNode(Node):
    """
    Google Ads

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'read_campaign'
        campaign_id: The campaign to retrieve details for
        customer_id: The Google Ads customer account
    ### When action = 'get_campaigns'
        campaign_status: Filter by campaign status (ENABLED, PAUSED, REMOVED)
        campaign_type: Filter by campaign type (SEARCH, DISPLAY, VIDEO, etc.)
        customer_id: The Google Ads customer account
        use_date: Toggle to use dates
    ### When action = 'get_campaigns' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'get_campaigns' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'get_campaigns' and use_date = False
        num_messages: Specify the number of campaigns to fetch
    ### When action = 'get_campaigns' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_campaign'
        campaign_id: The ID of the campaign
        campaign_name: The name of the campaign
        campaign_status: The status of the campaign
        campaign_type: The type of the campaign
        end_date: The end date of the campaign
        raw_data: The raw response data from Google Ads API
        start_date: The start date of the campaign
    ### When action = 'get_campaigns'
        campaign_ids: List of campaign IDs
        campaign_names: List of campaign names
        campaign_statuses: List of campaign statuses
        campaign_types: List of campaign types
        campaigns: Campaign details in JSON format
        raw_data: The raw response data from Google Ads API
        total_count: Total number of campaigns found
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Ads>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "get_campaigns**(*)**(*)": {
            "inputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "label": "Customer",
                    "placeholder": "Select customer",
                    "helper_text": "The Google Ads customer account",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=customer_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
                {
                    "field": "campaign_status",
                    "type": "string",
                    "value": "",
                    "label": "Campaign Status",
                    "placeholder": "Select status",
                    "helper_text": "Filter by campaign status (ENABLED, PAUSED, REMOVED)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=campaign_status&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "campaign_type",
                    "type": "string",
                    "value": "",
                    "label": "Campaign Type",
                    "placeholder": "Select type",
                    "helper_text": "Filter by campaign type (SEARCH, DISPLAY, VIDEO, etc.)",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=campaign_type&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "campaigns",
                    "type": "string",
                    "helper_text": "Campaign details in JSON format",
                },
                {
                    "field": "campaign_ids",
                    "type": "vec<string>",
                    "helper_text": "List of campaign IDs",
                },
                {
                    "field": "campaign_names",
                    "type": "vec<string>",
                    "helper_text": "List of campaign names",
                },
                {
                    "field": "campaign_types",
                    "type": "vec<string>",
                    "helper_text": "List of campaign types",
                },
                {
                    "field": "campaign_statuses",
                    "type": "vec<string>",
                    "helper_text": "List of campaign statuses",
                },
                {
                    "field": "total_count",
                    "type": "string",
                    "helper_text": "Total number of campaigns found",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Google Ads API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "get_campaigns",
            "task_name": "tasks.google_ads.get_campaigns",
            "description": "Get a list of campaigns from Google Ads with filtering options",
            "label": "Get Campaigns",
            "inputs_sort_order": [
                "integration",
                "action",
                "customer_id",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "num_messages",
                "campaign_status",
                "campaign_type",
            ],
        },
        "get_campaigns**false**(*)": {
            "inputs": [
                {
                    "field": "num_messages",
                    "type": "int32",
                    "value": 10,
                    "show_date_range": True,
                    "label": "Number of Campaigns",
                    "helper_text": "Specify the number of campaigns to fetch",
                }
            ],
            "outputs": [],
        },
        "get_campaigns**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_campaigns**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_campaigns**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "read_campaign**(*)**(*)": {
            "inputs": [
                {
                    "field": "customer_id",
                    "type": "string",
                    "value": "",
                    "label": "Customer",
                    "placeholder": "Select customer",
                    "helper_text": "The Google Ads customer account",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=customer_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "campaign_id",
                    "type": "string",
                    "value": "",
                    "label": "Campaign",
                    "placeholder": "Select campaign",
                    "helper_text": "The campaign to retrieve details for",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=campaign_id&page={}&page_size={dynamic_config.page_size}&q={}&customer_id={inputs.customer_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "campaign_id",
                    "type": "string",
                    "helper_text": "The ID of the campaign",
                },
                {
                    "field": "campaign_name",
                    "type": "string",
                    "helper_text": "The name of the campaign",
                },
                {
                    "field": "campaign_status",
                    "type": "string",
                    "helper_text": "The status of the campaign",
                },
                {
                    "field": "campaign_type",
                    "type": "string",
                    "helper_text": "The type of the campaign",
                },
                {
                    "field": "start_date",
                    "type": "timestamp",
                    "helper_text": "The start date of the campaign",
                },
                {
                    "field": "end_date",
                    "type": "timestamp",
                    "helper_text": "The end date of the campaign",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw response data from Google Ads API",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "read_campaign",
            "task_name": "tasks.google_ads.read_campaign",
            "description": "Retrieve details of a specific Google Ads campaign",
            "label": "Read Campaign",
            "inputs_sort_order": [
                "integration",
                "action",
                "customer_id",
                "campaign_id",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        campaign_id: str = "",
        campaign_status: str = "",
        campaign_type: str = "",
        customer_id: str = "",
        exact_date: Any = {"start": "", "end": ""},
        num_messages: int = 10,
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_ads",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if customer_id is not None:
            self.inputs["customer_id"] = customer_id
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if campaign_status is not None:
            self.inputs["campaign_status"] = campaign_status
        if campaign_type is not None:
            self.inputs["campaign_type"] = campaign_type
        if num_messages is not None:
            self.inputs["num_messages"] = num_messages
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if campaign_id is not None:
            self.inputs["campaign_id"] = campaign_id
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleAdsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("zapier")
class ZapierNode(Node):
    """


    ## Inputs
    ### Common Inputs
        payload: Text/JSON payload to deliver
        webhook_url: the Zapier URL to deliver the payload to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "payload",
            "helper_text": "Text/JSON payload to deliver",
            "value": "",
            "type": "string",
        },
        {
            "field": "webhook_url",
            "helper_text": "the Zapier URL to deliver the payload to",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        payload: str = "",
        webhook_url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="zapier",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if payload is not None:
            self.inputs["payload"] = payload
        if webhook_url is not None:
            self.inputs["webhook_url"] = webhook_url

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ZapierNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("make")
class MakeNode(Node):
    """


    ## Inputs
    ### Common Inputs
        payload: Text/JSON payload to deliver
        webhook_url: the Make URL to deliver the payload to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "payload",
            "helper_text": "Text/JSON payload to deliver",
            "value": "",
            "type": "string",
        },
        {
            "field": "webhook_url",
            "helper_text": "the Make URL to deliver the payload to",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        payload: str = "",
        webhook_url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="make",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if payload is not None:
            self.inputs["payload"] = payload
        if webhook_url is not None:
            self.inputs["webhook_url"] = webhook_url

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "MakeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("text_manipulation")
class TextManipulationNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="text_manipulation",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TextManipulationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_operations")
class FileOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="file_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "FileOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_operations")
class AiOperationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_operations",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiOperationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("file_to_text")
class FileToTextNode(Node):
    """
    Convert data from type File to type Text

    ## Inputs
    ### Common Inputs
        chunk_text: Whether to chunk the text into smaller pieces.
        file: The file to convert to text.
        file_parser: The type of file parser to use.
    ### When chunk_text = True
        chunk_overlap: The overlap of each chunk of text.
        chunk_size: The size of each chunk of text.

    ## Outputs
    ### When chunk_text = True
        processed_text: The text as a list of chunks.
    ### When chunk_text = False
        processed_text: The text as a string.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_text",
            "helper_text": "Whether to chunk the text into smaller pieces.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "file",
            "helper_text": "The file to convert to text.",
            "value": "",
            "type": "file",
        },
        {
            "field": "file_parser",
            "helper_text": "The type of file parser to use.",
            "value": "default",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "chunk_size",
                    "type": "int32",
                    "value": 1024,
                    "label": "Chunk Size",
                    "helper_text": "The size of each chunk of text.",
                    "is_advanced_setting": True,
                },
                {
                    "field": "chunk_overlap",
                    "type": "int32",
                    "value": 400,
                    "label": "Chunk Overlap",
                    "helper_text": "The overlap of each chunk of text.",
                    "is_advanced_setting": True,
                },
            ],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "vec<string>",
                    "label": "Processed Text",
                    "helper_text": "The text as a list of chunks.",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "processed_text",
                    "type": "string",
                    "label": "Processed Text",
                    "helper_text": "The text as a string.",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["chunk_text"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        chunk_text: bool = False,
        chunk_overlap: int = 400,
        chunk_size: int = 1024,
        file: str = "",
        file_parser: str = "default",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["chunk_text"] = chunk_text

        super().__init__(
            node_type="file_to_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if chunk_text is not None:
            self.inputs["chunk_text"] = chunk_text
        if file_parser is not None:
            self.inputs["file_parser"] = file_parser
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "FileToTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("code_execution")
class CodeExecutionNode(Node):
    """


    ## Inputs
    ### Common Inputs
        code: The code input
        language: The language input

    ## Outputs
    ### Common Outputs
        outputs: The outputs output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "code",
            "helper_text": "The code input",
            "value": "",
            "type": "string",
        },
        {
            "field": "language",
            "helper_text": "The language input",
            "value": 0,
            "type": "enum<int32>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "outputs", "helper_text": "The outputs output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        code: str = "",
        language: int = 0,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="code_execution",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if code is not None:
            self.inputs["code"] = code
        if language is not None:
            self.inputs["language"] = language

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CodeExecutionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("chunking")
class ChunkingNode(Node):
    """
    Split text into chunks. Supports different chunking strategies like markdown-aware, sentence-based, or dynamic sizing.

    ## Inputs
    ### Common Inputs
        chunk_overlap: The overlap of each chunk of text.
        chunk_size: The size of each chunk of text.
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        text: The text to chunk
    ### dynamic
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.

    ## Outputs
    ### Common Outputs
        chunks: The chunks output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "chunk_overlap",
            "helper_text": "The overlap of each chunk of text.",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The size of each chunk of text.",
            "value": 512,
            "type": "int32",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "text",
            "helper_text": "The text to chunk",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "chunks", "helper_text": "The chunks output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "dynamic": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["splitter_method"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        splitter_method: str = "markdown",
        chunk_overlap: int = 0,
        chunk_size: int = 512,
        segmentation_method: str = "words",
        text: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="chunking",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ChunkingNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("notifications")
class NotificationsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="notifications",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "NotificationsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("custom_smtp_email_sender")
class CustomSmtpEmailSenderNode(Node):
    """
    Send emails via SMTP

    ## Inputs
    ### Common Inputs
        connection_type: Security type: SSL, TLS, or STARTTLS
        email_body: Email content
        email_subject: Subject line of the email
        recipient_email: Recipient email address(es), comma-separated
        send_as_html: Send email in HTML format
        sender_email: Sender email address
        sender_name: Display name for sender (optional)
        sender_password: SMTP server password
        smtp_server: SMTP server hostname or IP
        smtp_server_port: SMTP server port (25, 465, 587)

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "connection_type",
            "helper_text": "Security type: SSL, TLS, or STARTTLS",
            "value": "SSL",
            "type": "enum<string>",
        },
        {
            "field": "email_body",
            "helper_text": "Email content",
            "value": "",
            "type": "string",
        },
        {
            "field": "email_subject",
            "helper_text": "Subject line of the email",
            "value": "",
            "type": "string",
        },
        {
            "field": "recipient_email",
            "helper_text": "Recipient email address(es), comma-separated",
            "value": "",
            "type": "string",
        },
        {
            "field": "send_as_html",
            "helper_text": "Send email in HTML format",
            "value": "",
            "type": "bool",
        },
        {
            "field": "sender_email",
            "helper_text": "Sender email address",
            "value": "",
            "type": "string",
        },
        {
            "field": "sender_name",
            "helper_text": "Display name for sender (optional)",
            "value": "",
            "type": "string",
        },
        {
            "field": "sender_password",
            "helper_text": "SMTP server password",
            "value": "",
            "type": "string",
        },
        {
            "field": "smtp_server",
            "helper_text": "SMTP server hostname or IP",
            "value": "",
            "type": "string",
        },
        {
            "field": "smtp_server_port",
            "helper_text": "SMTP server port (25, 465, 587)",
            "value": 465,
            "type": "int32",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        connection_type: str = "SSL",
        email_body: str = "",
        email_subject: str = "",
        recipient_email: str = "",
        send_as_html: bool = False,
        sender_email: str = "",
        sender_name: str = "",
        sender_password: str = "",
        smtp_server: str = "",
        smtp_server_port: int = 465,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="custom_smtp_email_sender",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if recipient_email is not None:
            self.inputs["recipient_email"] = recipient_email
        if email_subject is not None:
            self.inputs["email_subject"] = email_subject
        if email_body is not None:
            self.inputs["email_body"] = email_body
        if send_as_html is not None:
            self.inputs["send_as_html"] = send_as_html
        if smtp_server is not None:
            self.inputs["smtp_server"] = smtp_server
        if smtp_server_port is not None:
            self.inputs["smtp_server_port"] = smtp_server_port
        if sender_email is not None:
            self.inputs["sender_email"] = sender_email
        if sender_password is not None:
            self.inputs["sender_password"] = sender_password
        if sender_name is not None:
            self.inputs["sender_name"] = sender_name
        if connection_type is not None:
            self.inputs["connection_type"] = connection_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CustomSmtpEmailSenderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("email_notification")
class EmailNotificationNode(Node):
    """
    Send email notifications from no-reply@vectorshiftmail.com

    ## Inputs
    ### Common Inputs
        email_body: Email content
        email_subject: Subject line of the email
        recipient_email: Recipient email address(es), comma-separated
        send_as_html: Send email in HTML format

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "email_body",
            "helper_text": "Email content",
            "value": "",
            "type": "string",
        },
        {
            "field": "email_subject",
            "helper_text": "Subject line of the email",
            "value": "",
            "type": "string",
        },
        {
            "field": "recipient_email",
            "helper_text": "Recipient email address(es), comma-separated",
            "value": "",
            "type": "string",
        },
        {
            "field": "send_as_html",
            "helper_text": "Send email in HTML format",
            "value": "",
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        email_body: str = "",
        email_subject: str = "",
        recipient_email: str = "",
        send_as_html: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="email_notification",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if recipient_email is not None:
            self.inputs["recipient_email"] = recipient_email
        if email_subject is not None:
            self.inputs["email_subject"] = email_subject
        if email_body is not None:
            self.inputs["email_body"] = email_body
        if send_as_html is not None:
            self.inputs["send_as_html"] = send_as_html

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "EmailNotificationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sms_notification")
class SmsNotificationNode(Node):
    """
    Send text message notifications.

    ## Inputs
    ### Common Inputs
        message: SMS message content
        phone_number: US phone number in country code (+1)

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "message",
            "helper_text": "SMS message content",
            "value": "",
            "type": "string",
        },
        {
            "field": "phone_number",
            "helper_text": "US phone number in country code (+1)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        message: str = "",
        phone_number: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sms_notification",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if phone_number is not None:
            self.inputs["phone_number"] = phone_number
        if message is not None:
            self.inputs["message"] = message

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SmsNotificationNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_filter_list")
class AiFilterListNode(Node):
    """
    Filter items in a list given a specific AI condition. Example, Filter (Red, White, Boat) by whether it is a color: (Red, White)

    ## Inputs
    ### Common Inputs
        ai_condition: Write in natural language the condition to filter each item in the list
        filter_by: The items to filter the list by
        list_to_filter: The list to filter
        model: The specific model for filtering
        output_blank_value: If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted
        provider: The model provider

    ## Outputs
    ### Common Outputs
        output: The filtered list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "ai_condition",
            "helper_text": "Write in natural language the condition to filter each item in the list",
            "value": "",
            "type": "string",
        },
        {
            "field": "filter_by",
            "helper_text": "The items to filter the list by",
            "value": "",
            "type": "vec<string>",
        },
        {
            "field": "list_to_filter",
            "helper_text": "The list to filter",
            "value": "",
            "type": "vec<string>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for filtering",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "output_blank_value",
            "helper_text": "If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted",
            "value": False,
            "type": "bool",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The filtered list"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        ai_condition: str = "",
        filter_by: List[str] = [],
        list_to_filter: List[str] = [],
        model: str = "gpt-4o",
        output_blank_value: bool = False,
        provider: str = "openai",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_filter_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if list_to_filter is not None:
            self.inputs["list_to_filter"] = list_to_filter
        if filter_by is not None:
            self.inputs["filter_by"] = filter_by
        if ai_condition is not None:
            self.inputs["ai_condition"] = ai_condition
        if output_blank_value is not None:
            self.inputs["output_blank_value"] = output_blank_value
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiFilterListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("filter_list")
class FilterListNode(Node):
    """
    Filter a list given a specific condition. Example, Filter (Red, White, Blue) by (100, 95, 80)>90 is (Red, White)

    ## Inputs
    ### Common Inputs
        condition_type: The type of condition to apply
        condition_value: The value to compare the list items against
        output_blank_value: If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted
        type: The type of the list
    ### <T>
        filter_by: The items to filter the list by
        list_to_filter: The list to filter

    ## Outputs
    ### <T>
        output: The filtered list
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "condition_type",
            "helper_text": "The type of condition to apply",
            "value": "IsEmpty",
            "type": "enum<string>",
        },
        {
            "field": "condition_value",
            "helper_text": "The value to compare the list items against",
            "value": "",
            "type": "string",
        },
        {
            "field": "output_blank_value",
            "helper_text": "If true, output a blank value for values that do not meet the filter condition. If false, nothing will be outputted",
            "value": False,
            "type": "bool",
        },
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list_to_filter",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The list to filter",
                },
                {
                    "field": "filter_by",
                    "type": "vec<<T>>",
                    "value": "",
                    "helper_text": "The items to filter the list by",
                },
            ],
            "outputs": [
                {
                    "field": "output",
                    "type": "vec<<T>>",
                    "helper_text": "The filtered list",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        condition_type: str = "IsEmpty",
        condition_value: str = "",
        filter_by: List[Any] = [],
        list_to_filter: List[Any] = [],
        output_blank_value: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="filter_list",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if condition_type is not None:
            self.inputs["condition_type"] = condition_type
        if condition_value is not None:
            self.inputs["condition_value"] = condition_value
        if output_blank_value is not None:
            self.inputs["output_blank_value"] = output_blank_value
        if list_to_filter is not None:
            self.inputs["list_to_filter"] = list_to_filter
        if filter_by is not None:
            self.inputs["filter_by"] = filter_by

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "FilterListNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sales_data_enrichment")
class SalesDataEnrichmentNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="sales_data_enrichment",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SalesDataEnrichmentNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("email_validator")
class EmailValidatorNode(Node):
    """
    Validate an email address

    ## Inputs
    ### Common Inputs
        email_to_validate: The email you want to validate
        model: The validation model to use
    ### custom-validator
        api_key: The API key to use
        provider: The validation provider to use

    ## Outputs
    ### Common Outputs
        status: Whether the email is valid
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "email_to_validate",
            "helper_text": "The email you want to validate",
            "value": "",
            "type": "string",
        },
        {
            "field": "model",
            "helper_text": "The validation model to use",
            "value": "regex",
            "type": "enum<string>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "status", "helper_text": "Whether the email is valid"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "custom-validator": {
            "inputs": [
                {
                    "field": "provider",
                    "type": "enum<string>",
                    "value": "hunter",
                    "helper_text": "The validation provider to use",
                },
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "The API key to use",
                },
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["model"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        model: str = "regex",
        api_key: str = "",
        email_to_validate: str = "",
        provider: str = "hunter",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["model"] = model

        super().__init__(
            node_type="email_validator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if email_to_validate is not None:
            self.inputs["email_to_validate"] = email_to_validate
        if model is not None:
            self.inputs["model"] = model
        if provider is not None:
            self.inputs["provider"] = provider
        if api_key is not None:
            self.inputs["api_key"] = api_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "EmailValidatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("combine_text")
class CombineTextNode(Node):
    """
    Combine text inputs into a singular output.

    ## Inputs
    ### Common Inputs
        text: The text to combine

    ## Outputs
    ### Common Outputs
        processed_text: The combined text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "text",
            "helper_text": "The text to combine",
            "value": ["", ""],
            "type": "vec<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "processed_text", "helper_text": "The combined text"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        text: List[str] = ["", ""],
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="combine_text",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text is not None:
            self.inputs["text"] = text

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "CombineTextNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("find_and_replace")
class FindAndReplaceNode(Node):
    """
    Find and replace words in a given text.

    ## Inputs
    ### Common Inputs
        replacements: The replacements input
        text_to_manipulate: The text to find and replace words in

    ## Outputs
    ### Common Outputs
        processed_text: The final text with found words replaced
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "replacements",
            "helper_text": "The replacements input",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "text_to_manipulate",
            "helper_text": "The text to find and replace words in",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "processed_text",
            "helper_text": "The final text with found words replaced",
        }
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        replacements: List[Any] = [],
        text_to_manipulate: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="find_and_replace",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text_to_manipulate is not None:
            self.inputs["text_to_manipulate"] = text_to_manipulate
        if replacements is not None:
            self.inputs["replacements"] = replacements

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "FindAndReplaceNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_fill_pdf")
class AiFillPdfNode(Node):
    """
    Fill out a PDF with form fields using AI. The AI will understand and fill each field using provided context. To convert your PDF to have fillable input fields, use: https://www.sejda.com/pdf-forms

    ## Inputs
    ### Common Inputs
        context: Context used by LLM to fill PDF fields
        file: The PDF with form fields to be filled
        model: The specific model for filling the PDF
        provider: The model provider
        select_pages: Whether to select specific pages to fill
    ### When select_pages = True
        selected_pages: PDF page range

    ## Outputs
    ### Common Outputs
        filled_pdf: Filled PDF
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "context",
            "helper_text": "Context used by LLM to fill PDF fields",
            "value": "",
            "type": "string",
        },
        {
            "field": "file",
            "helper_text": "The PDF with form fields to be filled",
            "value": None,
            "type": "file",
        },
        {
            "field": "model",
            "helper_text": "The specific model for filling the PDF",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "select_pages",
            "helper_text": "Whether to select specific pages to fill",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "filled_pdf", "helper_text": "Filled PDF"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "selected_pages",
                    "type": "string",
                    "value": "",
                    "helper_text": "PDF page range",
                }
            ],
            "outputs": [],
        },
        "false": {"inputs": [], "outputs": []},
    }

    # List of parameters that affect configuration
    _PARAMS = ["select_pages"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        select_pages: bool = False,
        context: str = "",
        file: Optional[str] = None,
        model: str = "gpt-4o",
        provider: str = "openai",
        selected_pages: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["select_pages"] = select_pages

        super().__init__(
            node_type="ai_fill_pdf",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if select_pages is not None:
            self.inputs["select_pages"] = select_pages
        if context is not None:
            self.inputs["context"] = context
        if selected_pages is not None:
            self.inputs["selected_pages"] = selected_pages

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiFillPdfNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("extract_to_table")
class ExtractToTableNode(Node):
    """
    Extract data to a CSV using AI

    ## Inputs
    ### Common Inputs
        add_columns_manually: Add data points for some columns manually instead of having them extracted by the AI model.
        additional_context: Provide any additional context that may help the AI model extract the data.
        extract_multiple_rows: Choose the mode of extraction. If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.
        file: Your file should contain headers in the first row.
        manual_columns: Pass in data to column names manually.
        model: The specific model for extracting the table
        provider: The model provider
        text_for_extraction: Text to extract table from

    ## Outputs
    ### Common Outputs
        table: The table extracted from the text
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "add_columns_manually",
            "helper_text": "Add data points for some columns manually instead of having them extracted by the AI model.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "additional_context",
            "helper_text": "Provide any additional context that may help the AI model extract the data.",
            "value": "",
            "type": "string",
        },
        {
            "field": "extract_multiple_rows",
            "helper_text": "Choose the mode of extraction. If checked, it will extract multiple rows of data. If unchecked, it will extract a single row.",
            "value": True,
            "type": "bool",
        },
        {
            "field": "file",
            "helper_text": "Your file should contain headers in the first row.",
            "value": "",
            "type": "file",
        },
        {
            "field": "manual_columns",
            "helper_text": "Pass in data to column names manually.",
            "value": [],
            "type": "vec<Dict[str, Any]>",
        },
        {
            "field": "model",
            "helper_text": "The specific model for extracting the table",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "text_for_extraction",
            "helper_text": "Text to extract table from",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "table", "helper_text": "The table extracted from the text"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        add_columns_manually: bool = False,
        additional_context: str = "",
        extract_multiple_rows: bool = True,
        file: str = "",
        manual_columns: List[Any] = [],
        model: str = "gpt-4o",
        provider: str = "openai",
        text_for_extraction: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="extract_to_table",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if text_for_extraction is not None:
            self.inputs["text_for_extraction"] = text_for_extraction
        if extract_multiple_rows is not None:
            self.inputs["extract_multiple_rows"] = extract_multiple_rows
        if add_columns_manually is not None:
            self.inputs["add_columns_manually"] = add_columns_manually
        if manual_columns is not None:
            self.inputs["manual_columns"] = manual_columns
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if additional_context is not None:
            self.inputs["additional_context"] = additional_context
        if file is not None:
            self.inputs["file"] = file

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ExtractToTableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("sort_csv")
class SortCsvNode(Node):
    """
    Sort a CSV based on a column

    ## Inputs
    ### Common Inputs
        file: The CSV file to sort.
        has_headers: Whether the CSV has headers.
        is_file_variable: Whether the file is a variable.
        reverse_sort: Whether to reverse the sort.
    ### When is_file_variable = True
        column_index: The index of the column to sort by.
    ### When is_file_variable = False and has_headers = False
        column_index: The index of the column to sort by.
    ### When is_file_variable = False and has_headers = True
        column_to_sort_by: The column to sort by.

    ## Outputs
    ### Common Outputs
        output: The output output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file",
            "helper_text": "The CSV file to sort.",
            "value": None,
            "type": "file",
        },
        {
            "field": "has_headers",
            "helper_text": "Whether the CSV has headers.",
            "value": True,
            "type": "bool",
        },
        {
            "field": "is_file_variable",
            "helper_text": "Whether the file is a variable.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "reverse_sort",
            "helper_text": "Whether to reverse the sort.",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "output", "helper_text": "The output output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)": {
            "inputs": [
                {
                    "field": "column_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The index of the column to sort by.",
                }
            ],
            "outputs": [],
        },
        "false**true": {
            "inputs": [
                {
                    "field": "column_to_sort_by",
                    "type": "enum<string>",
                    "value": "",
                    "helper_text": "The column to sort by.",
                }
            ],
            "outputs": [],
        },
        "false**false": {
            "inputs": [
                {
                    "field": "column_index",
                    "type": "int32",
                    "value": 0,
                    "helper_text": "The index of the column to sort by.",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["is_file_variable", "has_headers"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        is_file_variable: bool = False,
        has_headers: bool = True,
        column_index: int = 0,
        column_to_sort_by: str = "",
        file: Optional[str] = None,
        reverse_sort: bool = False,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["is_file_variable"] = is_file_variable
        params["has_headers"] = has_headers

        super().__init__(
            node_type="sort_csv",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if is_file_variable is not None:
            self.inputs["is_file_variable"] = is_file_variable
        if file is not None:
            self.inputs["file"] = file
        if has_headers is not None:
            self.inputs["has_headers"] = has_headers
        if reverse_sort is not None:
            self.inputs["reverse_sort"] = reverse_sort
        if column_index is not None:
            self.inputs["column_index"] = column_index
        if column_to_sort_by is not None:
            self.inputs["column_to_sort_by"] = column_to_sort_by

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SortCsvNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_outlook")
class TriggerOutlookNode(Node):
    """
    Outlook Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Select the Trigger
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_email
        attachments: The attachments output
        contents_of_email: The contents_of_email output
        email_id: The email_id output
        received_time: The received_time output
        recipient_email: The recipient_email output
        sender_email: The sender_email output
        subject: The subject output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Outlook>",
        },
        {
            "field": "item_id",
            "helper_text": "Select the Trigger",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_email": {
            "inputs": [],
            "outputs": [
                {"field": "email_id", "type": "string"},
                {"field": "subject", "type": "string"},
                {"field": "sender_email", "type": "string"},
                {"field": "recipient_email", "type": "string"},
                {"field": "received_time", "type": "string"},
                {"field": "contents_of_email", "type": "string"},
                {"field": "attachments", "type": "vec<file>"},
            ],
            "name": "new_email",
            "task_name": "tasks.outlook.new_email",
            "description": "Triggers when new email appears in the specified mailbox",
            "label": "New Email",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        item_id: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_outlook",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerOutlookNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_gmail")
class TriggerGmailNode(Node):
    """
    Gmail Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Select the Trigger
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_email
        attachments: The attachments output
        contents_of_email: The contents_of_email output
        email_id: The email_id output
        received_time: The received_time output
        recipient_email: The recipient_email output
        sender_email: The sender_email output
        subject: The subject output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Gmail>",
        },
        {
            "field": "item_id",
            "helper_text": "Select the Trigger",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_email": {
            "inputs": [],
            "outputs": [
                {"field": "email_id", "type": "string"},
                {"field": "subject", "type": "string"},
                {"field": "sender_email", "type": "string"},
                {"field": "recipient_email", "type": "string"},
                {"field": "received_time", "type": "string"},
                {"field": "contents_of_email", "type": "string"},
                {"field": "attachments", "type": "vec<file>"},
            ],
            "name": "new_email",
            "task_name": "tasks.gmail.new_email",
            "description": "Triggers when new email appears in the specified mailbox",
            "label": "New Email",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        item_id: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_gmail",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerGmailNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_cron")
class TriggerCronNode(Node):
    """
    Cron Trigger

    ## Inputs
    ### Common Inputs
        event: The event input
        integration: The integration input
        item_id: Custom cron expression
        timezone: Timezone for the cron trigger
        trigger_enabled: Enable/Disable Automation
    ### monthly
        day_of_month: Day of the month to trigger
        time_of_day: Time of day to trigger (HH:MM)
    ### weekly
        day_of_week: Day of the week to trigger
        time_of_day: Time of day to trigger (HH:MM)
    ### daily
        time_of_day: Time of day to trigger (HH:MM)
        trigger_on_weekends: Trigger on weekends

    ## Outputs
    ### Common Outputs
        timestamp: The timestamp output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": {"object_type": 20, "object_id": "6809a715ad4615eeb652a551"},
            "type": "integration<Cron>",
        },
        {
            "field": "item_id",
            "helper_text": "Custom cron expression",
            "value": "0 0 * * *",
            "type": "string",
        },
        {
            "field": "timezone",
            "helper_text": "Timezone for the cron trigger",
            "value": "UTC",
            "type": "enum<string>",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "timestamp", "helper_text": "The timestamp output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "daily": {
            "inputs": [
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
                {
                    "field": "trigger_on_weekends",
                    "type": "bool",
                    "value": False,
                    "label": "Trigger on weekends",
                    "helper_text": "Trigger on weekends",
                },
            ],
            "outputs": [],
            "name": "daily",
            "task_name": "tasks.cron.daily",
            "description": "Triggers once a day at a specified time",
            "label": "Daily",
        },
        "weekly": {
            "inputs": [
                {
                    "field": "day_of_week",
                    "type": "enum<string>",
                    "value": "Monday",
                    "label": "Day of the week",
                    "placeholder": "Select a day",
                    "helper_text": "Day of the week to trigger",
                },
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
            ],
            "outputs": [],
            "name": "weekly",
            "task_name": "tasks.cron.weekly",
            "description": "Triggers once a week on a specified day and time",
            "label": "Weekly",
        },
        "monthly": {
            "inputs": [
                {
                    "field": "day_of_month",
                    "type": "int32",
                    "value": 1,
                    "label": "Day of the month",
                    "placeholder": "Select a day",
                    "helper_text": "Day of the month to trigger",
                },
                {
                    "field": "time_of_day",
                    "type": "string",
                    "value": "00:00",
                    "label": "Time of day",
                    "placeholder": "HH:MM",
                    "helper_text": "Time of day to trigger (HH:MM)",
                },
            ],
            "outputs": [],
            "name": "monthly",
            "task_name": "tasks.cron.monthly",
            "description": "Triggers once a month on a specified day and time",
            "label": "Monthly",
        },
        "custom": {
            "inputs": [],
            "outputs": [],
            "name": "custom",
            "task_name": "tasks.cron.custom",
            "description": "Triggers based on a custom cron expression",
            "label": "Custom Cron Expression",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        day_of_month: int = 1,
        day_of_week: str = "Monday",
        item_id: str = "0 0 * * *",
        time_of_day: str = "00:00",
        timezone: str = "UTC",
        trigger_enabled: bool = True,
        trigger_on_weekends: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_cron",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if timezone is not None:
            self.inputs["timezone"] = timezone
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if time_of_day is not None:
            self.inputs["time_of_day"] = time_of_day
        if trigger_on_weekends is not None:
            self.inputs["trigger_on_weekends"] = trigger_on_weekends
        if day_of_week is not None:
            self.inputs["day_of_week"] = day_of_week
        if day_of_month is not None:
            self.inputs["day_of_month"] = day_of_month
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerCronNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("trigger_slack")
class TriggerSlackNode(Node):
    """
    Slack Trigger

    ## Inputs
    ### Common Inputs
        channel: The name of the Slack channel
        event: The event input
        integration: The integration input
        item_id: The item_id input
        team: The name of the Slack team
        trigger_enabled: Enable/Disable Automation

    ## Outputs
    ### new_message
        attachments: Files attached to the message
        channel_id: Unique identifier of the channel where the message was sent
        channel_name: Name of the channel where the message was sent
        message: The content of the message
        message_id: Unique identifier for the message
        permalink: Direct link to access this message
        timestamp: When the message was sent
        user_id: Unique identifier of the message sender
        user_name: Display name of the message sender
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "channel",
            "helper_text": "The name of the Slack channel",
            "value": "",
            "type": "string",
        },
        {
            "field": "event",
            "helper_text": "The event input",
            "value": "",
            "type": "enum<string>",
        },
        {
            "field": "integration",
            "helper_text": "The integration input",
            "value": None,
            "type": "integration<Slack>",
        },
        {
            "field": "item_id",
            "helper_text": "The item_id input",
            "value": "",
            "type": "string",
        },
        {
            "field": "team",
            "helper_text": "The name of the Slack team",
            "value": "",
            "type": "string",
        },
        {
            "field": "trigger_enabled",
            "helper_text": "Enable/Disable Automation",
            "value": True,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "new_message": {
            "inputs": [],
            "outputs": [
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "The content of the message",
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "Unique identifier for the message",
                },
                {
                    "field": "timestamp",
                    "type": "string",
                    "helper_text": "When the message was sent",
                },
                {
                    "field": "user_name",
                    "type": "string",
                    "helper_text": "Display name of the message sender",
                },
                {
                    "field": "user_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the message sender",
                },
                {
                    "field": "attachments",
                    "type": "vec<file>",
                    "helper_text": "Files attached to the message",
                },
                {
                    "field": "channel_id",
                    "type": "string",
                    "helper_text": "Unique identifier of the channel where the message was sent",
                },
                {
                    "field": "channel_name",
                    "type": "string",
                    "helper_text": "Name of the channel where the message was sent",
                },
                {
                    "field": "permalink",
                    "type": "string",
                    "helper_text": "Direct link to access this message",
                },
            ],
            "name": "new_message",
            "task_name": "tasks.slack.new_message",
            "description": "Triggers when new message appears in the specified channel",
            "label": "New Message",
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["event"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        event: str = "",
        channel: str = "",
        item_id: str = "",
        team: str = "",
        trigger_enabled: bool = True,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["event"] = event

        super().__init__(
            node_type="trigger_slack",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if event is not None:
            self.inputs["event"] = event
        if trigger_enabled is not None:
            self.inputs["trigger_enabled"] = trigger_enabled
        if integration is not None:
            self.inputs["integration"] = integration
        if item_id is not None:
            self.inputs["item_id"] = item_id
        if team is not None:
            self.inputs["team"] = team
        if channel is not None:
            self.inputs["channel"] = channel
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TriggerSlackNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_actions")
class KnowledgeBaseActionsNode(Node):
    """


    ## Inputs
    ### Common Inputs
        sub_type: The sub_type input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "sub_type",
            "helper_text": "The sub_type input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        sub_type: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="knowledge_base_actions",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if sub_type is not None:
            self.inputs["sub_type"] = sub_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseActionsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_sync")
class KnowledgeBaseSyncNode(Node):
    """
    Automatically trigger a sync to the integrations in the selected knowledge base

    ## Inputs
    ### Common Inputs
        knowledge_base: The knowledge base to sync

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "knowledge_base",
            "helper_text": "The knowledge base to sync",
            "value": {},
            "type": "knowledge_base",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        knowledge_base: Any = {},
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="knowledge_base_sync",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if knowledge_base is not None:
            self.inputs["knowledge_base"] = knowledge_base

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseSyncNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("knowledge_base_create")
class KnowledgeBaseCreateNode(Node):
    """
    Dynamically create a Knowledge Base with configured options

    ## Inputs
    ### Common Inputs
        analyze_documents: To analyze document contents and enrich them when parsing
        apify_key: Apify API Key for scraping URLs (optional)
        chunk_overlap: The overlap of the chunks to store in the knowledge base
        chunk_size: The size of the chunks to store in the knowledge base
        collection_name: The name of the collection to store the knowledge base in
        embedding_model: LLM model to use for embedding documents in the KB
        embedding_provider: The embedding provider to use
        file_processing_implementation: The file processing implementation to use
        is_hybrid: Whether to create a hybrid knowledge base
        name: The name of the knowledge base
        precision: The precision to use for the knowledge base
        segmentation_method: The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.
        sharded: Whether to shard the knowledge base
        splitter_method: Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.
        vector_db_provider: The vector database provider to use

    ## Outputs
    ### Common Outputs
        knowledge_base: The created knowledge base
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "analyze_documents",
            "helper_text": "To analyze document contents and enrich them when parsing",
            "value": False,
            "type": "bool",
        },
        {
            "field": "apify_key",
            "helper_text": "Apify API Key for scraping URLs (optional)",
            "value": "",
            "type": "string",
        },
        {
            "field": "chunk_overlap",
            "helper_text": "The overlap of the chunks to store in the knowledge base",
            "value": 0,
            "type": "int32",
        },
        {
            "field": "chunk_size",
            "helper_text": "The size of the chunks to store in the knowledge base",
            "value": 400,
            "type": "int32",
        },
        {
            "field": "collection_name",
            "helper_text": "The name of the collection to store the knowledge base in",
            "value": "text-embedding-3-small",
            "type": "string",
        },
        {
            "field": "embedding_model",
            "helper_text": "LLM model to use for embedding documents in the KB",
            "value": "text-embedding-3-small",
            "type": "string",
        },
        {
            "field": "embedding_provider",
            "helper_text": "The embedding provider to use",
            "value": "openai",
            "type": "string",
        },
        {
            "field": "file_processing_implementation",
            "helper_text": "The file processing implementation to use",
            "value": "default",
            "type": "string",
        },
        {
            "field": "is_hybrid",
            "helper_text": "Whether to create a hybrid knowledge base",
            "value": False,
            "type": "bool",
        },
        {
            "field": "name",
            "helper_text": "The name of the knowledge base",
            "value": "",
            "type": "string",
        },
        {
            "field": "precision",
            "helper_text": "The precision to use for the knowledge base",
            "value": "Float16",
            "type": "string",
        },
        {
            "field": "segmentation_method",
            "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
            "value": "words",
            "type": "enum<string>",
        },
        {
            "field": "sharded",
            "helper_text": "Whether to shard the knowledge base",
            "value": True,
            "type": "bool",
        },
        {
            "field": "splitter_method",
            "helper_text": "Strategy for grouping segmented text into final chunks. 'sentence': groups sentences; 'markdown': respects Markdown structure (headers, code); 'dynamic': optimizes breaks for size using chosen segmentation method.",
            "value": "markdown",
            "type": "enum<string>",
        },
        {
            "field": "vector_db_provider",
            "helper_text": "The vector database provider to use",
            "value": "qdrant",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "knowledge_base", "helper_text": "The created knowledge base"}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "advanced": {
            "inputs": [
                {
                    "field": "segmentation_method",
                    "type": "enum<string>",
                    "value": "words",
                    "helper_text": "The method to break text into units before chunking. 'words': splits by word; 'sentences': splits by sentence boundary; 'paragraphs': splits by blank line/paragraph.",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["splitter_method"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        splitter_method: str = "markdown",
        analyze_documents: bool = False,
        apify_key: str = "",
        chunk_overlap: int = 0,
        chunk_size: int = 400,
        collection_name: str = "text-embedding-3-small",
        embedding_model: str = "text-embedding-3-small",
        embedding_provider: str = "openai",
        file_processing_implementation: str = "default",
        is_hybrid: bool = False,
        name: str = "",
        precision: str = "Float16",
        segmentation_method: str = "words",
        sharded: bool = True,
        vector_db_provider: str = "qdrant",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["splitter_method"] = splitter_method

        super().__init__(
            node_type="knowledge_base_create",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if name is not None:
            self.inputs["name"] = name
        if file_processing_implementation is not None:
            self.inputs["file_processing_implementation"] = (
                file_processing_implementation
            )
        if vector_db_provider is not None:
            self.inputs["vector_db_provider"] = vector_db_provider
        if collection_name is not None:
            self.inputs["collection_name"] = collection_name
        if embedding_model is not None:
            self.inputs["embedding_model"] = embedding_model
        if embedding_provider is not None:
            self.inputs["embedding_provider"] = embedding_provider
        if precision is not None:
            self.inputs["precision"] = precision
        if sharded is not None:
            self.inputs["sharded"] = sharded
        if chunk_size is not None:
            self.inputs["chunk_size"] = chunk_size
        if chunk_overlap is not None:
            self.inputs["chunk_overlap"] = chunk_overlap
        if splitter_method is not None:
            self.inputs["splitter_method"] = splitter_method
        if segmentation_method is not None:
            self.inputs["segmentation_method"] = segmentation_method
        if analyze_documents is not None:
            self.inputs["analyze_documents"] = analyze_documents
        if is_hybrid is not None:
            self.inputs["is_hybrid"] = is_hybrid
        if apify_key is not None:
            self.inputs["apify_key"] = apify_key

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "KnowledgeBaseCreateNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("share_object")
class ShareObjectNode(Node):
    """
    Share a VectorShift object with another user

    ## Inputs
    ### Common Inputs
        object_type: The object_type input
        org_name: Enter the name of the organization of the user (leave blank if not part of org)
        user_identifier: Enter the username or email of the user you want to share with
    ### knowledge_base
        object: The object input

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "object_type",
            "helper_text": "The object_type input",
            "value": "knowledge_base",
            "type": "enum<string>",
        },
        {
            "field": "org_name",
            "helper_text": "Enter the name of the organization of the user (leave blank if not part of org)",
            "value": "",
            "type": "string",
        },
        {
            "field": "user_identifier",
            "helper_text": "Enter the username or email of the user you want to share with",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "knowledge_base": {
            "inputs": [{"field": "object", "type": "knowledge_base"}],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["object_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        object_type: str = "knowledge_base",
        object: Optional[Any] = None,
        org_name: str = "",
        user_identifier: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["object_type"] = object_type

        super().__init__(
            node_type="share_object",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if object_type is not None:
            self.inputs["object_type"] = object_type
        if user_identifier is not None:
            self.inputs["user_identifier"] = user_identifier
        if org_name is not None:
            self.inputs["org_name"] = org_name
        if object is not None:
            self.inputs["object"] = object

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ShareObjectNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("rename_file")
class RenameFileNode(Node):
    """
    Rename an existing file, assigning a new name along with the file extension

    ## Inputs
    ### Common Inputs
        file: The file to rename.
        new_name: The new name of the file, including its extension (e.g., file.txt, file.pdf, file.csv)

    ## Outputs
    ### Common Outputs
        renamed_file: The renamed file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "file",
            "helper_text": "The file to rename.",
            "value": None,
            "type": "file",
        },
        {
            "field": "new_name",
            "helper_text": "The new name of the file, including its extension (e.g., file.txt, file.pdf, file.csv)",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "renamed_file", "helper_text": "The renamed file"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        file: Optional[str] = None,
        new_name: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="rename_file",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if file is not None:
            self.inputs["file"] = file
        if new_name is not None:
            self.inputs["new_name"] = new_name

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "RenameFileNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("start_flag")
class StartFlagNode(Node):
    """
    Start Flag

    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="start_flag",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "StartFlagNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("talk")
class TalkNode(Node):
    """
    Send a given message at a stage in a conversation.

    ## Inputs
    ### Common Inputs
        is_iframe: The is_iframe input
        variant: The variant input
    ### When variant = 'card'
        button: The button input
        content: The text to send to the user.
        description: The card’s description.
        image_url: The image to be sent at this step in the conversation.
        title: The card’s title.
    ### When variant = 'carousel'
        cards: The cards input
    ### When variant = 'message' and is_iframe = False
        content: The text to send to the user.
    ### When variant = 'message' and is_iframe = True
        content: The text to send to the user.
    ### When variant = 'image'
        image_url: The image to be sent at this step in the conversation.

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "is_iframe",
            "helper_text": "The is_iframe input",
            "value": False,
            "type": "bool",
        },
        {
            "field": "variant",
            "helper_text": "The variant input",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "message**false": {
            "title": "Message",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/message",
            "helper_text": "Send a given message at a stage in a conversation.",
            "short_description": "Send a given message at a stage in a conversation.",
            "inputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "The text to send to the user.",
                    "value": "",
                },
                {"field": "variant", "type": "string", "value": "message"},
            ],
            "outputs": [],
        },
        "message**true": {
            "title": "Message",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/message",
            "helper_text": "Send a given message at a stage in a conversation.",
            "short_description": "Send a given iframe at a stage in a conversation.",
            "inputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "The text to send to the user.",
                    "value": "<iframe src='ENTER_URL_HERE' width='320px' height='400px'></iframe>",
                },
                {"field": "variant", "type": "string", "value": "message"},
            ],
            "outputs": [],
            "banner_text": "Please add your url in 'ENTER_URL_HERE'. Iframe width should be 320px",
        },
        "image**(*)": {
            "title": "Image",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/image",
            "helper_text": "Send an image in chat at this step in the conversation.",
            "short_description": "Send an image in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "image"},
                {
                    "field": "image_url",
                    "type": "image",
                    "helper_text": "The image to be sent at this step in the conversation.",
                },
            ],
            "outputs": [],
        },
        "card**(*)": {
            "title": "Card",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/card",
            "helper_text": "Send a card (a component with image, title, description, and button) in chat at this step in the conversation.",
            "short_description": "Send a card (a component with image, title, description, and button) in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "card"},
                {"field": "content", "type": "string", "value": "This is content"},
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "helper_text": "The card’s title.",
                },
                {
                    "field": "description",
                    "type": "string",
                    "value": "",
                    "helper_text": "The card’s description.",
                },
                {
                    "field": "button",
                    "type": "Dict[str, Any]",
                    "value": {
                        "id": "asfkwewkfmdke",
                        "name": "Submit",
                        "url": "https://vectorshift.ai/",
                        "actionType": "Link",
                    },
                    "table": {
                        "name": {"helper_text": "The name of the button."},
                        "url": {
                            "helper_text": "The URL to navigate to when the button is clicked."
                        },
                        "actionType": {
                            "helper_text": "Select the action to occur when the button is clicked."
                        },
                    },
                },
                {
                    "field": "image_url",
                    "type": "image",
                    "helper_text": "The card’s image.",
                },
            ],
            "outputs": [],
        },
        "carousel**(*)": {
            "title": "Carousel",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/talk/carousel",
            "helper_text": "Send a carousel (a gallery of multiple cards) in chat at this step in the conversation.",
            "short_description": "Send a carousel (a gallery of multiple cards) in chat at this step in the conversation.",
            "inputs": [
                {"field": "variant", "type": "string", "value": "carousel"},
                {
                    "field": "cards",
                    "type": "vec<Dict[str, Any] }>",
                    "value": [
                        {
                            "id": "afgj3rf4fmo3i4jrf43rgfm",
                            "title": "Card 1",
                            "description": "This is a description",
                            "image_url": {},
                            "button": {
                                "id": "fref43jrfn",
                                "name": "Submit",
                                "url": "https://vectorshift.ai/",
                                "actionType": "Link",
                            },
                        }
                    ],
                    "table": {
                        "title": {"helper_text": "The card’s title."},
                        "description": {"helper_text": "The card’s description."},
                        "image_url": {"helper_text": "The card’s image URL."},
                        "button": {
                            "name": {"helper_text": "The name of the button."},
                            "url": {
                                "helper_text": "The URL to navigate to when the button is clicked."
                            },
                            "actionType": {
                                "helper_text": "Select the action to occur when the button is clicked."
                            },
                        },
                    },
                },
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["variant", "is_iframe"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variant: str = "",
        is_iframe: bool = False,
        button: Any = {
            "id": "asfkwewkfmdke",
            "name": "Submit",
            "url": "https://vectorshift.ai/",
            "actionType": "Link",
        },
        cards: List[Any] = [
            {
                "id": "afgj3rf4fmo3i4jrf43rgfm",
                "title": "Card 1",
                "description": "This is a description",
                "image_url": {},
                "button": {
                    "id": "fref43jrfn",
                    "name": "Submit",
                    "url": "https://vectorshift.ai/",
                    "actionType": "Link",
                },
            }
        ],
        content: str = "",
        description: str = "",
        image_url: Optional[Any] = None,
        title: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variant"] = variant
        params["is_iframe"] = is_iframe

        super().__init__(
            node_type="talk",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variant is not None:
            self.inputs["variant"] = variant
        if is_iframe is not None:
            self.inputs["is_iframe"] = is_iframe
        if content is not None:
            self.inputs["content"] = content
        if image_url is not None:
            self.inputs["image_url"] = image_url
        if title is not None:
            self.inputs["title"] = title
        if description is not None:
            self.inputs["description"] = description
        if button is not None:
            self.inputs["button"] = button
        if cards is not None:
            self.inputs["cards"] = cards

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "TalkNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("listen")
class ListenNode(Node):
    """
    Listen for user input at a stage in the conversation.

    ## Inputs
    ### Common Inputs
        variant: The variant input
    ### button
        allow_user_message: The allow_user_message input
        buttons: The buttons input
        processed_outputs: The processed_outputs input

    ## Outputs
    ### button
        [processed_outputs]: The [processed_outputs] output
    ### capture
        response: The user message.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "variant",
            "helper_text": "The variant input",
            "value": "",
            "type": "string",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "button": {
            "title": "Button",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/listen/button",
            "helper_text": "Present users with clickable buttons during a conversation at this step and wait for the user to select one.",
            "short_description": "Present users with clickable buttons during a conversation at this step and wait for the user to select one.",
            "inputs": [
                {
                    "field": "buttons",
                    "type": "vec<Dict[str, Any]>",
                    "value": [{"name": "Button 1", "id": "8awi58eyqirm8ik9aq3"}],
                },
                {
                    "field": "processed_outputs",
                    "type": "map<string, string>",
                    "value": {"button_1": "path"},
                },
                {"field": "variant", "type": "string", "value": "button"},
                {"field": "allow_user_message", "type": "bool", "value": False},
            ],
            "outputs": [{"field": "[processed_outputs]", "type": ""}],
        },
        "capture": {
            "title": "Capture",
            "documentation_url": "https://docs.vectorshift.ai/platform/pipelines/conversational/listen/capture",
            "helper_text": "The conversation will pause at this step in the conversation and wait for the user to respond in chat. The user response will be stored in the capture response variable.",
            "short_description": "The conversation will pause at this step in the conversation and wait for the user to respond in chat. The user response will be stored in the capture response variable.",
            "inputs": [{"field": "variant", "type": "string", "value": "capture"}],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "value": "",
                    "helper_text": "The user message.",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["variant"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variant: str = "",
        allow_user_message: bool = False,
        buttons: List[Any] = [{"name": "Button 1", "id": "8awi58eyqirm8ik9aq3"}],
        processed_outputs: Dict[str, str] = {"button_1": "path"},
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variant"] = variant

        super().__init__(
            node_type="listen",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variant is not None:
            self.inputs["variant"] = variant
        if buttons is not None:
            self.inputs["buttons"] = buttons
        if processed_outputs is not None:
            self.inputs["processed_outputs"] = processed_outputs
        if allow_user_message is not None:
            self.inputs["allow_user_message"] = allow_user_message

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ListenNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("add_node")
class AddNodeNode(Node):
    """
    Add Node

    ## Inputs
        None

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = []

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="add_node",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AddNodeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("convert_type")
class ConvertTypeNode(Node):
    """
    Convert value from source type to target type.

    ## Inputs
    ### Common Inputs
        source_type: The type of the value to convert.
        target_type: The type to convert the value to.
        value: The value to convert

    ## Outputs
    ### int32
        converted_value: The converted value in Integer type
    ### float
        converted_value: The converted value in Decimal type
    ### bool
        converted_value: The converted value in Boolean type
    ### timestamp
        converted_value: The converted value in Timestamp type
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "source_type",
            "helper_text": "The type of the value to convert.",
            "value": "string",
            "type": "enum<string>",
        },
        {
            "field": "target_type",
            "helper_text": "The type to convert the value to.",
            "value": "int32",
            "type": "enum<string>",
        },
        {
            "field": "value",
            "helper_text": "The value to convert",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "int32": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "int32",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "int32",
                    "helper_text": "The converted value in Integer type",
                }
            ],
        },
        "float": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "float",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "float",
                    "helper_text": "The converted value in Decimal type",
                }
            ],
        },
        "bool": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "bool",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "bool",
                    "helper_text": "The converted value in Boolean type",
                }
            ],
        },
        "timestamp": {
            "inputs": [
                {
                    "field": "target_type",
                    "type": "enum<string>",
                    "value": "timestamp",
                    "helper_text": "The type to convert the value to.",
                }
            ],
            "outputs": [
                {
                    "field": "converted_value",
                    "type": "timestamp",
                    "helper_text": "The converted value in Timestamp type",
                }
            ],
            "banner_text": "Timestamp format: YYYY-MM-DDTHH:MM:SS",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["target_type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        target_type: str = "int32",
        source_type: str = "string",
        value: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["target_type"] = target_type

        super().__init__(
            node_type="convert_type",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if value is not None:
            self.inputs["value"] = value
        if source_type is not None:
            self.inputs["source_type"] = source_type
        if target_type is not None:
            self.inputs["target_type"] = target_type

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ConvertTypeNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("set_variable")
class SetVariableNode(Node):
    """
    Set a variable to a new value

    ## Inputs
    ### Common Inputs
        scope: The scope of the variable
        variable_id: The ID of the variable to set
        variable_set_id: The ID of the variable set
    ### When variable_set_id = '[variable_sets._id.<A>]' and scope = '<Scope>' and variable_id = '<VariableId>'
        value: The new value to set the variable to

    ## Outputs
        None
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "scope",
            "helper_text": "The scope of the variable",
            "value": "",
            "type": "string",
        },
        {
            "field": "variable_id",
            "helper_text": "The ID of the variable to set",
            "value": "",
            "type": "string",
        },
        {
            "field": "variable_set_id",
            "helper_text": "The ID of the variable set",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "[variable_sets._id.<A>]**<Scope>**<VariableId>": {
            "inputs": [
                {
                    "field": "value",
                    "type": "{<A>.variables.<Scope>.<VariableId>.data_type}",
                    "helper_text": "The new value to set the variable to",
                }
            ],
            "outputs": [],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["variable_set_id", "scope", "variable_id"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        variable_set_id: str = "",
        scope: str = "",
        variable_id: str = "",
        value: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["variable_set_id"] = variable_set_id
        params["scope"] = scope
        params["variable_id"] = variable_id

        super().__init__(
            node_type="set_variable",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if variable_set_id is not None:
            self.inputs["variable_set_id"] = variable_set_id
        if variable_id is not None:
            self.inputs["variable_id"] = variable_id
        if scope is not None:
            self.inputs["scope"] = scope
        if value is not None:
            self.inputs["value"] = value
        if value is not None:
            self.inputs["value"] = value

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "SetVariableNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("list_deduplicator")
class ListDeduplicatorNode(Node):
    """
    Remove duplicate items from a list. Outputs a list of unique items.

    ## Inputs
    ### Common Inputs
        type: The type of the list
    ### <T>
        list: The list to deduplicate

    ## Outputs
    ### <T>
        unique_items: The list of unique items
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "type",
            "helper_text": "The type of the list",
            "value": "string",
            "type": "enum<string>",
        }
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "<T>": {
            "inputs": [
                {
                    "field": "list",
                    "type": "vec<<T>>",
                    "value": [],
                    "helper_text": "The list to deduplicate",
                }
            ],
            "outputs": [
                {
                    "field": "unique_items",
                    "type": "vec<<T>>",
                    "helper_text": "The list of unique items",
                }
            ],
        }
    }

    # List of parameters that affect configuration
    _PARAMS = ["type"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        type: str = "string",
        list: List[Any] = [],
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["type"] = type

        super().__init__(
            node_type="list_deduplicator",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if type is not None:
            self.inputs["type"] = type
        if list is not None:
            self.inputs["list"] = list

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ListDeduplicatorNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("browser_extension")
class BrowserExtensionNode(Node):
    """
    Run a VectorShift workflow using the current page captured by the VectorShift chrome extension as input.

    ## Inputs
    ### Common Inputs
        page_content: The content of the page
        page_html: The HTML of the page
        page_urls: The URLs of the pages
        screenshot: The screenshot of the page
        show_chrome_extension: Deploy to chrome extension
        url: The URL of the page

    ## Outputs
    ### Common Outputs
        page_content: The content of the current page
        page_html: The HTML of the current page
        page_urls: The URLs on the current page
        screenshot: The screenshot of the current page
        url: The URL of the current page
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "page_content",
            "helper_text": "The content of the page",
            "value": "",
            "type": "string",
        },
        {
            "field": "page_html",
            "helper_text": "The HTML of the page",
            "value": "",
            "type": "string",
        },
        {
            "field": "page_urls",
            "helper_text": "The URLs of the pages",
            "value": [],
            "type": "vec<string>",
        },
        {
            "field": "screenshot",
            "helper_text": "The screenshot of the page",
            "value": {},
            "type": "image",
        },
        {
            "field": "show_chrome_extension",
            "helper_text": "Deploy to chrome extension",
            "value": True,
            "type": "bool",
        },
        {
            "field": "url",
            "helper_text": "The URL of the page",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "page_content", "helper_text": "The content of the current page"},
        {"field": "page_html", "helper_text": "The HTML of the current page"},
        {"field": "page_urls", "helper_text": "The URLs on the current page"},
        {"field": "screenshot", "helper_text": "The screenshot of the current page"},
        {"field": "url", "helper_text": "The URL of the current page"},
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        page_content: str = "",
        page_html: str = "",
        page_urls: List[str] = [],
        screenshot: Any = {},
        show_chrome_extension: bool = True,
        url: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="browser_extension",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if url is not None:
            self.inputs["url"] = url
        if page_urls is not None:
            self.inputs["page_urls"] = page_urls
        if page_content is not None:
            self.inputs["page_content"] = page_content
        if page_html is not None:
            self.inputs["page_html"] = page_html
        if screenshot is not None:
            self.inputs["screenshot"] = screenshot
        if show_chrome_extension is not None:
            self.inputs["show_chrome_extension"] = show_chrome_extension

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "BrowserExtensionNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_contacts")
class IntegrationGoogleContactsNode(Node):
    """
    Google Contacts

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### delete_contact
        contact_id: Google Contacts resource ID to delete
    ### read_contact
        contact_id: Google Contacts resource ID to delete
    ### update_contact
        contact_id: Google Contacts resource ID to delete
        email: Email address of the contact
        family_name: Last name of the contact
        given_name: First name of the contact
        organization: Organization name of the contact
        phone: Phone number of the contact
    ### create_contact
        email: Email address of the contact
        family_name: Last name of the contact
        given_name: First name of the contact
        organization: Organization name of the contact
        phone: Phone number of the contact
    ### get_contacts
        limit: Maximum number of contacts to retrieve
        query: Search query to filter contacts

    ## Outputs
    ### read_contact
        contact_data: Contact information as structured data
        contact_id: Google Contacts resource ID
        contact_name: Contact's full display name
        display_name: Contact's display name
        email: Contact's primary email address
        etag: ETag for the contact resource
        family_name: Contact's last name
        full_name: Contact's full name
        given_name: Contact's first name
        organization: Contact's organization name
        phone: Contact's primary phone number
        raw_data: Raw contact data with all fields
        resource_name: Google Contacts resource name
    ### update_contact
        contact_data: Updated contact information as structured data
        contact_id: Google Contacts resource ID
        contact_name: Contact's full display name
        display_name: Contact's display name
        email: Contact's primary email address
        etag: ETag for the contact resource
        family_name: Contact's last name
        full_name: Contact's full name
        given_name: Contact's first name
        organization: Contact's organization name
        phone: Contact's primary phone number
        raw_data: Raw contact data with all fields
        resource_name: Google Contacts resource name
        success: Success status of the operation
    ### create_contact
        contact_id: Google Contacts resource ID
        success: Success status of the operation
    ### get_contacts
        contact_ids: Array of contact IDs
        contacts: List of contacts as structured data
        display_names: Array of display names
        emails: Array of email addresses
        family_names: Array of family names
        given_names: Array of given names
        phones: Array of phone numbers
        total_count: Total number of contacts found
    ### delete_contact
        message: Confirmation message
        success: Success status of the operation
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Contacts>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "create_contact": {
            "inputs": [
                {
                    "field": "given_name",
                    "type": "string",
                    "value": "",
                    "label": "Given Name",
                    "placeholder": "John",
                    "helper_text": "First name of the contact",
                },
                {
                    "field": "family_name",
                    "type": "string",
                    "value": "",
                    "label": "Family Name",
                    "placeholder": "Doe",
                    "helper_text": "Last name of the contact",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@example.com",
                    "helper_text": "Email address of the contact",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Phone number of the contact",
                },
                {
                    "field": "organization",
                    "type": "string",
                    "value": "",
                    "label": "Organization",
                    "placeholder": "Acme Corp",
                    "helper_text": "Organization name of the contact",
                },
            ],
            "outputs": [
                {
                    "field": "contact_id",
                    "type": "string",
                    "helper_text": "Google Contacts resource ID",
                },
                {
                    "field": "success",
                    "type": "string",
                    "helper_text": "Success status of the operation",
                },
            ],
            "name": "create_contact",
            "task_name": "tasks.google_contacts.create_contact",
            "description": "Create a new contact",
            "label": "Create Contact",
            "variant": "default_integration_nodes",
            "inputs_sort_order": [
                "given_name",
                "family_name",
                "email",
                "phone",
                "organization",
            ],
            "required": ["given_name"],
        },
        "delete_contact": {
            "inputs": [
                {
                    "field": "contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact",
                    "placeholder": "people/c123456789",
                    "helper_text": "Google Contacts resource ID to delete",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=contact_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "string",
                    "helper_text": "Success status of the operation",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Confirmation message",
                },
            ],
            "name": "delete_contact",
            "task_name": "tasks.google_contacts.delete_contact",
            "description": "Delete an existing contact",
            "label": "Delete Contact",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["contact_id"],
            "required": ["contact_id"],
        },
        "read_contact": {
            "inputs": [
                {
                    "field": "contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact",
                    "placeholder": "people/c123456789",
                    "helper_text": "Google Contacts resource ID to retrieve",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=contact_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                }
            ],
            "outputs": [
                {
                    "field": "contact_data",
                    "type": "vec<Dict[str, Any]>",
                    "helper_text": "Contact information as structured data",
                },
                {
                    "field": "resource_name",
                    "type": "string",
                    "helper_text": "Google Contacts resource name",
                },
                {
                    "field": "contact_id",
                    "type": "string",
                    "helper_text": "Google Contacts resource ID",
                },
                {
                    "field": "given_name",
                    "type": "string",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "family_name",
                    "type": "string",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "Contact's display name",
                },
                {
                    "field": "contact_name",
                    "type": "string",
                    "helper_text": "Contact's full display name",
                },
                {
                    "field": "full_name",
                    "type": "string",
                    "helper_text": "Contact's full name",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "Contact's primary email address",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "helper_text": "Contact's primary phone number",
                },
                {
                    "field": "organization",
                    "type": "string",
                    "helper_text": "Contact's organization name",
                },
                {
                    "field": "etag",
                    "type": "string",
                    "helper_text": "ETag for the contact resource",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw contact data with all fields",
                },
            ],
            "name": "read_contact",
            "task_name": "tasks.google_contacts.read_contact",
            "description": "Read a specific contact by ID",
            "label": "Read Contact",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["contact_id"],
            "required": ["contact_id"],
        },
        "get_contacts": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "string",
                    "value": "",
                    "label": "Limit",
                    "placeholder": "100",
                    "helper_text": "Maximum number of contacts to retrieve",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "label": "Query",
                    "placeholder": "john",
                    "helper_text": "Search query to filter contacts",
                },
            ],
            "outputs": [
                {
                    "field": "contacts",
                    "type": "vec<Dict[str, Any]>",
                    "helper_text": "List of contacts as structured data",
                },
                {
                    "field": "total_count",
                    "type": "string",
                    "helper_text": "Total number of contacts found",
                },
                {
                    "field": "contact_ids",
                    "type": "vec<string>",
                    "helper_text": "Array of contact IDs",
                },
                {
                    "field": "given_names",
                    "type": "vec<string>",
                    "helper_text": "Array of given names",
                },
                {
                    "field": "family_names",
                    "type": "vec<string>",
                    "helper_text": "Array of family names",
                },
                {
                    "field": "display_names",
                    "type": "vec<string>",
                    "helper_text": "Array of display names",
                },
                {
                    "field": "emails",
                    "type": "vec<string>",
                    "helper_text": "Array of email addresses",
                },
                {
                    "field": "phones",
                    "type": "vec<string>",
                    "helper_text": "Array of phone numbers",
                },
            ],
            "name": "get_contacts",
            "task_name": "tasks.google_contacts.get_contacts",
            "description": "Retrieve contacts with optional filtering",
            "label": "Get Contacts",
            "variant": "default_integration_nodes",
            "inputs_sort_order": ["limit", "query"],
        },
        "update_contact": {
            "inputs": [
                {
                    "field": "contact_id",
                    "type": "string",
                    "value": "",
                    "label": "Contact",
                    "placeholder": "people/c123456789",
                    "helper_text": "Google Contacts resource ID to update",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=contact_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "given_name",
                    "type": "string",
                    "value": "",
                    "label": "Given Name",
                    "placeholder": "John",
                    "helper_text": "Updated first name of the contact",
                },
                {
                    "field": "family_name",
                    "type": "string",
                    "value": "",
                    "label": "Family Name",
                    "placeholder": "Doe",
                    "helper_text": "Updated last name of the contact",
                },
                {
                    "field": "email",
                    "type": "string",
                    "value": "",
                    "label": "Email",
                    "placeholder": "john@example.com",
                    "helper_text": "Updated email address of the contact",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "value": "",
                    "label": "Phone",
                    "placeholder": "+1-555-123-4567",
                    "helper_text": "Updated phone number of the contact",
                },
                {
                    "field": "organization",
                    "type": "string",
                    "value": "",
                    "label": "Organization",
                    "placeholder": "Acme Corp",
                    "helper_text": "Updated organization name of the contact",
                },
            ],
            "outputs": [
                {
                    "field": "contact_data",
                    "type": "string",
                    "helper_text": "Updated contact information as structured data",
                },
                {
                    "field": "resource_name",
                    "type": "string",
                    "helper_text": "Google Contacts resource name",
                },
                {
                    "field": "contact_id",
                    "type": "string",
                    "helper_text": "Google Contacts resource ID",
                },
                {
                    "field": "given_name",
                    "type": "string",
                    "helper_text": "Contact's first name",
                },
                {
                    "field": "family_name",
                    "type": "string",
                    "helper_text": "Contact's last name",
                },
                {
                    "field": "display_name",
                    "type": "string",
                    "helper_text": "Contact's display name",
                },
                {
                    "field": "contact_name",
                    "type": "string",
                    "helper_text": "Contact's full display name",
                },
                {
                    "field": "full_name",
                    "type": "string",
                    "helper_text": "Contact's full name",
                },
                {
                    "field": "email",
                    "type": "string",
                    "helper_text": "Contact's primary email address",
                },
                {
                    "field": "phone",
                    "type": "string",
                    "helper_text": "Contact's primary phone number",
                },
                {
                    "field": "organization",
                    "type": "string",
                    "helper_text": "Contact's organization name",
                },
                {
                    "field": "etag",
                    "type": "string",
                    "helper_text": "ETag for the contact resource",
                },
                {
                    "field": "success",
                    "type": "string",
                    "helper_text": "Success status of the operation",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw contact data with all fields",
                },
            ],
            "name": "update_contact",
            "task_name": "tasks.google_contacts.update_contact",
            "description": "Update an existing contact",
            "label": "Update Contact",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "contact_id",
                "given_name",
                "family_name",
                "email",
                "phone",
                "organization",
            ],
            "required": ["contact_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        contact_id: str = "",
        email: str = "",
        family_name: str = "",
        given_name: str = "",
        limit: str = "",
        organization: str = "",
        phone: str = "",
        query: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_contacts",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if given_name is not None:
            self.inputs["given_name"] = given_name
        if family_name is not None:
            self.inputs["family_name"] = family_name
        if email is not None:
            self.inputs["email"] = email
        if phone is not None:
            self.inputs["phone"] = phone
        if organization is not None:
            self.inputs["organization"] = organization
        if contact_id is not None:
            self.inputs["contact_id"] = contact_id
        if limit is not None:
            self.inputs["limit"] = limit
        if query is not None:
            self.inputs["query"] = query
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleContactsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_big_query")
class IntegrationGoogleBigQueryNode(Node):
    """
    Google BigQuery

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### When action = 'insert_rows' and endpoint_0 = '[endpoint_0.<A>]'
        [<A>.inputs]: The [<A>.inputs] input
    ### When action = 'insert_rows'
        bigquery_table_id: The ID of the table to insert data into
        dataset_id: The ID of the dataset containing the table
        ignore_unknown_values: Ignore values that do not match the table schema
        project_id: The Google Cloud project ID
        skip_invalid_rows: Skip rows that contain invalid data
    ### When action = 'execute_query'
        dry_run: Validate query without executing
        project_id: The Google Cloud project ID
        query: SQL query to execute
        timeout_ms: Query timeout in milliseconds
        use_legacy_sql: Use Legacy SQL syntax

    ## Outputs
    ### When action = 'execute_query'
        cache_hit: Whether the query result was served from cache
        job_id: ID of the query job
        raw_data: Raw BigQuery API response in JSON format
        rows: Query results in JSON format
        schema: Result schema in JSON format
        total_bytes_processed: Total bytes processed by the query
        total_rows: Total number of rows returned
    ### When action = 'insert_rows'
        insert_errors: Array of any errors that occurred during insertion
        inserted_rows: Number of rows that were inserted
        raw_data: Raw BigQuery API response in JSON format
        success: Whether the insertion was successful
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google BigQuery>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "execute_query**(*)": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The Google Cloud project ID",
                    "label": "Project ID",
                    "placeholder": "Select a project",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "helper_text": "SQL query to execute",
                    "label": "Query",
                    "placeholder": "SELECT * FROM `project.dataset.table` LIMIT 10",
                    "order": 4,
                },
                {
                    "field": "use_legacy_sql",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Use Legacy SQL syntax",
                    "label": "Use Legacy SQL",
                    "order": 5,
                },
                {
                    "field": "dry_run",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Validate query without executing",
                    "label": "Dry Run",
                    "order": 6,
                },
                {
                    "field": "timeout_ms",
                    "type": "int32",
                    "value": 30000,
                    "helper_text": "Query timeout in milliseconds",
                    "label": "Timeout (ms)",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "job_id",
                    "type": "string",
                    "helper_text": "ID of the query job",
                },
                {
                    "field": "rows",
                    "type": "string",
                    "helper_text": "Query results in JSON format",
                },
                {
                    "field": "schema",
                    "type": "string",
                    "helper_text": "Result schema in JSON format",
                },
                {
                    "field": "total_rows",
                    "type": "string",
                    "helper_text": "Total number of rows returned",
                },
                {
                    "field": "total_bytes_processed",
                    "type": "string",
                    "helper_text": "Total bytes processed by the query",
                },
                {
                    "field": "cache_hit",
                    "type": "bool",
                    "helper_text": "Whether the query result was served from cache",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw BigQuery API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "execute_query",
            "task_name": "tasks.google_big_query.run_query",
            "description": "Execute a SQL query in Google BigQuery",
            "label": "Execute Query",
            "inputs_sort_order": [
                "integration",
                "action",
                "project_id",
                "query",
                "use_legacy_sql",
                "dry_run",
                "timeout_ms",
            ],
            "required": ["project_id", "query"],
        },
        "insert_rows**(*)": {
            "inputs": [
                {
                    "field": "project_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The Google Cloud project ID",
                    "label": "Project ID",
                    "placeholder": "Select a project",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=project_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "dataset_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the dataset containing the table",
                    "label": "Dataset ID",
                    "placeholder": "Select a dataset",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=dataset_id&project_id={inputs.project_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "bigquery_table_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the table to insert data into",
                    "label": "Table ID",
                    "placeholder": "Select a table",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=bigquery_table_id&project_id={inputs.project_id}&dataset_id={inputs.dataset_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 5,
                },
                {
                    "field": "ignore_unknown_values",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Ignore values that do not match the table schema",
                    "label": "Ignore Unknown Values",
                    "order": 6,
                },
                {
                    "field": "skip_invalid_rows",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Skip rows that contain invalid data",
                    "label": "Skip Invalid Rows",
                    "order": 7,
                },
            ],
            "outputs": [
                {
                    "field": "insert_errors",
                    "type": "array",
                    "helper_text": "Array of any errors that occurred during insertion",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the insertion was successful",
                },
                {
                    "field": "inserted_rows",
                    "type": "int32",
                    "helper_text": "Number of rows that were inserted",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw BigQuery API response in JSON format",
                },
            ],
            "variant": "common_integration_nodes",
            "name": "insert_rows",
            "task_name": "tasks.google_big_query.insert_rows",
            "description": "Insert rows into a table in Google BigQuery",
            "label": "Insert Rows",
            "inputs_sort_order": [
                "integration",
                "action",
                "project_id",
                "dataset_id",
                "bigquery_table_id",
                "ignore_unknown_values",
                "skip_invalid_rows",
            ],
            "required": ["project_id", "dataset_id", "bigquery_table_id"],
        },
        "insert_rows**[endpoint_0.<A>]": {
            "inputs": [{"field": "[<A>.inputs]", "type": ""}],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "endpoint_0"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        bigquery_table_id: str = "",
        dataset_id: str = "",
        dry_run: bool = False,
        ignore_unknown_values: bool = False,
        project_id: str = "",
        query: str = "",
        skip_invalid_rows: bool = False,
        timeout_ms: int = 30000,
        use_legacy_sql: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_big_query",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if project_id is not None:
            self.inputs["project_id"] = project_id
        if query is not None:
            self.inputs["query"] = query
        if use_legacy_sql is not None:
            self.inputs["use_legacy_sql"] = use_legacy_sql
        if dry_run is not None:
            self.inputs["dry_run"] = dry_run
        if timeout_ms is not None:
            self.inputs["timeout_ms"] = timeout_ms
        if dataset_id is not None:
            self.inputs["dataset_id"] = dataset_id
        if bigquery_table_id is not None:
            self.inputs["bigquery_table_id"] = bigquery_table_id
        if ignore_unknown_values is not None:
            self.inputs["ignore_unknown_values"] = ignore_unknown_values
        if skip_invalid_rows is not None:
            self.inputs["skip_invalid_rows"] = skip_invalid_rows
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleBigQueryNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("excel_cell_reader")
class ExcelCellReaderNode(Node):
    """
    Read the contents from a Excel cell and output the value.

    ## Inputs
    ### Common Inputs
        cell_index: The cell to read from.
        read_formatting: Whether to read the formatting of the cell.
        selected_file: The file to read from.
        sheet: The sheet to read from.

    ## Outputs
    ### Common Outputs
        cell_value: The value of the cell
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "cell_index",
            "helper_text": "The cell to read from.",
            "value": "",
            "type": "string",
        },
        {
            "field": "read_formatting",
            "helper_text": "Whether to read the formatting of the cell.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "selected_file",
            "helper_text": "The file to read from.",
            "value": None,
            "type": "file",
        },
        {
            "field": "sheet",
            "helper_text": "The sheet to read from.",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "cell_value", "helper_text": "The value of the cell"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        cell_index: str = "",
        read_formatting: bool = False,
        selected_file: Optional[str] = None,
        sheet: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="excel_cell_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if sheet is not None:
            self.inputs["sheet"] = sheet
        if cell_index is not None:
            self.inputs["cell_index"] = cell_index
        if read_formatting is not None:
            self.inputs["read_formatting"] = read_formatting

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ExcelCellReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("excel_cell_writer")
class ExcelCellWriterNode(Node):
    """
    Write a value to a Excel cell.

    ## Inputs
    ### Common Inputs
        cell_index: The cell to read from.
        cell_value: The value to write to the cell.
        selected_file: The file to read from.
        set_fill_color: Whether to set the fill color of the cell.
        set_horizontal_alignment: Whether to set the horizontal alignment of the cell.
        set_vertical_alignment: Whether to set the vertical alignment of the cell.
        sheet: The sheet to read from.
    ### When set_fill_color = True
        fill_color: The fill color of the cell.
    ### When set_horizontal_alignment = True
        horizontal_alignment: The horizontal alignment of the cell.
    ### When set_vertical_alignment = True
        vertical_alignment: The vertical alignment of the cell.

    ## Outputs
    ### Common Outputs
        output_file: The updated Excel file.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "cell_index",
            "helper_text": "The cell to read from.",
            "value": "",
            "type": "string",
        },
        {
            "field": "cell_value",
            "helper_text": "The value to write to the cell.",
            "value": "",
            "type": "string",
        },
        {
            "field": "selected_file",
            "helper_text": "The file to read from.",
            "value": None,
            "type": "file",
        },
        {
            "field": "set_fill_color",
            "helper_text": "Whether to set the fill color of the cell.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "set_horizontal_alignment",
            "helper_text": "Whether to set the horizontal alignment of the cell.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "set_vertical_alignment",
            "helper_text": "Whether to set the vertical alignment of the cell.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "sheet",
            "helper_text": "The sheet to read from.",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output_file", "helper_text": "The updated Excel file."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)**(*)": {
            "inputs": [
                {
                    "field": "vertical_alignment",
                    "type": "enum<string>",
                    "value": "bottom",
                    "helper_text": "The vertical alignment of the cell.",
                    "label": "Vertical Alignment",
                    "agent_field_type": "dynamic",
                }
            ],
            "outputs": [],
        },
        "(*)**true**(*)": {
            "inputs": [
                {
                    "field": "horizontal_alignment",
                    "type": "enum<string>",
                    "value": "left",
                    "helper_text": "The horizontal alignment of the cell.",
                    "label": "Horizontal Alignment",
                    "agent_field_type": "dynamic",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**true": {
            "inputs": [
                {
                    "field": "fill_color",
                    "type": "string",
                    "value": "FFFFFF",
                    "helper_text": "The fill color of the cell.",
                    "label": "Fill Color",
                    "agent_field_type": "dynamic",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["set_vertical_alignment", "set_horizontal_alignment", "set_fill_color"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        set_vertical_alignment: bool = False,
        set_horizontal_alignment: bool = False,
        set_fill_color: bool = False,
        cell_index: str = "",
        cell_value: str = "",
        fill_color: str = "FFFFFF",
        horizontal_alignment: str = "left",
        selected_file: Optional[str] = None,
        sheet: str = "",
        vertical_alignment: str = "bottom",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["set_vertical_alignment"] = set_vertical_alignment
        params["set_horizontal_alignment"] = set_horizontal_alignment
        params["set_fill_color"] = set_fill_color

        super().__init__(
            node_type="excel_cell_writer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if sheet is not None:
            self.inputs["sheet"] = sheet
        if cell_index is not None:
            self.inputs["cell_index"] = cell_index
        if cell_value is not None:
            self.inputs["cell_value"] = cell_value
        if set_vertical_alignment is not None:
            self.inputs["set_vertical_alignment"] = set_vertical_alignment
        if set_horizontal_alignment is not None:
            self.inputs["set_horizontal_alignment"] = set_horizontal_alignment
        if set_fill_color is not None:
            self.inputs["set_fill_color"] = set_fill_color
        if vertical_alignment is not None:
            self.inputs["vertical_alignment"] = vertical_alignment
        if horizontal_alignment is not None:
            self.inputs["horizontal_alignment"] = horizontal_alignment
        if fill_color is not None:
            self.inputs["fill_color"] = fill_color

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ExcelCellWriterNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("excel_file_reader")
class ExcelFileReaderNode(Node):
    """
    Read the contents from a Excel file and output the value.

    ## Inputs
    ### Common Inputs
        read_formatting: Whether to read the formatting of the cell.
        read_formula: Whether to read the formula of the cell.
        read_single_sheet: Whether to read a single sheet from the Excel file.
        selected_file: The file to read from.
    ### When read_single_sheet = True
        sheet: The sheet to read from.

    ## Outputs
    ### When read_single_sheet = True
        file_content: The text of the selected sheet in the Excel file
    ### When read_single_sheet = False
        file_content: The text of all sheets in the Excel file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "read_formatting",
            "helper_text": "Whether to read the formatting of the cell.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "read_formula",
            "helper_text": "Whether to read the formula of the cell.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "read_single_sheet",
            "helper_text": "Whether to read a single sheet from the Excel file.",
            "value": True,
            "type": "bool",
        },
        {
            "field": "selected_file",
            "helper_text": "The file to read from.",
            "value": None,
            "type": "file",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true": {
            "inputs": [
                {
                    "field": "sheet",
                    "type": "string",
                    "value": "",
                    "helper_text": "The sheet to read from.",
                    "label": "Sheet",
                    "agent_field_type": "dynamic",
                }
            ],
            "outputs": [
                {
                    "field": "file_content",
                    "type": "string",
                    "helper_text": "The text of the selected sheet in the Excel file",
                    "label": "Text",
                }
            ],
        },
        "false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "file_content",
                    "type": "string",
                    "helper_text": "The text of all sheets in the Excel file",
                    "label": "Text",
                }
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["read_single_sheet"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        read_single_sheet: bool = True,
        read_formatting: bool = False,
        read_formula: bool = False,
        selected_file: Optional[str] = None,
        sheet: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["read_single_sheet"] = read_single_sheet

        super().__init__(
            node_type="excel_file_reader",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if read_single_sheet is not None:
            self.inputs["read_single_sheet"] = read_single_sheet
        if read_formatting is not None:
            self.inputs["read_formatting"] = read_formatting
        if read_formula is not None:
            self.inputs["read_formula"] = read_formula
        if sheet is not None:
            self.inputs["sheet"] = sheet

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ExcelFileReaderNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_docs")
class IntegrationGoogleDocsNode(Node):
    """
    Google Docs

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your Google Docs account
    ### When action = 'create_document'
        content: Initial content for the document (optional)
        title: Title of the document
    ### When action = 'update_document'
        content: Initial content for the document (optional)
        file_id: Select a File to read
        operation: How to handle the content (replace, append, prepend)
        title: Title of the document
    ### When action = 'get_documents' and use_date = True and use_exact_date = False
        date_range: pick the relative date range
    ### When action = 'read_doc_url'
        doc_url: Enter the public URL of the Google Doc
    ### When action = 'get_documents' and use_date = True and use_exact_date = True
        exact_date: Pick the start and end dates
    ### When action = 'read_doc'
        file_id: Select a File to read
    ### When action = 'write_to_doc'
        file_id: Select a File to read
        text: The text that will be added to the File
    ### When action = 'delete_document'
        file_id: Select a File to read
    ### When action = 'get_document_info'
        file_id: Select a File to read
    ### When action = 'get_document_revisions'
        file_id: Select a File to read
    ### When action = 'get_documents'
        folder_id: ID of the folder to search in (optional)
        order_by: How to order the results
        query: Search query to filter documents by name
        shared_with_me: Include documents shared with me
        use_date: Toggle to use dates
    ### When action = 'get_documents' and use_date = False
        limit: Specify the number of documents to fetch
    ### When action = 'get_documents' and use_date = True
        use_exact_date: Switch between exact date range and relative dates

    ## Outputs
    ### When action = 'read_doc_url'
        content: HTML body of the Google Doc
    ### When action = 'update_document'
        content: Updated content of the document
        document_id: ID of the updated document
        document_title: Title of the updated document
        raw_data: Raw updated document data in JSON format
        revision_id: New revision ID of the document
    ### When action = 'create_document'
        created_time: Creation timestamp of the document
        document_id: ID of the created document
        document_title: Title of the created document
        document_url: URL of the created document
        raw_data: Raw document data in JSON format
    ### When action = 'get_document_info'
        created_time: Creation time of the document
        document_id: ID of the document
        document_title: Title of the document
        document_url: URL of the document
        modified_time: Last modification time of the document
        owners: Document owners in JSON format
        raw_data: Raw document info in JSON format
        shared: Whether the document is shared
    ### When action = 'get_documents'
        created_times: List of document creation times
        document_count: Number of documents found
        document_ids: List of document IDs
        document_titles: List of document titles
        document_urls: List of document URLs
        documents: Documents data in JSON format
        modified_times: List of document modification times
        raw_data: Raw API response data in JSON format
    ### When action = 'delete_document'
        message: Success message
        raw_data: Raw response data in JSON format
        success: Whether the document was successfully deleted
    ### When action = 'get_document_revisions'
        raw_data: Raw API response data in JSON format
        revision_ids: List of revision IDs
        revision_times: List of revision timestamps
        revisions: Document revisions in JSON format
    ### When action = 'read_doc'
        text: The text content of the selected file
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your Google Docs account",
            "value": None,
            "type": "integration<Google Docs>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "read_doc**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to read",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "text",
                    "type": "string",
                    "helper_text": "The text content of the selected file",
                }
            ],
            "variant": "common_integration_file_nodes",
            "name": "read_doc",
            "task_name": "tasks.google_docs.read_doc",
            "description": "Retrieves and returns the plain text content of a user-selected Google Doc.",
            "label": "Read Google Doc",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
        "write_to_doc**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to append the text to",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                },
                {
                    "field": "text",
                    "type": "string",
                    "value": "",
                    "label": "Text",
                    "placeholder": "Hello World!",
                    "helper_text": "The text that will be added to the File",
                },
            ],
            "outputs": [],
            "variant": "common_integration_file_nodes",
            "name": "write_to_doc",
            "task_name": "tasks.google_docs.write_to_doc",
            "description": "Append text to an existing document",
            "label": "Append Text to Document",
            "inputs_sort_order": ["integration", "action", "file_id", "text"],
        },
        "read_doc_url**(*)**(*)": {
            "inputs": [
                {
                    "field": "doc_url",
                    "type": "string",
                    "value": "",
                    "label": "Google Doc URL",
                    "helper_text": "Enter the public URL of the Google Doc",
                    "placeholder": "Enter the public URL of the Google Doc",
                }
            ],
            "outputs": [
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "HTML body of the Google Doc",
                }
            ],
            "variant": "default_integration_nodes",
            "banner_text": 'Ensure that the Google Docs\'s permissions is set to "Anyone with the Link"',
            "name": "read_doc_url",
            "task_name": "tasks.google_docs.read_doc_url",
            "description": "Download the contents of a publicly accessible Google Docs file using its shared URL",
            "label": "Read from Doc URL",
            "inputs_sort_order": ["integration", "action", "doc_url"],
        },
        "create_document**(*)**(*)": {
            "inputs": [
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Title of the document",
                    "label": "Document Title",
                    "placeholder": "My New Document",
                },
                {
                    "field": "content",
                    "type": "string",
                    "value": "",
                    "helper_text": "Initial content for the document (optional)",
                    "label": "Initial Content",
                    "placeholder": "Enter initial document content...",
                },
            ],
            "outputs": [
                {
                    "field": "document_id",
                    "type": "string",
                    "helper_text": "ID of the created document",
                },
                {
                    "field": "document_title",
                    "type": "string",
                    "helper_text": "Title of the created document",
                },
                {
                    "field": "document_url",
                    "type": "string",
                    "helper_text": "URL of the created document",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation timestamp of the document",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw document data in JSON format",
                },
            ],
            "variant": "default_integration_nodes",
            "hidden": True,
            "name": "create_document",
            "task_name": "tasks.google_docs.create_document",
            "description": "Create a new Google Docs document",
            "label": "Create Document",
            "inputs_sort_order": ["integration", "action", "title", "content"],
        },
        "update_document**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to update",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "helper_text": "New title for the document",
                    "label": "Document Title",
                    "placeholder": "Updated document title",
                },
                {
                    "field": "content",
                    "type": "string",
                    "value": "",
                    "helper_text": "New content for the document",
                    "label": "Document Content",
                    "placeholder": "Enter updated content...",
                },
                {
                    "field": "operation",
                    "type": "string",
                    "value": "replace",
                    "helper_text": "How to handle the content (replace, append, prepend)",
                    "label": "Operation",
                    "placeholder": "replace",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Replace", "value": "replace"},
                            {"label": "Append", "value": "append"},
                            {"label": "Prepend", "value": "prepend"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "document_id",
                    "type": "string",
                    "helper_text": "ID of the updated document",
                },
                {
                    "field": "document_title",
                    "type": "string",
                    "helper_text": "Title of the updated document",
                },
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "Updated content of the document",
                },
                {
                    "field": "revision_id",
                    "type": "string",
                    "helper_text": "New revision ID of the document",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw updated document data in JSON format",
                },
            ],
            "variant": "common_integration_file_nodes",
            "hidden": True,
            "name": "update_document",
            "task_name": "tasks.google_docs.update_document",
            "description": "Update the title and/or content of an existing Google Docs document",
            "label": "Update Document",
            "inputs_sort_order": [
                "integration",
                "action",
                "file_id",
                "title",
                "content",
                "operation",
            ],
        },
        "delete_document**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to delete",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the document was successfully deleted",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw response data in JSON format",
                },
            ],
            "name": "delete_document",
            "hidden": True,
            "task_name": "tasks.google_docs.delete_document",
            "description": "Delete an existing Google Docs document",
            "label": "Delete Document",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
        "get_documents**(*)**(*)": {
            "inputs": [
                {
                    "field": "folder_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "ID of the folder to search in (optional)",
                    "label": "Folder ID",
                    "placeholder": "1a2b3c4d5e6f7g8h9i",
                },
                {
                    "field": "query",
                    "type": "string",
                    "value": "",
                    "helper_text": "Search query to filter documents by name",
                    "label": "Search Query",
                    "placeholder": "document name",
                },
                {
                    "field": "shared_with_me",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include documents shared with me",
                    "label": "Include Shared Documents",
                },
                {
                    "field": "order_by",
                    "type": "string",
                    "value": "modifiedTime desc",
                    "helper_text": "How to order the results",
                    "label": "Order By",
                    "placeholder": "modifiedTime desc",
                },
                {
                    "field": "use_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Date",
                    "helper_text": "Toggle to use dates",
                },
            ],
            "outputs": [
                {
                    "field": "documents",
                    "type": "string",
                    "helper_text": "Documents data in JSON format",
                },
                {
                    "field": "document_count",
                    "type": "int32",
                    "helper_text": "Number of documents found",
                },
                {
                    "field": "document_ids",
                    "type": "vec<string>",
                    "helper_text": "List of document IDs",
                },
                {
                    "field": "document_titles",
                    "type": "vec<string>",
                    "helper_text": "List of document titles",
                },
                {
                    "field": "document_urls",
                    "type": "vec<string>",
                    "helper_text": "List of document URLs",
                },
                {
                    "field": "created_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of document creation times",
                },
                {
                    "field": "modified_times",
                    "type": "vec<string>",
                    "helper_text": "List of document modification times",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "variant": "get_integration_nodes",
            "hidden": True,
            "name": "get_documents",
            "task_name": "tasks.google_docs.get_documents",
            "description": "Get a list of Google Docs documents with filtering options",
            "label": "Get Documents",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_id",
                "query",
                "shared_with_me",
                "order_by",
                "use_date",
                "use_exact_date",
                "date_range",
                "exact_date",
                "limit",
            ],
        },
        "get_documents**false**(*)": {
            "inputs": [
                {
                    "field": "limit",
                    "type": "int32",
                    "value": 100,
                    "show_date_range": True,
                    "label": "Number of Documents",
                    "helper_text": "Specify the number of documents to fetch",
                }
            ],
            "outputs": [],
        },
        "get_documents**true**(*)": {
            "inputs": [
                {
                    "field": "use_exact_date",
                    "type": "bool",
                    "value": False,
                    "show_date_range": True,
                    "label": "Use Exact Date",
                    "helper_text": "Switch between exact date range and relative dates",
                }
            ],
            "outputs": [],
        },
        "get_documents**true**false": {
            "inputs": [
                {
                    "field": "date_range",
                    "type": "Dict[str, Any]",
                    "value": {
                        "date_type": "Last",
                        "date_value": 1,
                        "date_period": "Months",
                    },
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Date Range",
                    "placeholder": "last 3 days",
                    "helper_text": "pick the relative date range",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_documents**true**true": {
            "inputs": [
                {
                    "field": "exact_date",
                    "type": "Dict[str, Any]",
                    "value": {"start": "", "end": ""},
                    "show_data_range": True,
                    "hidden": True,
                    "label": "Exact Date",
                    "placeholder": "2021-01-01 12:00:00",
                    "helper_text": "Pick the start and end dates",
                    "component": {"type": "date_range"},
                }
            ],
            "outputs": [],
        },
        "get_document_info**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to get info for",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "document_id",
                    "type": "string",
                    "helper_text": "ID of the document",
                },
                {
                    "field": "document_title",
                    "type": "string",
                    "helper_text": "Title of the document",
                },
                {
                    "field": "document_url",
                    "type": "string",
                    "helper_text": "URL of the document",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the document",
                },
                {
                    "field": "modified_time",
                    "type": "string",
                    "helper_text": "Last modification time of the document",
                },
                {
                    "field": "owners",
                    "type": "string",
                    "helper_text": "Document owners in JSON format",
                },
                {
                    "field": "shared",
                    "type": "bool",
                    "helper_text": "Whether the document is shared",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw document info in JSON format",
                },
            ],
            "name": "get_document_info",
            "hidden": True,
            "task_name": "tasks.google_docs.get_document_info",
            "description": "Get detailed information about a Google Docs document",
            "label": "Get Document Info",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
        "get_document_revisions**(*)**(*)": {
            "inputs": [
                {
                    "field": "file_id",
                    "type": "string",
                    "hidden": True,
                    "label": "File",
                    "helper_text": "Select a File to get revisions for",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "revisions",
                    "type": "string",
                    "helper_text": "Document revisions in JSON format",
                },
                {
                    "field": "revision_ids",
                    "type": "vec<string>",
                    "helper_text": "List of revision IDs",
                },
                {
                    "field": "revision_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of revision timestamps",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw API response data in JSON format",
                },
            ],
            "name": "get_document_revisions",
            "hidden": True,
            "task_name": "tasks.google_docs.get_document_revisions",
            "description": "Get all revisions for a Google Docs document",
            "label": "Get Document Revisions",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": ["integration", "action", "file_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action", "use_date", "use_exact_date"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        use_date: bool = False,
        use_exact_date: bool = False,
        content: str = "",
        doc_url: str = "",
        exact_date: Any = {"start": "", "end": ""},
        file_id: Optional[str] = None,
        folder_id: str = "",
        limit: int = 100,
        operation: str = "replace",
        order_by: str = "modifiedTime desc",
        query: str = "",
        shared_with_me: bool = False,
        text: str = "",
        title: str = "",
        date_range: Optional[Any] = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action
        params["use_date"] = use_date
        params["use_exact_date"] = use_exact_date

        super().__init__(
            node_type="integration_google_docs",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if file_id is not None:
            self.inputs["file_id"] = file_id
        if text is not None:
            self.inputs["text"] = text
        if doc_url is not None:
            self.inputs["doc_url"] = doc_url
        if title is not None:
            self.inputs["title"] = title
        if content is not None:
            self.inputs["content"] = content
        if operation is not None:
            self.inputs["operation"] = operation
        if folder_id is not None:
            self.inputs["folder_id"] = folder_id
        if query is not None:
            self.inputs["query"] = query
        if shared_with_me is not None:
            self.inputs["shared_with_me"] = shared_with_me
        if order_by is not None:
            self.inputs["order_by"] = order_by
        if use_date is not None:
            self.inputs["use_date"] = use_date
        if limit is not None:
            self.inputs["limit"] = limit
        if use_exact_date is not None:
            self.inputs["use_exact_date"] = use_exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if exact_date is not None:
            self.inputs["exact_date"] = exact_date
        if date_range is not None:
            self.inputs["date_range"] = date_range
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleDocsNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_tasks")
class IntegrationGoogleTasksNode(Node):
    """
    Google Tasks

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your Google Tasks account
    ### get_tasks
        completed_max: Maximum completion time
        completed_min: Minimum completion time
        due_max: Maximum due date
        due_min: Minimum due date
        max_results: Maximum number of tasks to return
        show_completed: Include completed tasks
        show_deleted: Include deleted tasks
        show_hidden: Include hidden tasks
        task_list_id: Select the task list
        updated_min: Minimum update time
    ### add_task
        due: Due date
        notes: Task notes
        task_list_id: Select the task list
        title: Task title
    ### update_task
        due: Due date
        notes: Task notes
        status: Task status
        task_id: Select the task to delete
        task_list_id: Select the task list
        title: Task title
    ### delete_task
        task_id: Select the task to delete
        task_list_id: Select the task list
    ### read_task
        task_id: Select the task to delete
        task_list_id: Select the task list

    ## Outputs
    ### delete_task
        message: Deletion status message
        success: Whether the task was deleted successfully
    ### add_task
        success: Whether the task was created successfully
        task_data: Created task data in JSON format
        task_id: ID of the created task
        task_title: Title of the created task
        task_url: URL of the created task
    ### update_task
        success: Whether the task was updated successfully
        task_data: Updated task data in JSON format
        task_id: ID of the updated task
        task_status: Status of the updated task
        task_title: Title of the updated task
        task_updated: Last updated date of the task
    ### read_task
        task_completed: Completion date of the retrieved task
        task_data: Retrieved task data in JSON format
        task_due: Due date of the retrieved task
        task_id: ID of the retrieved task
        task_notes: Notes of the retrieved task
        task_status: Status of the retrieved task
        task_title: Title of the retrieved task
        task_updated: Last updated date of the retrieved task
    ### get_tasks
        task_count: Number of tasks returned
        task_due_dates: List of task due dates
        task_ids: List of task IDs
        task_statuses: List of task statuses
        task_titles: List of task titles
        tasks: All tasks data in JSON format
        total_count: Total number of tasks matching filters
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your Google Tasks account",
            "value": None,
            "type": "integration<Google Tasks>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "add_task": {
            "inputs": [
                {
                    "field": "task_list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the task list",
                    "label": "Task List",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=task_list_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "helper_text": "Task title",
                    "label": "Task Title",
                    "placeholder": "Enter task title",
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "helper_text": "Task notes",
                    "label": "Task Notes",
                    "placeholder": "Enter task notes",
                },
                {
                    "field": "due",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Due date",
                    "label": "Due Date",
                    "placeholder": "2024-01-15T10:00:00Z",
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the created task",
                },
                {
                    "field": "task_title",
                    "type": "string",
                    "helper_text": "Title of the created task",
                },
                {
                    "field": "task_url",
                    "type": "string",
                    "helper_text": "URL of the created task",
                },
                {
                    "field": "task_data",
                    "type": "string",
                    "helper_text": "Created task data in JSON format",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was created successfully",
                },
            ],
            "name": "add_task",
            "task_name": "tasks.google_tasks.add_task",
            "description": "Add a new task to a Google Tasks list",
            "label": "Add Task",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_list_id",
                "title",
                "notes",
                "due",
            ],
            "required": ["task_list_id", "title"],
        },
        "delete_task": {
            "inputs": [
                {
                    "field": "task_list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the task list",
                    "label": "Task List",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=task_list_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the task to delete",
                    "label": "Task ID",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=task_id&task_list_id={inputs.task_list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was deleted successfully",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Deletion status message",
                },
            ],
            "name": "delete_task",
            "task_name": "tasks.google_tasks.delete_task",
            "description": "Delete a task from a Google Tasks list",
            "label": "Delete Task",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_list_id", "task_id"],
            "required": ["task_list_id", "task_id"],
        },
        "read_task": {
            "inputs": [
                {
                    "field": "task_list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the task list",
                    "label": "Task List",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=task_list_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the task to retrieve",
                    "label": "Task ID",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=task_id&task_list_id={inputs.task_list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the retrieved task",
                },
                {
                    "field": "task_title",
                    "type": "string",
                    "helper_text": "Title of the retrieved task",
                },
                {
                    "field": "task_notes",
                    "type": "string",
                    "helper_text": "Notes of the retrieved task",
                },
                {
                    "field": "task_status",
                    "type": "string",
                    "helper_text": "Status of the retrieved task",
                },
                {
                    "field": "task_due",
                    "type": "timestamp",
                    "helper_text": "Due date of the retrieved task",
                },
                {
                    "field": "task_completed",
                    "type": "timestamp",
                    "helper_text": "Completion date of the retrieved task",
                },
                {
                    "field": "task_updated",
                    "type": "timestamp",
                    "helper_text": "Last updated date of the retrieved task",
                },
                {
                    "field": "task_data",
                    "type": "string",
                    "helper_text": "Retrieved task data in JSON format",
                },
            ],
            "name": "read_task",
            "task_name": "tasks.google_tasks.read_task",
            "description": "Retrieve a specific task from a Google Tasks list",
            "label": "Read Task",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "task_list_id", "task_id"],
            "required": ["task_list_id", "task_id"],
        },
        "get_tasks": {
            "inputs": [
                {
                    "field": "task_list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the task list",
                    "label": "Task List",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=task_list_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "completed_min",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Minimum completion time",
                    "label": "Completed Min",
                    "placeholder": "2024-01-01T00:00:00Z",
                },
                {
                    "field": "completed_max",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Maximum completion time",
                    "label": "Completed Max",
                    "placeholder": "2024-12-31T23:59:59Z",
                },
                {
                    "field": "due_min",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Minimum due date",
                    "label": "Due Min",
                    "placeholder": "2024-01-01T00:00:00Z",
                },
                {
                    "field": "due_max",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Maximum due date",
                    "label": "Due Max",
                    "placeholder": "2024-12-31T23:59:59Z",
                },
                {
                    "field": "show_completed",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include completed tasks",
                    "label": "Show Completed",
                },
                {
                    "field": "show_deleted",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include deleted tasks",
                    "label": "Show Deleted",
                },
                {
                    "field": "show_hidden",
                    "type": "bool",
                    "value": False,
                    "helper_text": "Include hidden tasks",
                    "label": "Show Hidden",
                },
                {
                    "field": "updated_min",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "Minimum update time",
                    "label": "Updated Min",
                    "placeholder": "2024-01-01T00:00:00Z",
                },
                {
                    "field": "max_results",
                    "type": "int32",
                    "value": 100,
                    "helper_text": "Maximum number of tasks to return",
                    "label": "Max Results",
                    "component": {
                        "type": "int32",
                        "slider": True,
                        "min": 1,
                        "max": 1000,
                        "step": 1,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "tasks",
                    "type": "string",
                    "helper_text": "All tasks data in JSON format",
                },
                {
                    "field": "task_count",
                    "type": "int32",
                    "helper_text": "Number of tasks returned",
                },
                {
                    "field": "task_ids",
                    "type": "vec<string>",
                    "helper_text": "List of task IDs",
                },
                {
                    "field": "task_titles",
                    "type": "vec<string>",
                    "helper_text": "List of task titles",
                },
                {
                    "field": "task_statuses",
                    "type": "vec<string>",
                    "helper_text": "List of task statuses",
                },
                {
                    "field": "task_due_dates",
                    "type": "vec<timestamp>",
                    "helper_text": "List of task due dates",
                },
                {
                    "field": "total_count",
                    "type": "int32",
                    "helper_text": "Total number of tasks matching filters",
                },
            ],
            "name": "get_tasks",
            "task_name": "tasks.google_tasks.get_tasks",
            "description": "Retrieve all tasks from a Google Tasks list with filtering options",
            "label": "Get Tasks",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_list_id",
                "completed_min",
                "completed_max",
                "due_min",
                "due_max",
                "show_completed",
                "show_deleted",
                "show_hidden",
                "updated_min",
                "max_results",
            ],
            "required": ["task_list_id"],
        },
        "update_task": {
            "inputs": [
                {
                    "field": "task_list_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the task list",
                    "label": "Task List",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=task_list_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "task_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "Select the task to update",
                    "label": "Task ID",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/integrations-go/item/{inputs.integration.object_id}?field=task_id&task_list_id={inputs.task_list_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                },
                {
                    "field": "title",
                    "type": "string",
                    "value": "",
                    "helper_text": "New task title",
                    "label": "Task Title",
                    "placeholder": "Enter new task title",
                },
                {
                    "field": "notes",
                    "type": "string",
                    "value": "",
                    "helper_text": "New task notes",
                    "label": "Task Notes",
                    "placeholder": "Enter new task notes",
                },
                {
                    "field": "due",
                    "type": "timestamp",
                    "value": "",
                    "helper_text": "New due date",
                    "label": "Due Date",
                    "placeholder": "2024-01-15T10:00:00Z",
                },
                {
                    "field": "status",
                    "type": "string",
                    "value": "needsAction",
                    "helper_text": "Task status",
                    "label": "Status",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Needs Action", "value": "needsAction"},
                            {"label": "Completed", "value": "completed"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "task_id",
                    "type": "string",
                    "helper_text": "ID of the updated task",
                },
                {
                    "field": "task_title",
                    "type": "string",
                    "helper_text": "Title of the updated task",
                },
                {
                    "field": "task_status",
                    "type": "string",
                    "helper_text": "Status of the updated task",
                },
                {
                    "field": "task_updated",
                    "type": "timestamp",
                    "helper_text": "Last updated date of the task",
                },
                {
                    "field": "task_data",
                    "type": "string",
                    "helper_text": "Updated task data in JSON format",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the task was updated successfully",
                },
            ],
            "name": "update_task",
            "task_name": "tasks.google_tasks.update_task",
            "description": "Update an existing task in a Google Tasks list",
            "label": "Update Task",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "task_list_id",
                "task_id",
                "title",
                "notes",
                "due",
                "status",
            ],
            "required": ["task_list_id", "task_id"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        completed_max: Any = None,
        completed_min: Any = None,
        due: Any = None,
        due_max: Any = None,
        due_min: Any = None,
        max_results: int = 100,
        notes: str = "",
        show_completed: bool = False,
        show_deleted: bool = False,
        show_hidden: bool = False,
        status: str = "needsAction",
        task_id: str = "",
        task_list_id: str = "",
        title: str = "",
        updated_min: Any = None,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_tasks",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if task_list_id is not None:
            self.inputs["task_list_id"] = task_list_id
        if title is not None:
            self.inputs["title"] = title
        if notes is not None:
            self.inputs["notes"] = notes
        if due is not None:
            self.inputs["due"] = due
        if task_id is not None:
            self.inputs["task_id"] = task_id
        if completed_min is not None:
            self.inputs["completed_min"] = completed_min
        if completed_max is not None:
            self.inputs["completed_max"] = completed_max
        if due_min is not None:
            self.inputs["due_min"] = due_min
        if due_max is not None:
            self.inputs["due_max"] = due_max
        if show_completed is not None:
            self.inputs["show_completed"] = show_completed
        if show_deleted is not None:
            self.inputs["show_deleted"] = show_deleted
        if show_hidden is not None:
            self.inputs["show_hidden"] = show_hidden
        if updated_min is not None:
            self.inputs["updated_min"] = updated_min
        if max_results is not None:
            self.inputs["max_results"] = max_results
        if status is not None:
            self.inputs["status"] = status
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleTasksNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_google_chat")
class IntegrationGoogleChatNode(Node):
    """
    Integrate with Google Chat to send messages, manage spaces, and handle memberships

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your account
    ### get_spaces
        filter: Filter for spaces
        page_size: The number of memberships to return
    ### read_membership
        membership_id: The ID of the membership
        space_id: The ID of the space
    ### delete_message
        message_id: The ID of the message to delete
        space_id: The ID of the space
    ### read_message
        message_id: The ID of the message to delete
        space_id: The ID of the space
    ### update_message
        message_id: The ID of the message to delete
        message_text: The text of the message
        space_id: The ID of the space
        update_mask: Update mask for the message
    ### send_message
        message_text: The text of the message
        space_id: The ID of the space
        thread_key: Thread key for threaded messages
    ### get_memberships
        page_size: The number of memberships to return
        space_id: The ID of the space
    ### read_space
        space_id: The ID of the space

    ## Outputs
    ### read_membership
        created_time: The creation time of the membership
        member_display_name: The display name of the member
        member_info: Formatted member information
        member_name: The name of the member
        member_type: The type of the member
        membership_id: The ID of the membership
        membership_role: The role of the membership
        membership_state: The state of the membership
        raw_data: Raw membership data
    ### send_message
        created_time: Creation time of the message
        message_id: ID of the created message
        message_text: Text content of the message
        raw_data: Raw message data
        sender_display_name: Display name of the sender
        sender_name: Name of the sender
        sender_type: Type of the sender
        success: Whether the message was sent successfully
        thread_key: Key of the thread
        thread_name: Name of the thread
        updated_time: Last update time of the message
    ### read_message
        created_time: Creation time of the message
        message_content: Content of the message (alias for message_text)
        message_id: ID of the message
        message_text: Text content of the message
        raw_data: Raw message data
        sender_display_name: Display name of the sender
        sender_name: Name of the sender
        sender_type: Type of the sender
        thread_key: Key of the thread
        thread_name: Name of the thread
        updated_time: Last update time of the message
    ### update_message
        created_time: Creation time of the message
        message_id: ID of the updated message
        message_text: Updated text content of the message
        raw_data: Raw updated message data
        sender_display_name: Display name of the sender
        sender_name: Name of the sender
        sender_type: Type of the sender
        success: Whether the message was updated successfully
        thread_key: Key of the thread
        thread_name: Name of the thread
        updated_time: Last update time of the message
    ### read_space
        created_time: Creation time of the space
        modified_time: Last modified time of the space
        raw_data: Raw space data
        space_id: ID of the space
        space_info: Formatted space information
        space_name: Name of the space
        space_type: Type of the space
    ### get_memberships
        created_times: List of creation times
        member_display_names: List of member display names
        member_names: List of member names
        member_types: List of member types
        membership_count: Total number of memberships
        membership_ids: List of membership IDs
        membership_roles: List of membership roles
        membership_states: List of membership states
        memberships: List of membership objects
        raw_data: Raw memberships data
        total_count: Total count of memberships
    ### get_spaces
        created_times: List of creation times
        modified_times: List of modification times
        raw_data: Raw spaces data
        space_count: Total number of spaces
        space_ids: List of space IDs
        space_names: List of space names
        space_types: List of space types
        spaces: List of space objects
        total_count: Total count of spaces
    ### delete_message
        deleted_message_id: ID of the deleted message
        message: Success message
        raw_data: Raw delete operation data
        success: Whether the message was deleted successfully
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your account",
            "value": None,
            "type": "integration<Google Chat>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "read_membership": {
            "inputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "membership_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the membership",
                    "label": "Membership",
                    "placeholder": "Select membership",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=membership_id&space_id={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "membership_id",
                    "type": "string",
                    "helper_text": "The ID of the membership",
                },
                {
                    "field": "membership_state",
                    "type": "string",
                    "helper_text": "The state of the membership",
                },
                {
                    "field": "membership_role",
                    "type": "string",
                    "helper_text": "The role of the membership",
                },
                {
                    "field": "member_name",
                    "type": "string",
                    "helper_text": "The name of the member",
                },
                {
                    "field": "member_display_name",
                    "type": "string",
                    "helper_text": "The display name of the member",
                },
                {
                    "field": "member_type",
                    "type": "string",
                    "helper_text": "The type of the member",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "The creation time of the membership",
                },
                {
                    "field": "member_info",
                    "type": "string",
                    "helper_text": "Formatted member information",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw membership data",
                },
            ],
            "name": "read_membership",
            "task_name": "tasks.google_chat.read_membership",
            "description": "Read a membership",
            "label": "Read Membership",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "space_id", "membership_id"],
            "required": ["space_id", "membership_id"],
        },
        "get_memberships": {
            "inputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "page_size",
                    "type": "string",
                    "value": "",
                    "helper_text": "The number of memberships to return",
                    "label": "Page Size",
                    "placeholder": "100",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "memberships",
                    "type": "string",
                    "helper_text": "List of membership objects",
                },
                {
                    "field": "membership_count",
                    "type": "int32",
                    "helper_text": "Total number of memberships",
                },
                {
                    "field": "membership_ids",
                    "type": "vec<string>",
                    "helper_text": "List of membership IDs",
                },
                {
                    "field": "membership_states",
                    "type": "vec<string>",
                    "helper_text": "List of membership states",
                },
                {
                    "field": "membership_roles",
                    "type": "vec<string>",
                    "helper_text": "List of membership roles",
                },
                {
                    "field": "member_names",
                    "type": "vec<string>",
                    "helper_text": "List of member names",
                },
                {
                    "field": "member_display_names",
                    "type": "vec<string>",
                    "helper_text": "List of member display names",
                },
                {
                    "field": "member_types",
                    "type": "vec<string>",
                    "helper_text": "List of member types",
                },
                {
                    "field": "created_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of creation times",
                },
                {
                    "field": "total_count",
                    "type": "string",
                    "helper_text": "Total count of memberships",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw memberships data",
                },
            ],
            "name": "get_memberships",
            "task_name": "tasks.google_chat.get_memberships",
            "description": "Get memberships in a space",
            "label": "Get Memberships",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "space_id", "page_size"],
            "required": ["space_id"],
        },
        "send_message": {
            "inputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "message_text",
                    "type": "string",
                    "value": "",
                    "helper_text": "The text of the message",
                    "label": "Message Text",
                    "placeholder": "Hello, this is a message",
                    "order": 4,
                },
                {
                    "field": "thread_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Thread key for threaded messages",
                    "label": "Thread Key",
                    "placeholder": "Optional thread key",
                    "order": 5,
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the created message",
                },
                {
                    "field": "message_text",
                    "type": "string",
                    "helper_text": "Text content of the message",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the message",
                },
                {
                    "field": "updated_time",
                    "type": "timestamp",
                    "helper_text": "Last update time of the message",
                },
                {
                    "field": "thread_name",
                    "type": "string",
                    "helper_text": "Name of the thread",
                },
                {
                    "field": "thread_key",
                    "type": "string",
                    "helper_text": "Key of the thread",
                },
                {
                    "field": "sender_name",
                    "type": "string",
                    "helper_text": "Name of the sender",
                },
                {
                    "field": "sender_display_name",
                    "type": "string",
                    "helper_text": "Display name of the sender",
                },
                {
                    "field": "sender_type",
                    "type": "string",
                    "helper_text": "Type of the sender",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was sent successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw message data",
                },
            ],
            "name": "send_message",
            "task_name": "tasks.google_chat.send_message",
            "description": "Send a message",
            "label": "Send Message",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "space_id",
                "message_text",
                "thread_key",
            ],
            "required": ["space_id", "message_text"],
        },
        "delete_message": {
            "inputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the message to delete",
                    "label": "Message",
                    "placeholder": "Select message",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=message_id&space_id={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was deleted successfully",
                },
                {
                    "field": "deleted_message_id",
                    "type": "string",
                    "helper_text": "ID of the deleted message",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success message",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw delete operation data",
                },
            ],
            "name": "delete_message",
            "task_name": "tasks.google_chat.delete_message",
            "description": "Delete a message",
            "label": "Delete Message",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "space_id", "message_id"],
            "required": ["space_id", "message_id"],
        },
        "read_message": {
            "inputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the message",
                    "label": "Message",
                    "placeholder": "Select message",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=message_id&space_id={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the message",
                },
                {
                    "field": "message_text",
                    "type": "string",
                    "helper_text": "Text content of the message",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the message",
                },
                {
                    "field": "updated_time",
                    "type": "timestamp",
                    "helper_text": "Last update time of the message",
                },
                {
                    "field": "thread_name",
                    "type": "string",
                    "helper_text": "Name of the thread",
                },
                {
                    "field": "thread_key",
                    "type": "string",
                    "helper_text": "Key of the thread",
                },
                {
                    "field": "sender_name",
                    "type": "string",
                    "helper_text": "Name of the sender",
                },
                {
                    "field": "sender_display_name",
                    "type": "string",
                    "helper_text": "Display name of the sender",
                },
                {
                    "field": "sender_type",
                    "type": "string",
                    "helper_text": "Type of the sender",
                },
                {
                    "field": "message_content",
                    "type": "string",
                    "helper_text": "Content of the message (alias for message_text)",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw message data",
                },
            ],
            "name": "read_message",
            "task_name": "tasks.google_chat.read_message",
            "description": "Read a message",
            "label": "Read Message",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "space_id", "message_id"],
            "required": ["space_id", "message_id"],
        },
        "update_message": {
            "inputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                },
                {
                    "field": "message_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the message to update",
                    "label": "Message",
                    "placeholder": "Select message",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=message_id&space_id={inputs.space_id}&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 4,
                },
                {
                    "field": "message_text",
                    "type": "string",
                    "value": "",
                    "helper_text": "The new text of the message",
                    "label": "Message Text",
                    "placeholder": "Updated message text",
                    "order": 5,
                },
                {
                    "field": "update_mask",
                    "type": "string",
                    "value": "",
                    "helper_text": "Update mask for the message",
                    "label": "Update Mask",
                    "placeholder": "text",
                    "order": 6,
                },
            ],
            "outputs": [
                {
                    "field": "message_id",
                    "type": "string",
                    "helper_text": "ID of the updated message",
                },
                {
                    "field": "message_text",
                    "type": "string",
                    "helper_text": "Updated text content of the message",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the message",
                },
                {
                    "field": "updated_time",
                    "type": "timestamp",
                    "helper_text": "Last update time of the message",
                },
                {
                    "field": "thread_name",
                    "type": "string",
                    "helper_text": "Name of the thread",
                },
                {
                    "field": "thread_key",
                    "type": "string",
                    "helper_text": "Key of the thread",
                },
                {
                    "field": "sender_name",
                    "type": "string",
                    "helper_text": "Name of the sender",
                },
                {
                    "field": "sender_display_name",
                    "type": "string",
                    "helper_text": "Display name of the sender",
                },
                {
                    "field": "sender_type",
                    "type": "string",
                    "helper_text": "Type of the sender",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the message was updated successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw updated message data",
                },
            ],
            "name": "update_message",
            "task_name": "tasks.google_chat.update_message",
            "description": "Update a message",
            "label": "Update Message",
            "variant": "common_integration_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "space_id",
                "message_id",
                "message_text",
                "update_mask",
            ],
            "required": ["space_id", "message_id", "message_text"],
        },
        "read_space": {
            "inputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The ID of the space",
                    "label": "Space",
                    "placeholder": "Select space",
                    "agent_field_type": "static",
                    "component": {
                        "type": "dropdown",
                        "dynamic_config": {
                            "endpoint": "/{prefix}/item/{inputs.integration.object_id}?field=space_id&page={}&page_size={dynamic_config.page_size}&q={}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "refreshable": True,
                            "useSameEndpointForRefresh": True,
                        },
                    },
                    "order": 3,
                }
            ],
            "outputs": [
                {
                    "field": "space_id",
                    "type": "string",
                    "helper_text": "ID of the space",
                },
                {
                    "field": "space_name",
                    "type": "string",
                    "helper_text": "Name of the space",
                },
                {
                    "field": "space_type",
                    "type": "string",
                    "helper_text": "Type of the space",
                },
                {
                    "field": "created_time",
                    "type": "timestamp",
                    "helper_text": "Creation time of the space",
                },
                {
                    "field": "modified_time",
                    "type": "timestamp",
                    "helper_text": "Last modified time of the space",
                },
                {
                    "field": "space_info",
                    "type": "string",
                    "helper_text": "Formatted space information",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw space data",
                },
            ],
            "name": "read_space",
            "task_name": "tasks.google_chat.read_space",
            "description": "Read a space",
            "label": "Read Space",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "space_id"],
            "required": ["space_id"],
        },
        "get_spaces": {
            "inputs": [
                {
                    "field": "page_size",
                    "type": "string",
                    "value": "",
                    "helper_text": "The number of spaces to return",
                    "label": "Page Size",
                    "placeholder": "100",
                    "order": 3,
                },
                {
                    "field": "filter",
                    "type": "string",
                    "value": "",
                    "helper_text": "Filter for spaces",
                    "label": "Filter",
                    "placeholder": "Optional filter",
                    "order": 4,
                },
            ],
            "outputs": [
                {
                    "field": "spaces",
                    "type": "string",
                    "helper_text": "List of space objects",
                },
                {
                    "field": "space_count",
                    "type": "int32",
                    "helper_text": "Total number of spaces",
                },
                {
                    "field": "space_ids",
                    "type": "vec<string>",
                    "helper_text": "List of space IDs",
                },
                {
                    "field": "space_names",
                    "type": "vec<string>",
                    "helper_text": "List of space names",
                },
                {
                    "field": "space_types",
                    "type": "vec<string>",
                    "helper_text": "List of space types",
                },
                {
                    "field": "created_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of creation times",
                },
                {
                    "field": "modified_times",
                    "type": "vec<timestamp>",
                    "helper_text": "List of modification times",
                },
                {
                    "field": "total_count",
                    "type": "string",
                    "helper_text": "Total count of spaces",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw spaces data",
                },
            ],
            "name": "get_spaces",
            "task_name": "tasks.google_chat.get_spaces",
            "description": "Get spaces the caller is a member of",
            "label": "Get Spaces",
            "variant": "common_integration_nodes",
            "inputs_sort_order": ["integration", "action", "page_size", "filter"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        filter: str = "",
        membership_id: str = "",
        message_id: str = "",
        message_text: str = "",
        page_size: str = "",
        space_id: str = "",
        thread_key: str = "",
        update_mask: str = "",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_google_chat",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if integration is not None:
            self.inputs["integration"] = integration
        if action is not None:
            self.inputs["action"] = action
        if space_id is not None:
            self.inputs["space_id"] = space_id
        if membership_id is not None:
            self.inputs["membership_id"] = membership_id
        if page_size is not None:
            self.inputs["page_size"] = page_size
        if message_text is not None:
            self.inputs["message_text"] = message_text
        if thread_key is not None:
            self.inputs["thread_key"] = thread_key
        if message_id is not None:
            self.inputs["message_id"] = message_id
        if update_mask is not None:
            self.inputs["update_mask"] = update_mask
        if filter is not None:
            self.inputs["filter"] = filter
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationGoogleChatNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("ai_routing")
class AiRoutingNode(Node):
    """
    Route the execution flow to different paths based on the value of the conditions.

    ## Inputs
    ### Common Inputs
        conditions: The conditions input
        input_query: Specify the message that the AI router will classify
        max_tokens: The maximum number of tokens to generate
        model: The specific model for categorization
        outputs: The outputs input
        provider: The model provider
        shared_memory: The shared memory that will be used as context for AI to determine the routing
        temperature: The temperature of the model
        top_p: The top-p value

    ## Outputs
    ### Common Outputs
        [outputs]: The [outputs] output
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "conditions",
            "helper_text": "The conditions input",
            "value": [""],
            "type": "vec<string>",
        },
        {
            "field": "input_query",
            "helper_text": "Specify the message that the AI router will classify",
            "value": "",
            "type": "string",
        },
        {
            "field": "max_tokens",
            "helper_text": "The maximum number of tokens to generate",
            "value": 2048,
            "type": "int64",
        },
        {
            "field": "model",
            "helper_text": "The specific model for categorization",
            "value": "gpt-4o",
            "type": "enum<string>",
        },
        {
            "field": "outputs",
            "helper_text": "The outputs input",
            "value": {},
            "type": "map<string, string>",
        },
        {
            "field": "provider",
            "helper_text": "The model provider",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "shared_memory",
            "helper_text": "The shared memory that will be used as context for AI to determine the routing",
            "value": "",
            "type": "string",
        },
        {
            "field": "temperature",
            "helper_text": "The temperature of the model",
            "value": 0.7,
            "type": "float",
        },
        {
            "field": "top_p",
            "helper_text": "The top-p value",
            "value": 1.0,
            "type": "float",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [{"field": "[outputs]", "helper_text": "The [outputs] output"}]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {}

    # List of parameters that affect configuration
    _PARAMS = []

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        conditions: List[str] = [""],
        input_query: str = "",
        max_tokens: int = 2048,
        model: str = "gpt-4o",
        outputs: Dict[str, str] = {},
        provider: str = "openai",
        shared_memory: str = "",
        temperature: Any = 0.7,
        top_p: Any = 1.0,
        **kwargs
    ):
        # Initialize with params
        params = {}

        super().__init__(
            node_type="ai_routing",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if input_query is not None:
            self.inputs["input_query"] = input_query
        if shared_memory is not None:
            self.inputs["shared_memory"] = shared_memory
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if temperature is not None:
            self.inputs["temperature"] = temperature
        if max_tokens is not None:
            self.inputs["max_tokens"] = max_tokens
        if top_p is not None:
            self.inputs["top_p"] = top_p
        if conditions is not None:
            self.inputs["conditions"] = conditions
        if outputs is not None:
            self.inputs["outputs"] = outputs

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "AiRoutingNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_twilio")
class IntegrationTwilioNode(Node):
    """
    Twilio

    ## Inputs
    ### Common Inputs
        action: Select the Twilio operation to perform
        integration: Provide your Twilio API Key SID and Secret
    ### make_call
        language: Language for text-to-speech
        message: Enter the message content to send
        to: Enter the recipient's phone number (include country code)
        voice: Select the voice for text-to-speech
    ### send_message
        media_url: URL of media to send (for MMS only)
        message: Enter the message content to send
        message_type: Select the type of message to send
        to: Enter the recipient's phone number (include country code)

    ## Outputs
    ### make_call
        call_sid: Unique identifier for the initiated call
        duration: Duration of the call in seconds
        error_code: Error code if call failed
        error_message: Error message if call failed
        price: Price charged for the call
        price_unit: Currency unit for the price
        raw_data: Raw JSON response from Twilio API
        status: Status of the call operation
    ### send_message
        error_code: Error code if message failed
        error_message: Error message if send failed
        message_sid: Unique identifier for the sent message
        price: Price charged for the message
        price_unit: Currency unit for the price
        raw_data: Raw JSON response from Twilio API
        status: Status of the message send operation
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the Twilio operation to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Provide your Twilio API Key SID and Secret",
            "value": None,
            "type": "integration<Twilio>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "send_message": {
            "inputs": [
                {
                    "field": "to",
                    "type": "string",
                    "value": "",
                    "label": "Recipient Number",
                    "placeholder": "+1234567890",
                    "helper_text": "Enter the recipient's phone number (include country code)",
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message Content",
                    "placeholder": "Your message here",
                    "helper_text": "Enter the message content to send",
                },
                {
                    "field": "message_type",
                    "type": "string",
                    "value": "SMS",
                    "label": "Message Type",
                    "helper_text": "Select the type of message to send",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "SMS", "value": "SMS"},
                            {"label": "MMS", "value": "MMS"},
                            {"label": "WhatsApp", "value": "WhatsApp"},
                        ],
                    },
                },
                {
                    "field": "media_url",
                    "type": "string",
                    "value": "",
                    "label": "Media URL",
                    "placeholder": "https://example.com/image.jpg",
                    "helper_text": "URL of media to send (for MMS only)",
                },
            ],
            "outputs": [
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the message send operation",
                },
                {
                    "field": "message_sid",
                    "type": "string",
                    "helper_text": "Unique identifier for the sent message",
                },
                {
                    "field": "error_code",
                    "type": "string",
                    "helper_text": "Error code if message failed",
                },
                {
                    "field": "error_message",
                    "type": "string",
                    "helper_text": "Error message if send failed",
                },
                {
                    "field": "price",
                    "type": "string",
                    "helper_text": "Price charged for the message",
                },
                {
                    "field": "price_unit",
                    "type": "string",
                    "helper_text": "Currency unit for the price",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw JSON response from Twilio API",
                },
            ],
            "name": "send_message",
            "task_name": "tasks.twilio.send_message",
            "description": "Send an SMS, MMS, or WhatsApp message using Twilio",
            "label": "Send Message",
            "required": ["to", "message", "message_type"],
            "input_sort_order": [
                "integration",
                "action",
                "to",
                "message",
                "message_type",
                "media_url",
            ],
        },
        "make_call": {
            "inputs": [
                {
                    "field": "to",
                    "type": "string",
                    "value": "",
                    "label": "Recipient Number",
                    "placeholder": "+1234567890",
                    "helper_text": "Enter the recipient's phone number (include country code)",
                },
                {
                    "field": "message",
                    "type": "string",
                    "value": "",
                    "label": "Message Content",
                    "placeholder": "Hello, this is a call from your application",
                    "helper_text": "Enter the message content for text-to-speech",
                },
                {
                    "field": "voice",
                    "type": "string",
                    "value": "alice",
                    "label": "Voice",
                    "helper_text": "Select the voice for text-to-speech",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Alice", "value": "alice"},
                            {"label": "Man", "value": "man"},
                            {"label": "Woman", "value": "woman"},
                        ],
                    },
                },
                {
                    "field": "language",
                    "type": "string",
                    "value": "en",
                    "label": "Language",
                    "helper_text": "Language for text-to-speech",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "English", "value": "en"},
                            {"label": "Spanish", "value": "es"},
                            {"label": "French", "value": "fr"},
                            {"label": "German", "value": "de"},
                        ],
                    },
                },
            ],
            "outputs": [
                {
                    "field": "status",
                    "type": "string",
                    "helper_text": "Status of the call operation",
                },
                {
                    "field": "call_sid",
                    "type": "string",
                    "helper_text": "Unique identifier for the initiated call",
                },
                {
                    "field": "duration",
                    "type": "string",
                    "helper_text": "Duration of the call in seconds",
                },
                {
                    "field": "price",
                    "type": "string",
                    "helper_text": "Price charged for the call",
                },
                {
                    "field": "price_unit",
                    "type": "string",
                    "helper_text": "Currency unit for the price",
                },
                {
                    "field": "error_code",
                    "type": "string",
                    "helper_text": "Error code if call failed",
                },
                {
                    "field": "error_message",
                    "type": "string",
                    "helper_text": "Error message if call failed",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "Raw JSON response from Twilio API",
                },
            ],
            "name": "make_call",
            "task_name": "tasks.twilio.make_call",
            "description": "Make a phone call using Twilio's text-to-speech feature",
            "label": "Make Call",
            "required": ["to", "message", "voice", "language"],
            "input_sort_order": [
                "integration",
                "action",
                "to",
                "message",
                "voice",
                "language",
            ],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        language: str = "en",
        media_url: str = "",
        message: str = "",
        message_type: str = "SMS",
        to: str = "",
        voice: str = "alice",
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_twilio",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if to is not None:
            self.inputs["to"] = to
        if message is not None:
            self.inputs["message"] = message
        if message_type is not None:
            self.inputs["message_type"] = message_type
        if media_url is not None:
            self.inputs["media_url"] = media_url
        if voice is not None:
            self.inputs["voice"] = voice
        if language is not None:
            self.inputs["language"] = language
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationTwilioNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("integration_aws_s_3")
class IntegrationAwsS3Node(Node):
    """
    AWS S3

    ## Inputs
    ### Common Inputs
        action: Select the action to perform
        integration: Connect to your AWS account
    ### create_bucket
        bucket_name: Enter the name of the bucket to create
        public_read_access: Allow public read access to objects
        region: AWS region for the bucket
        versioning_enabled: Enable object versioning for this bucket
    ### delete_bucket
        bucket_name: Enter the name of the bucket to create
    ### search_bucket
        bucket_name: Enter the name of the bucket to create
        max_results: Maximum number of results to return
        search_query: Search for objects containing this text in their key
    ### upload_file
        bucket_name: Enter the name of the bucket to create
        content_type: MIME type of the file (optional)
        file: Select a file to upload
        metadata: Custom metadata as JSON
        object_key: Enter the key (path) for the object
        storage_class: Select the storage class
    ### list_files
        bucket_name: Enter the name of the bucket to create
        max_keys: Maximum number of objects to return
        prefix: Filter objects by prefix
    ### list_folders
        bucket_name: Enter the name of the bucket to create
        delimiter: Delimiter for folder structure
        prefix: Filter objects by prefix
    ### copy_file
        destination_key: Select the folder and enter the filename
        source_key: Select the source object
    ### create_folder
        folder_name: Name of the new folder to create
        parent_folder_id: Select the parent folder (optional - leave empty to create in bucket root)
    ### delete_folder
        folder_name: Name of the new folder to create
        force_delete: Delete folder even if it contains files
    ### download_file
        object_key: Enter the key (path) for the object
    ### delete_file
        object_key: Enter the key (path) for the object

    ## Outputs
    ### create_bucket
        bucket_name: The name of the created bucket
        location: The region where the bucket was created
        raw_data: The raw API response data
        success: Whether the bucket was created successfully
    ### upload_file
        bucket_name: The bucket containing the object
        etag: The ETag of the object
        object_key: The key of the uploaded object
        raw_data: The raw API response data
        size: The size of the object in bytes
        success: Whether the upload was successful
        url: The S3 URL of the object
        version_id: The version ID of the object (if versioning enabled)
    ### download_file
        bucket_name: The bucket containing the object
        content: The content of the object (if text-based)
        content_length: The size of the object in bytes
        content_type: The content type of the object
        etag: The ETag of the object
        file: The downloaded file
        last_modified: When the object was last modified
        metadata: Custom metadata of the object
        object_key: The key of the downloaded object
        raw_data: The raw API response data
    ### create_folder
        bucket_name: The bucket containing the folder
        folder_name: The name of the created folder
        raw_data: The raw API response data
        success: Whether the folder was created successfully
    ### list_buckets
        bucket_names: List of bucket names
        buckets: List of bucket objects
        creation_dates: List of bucket creation dates
        raw_data: The raw API response data
    ### delete_folder
        deleted_count: Number of objects deleted
        deleted_objects: List of deleted object keys
        message: Success or error message
        success: Whether the folder was deleted successfully
    ### copy_file
        destination_key: The destination object key
        etag: The ETag of the copied object
        raw_data: The raw API response data
        source_key: The source object key
        success: Whether the copy was successful
    ### list_files
        etags: List of object ETags
        last_modified_dates: List of last modified dates
        object_keys: List of object keys
        object_sizes: List of object sizes in bytes
        objects: List of object metadata
        raw_data: The raw API response data
        truncated: Whether the result was truncated
    ### list_folders
        folder_count: Number of folders found
        folder_names: List of folder names
        folders: JSON array of folder prefixes
        raw_data: The raw API response data
    ### delete_bucket
        message: Success or error message
        success: Whether the deletion was successful
    ### delete_file
        message: Success or error message
        success: Whether the deletion was successful
        version_id: Version ID of the deleted object (if versioning enabled)
    ### search_bucket
        object_count: Number of matching objects found
        object_keys: List of matching object keys
        objects: JSON array of matching objects
        raw_data: The raw API response data
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "action",
            "helper_text": "Select the action to perform",
            "value": "",
            "type": "string",
        },
        {
            "field": "integration",
            "helper_text": "Connect to your AWS account",
            "value": None,
            "type": "integration<Aws S3>",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = []

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)": {"inputs": [], "outputs": [], "variant": "common_integration_nodes"},
        "create_bucket": {
            "inputs": [
                {
                    "field": "bucket_name",
                    "type": "string",
                    "value": "",
                    "label": "Bucket Name",
                    "helper_text": "Enter the name of the bucket to create",
                    "placeholder": "my-s3-bucket",
                },
                {
                    "field": "region",
                    "type": "string",
                    "value": "us-east-1",
                    "label": "Region",
                    "helper_text": "AWS region for the bucket",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "US East (N. Virginia)", "value": "us-east-1"},
                            {"label": "US East (Ohio)", "value": "us-east-2"},
                            {"label": "US West (N. California)", "value": "us-west-1"},
                            {"label": "US West (Oregon)", "value": "us-west-2"},
                            {"label": "Africa (Cape Town)", "value": "af-south-1"},
                            {"label": "Asia Pacific (Hong Kong)", "value": "ap-east-1"},
                            {
                                "label": "Asia Pacific (Hyderabad)",
                                "value": "ap-south-2",
                            },
                            {
                                "label": "Asia Pacific (Jakarta)",
                                "value": "ap-southeast-3",
                            },
                            {
                                "label": "Asia Pacific (Melbourne)",
                                "value": "ap-southeast-4",
                            },
                            {"label": "Asia Pacific (Mumbai)", "value": "ap-south-1"},
                            {
                                "label": "Asia Pacific (Osaka)",
                                "value": "ap-northeast-3",
                            },
                            {
                                "label": "Asia Pacific (Seoul)",
                                "value": "ap-northeast-2",
                            },
                            {
                                "label": "Asia Pacific (Singapore)",
                                "value": "ap-southeast-1",
                            },
                            {
                                "label": "Asia Pacific (Sydney)",
                                "value": "ap-southeast-2",
                            },
                            {
                                "label": "Asia Pacific (Tokyo)",
                                "value": "ap-northeast-1",
                            },
                            {"label": "Canada (Central)", "value": "ca-central-1"},
                            {"label": "Canada West (Calgary)", "value": "ca-west-1"},
                            {"label": "Europe (Frankfurt)", "value": "eu-central-1"},
                            {"label": "Europe (Ireland)", "value": "eu-west-1"},
                            {"label": "Europe (London)", "value": "eu-west-2"},
                            {"label": "Europe (Milan)", "value": "eu-south-1"},
                            {"label": "Europe (Paris)", "value": "eu-west-3"},
                            {"label": "Europe (Spain)", "value": "eu-south-2"},
                            {"label": "Europe (Stockholm)", "value": "eu-north-1"},
                            {"label": "Europe (Zurich)", "value": "eu-central-2"},
                            {"label": "Israel (Tel Aviv)", "value": "il-central-1"},
                            {"label": "Middle East (Bahrain)", "value": "me-south-1"},
                            {"label": "Middle East (UAE)", "value": "me-central-1"},
                            {
                                "label": "South America (São Paulo)",
                                "value": "sa-east-1",
                            },
                        ],
                    },
                },
                {
                    "field": "versioning_enabled",
                    "type": "bool",
                    "value": False,
                    "label": "Enable Versioning",
                    "helper_text": "Enable object versioning for this bucket",
                },
                {
                    "field": "public_read_access",
                    "type": "bool",
                    "value": False,
                    "label": "Public Read Access",
                    "helper_text": "Allow public read access to objects",
                },
            ],
            "outputs": [
                {
                    "field": "bucket_name",
                    "type": "string",
                    "helper_text": "The name of the created bucket",
                },
                {
                    "field": "location",
                    "type": "string",
                    "helper_text": "The region where the bucket was created",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the bucket was created successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "create_bucket",
            "task_name": "tasks.aws_s3.create_bucket",
            "description": "Creates a new bucket in Amazon S3",
            "label": "Create Bucket",
            "input_sort_order": [
                "integration",
                "action",
                "bucket_name",
                "region",
                "versioning_enabled",
                "public_read_access",
            ],
            "required": ["bucket_name", "region"],
        },
        "list_buckets": {
            "inputs": [],
            "outputs": [
                {
                    "field": "buckets",
                    "type": "string",
                    "helper_text": "List of bucket objects",
                },
                {
                    "field": "bucket_names",
                    "type": "vec<string>",
                    "helper_text": "List of bucket names",
                },
                {
                    "field": "creation_dates",
                    "type": "vec<string>",
                    "helper_text": "List of bucket creation dates",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "list_buckets",
            "task_name": "tasks.aws_s3.list_buckets",
            "description": "Lists all buckets in the AWS account",
            "label": "List Buckets",
            "input_sort_order": ["integration", "action"],
        },
        "delete_bucket": {
            "inputs": [
                {
                    "field": "bucket_name",
                    "type": "string",
                    "hidden": True,
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket to delete",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
            ],
            "name": "delete_bucket",
            "task_name": "tasks.aws_s3.delete_bucket",
            "description": "Deletes a bucket from Amazon S3",
            "label": "Delete Bucket",
            "variant": "common_integration_file_nodes",
            "input_sort_order": ["integration", "action", "bucket_name"],
            "required": ["bucket_name"],
        },
        "search_bucket": {
            "inputs": [
                {
                    "field": "bucket_name",
                    "type": "string",
                    "hidden": True,
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket to search within",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "search_query",
                    "type": "string",
                    "value": "",
                    "label": "Search Query",
                    "helper_text": "Search for objects containing this text in their key",
                    "placeholder": "documents/",
                },
                {
                    "field": "max_results",
                    "type": "int32",
                    "value": 100,
                    "label": "Max Results",
                    "helper_text": "Maximum number of results to return",
                    "placeholder": "100",
                },
            ],
            "outputs": [
                {
                    "field": "objects",
                    "type": "string",
                    "helper_text": "JSON array of matching objects",
                },
                {
                    "field": "object_keys",
                    "type": "vec<string>",
                    "helper_text": "List of matching object keys",
                },
                {
                    "field": "object_count",
                    "type": "int32",
                    "helper_text": "Number of matching objects found",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "search_bucket",
            "task_name": "tasks.aws_s3.search_bucket",
            "description": "Search for objects within an S3 bucket by key name",
            "label": "Search Within Bucket",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "bucket_name",
                "search_query",
                "max_results",
            ],
            "required": ["bucket_name", "search_query"],
        },
        "upload_file": {
            "inputs": [
                {
                    "field": "bucket_name",
                    "type": "string",
                    "hidden": True,
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "object_key",
                    "type": "string",
                    "value": "",
                    "label": "Object Key",
                    "helper_text": "Enter the key (path) for the object",
                    "placeholder": "folder/subfolder/file.txt",
                },
                {
                    "field": "file",
                    "type": "file",
                    "label": "File",
                    "helper_text": "Select a file to upload",
                    "value": "",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "value": "",
                    "label": "Content Type",
                    "helper_text": "MIME type of the file (optional)",
                    "placeholder": "text/plain",
                },
                {
                    "field": "storage_class",
                    "type": "string",
                    "value": "STANDARD",
                    "label": "Storage Class",
                    "helper_text": "Select the storage class",
                    "component": {
                        "type": "dropdown",
                        "options": [
                            {"label": "Standard", "value": "STANDARD"},
                            {
                                "label": "Reduced Redundancy",
                                "value": "REDUCED_REDUNDANCY",
                            },
                            {"label": "Standard-IA", "value": "STANDARD_IA"},
                            {"label": "One Zone-IA", "value": "ONEZONE_IA"},
                            {"label": "Glacier", "value": "GLACIER"},
                            {"label": "Deep Archive", "value": "DEEP_ARCHIVE"},
                        ],
                    },
                },
                {
                    "field": "metadata",
                    "type": "string",
                    "value": "",
                    "label": "Metadata",
                    "helper_text": "Custom metadata as JSON",
                    "placeholder": '{"key": "value"}',
                },
            ],
            "outputs": [
                {
                    "field": "object_key",
                    "type": "string",
                    "helper_text": "The key of the uploaded object",
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "helper_text": "The bucket containing the object",
                },
                {
                    "field": "etag",
                    "type": "string",
                    "helper_text": "The ETag of the object",
                },
                {
                    "field": "version_id",
                    "type": "string",
                    "helper_text": "The version ID of the object (if versioning enabled)",
                },
                {
                    "field": "size",
                    "type": "string",
                    "helper_text": "The size of the object in bytes",
                },
                {
                    "field": "url",
                    "type": "string",
                    "helper_text": "The S3 URL of the object",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the upload was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "upload_file",
            "task_name": "tasks.aws_s3.upload_file",
            "description": "Upload a file to Amazon S3 with optional metadata and storage class",
            "label": "Upload File",
            "variant": "common_integration_file_nodes",
            "input_sort_order": [
                "integration",
                "action",
                "bucket_name",
                "object_key",
                "file",
                "content_type",
                "storage_class",
                "metadata",
            ],
            "required": ["bucket_name", "object_key", "file"],
        },
        "download_file": {
            "inputs": [
                {
                    "field": "object_key",
                    "type": "string",
                    "hidden": True,
                    "label": "Object Key",
                    "helper_text": "Select the object to download",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {"field": "file", "type": "file", "helper_text": "The downloaded file"},
                {
                    "field": "object_key",
                    "type": "string",
                    "helper_text": "The key of the downloaded object",
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "helper_text": "The bucket containing the object",
                },
                {
                    "field": "content",
                    "type": "string",
                    "helper_text": "The content of the object (if text-based)",
                },
                {
                    "field": "content_type",
                    "type": "string",
                    "helper_text": "The content type of the object",
                },
                {
                    "field": "content_length",
                    "type": "string",
                    "helper_text": "The size of the object in bytes",
                },
                {
                    "field": "last_modified",
                    "type": "timestamp",
                    "helper_text": "When the object was last modified",
                },
                {
                    "field": "etag",
                    "type": "string",
                    "helper_text": "The ETag of the object",
                },
                {
                    "field": "metadata",
                    "type": "string",
                    "helper_text": "Custom metadata of the object",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "download_file",
            "task_name": "tasks.aws_s3.download_file",
            "description": "Download a file from Amazon S3 and retrieve its content and metadata",
            "label": "Download File",
            "variant": "common_integration_file_nodes",
            "input_sort_order": ["integration", "action", "object_key"],
            "required": ["object_key"],
        },
        "list_files": {
            "inputs": [
                {
                    "field": "bucket_name",
                    "type": "string",
                    "hidden": True,
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "prefix",
                    "type": "string",
                    "value": "",
                    "label": "Prefix",
                    "helper_text": "Filter objects by prefix",
                    "placeholder": "folder/",
                },
                {
                    "field": "max_keys",
                    "type": "int32",
                    "value": 10,
                    "label": "Max Keys",
                    "helper_text": "Maximum number of objects to return",
                    "placeholder": "10",
                },
            ],
            "outputs": [
                {
                    "field": "objects",
                    "type": "string",
                    "helper_text": "List of object metadata",
                },
                {
                    "field": "object_keys",
                    "type": "vec<string>",
                    "helper_text": "List of object keys",
                },
                {
                    "field": "object_sizes",
                    "type": "vec<string>",
                    "helper_text": "List of object sizes in bytes",
                },
                {
                    "field": "last_modified_dates",
                    "type": "vec<string>",
                    "helper_text": "List of last modified dates",
                },
                {
                    "field": "etags",
                    "type": "vec<string>",
                    "helper_text": "List of object ETags",
                },
                {
                    "field": "truncated",
                    "type": "bool",
                    "helper_text": "Whether the result was truncated",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "list_files",
            "task_name": "tasks.aws_s3.list_files",
            "description": "List all files (objects) in an Amazon S3 bucket with optional prefix filtering",
            "label": "List Files",
            "variant": "common_integration_file_nodes",
            "input_sort_order": [
                "integration",
                "action",
                "bucket_name",
                "prefix",
                "max_keys",
            ],
            "required": ["bucket_name"],
        },
        "delete_file": {
            "inputs": [
                {
                    "field": "object_key",
                    "type": "string",
                    "hidden": True,
                    "label": "Object Key",
                    "helper_text": "Select the object to delete",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                }
            ],
            "outputs": [
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the deletion was successful",
                },
                {
                    "field": "version_id",
                    "type": "string",
                    "helper_text": "Version ID of the deleted object (if versioning enabled)",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
            ],
            "name": "delete_file",
            "task_name": "tasks.aws_s3.delete_file",
            "description": "Delete a file from Amazon S3",
            "label": "Delete File",
            "variant": "common_integration_file_nodes",
            "input_sort_order": ["integration", "action", "object_key"],
            "required": ["object_key"],
        },
        "copy_file": {
            "inputs": [
                {
                    "field": "source_key",
                    "type": "string",
                    "hidden": True,
                    "label": "Source Object Key",
                    "helper_text": "Select the source object",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": False,
                        },
                        "multi_select": False,
                        "select_directories": False,
                        "select_file": True,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "destination_key",
                    "type": "string",
                    "value": "",
                    "label": "Destination Key",
                    "helper_text": "Select the folder and enter the filename",
                    "placeholder": "folder/new-file.txt",
                    "agent_field_type": "static",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                },
            ],
            "outputs": [
                {
                    "field": "source_key",
                    "type": "string",
                    "helper_text": "The source object key",
                },
                {
                    "field": "destination_key",
                    "type": "string",
                    "helper_text": "The destination object key",
                },
                {
                    "field": "etag",
                    "type": "string",
                    "helper_text": "The ETag of the copied object",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the copy was successful",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "copy_file",
            "task_name": "tasks.aws_s3.copy_file",
            "description": "Copy a file from one location to another in Amazon S3",
            "label": "Copy File",
            "variant": "common_integration_file_nodes",
            "input_sort_order": [
                "integration",
                "action",
                "source_key",
                "destination_key",
            ],
            "required": ["source_key", "destination_key"],
        },
        "create_folder": {
            "inputs": [
                {
                    "field": "parent_folder_id",
                    "type": "string",
                    "value": "",
                    "hidden": True,
                    "helper_text": "Select the parent folder (optional - leave empty to create in bucket root)",
                    "label": "Parent Folder",
                    "placeholder": "",
                    "order": 3,
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "folder_name",
                    "type": "string",
                    "value": "",
                    "label": "Folder Name",
                    "helper_text": "Name of the new folder to create",
                    "placeholder": "New Folder",
                },
            ],
            "outputs": [
                {
                    "field": "folder_name",
                    "type": "string",
                    "helper_text": "The name of the created folder",
                },
                {
                    "field": "bucket_name",
                    "type": "string",
                    "helper_text": "The bucket containing the folder",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the folder was created successfully",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "create_folder",
            "task_name": "tasks.aws_s3.create_folder",
            "description": "Create a folder in Amazon S3 by creating a placeholder object",
            "label": "Create Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "parent_folder_id",
                "folder_name",
            ],
            "required": ["folder_name"],
        },
        "delete_folder": {
            "inputs": [
                {
                    "field": "folder_name",
                    "type": "string",
                    "hidden": True,
                    "value": "",
                    "label": "Folder Name",
                    "helper_text": "Select the folder to delete",
                    "placeholder": "folder/subfolder/",
                    "agent_field_type": "static",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                },
                {
                    "field": "force_delete",
                    "type": "bool",
                    "value": False,
                    "label": "Force Delete",
                    "helper_text": "Delete folder even if it contains files",
                },
            ],
            "outputs": [
                {
                    "field": "deleted_objects",
                    "type": "vec<string>",
                    "helper_text": "List of deleted object keys",
                },
                {
                    "field": "deleted_count",
                    "type": "int32",
                    "helper_text": "Number of objects deleted",
                },
                {
                    "field": "success",
                    "type": "bool",
                    "helper_text": "Whether the folder was deleted successfully",
                },
                {
                    "field": "message",
                    "type": "string",
                    "helper_text": "Success or error message",
                },
            ],
            "name": "delete_folder",
            "task_name": "tasks.aws_s3.delete_folder",
            "description": "Delete a folder and optionally all its contents from Amazon S3",
            "label": "Delete Folder",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "folder_name",
                "force_delete",
            ],
            "required": ["folder_name"],
        },
        "list_folders": {
            "inputs": [
                {
                    "field": "bucket_name",
                    "type": "string",
                    "hidden": True,
                    "label": "Bucket Name",
                    "helper_text": "Select the bucket",
                    "component": {
                        "type": "folder",
                        "dynamic_config": {
                            "metadata_endpoint": "/{prefix}/metadata/children/{inputs.integration.object_id}?parent_id={}&page={}&page_size={dynamic_config.page_size}&directory={dynamic_config.show_only_directories}&q={}",
                            "tree_endpoint": "/{prefix}/metadata/get-tree/{inputs.integration.object_id}",
                            "page_size": 25,
                            "supports_search": True,
                            "supports_pagination": True,
                            "show_only_directories": True,
                        },
                        "multi_select": False,
                        "select_directories": True,
                        "select_file": False,
                    },
                    "agent_field_type": "static",
                },
                {
                    "field": "prefix",
                    "type": "string",
                    "value": "",
                    "label": "Prefix",
                    "helper_text": "Filter folders by prefix",
                    "placeholder": "folder/",
                },
                {
                    "field": "delimiter",
                    "type": "string",
                    "value": "/",
                    "label": "Delimiter",
                    "helper_text": "Delimiter for folder structure",
                    "placeholder": "/",
                },
            ],
            "outputs": [
                {
                    "field": "folders",
                    "type": "string",
                    "helper_text": "JSON array of folder prefixes",
                },
                {
                    "field": "folder_names",
                    "type": "vec<string>",
                    "helper_text": "List of folder names",
                },
                {
                    "field": "folder_count",
                    "type": "int32",
                    "helper_text": "Number of folders found",
                },
                {
                    "field": "raw_data",
                    "type": "string",
                    "helper_text": "The raw API response data",
                },
            ],
            "name": "list_folders",
            "task_name": "tasks.aws_s3.list_folders",
            "description": "List all folders (common prefixes) in an Amazon S3 bucket",
            "label": "List Folders",
            "variant": "common_integration_file_nodes",
            "inputs_sort_order": [
                "integration",
                "action",
                "bucket_name",
                "prefix",
                "delimiter",
            ],
            "required": ["bucket_name"],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["action"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        action: str = "",
        bucket_name: str = "",
        content_type: str = "",
        delimiter: str = "/",
        destination_key: str = "",
        file: str = "",
        folder_name: str = "",
        force_delete: bool = False,
        max_keys: int = 10,
        max_results: int = 100,
        metadata: str = "",
        object_key: str = "",
        parent_folder_id: str = "",
        prefix: str = "",
        public_read_access: bool = False,
        region: str = "us-east-1",
        search_query: str = "",
        source_key: Optional[str] = None,
        storage_class: str = "STANDARD",
        versioning_enabled: bool = False,
        integration: Optional[Any] = None,
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["action"] = action

        super().__init__(
            node_type="integration_aws_s_3",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if action is not None:
            self.inputs["action"] = action
        if integration is not None:
            self.inputs["integration"] = integration
        if bucket_name is not None:
            self.inputs["bucket_name"] = bucket_name
        if region is not None:
            self.inputs["region"] = region
        if versioning_enabled is not None:
            self.inputs["versioning_enabled"] = versioning_enabled
        if public_read_access is not None:
            self.inputs["public_read_access"] = public_read_access
        if search_query is not None:
            self.inputs["search_query"] = search_query
        if max_results is not None:
            self.inputs["max_results"] = max_results
        if object_key is not None:
            self.inputs["object_key"] = object_key
        if file is not None:
            self.inputs["file"] = file
        if content_type is not None:
            self.inputs["content_type"] = content_type
        if storage_class is not None:
            self.inputs["storage_class"] = storage_class
        if metadata is not None:
            self.inputs["metadata"] = metadata
        if prefix is not None:
            self.inputs["prefix"] = prefix
        if max_keys is not None:
            self.inputs["max_keys"] = max_keys
        if source_key is not None:
            self.inputs["source_key"] = source_key
        if destination_key is not None:
            self.inputs["destination_key"] = destination_key
        if parent_folder_id is not None:
            self.inputs["parent_folder_id"] = parent_folder_id
        if folder_name is not None:
            self.inputs["folder_name"] = folder_name
        if force_delete is not None:
            self.inputs["force_delete"] = force_delete
        if delimiter is not None:
            self.inputs["delimiter"] = delimiter
        if integration is not None:
            self.inputs["integration"] = integration

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "IntegrationAwsS3Node":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("excel_writer")
class ExcelWriterNode(Node):
    """
    Write a list of values to a Excel sheet.

    ## Inputs
    ### Common Inputs
        cell_start_index: The cell to start writing from.
        cell_values: The values to write to the cells.
        selected_file: The file to write to.
        set_fill_color: Whether to set the fill color of the cells.
        set_horizontal_alignment: Whether to set the horizontal alignment of the cells.
        set_vertical_alignment: Whether to set the vertical alignment of the cells.
        sheet: The sheet to write to.
    ### When set_fill_color = True
        fill_color: The fill color of the cells.
    ### When set_horizontal_alignment = True
        horizontal_alignment: The horizontal alignment of the cells.
    ### When set_vertical_alignment = True
        vertical_alignment: The vertical alignment of the cells.

    ## Outputs
    ### Common Outputs
        output_file: The updated Excel file.
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "cell_start_index",
            "helper_text": "The cell to start writing from.",
            "value": "",
            "type": "string",
        },
        {
            "field": "cell_values",
            "helper_text": "The values to write to the cells.",
            "value": "",
            "type": "vec<string>",
        },
        {
            "field": "selected_file",
            "helper_text": "The file to write to.",
            "value": None,
            "type": "file",
        },
        {
            "field": "set_fill_color",
            "helper_text": "Whether to set the fill color of the cells.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "set_horizontal_alignment",
            "helper_text": "Whether to set the horizontal alignment of the cells.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "set_vertical_alignment",
            "helper_text": "Whether to set the vertical alignment of the cells.",
            "value": False,
            "type": "bool",
        },
        {
            "field": "sheet",
            "helper_text": "The sheet to write to.",
            "value": "",
            "type": "string",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {"field": "output_file", "helper_text": "The updated Excel file."}
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "true**(*)**(*)": {
            "inputs": [
                {
                    "field": "vertical_alignment",
                    "type": "enum<string>",
                    "value": "bottom",
                    "helper_text": "The vertical alignment of the cells.",
                    "label": "Vertical Alignment",
                    "agent_field_type": "dynamic",
                }
            ],
            "outputs": [],
        },
        "(*)**true**(*)": {
            "inputs": [
                {
                    "field": "horizontal_alignment",
                    "type": "enum<string>",
                    "value": "left",
                    "helper_text": "The horizontal alignment of the cells.",
                    "label": "Horizontal Alignment",
                    "agent_field_type": "dynamic",
                }
            ],
            "outputs": [],
        },
        "(*)**(*)**true": {
            "inputs": [
                {
                    "field": "fill_color",
                    "type": "string",
                    "value": "FFFFFF",
                    "helper_text": "The fill color of the cells.",
                    "label": "Fill Color",
                    "agent_field_type": "dynamic",
                }
            ],
            "outputs": [],
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["set_vertical_alignment", "set_horizontal_alignment", "set_fill_color"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        set_vertical_alignment: bool = False,
        set_horizontal_alignment: bool = False,
        set_fill_color: bool = False,
        cell_start_index: str = "",
        cell_values: List[str] = [],
        fill_color: str = "FFFFFF",
        horizontal_alignment: str = "left",
        selected_file: Optional[str] = None,
        sheet: str = "",
        vertical_alignment: str = "bottom",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["set_vertical_alignment"] = set_vertical_alignment
        params["set_horizontal_alignment"] = set_horizontal_alignment
        params["set_fill_color"] = set_fill_color

        super().__init__(
            node_type="excel_writer",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if selected_file is not None:
            self.inputs["selected_file"] = selected_file
        if sheet is not None:
            self.inputs["sheet"] = sheet
        if cell_start_index is not None:
            self.inputs["cell_start_index"] = cell_start_index
        if cell_values is not None:
            self.inputs["cell_values"] = cell_values
        if set_vertical_alignment is not None:
            self.inputs["set_vertical_alignment"] = set_vertical_alignment
        if set_horizontal_alignment is not None:
            self.inputs["set_horizontal_alignment"] = set_horizontal_alignment
        if set_fill_color is not None:
            self.inputs["set_fill_color"] = set_fill_color
        if vertical_alignment is not None:
            self.inputs["vertical_alignment"] = vertical_alignment
        if horizontal_alignment is not None:
            self.inputs["horizontal_alignment"] = horizontal_alignment
        if fill_color is not None:
            self.inputs["fill_color"] = fill_color

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "ExcelWriterNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


@Node.register_node_type("deep_research")
class DeepResearchNode(Node):
    """
    Perform advanced AI research and analysis with specialized model capabilities

    ## Inputs
    ### Common Inputs
        conversation: Previous conversation context for research continuity
        input: The data input for deep research analysis
        instructions: Specific instructions for the deep research task
        max_output_tokens: Maximum number of tokens in the research output
        max_tool_calls: Maximum number of tool calls during research
        model: Select the LLM model for deep research
        parallel_tool_calls: Enable parallel tool execution for faster research
        previous_response_id: ID of previous response for continuation
        prompt_cache_key: Cache key for prompt optimization
        provider: Select the LLM provider for deep research
        safety_identifier: Safety identifier for content filtering
        service_tier: Service tier for the research request
        stream: Whether to stream the research response
        tool_choice: Specific tool choice for research
        tools: Tools to use for research
        truncation: Truncation strategy for long inputs
        use_personal_api_key: Whether to use a personal API key
    ### When stream = True
        api_key: Your personal API key for the research provider
    ### When provider = 'azure'
        deployment_id: The deployment ID for the Azure OpenAI model
        endpoint: The Azure OpenAI endpoint URL
    ### When provider = 'openai'
        finetuned_model: Use your finetuned model for deep research

    ## Outputs
    ### Common Outputs
        conversation: The updated conversation including the research response
        created_at: Timestamp when the research was created
        credits_used: Number of credits consumed
        error: Error message if research failed
        id: The unique ID of the research response
        incomplete_details: Details about incomplete research
        input_tokens: Number of input tokens used
        output_tokens: Number of output tokens generated
        response: The research output and findings
        tokens_used: Total number of tokens used in research
    """

    # Common inputs and outputs
    _COMMON_INPUTS = [
        {
            "field": "conversation",
            "helper_text": "Previous conversation context for research continuity",
            "value": "",
            "type": "string",
        },
        {
            "field": "input",
            "helper_text": "The data input for deep research analysis",
            "value": "",
            "type": "string",
        },
        {
            "field": "instructions",
            "helper_text": "Specific instructions for the deep research task",
            "value": "",
            "type": "string",
        },
        {
            "field": "max_output_tokens",
            "helper_text": "Maximum number of tokens in the research output",
            "value": 128000,
            "type": "int32",
        },
        {
            "field": "max_tool_calls",
            "helper_text": "Maximum number of tool calls during research",
            "value": 10,
            "type": "int32",
        },
        {
            "field": "model",
            "helper_text": "Select the LLM model for deep research",
            "value": "o3-deep-research",
            "type": "enum<string>",
        },
        {
            "field": "parallel_tool_calls",
            "helper_text": "Enable parallel tool execution for faster research",
            "value": True,
            "type": "bool",
        },
        {
            "field": "previous_response_id",
            "helper_text": "ID of previous response for continuation",
            "value": "",
            "type": "string",
        },
        {
            "field": "prompt_cache_key",
            "helper_text": "Cache key for prompt optimization",
            "value": "",
            "type": "string",
        },
        {
            "field": "provider",
            "helper_text": "Select the LLM provider for deep research",
            "value": "openai",
            "type": "enum<string>",
        },
        {
            "field": "safety_identifier",
            "helper_text": "Safety identifier for content filtering",
            "value": "",
            "type": "string",
        },
        {
            "field": "service_tier",
            "helper_text": "Service tier for the research request",
            "value": "",
            "type": "string",
        },
        {
            "field": "stream",
            "helper_text": "Whether to stream the research response",
            "value": False,
            "type": "bool",
        },
        {
            "field": "tool_choice",
            "helper_text": "Specific tool choice for research",
            "value": "",
            "type": "string",
        },
        {
            "field": "tools",
            "helper_text": "Tools to use for research",
            "value": [{"type": "web_search_preview"}],
            "type": "vec<map<string, any>>",
        },
        {
            "field": "truncation",
            "helper_text": "Truncation strategy for long inputs",
            "value": "",
            "type": "string",
        },
        {
            "field": "use_personal_api_key",
            "helper_text": "Whether to use a personal API key",
            "value": False,
            "type": "bool",
        },
    ]

    # Common outputs and inputs
    _COMMON_OUTPUTS = [
        {
            "field": "conversation",
            "helper_text": "The updated conversation including the research response",
        },
        {
            "field": "created_at",
            "helper_text": "Timestamp when the research was created",
        },
        {"field": "credits_used", "helper_text": "Number of credits consumed"},
        {"field": "error", "helper_text": "Error message if research failed"},
        {"field": "id", "helper_text": "The unique ID of the research response"},
        {
            "field": "incomplete_details",
            "helper_text": "Details about incomplete research",
        },
        {"field": "input_tokens", "helper_text": "Number of input tokens used"},
        {"field": "output_tokens", "helper_text": "Number of output tokens generated"},
        {"field": "response", "helper_text": "The research output and findings"},
        {
            "field": "tokens_used",
            "helper_text": "Total number of tokens used in research",
        },
    ]

    # Configuration patterns and their associated inputs/outputs
    _CONFIGS = {
        "(*)**(*)**true": {
            "inputs": [],
            "outputs": [
                {
                    "field": "response",
                    "type": "stream<string>",
                    "helper_text": "The research response as a stream of text",
                }
            ],
        },
        "(*)**(*)**false": {
            "inputs": [],
            "outputs": [
                {
                    "field": "response",
                    "type": "string",
                    "helper_text": "The research response as a single string",
                }
            ],
        },
        "(*)**true**(*)": {
            "inputs": [
                {
                    "field": "api_key",
                    "type": "string",
                    "value": "",
                    "helper_text": "Your personal API key for the research provider",
                }
            ],
            "outputs": [],
        },
        "openai**(*)**(*)": {
            "inputs": [
                {
                    "field": "finetuned_model",
                    "type": "string",
                    "value": "",
                    "helper_text": "Use your finetuned model for deep research",
                    "is_advanced_setting": True,
                }
            ],
            "outputs": [],
            "title": "OpenAI Deep Research",
        },
        "azure**(*)**(*)": {
            "inputs": [
                {
                    "field": "endpoint",
                    "type": "string",
                    "value": "",
                    "helper_text": "The Azure OpenAI endpoint URL",
                    "is_advanced_setting": True,
                },
                {
                    "field": "deployment_id",
                    "type": "string",
                    "value": "",
                    "helper_text": "The deployment ID for the Azure OpenAI model",
                    "is_advanced_setting": True,
                },
            ],
            "outputs": [],
            "title": "Azure Deep Research",
        },
        "anthropic**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "title": "Anthropic Deep Research",
        },
        "google**(*)**(*)": {
            "inputs": [],
            "outputs": [],
            "title": "Google Deep Research",
        },
    }

    # List of parameters that affect configuration
    _PARAMS = ["provider", "stream", "use_personal_api_key"]

    def __init__(
        self,
        id: Optional[str] = None,
        node_name: Optional[str] = None,
        execution_mode: Optional[str] = None,
        provider: str = "openai",
        stream: bool = False,
        use_personal_api_key: bool = False,
        api_key: str = "",
        conversation: str = "",
        deployment_id: str = "",
        endpoint: str = "",
        finetuned_model: str = "",
        input: str = "",
        instructions: str = "",
        max_output_tokens: int = 128000,
        max_tool_calls: int = 10,
        model: str = "o3-deep-research",
        parallel_tool_calls: bool = True,
        previous_response_id: str = "",
        prompt_cache_key: str = "",
        safety_identifier: str = "",
        service_tier: str = "",
        tool_choice: str = "",
        tools: List[Dict[str, Any]] = [{"type": "web_search_preview"}],
        truncation: str = "",
        **kwargs
    ):
        # Initialize with params
        params = {}
        params["provider"] = provider
        params["stream"] = stream
        params["use_personal_api_key"] = use_personal_api_key

        super().__init__(
            node_type="deep_research",
            params=params,
            id=id,
            node_name=node_name,
            execution_mode=execution_mode,
        )

        # Set input values
        if provider is not None:
            self.inputs["provider"] = provider
        if model is not None:
            self.inputs["model"] = model
        if input is not None:
            self.inputs["input"] = input
        if instructions is not None:
            self.inputs["instructions"] = instructions
        if conversation is not None:
            self.inputs["conversation"] = conversation
        if max_output_tokens is not None:
            self.inputs["max_output_tokens"] = max_output_tokens
        if max_tool_calls is not None:
            self.inputs["max_tool_calls"] = max_tool_calls
        if parallel_tool_calls is not None:
            self.inputs["parallel_tool_calls"] = parallel_tool_calls
        if previous_response_id is not None:
            self.inputs["previous_response_id"] = previous_response_id
        if prompt_cache_key is not None:
            self.inputs["prompt_cache_key"] = prompt_cache_key
        if safety_identifier is not None:
            self.inputs["safety_identifier"] = safety_identifier
        if service_tier is not None:
            self.inputs["service_tier"] = service_tier
        if tool_choice is not None:
            self.inputs["tool_choice"] = tool_choice
        if tools is not None:
            self.inputs["tools"] = tools
        if truncation is not None:
            self.inputs["truncation"] = truncation
        if stream is not None:
            self.inputs["stream"] = stream
        if use_personal_api_key is not None:
            self.inputs["use_personal_api_key"] = use_personal_api_key
        if api_key is not None:
            self.inputs["api_key"] = api_key
        if finetuned_model is not None:
            self.inputs["finetuned_model"] = finetuned_model
        if endpoint is not None:
            self.inputs["endpoint"] = endpoint
        if deployment_id is not None:
            self.inputs["deployment_id"] = deployment_id

        # Update any additional inputs
        if kwargs:
            self.update_inputs(**kwargs)
        self.set_node_task_name()
        self.set_output_name_attributes()

    @classmethod
    def from_dict(cls, data: dict) -> "DeepResearchNode":
        """Create a node instance from a dictionary."""
        inputs = data.get("inputs", {})
        id = data.get("id", None)
        name = data.get("name", None)
        execution_mode = data.get("execution_mode", None)
        return cls(**inputs, id=id, node_name=name, execution_mode=execution_mode)


__all__ = [
    "AppendFilesNode",
    "StickyNoteNode",
    "CustomGroupNode",
    "TransformationNode",
    "ChatFileReaderNode",
    "PipelineNode",
    "AgentNode",
    "ChatMemoryNode",
    "LlmNode",
    "InputNode",
    "OutputNode",
    "CategorizerNode",
    "ExtractDataNode",
    "DataCollectorNode",
    "ScorerNode",
    "SpeechToTextNode",
    "FileSaveNode",
    "ImageGenNode",
    "FileNode",
    "GetListItemNode",
    "LlmOpenAiVisionNode",
    "LlmGoogleVisionNode",
    "SplitTextNode",
    "SummarizerNode",
    "TextNode",
    "TextToFileNode",
    "TimeNode",
    "TranslatorNode",
    "TtsElevenLabsNode",
    "TtsOpenAiNode",
    "AiAudioOperationsNode",
    "AiTextToSpeechNode",
    "AiSpeechToTextNode",
    "AiImageOperationsNode",
    "AiImageToTextNode",
    "AiTextToImageNode",
    "LlmAnthropicVisionNode",
    "SemanticSearchNode",
    "KnowledgeBaseNode",
    "KnowledgeBaseLoaderNode",
    "MapNode",
    "MergeNode",
    "ConditionNode",
    "NlToSqlNode",
    "ReadJsonValuesNode",
    "WriteJsonValueNode",
    "ApiNode",
    "UrlLoaderNode",
    "WikipediaNode",
    "YoutubeNode",
    "ArxivNode",
    "SerpApiNode",
    "YouDotComNode",
    "ExaAiNode",
    "GoogleSearchNode",
    "GoogleAlertRssReaderNode",
    "RssFeedReaderNode",
    "CsvQueryNode",
    "CsvReaderNode",
    "CsvWriterNode",
    "CreateListNode",
    "CombineListNode",
    "ListTrimmerNode",
    "DuplicateListNode",
    "FlattenListNode",
    "JoinListItemNode",
    "CsvToExcelNode",
    "TextFormatterNode",
    "JsonOperationsNode",
    "ListOperationsNode",
    "IntegrationGmailNode",
    "IntegrationCopperNode",
    "IntegrationDiscordNode",
    "IntegrationTelegramNode",
    "IntegrationLinearNode",
    "IntegrationOutlookNode",
    "IntegrationSalesforceNode",
    "IntegrationSlackNode",
    "IntegrationAsanaNode",
    "IntegrationJiraNode",
    "IntegrationSugarCrmNode",
    "IntegrationGithubNode",
    "IntegrationZendeskNode",
    "IntegrationStripeNode",
    "IntegrationTeamsNode",
    "IntegrationXNode",
    "IntegrationGohighlevelNode",
    "IntegrationPeopledatalabsNode",
    "IntegrationDropboxNode",
    "IntegrationHubspotNode",
    "IntegrationElasticsearchNode",
    "IntegrationMongodbNode",
    "IntegrationSnowflakeNode",
    "IntegrationPineconeNode",
    "IntegrationPostgresNode",
    "IntegrationMysqlNode",
    "IntegrationWordpressNode",
    "IntegrationLinkedinNode",
    "IntegrationGoogleCalendarNode",
    "IntegrationMicrosoftCalendarNode",
    "IntegrationMailgunNode",
    "IntegrationGoogleSlidesNode",
    "IntegrationGoogleWorkspaceAdminNode",
    "IntegrationGoogleCloudStorageNode",
    "IntegrationGoogleFirebaseRealtimeDbNode",
    "IntegrationGoogleCloudFirestoreNode",
    "IntegrationGooglePerspectiveNode",
    "IntegrationMicrosoftNode",
    "IntegrationTypeformNode",
    "IntegrationBoxNode",
    "IntegrationGoogleDriveNode",
    "IntegrationGoogleSheetsNode",
    "IntegrationGoogleAnalyticsNode",
    "IntegrationAirtableNode",
    "IntegrationNotionNode",
    "IntegrationDatabricksNode",
    "IntegrationWeaviateNode",
    "IntegrationBlandAiNode",
    "IntegrationAlgoliaNode",
    "IntegrationApolloNode",
    "IntegrationClickupNode",
    "IntegrationGoogleAdsNode",
    "ZapierNode",
    "MakeNode",
    "TextManipulationNode",
    "FileOperationsNode",
    "AiOperationsNode",
    "FileToTextNode",
    "CodeExecutionNode",
    "ChunkingNode",
    "NotificationsNode",
    "CustomSmtpEmailSenderNode",
    "EmailNotificationNode",
    "SmsNotificationNode",
    "AiFilterListNode",
    "FilterListNode",
    "SalesDataEnrichmentNode",
    "EmailValidatorNode",
    "CombineTextNode",
    "FindAndReplaceNode",
    "AiFillPdfNode",
    "ExtractToTableNode",
    "SortCsvNode",
    "TriggerOutlookNode",
    "TriggerGmailNode",
    "TriggerCronNode",
    "TriggerSlackNode",
    "KnowledgeBaseActionsNode",
    "KnowledgeBaseSyncNode",
    "KnowledgeBaseCreateNode",
    "ShareObjectNode",
    "RenameFileNode",
    "StartFlagNode",
    "TalkNode",
    "ListenNode",
    "AddNodeNode",
    "ConvertTypeNode",
    "SetVariableNode",
    "ListDeduplicatorNode",
    "BrowserExtensionNode",
    "IntegrationGoogleContactsNode",
    "IntegrationGoogleBigQueryNode",
    "ExcelCellReaderNode",
    "ExcelCellWriterNode",
    "ExcelFileReaderNode",
    "IntegrationGoogleDocsNode",
    "IntegrationGoogleTasksNode",
    "IntegrationGoogleChatNode",
    "AiRoutingNode",
    "IntegrationTwilioNode",
    "IntegrationAwsS3Node",
    "ExcelWriterNode",
    "DeepResearchNode",
]
