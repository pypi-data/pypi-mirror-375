from __future__ import annotations
from datetime import datetime
from typing import Optional
import uuid

from sqlalchemy import (
    String, Boolean, DateTime, JSON, Text, func, Index
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy.ext.mutable import MutableDict, MutableList

from svc_infra.db.base import ModelBase
from svc_infra.api.fastapi.db.user.user_logic import _pwd
from svc_infra.db.uniq import make_unique_indexes

class User(ModelBase):
    __tablename__ = "users"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    email: Mapped[str] = mapped_column(String(320), index=True, nullable=False)
    full_name: Mapped[Optional[str]] = mapped_column(String(255))
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    is_superuser: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    is_verified: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)

    # auth state
    password_hash: Mapped[str] = mapped_column(String(512), nullable=False)

    # Write-only facade over password
    @property
    def password(self) -> str:
        raise AttributeError("password is write-only")

    @password.setter
    def password(self, raw: str) -> None:
        self.password_hash = _pwd.hash(raw)

    last_login: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    disabled_reason: Mapped[Optional[str]] = mapped_column(Text)

    # org / roles / mfa
    tenant_id: Mapped[Optional[str]] = mapped_column(String(64), index=True)
    roles: Mapped[list[str]] = mapped_column(MutableList.as_mutable(JSON), default=list)
    mfa_enabled: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)

    # misc (avoid attr name 'metadata' clash)
    extra: Mapped[dict] = mapped_column("metadata", MutableDict.as_mutable(JSON), default=dict)

    # auditing (DB-side timestamps)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False
    )

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email!r}>"

# --- Input data pre-processing hooks ------------------------------------------

def user_pre_create(data: Dict[str, Any]) -> Dict[str, Any]:
    data = dict(data)
    if "password" in data:
        data["password_hash"] = _pwd.hash(data.pop("password"))
    if "metadata" in data:
        data["extra"] = data.pop("metadata")
    data.setdefault("roles", [])
    return data

def user_pre_update(data: Dict[str, Any]) -> Dict[str, Any]:
    data = dict(data)
    if "password" in data:
        data["password_hash"] = _pwd.hash(data.pop("password"))
    if "metadata" in data:
        data["extra"] = data.pop("metadata")
    return data

# --- Uniqueness policy --------------------------------------------------------

# Unique indexes, including case-insensitive and/or tenant-scoped.
for _ix in make_unique_indexes(
    User,
    unique_ci=["email"],            # case-insensitive unique email
    tenant_field="tenant_id",       # scoped by tenant if provided
):
    # Simply iterating keeps them registered with the Table metadata.
    # (No further action needed if you use Alembic autogenerate or metadata.create_all.)
    pass