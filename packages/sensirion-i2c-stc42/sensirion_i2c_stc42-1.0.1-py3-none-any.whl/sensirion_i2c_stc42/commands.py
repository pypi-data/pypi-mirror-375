#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2025 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 1.3.4
# Product:       stc42
# Model-Version: 1.0.1
#
"""
The transfer classes specify the data that is transferred between host and sensor. The generated transfer classes
are used by the driver class and not intended for direct use.
"""

from sensirion_driver_adapters.transfer import Transfer
from sensirion_driver_adapters.rx_tx_data import TxData, RxData
from sensirion_driver_support_types.bitfield import BitField, BitfieldContainer


class ScaleFactorType(BitfieldContainer):
    scale_factor = BitField(offset=0, width=12)
    unit = BitField(offset=12, width=4)


class ReadErrorFlags(BitfieldContainer):
    padding = BitField(offset=0, width=8)
    i2c_error = BitField(offset=8, width=1)
    dew_point_out_of_range = BitField(offset=9, width=1)
    measurement_to_low = BitField(offset=10, width=1)
    vdd_out_of_range = BitField(offset=11, width=1)
    eeprom_access_error = BitField(offset=12, width=1)
    memory_access_error = BitField(offset=13, width=1)
    asc_baseline_out_of_range = BitField(offset=14, width=1)
    asc_baseline_warning = BitField(offset=15, width=1)


class ReadProductInfo(Transfer):
    """Read product type and serial number"""

    CMD_ID = 0x365b

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.005, slave_address=None, ignore_ack=False)
    rx = RxData(descriptor='>I4H', convert_to_int=True)


class StartConcentrationMeasurement(Transfer):
    """Start measuring the H₂ concentration"""

    CMD_ID = 0x2152

    def __init__(self, measurement_period):
        self._measurement_period = measurement_period

    def pack(self):
        return self.tx_data.pack([self._measurement_period])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.075, slave_address=None, ignore_ack=False)


class ReadMeasurementTicks(Transfer):
    """
    Read the measurement values from the sensor.

    Between the command ``start_concentration_measurement`` and the command read_measurement_ticks
    it is required to wait for the maximum value of measure-time ms and measurement_period ms. Otherwise the sensor will NACK the request.
    The same wait time needs to be observed between two successive calls to ``read_measurement_ticks``.
    """

    CMD_ID = 0xec05

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>HHHHHH')


class StopMeasurement(Transfer):
    """The sensor will stop measuring"""

    CMD_ID = 0x3ff9

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class CompensateTemperatureWithSht4x(Transfer):
    """
    When using this option the STC4x will read temperature values from an **SHT4x** sensor that
    is attached to the I²C master bus of the STC (Pin 9 and 1).
    """

    CMD_ID = 0x2619

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class EnableManualTemperatureCompensation(Transfer):
    """Allows to write temperature values to the sensor"""

    CMD_ID = 0x2612

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class SetCompensationTemperatureTicks(Transfer):
    """
    Write a new temperature value to the sensor. The value is used as temperature compensation value
    until another value is written to the sensor.
    """

    CMD_ID = 0xe000

    def __init__(self, temperature_ticks):
        self._temperature_ticks = temperature_ticks

    def pack(self):
        return self.tx_data.pack([self._temperature_ticks])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class CompensateHumidityWithSht4x(Transfer):
    """
    When using this option the STC4x will read relative humidity values from an **SHT4x** sensor that
    is attached to the I²C master bus of the STC (Pin 9 and 1).
    """

    CMD_ID = 0x2657

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class EnableManualHumidityCompensation(Transfer):
    """
    Enables the option to adjust the readings for humidity impact using values written by
    application software.
    """

    CMD_ID = 0x264a

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class SetCompensationHumidityTicks(Transfer):
    """
    Write a new relative humidity value to the sensor. The value is used as relative_humidity
    compensation value until another value is written to the sensor.
    """

    CMD_ID = 0xe00b

    def __init__(self, relative_humidity_ticks):
        self._relative_humidity_ticks = relative_humidity_ticks

    def pack(self):
        return self.tx_data.pack([self._relative_humidity_ticks])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class EnableManualPressureCompensation(Transfer):
    """
    Enables the option to adjust the readings for pressure impact using values written by
    application software.
    """

    CMD_ID = 0x2698

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class SetCompensationPressureMbar(Transfer):
    """
    Write a new pressure value [mbar] to the sensor. The value is used as pressure
    compensation value until another value is written to the sensor.
    """

    CMD_ID = 0xe016

    def __init__(self, pressure_mbar):
        self._pressure_mbar = pressure_mbar

    def pack(self):
        return self.tx_data.pack([self._pressure_mbar])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class PerformForcedRecalibrationTicks(Transfer):
    """
    Forced recalibration is used to improve the sensor output with a known reference value.

    Before initiating forced recalibration, the sensor needs to be configured for proper compensation of ambient conditions (temperature, relative humidity and pressure).
    The effect of FRC takes place immediately after the command is executed and takes effect with the first subsequent measurement.

    FRC must only be performed when a well-known accurate reference concentration value is available, e.g. in a production facility where only air is present.
    Sensors can be permanently compromised if FRC is performed with a parameter ``hydrogen_concentration`` that largely deviates from the actual gas concentrations.
    For the best possible performance, the FRC should be executed close to the median operating temperature, humidity, pressure, and concentration of the end application.

    Typical applications for FRC:

    - After soldering and assembly
    - Before commissioning a product
    - Before starting a measurement series


    The forced recalibration requires that the command ``start_concentration_measurement`` was called before with ``measurement_period > 0``.
    The command is only started if the error-bits ``i2c_error``, ``vdd_out_of_range`` and
    ``memory_access_error`` are not set.
    """

    CMD_ID = 0xe01d

    def __init__(self, hydrogen_concentration):
        self._hydrogen_concentration = hydrogen_concentration

    def pack(self):
        return self.tx_data.pack([self._hydrogen_concentration])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class EnableAutomaticSelfCalibration(Transfer):
    """
    **Enable automatic self calibration**

    The sensor runs by default in Automatic Self-Calibration mode.
    This mode will enhance the accuracy for applications where the target gas is not present for most of the time and is mandatory for long term use.
    This feature can be disabled and enabled with the following commands.
    """

    CMD_ID = 0x3f86

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class DisableAutomaticSelfCalibration(Transfer):
    """
    **Disable automatic self calibration**

    Allows to disable automatic self calibration.
    """

    CMD_ID = 0x3f07

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class EnterSleepMode(Transfer):
    """
    The enter_sleep_mode command sets the sensor to sleep mode through the I2C interface. The written relative humidity,
    temperature, and pressure compensation values as well as the ASC state will be retained while in sleep mode.
    """

    CMD_ID = 0x36e0

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
