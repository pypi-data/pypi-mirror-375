import json
import logging
import re
import urllib.request
from pathlib import Path
from textwrap import dedent, indent
from typing import Set

from generator_config import TAPIR_CONFIG, OFFICIAL_CONFIG, ApiSourceConfig

log = logging.getLogger()

REGISTER_AS_MCP_TOOLS = False

FILE_HEADER = "# This file is auto-generated by generate_tools.py. DO NOT EDIT."
PAGINATED_DOCSTRING_ADDENDUM = """
    This response is paginated. If 'next_page_token' is returned, call this function
    again with that token to get the next page of results."""

def camel_to_snake(name: str) -> str:
    s1 = re.sub(r'(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub(r'([a-z0-9])([A-Z])', r'\1_\2', s1).lower()


def get_command_model_names(command_name: str) -> tuple[str, str]:
    return f"{command_name}Parameters", f"{command_name}Result"


def fetch_json_data(url: str, description: str) -> list | dict:
    log.info(f"Fetching {description} from {url}...")
    try:
        with urllib.request.urlopen(url) as response:
            if response.status == 200:
                log.info(f"Successfully fetched {description}.")
                return json.loads(response.read().decode("utf-8"))
            raise ConnectionError(f"Failed to fetch file: HTTP {response.status}")
    except urllib.request.HTTPError as e:
        log.error(f"Failed to fetch {description}: {e}")
        return []


def group_commands_by_category(command_details: list[dict]) -> dict[str, list[dict]]:
    grouped = {}
    for cmd in command_details:
        group_key = cmd["group"]
        grouped.setdefault(group_key, []).append(cmd)
    log.info(f"Grouped {len(command_details)} commands into {len(grouped)} categories.")
    return grouped


def prepare_output_directory(path: Path):
    if path.exists():
        log.warning(f"Output directory {path} exists. Cleaning...")
        for f in path.glob("*.py"):
            f.unlink()
    else:
        path.mkdir(parents=True, exist_ok=True)
    log.info(f"Prepared generation directory: {path}")


def _generate_imports_for_group(commands: list[dict], valid_model_names: set[str], config: ApiSourceConfig) -> str:
    imports = set()
    for cmd in commands:
        p_model, r_model = get_command_model_names(cmd["name_camel"])
        if p_model in valid_model_names:
            imports.add(p_model)
        if r_model in valid_model_names:
            imports.add(r_model)
    if not imports:
        return ""
    import_statements = ",\n".join(f"    {imp}" for imp in sorted(list(imports)))
    return dedent(f"""
    from multiconn_archicad.models.{config.name}.commands import (
    {import_statements}
    )
    """)


def _generate_paginated_model_code(original_result_model: str, paginated_result_model: str,
                                   list_attribute_name: str) -> str:
    return dedent(f'''
class {paginated_result_model}({original_result_model}):
    """A paginated version of the {original_result_model}."""
    {list_attribute_name}: list[Any]
    next_page_token: str | None = None
''')


def _generate_call_block(cmd: dict, result_model: str, has_params: bool, has_result: bool, config: ApiSourceConfig) -> str:
    params_for_api_call = "params.model_dump(mode='json')" if has_params else "{}"
    api_call = f'conn_header.core.{config.api_call_method}'
    if has_result:
        return dedent(f'''
            result_dict = {api_call}(
                command="{cmd["name_for_api"]}",
                parameters={params_for_api_call}
            )
            return {result_model}.model_validate(result_dict)
        ''')
    else:
        return dedent(f'''
            {api_call}(
                command="{cmd["name_for_api"]}",
                parameters={params_for_api_call}
            )
            return None
        ''')


def _generate_paginated_call_block(cmd: dict, original_result_model: str, paginated_result_model: str, list_attribute_name: str, has_params: bool, config: ApiSourceConfig) -> str:
    params_for_api_call = "params.model_dump(mode='json')" if has_params else "{}"
    cache_key_params_part = f':{{params.model_dump_json()}}' if has_params else ''
    api_call = f'conn_header.core.{config.api_call_method}'

    return dedent(f'''
        cache_key = f"{{port}}:{cmd["name_camel"]}{cache_key_params_part}"
        
        if not page_token:
            full_response_dict = {api_call}(
                command="{cmd["name_for_api"]}",
                parameters={params_for_api_call}
            )
            full_response_model = {original_result_model}.model_validate(full_response_dict)
            PAGINATION_CACHE[cache_key] = (full_response_model, time.time())

        if cache_key not in PAGINATION_CACHE:
            raise ValueError("Pagination session expired or invalid. Please start a new request.")

        full_response_model, timestamp = PAGINATION_CACHE[cache_key]
        if time.time() - timestamp > CACHE_LIFETIME_SECONDS:
            del PAGINATION_CACHE[cache_key]
            raise ValueError("Pagination session expired. Please start a new request.")

        list_to_paginate = getattr(full_response_model, "{list_attribute_name}")
        paginated_result = handle_paginated_request(list_to_paginate, page_token)

        response_data = full_response_model.model_dump()
        response_data["{list_attribute_name}"] = paginated_result.items
        response_data["next_page_token"] = paginated_result.next_page_token

        return {paginated_result_model}.model_validate(response_data)
    ''')


def _generate_tool_function_code(command: dict, valid_model_names: set[str], config: ApiSourceConfig) -> str:
    command_name_camel = command["name_camel"]
    command_name_snake = camel_to_snake(command_name_camel)
    short_group_name = config.group_mapping.get(command["group"], "dev")
    tool_name = f"{short_group_name}_{command_name_snake}"

    params_model, result_model = get_command_model_names(command_name_camel)
    has_params = params_model in valid_model_names
    has_result = result_model in valid_model_names
    is_paginated = command_name_camel in config.paginated_commands

    param_signature = f", params: {params_model}" if has_params else ""
    docstring_addendum = ""
    model_code = ""

    if is_paginated:
        list_attribute_name = config.paginated_commands[command_name_camel]
        paginated_result_model = f"Paginated{result_model}"
        param_signature += ", page_token: str | None = None"
        return_annotation = paginated_result_model
        docstring_addendum = PAGINATED_DOCSTRING_ADDENDUM
        model_code = _generate_paginated_model_code(result_model, paginated_result_model, list_attribute_name)
        call_block = _generate_paginated_call_block(command, result_model, paginated_result_model, list_attribute_name, has_params, config)
        param_reg_arg = params_model if has_params else "None"
        result_reg_arg = paginated_result_model
    else:
        return_annotation = result_model if has_result else "None"
        call_block = _generate_call_block(command, result_model, has_params, has_result, config)
        param_reg_arg = params_model if has_params else "None"
        result_reg_arg = result_model if has_result else "None"

    docstring = f'"""\n{indent(command["description"], "    ")}{indent(docstring_addendum, "    ")}\n    """'
    decorator = ""
    if REGISTER_AS_MCP_TOOLS:
        decorator = dedent(f'''
        @mcp.tool(
            name="{tool_name}",
            title="{command_name_camel}",
            description="{command["description"]}"
        )
        ''')

    function_code = f'''{decorator}def {command_name_snake}(port: int{param_signature}) -> {return_annotation}:
    {docstring}
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {{port}} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:
{indent(call_block, "        ")}
    except ValidationError as e:
        log.error(f"Validation error for {command_name_camel} result: {{e}}")
        raise ValueError(f"Received an invalid response from the Archicad API: {{e}}")
    except Exception as e:
        log.error(f"Error executing {command_name_camel} on port {{port}}: {{e}}")
        raise e
'''
    registration_call = dedent(f"""
    register_tool_for_dispatch(
        {command_name_snake},
        name="{tool_name}",
        title="{command_name_camel}",
        description="{command["description"]}",
        params_model={param_reg_arg},
        result_model={result_reg_arg}
    )
    """)
    return f"{model_code}\n\n{function_code}\n{registration_call}".strip() + "\n"


def generate_tool_files(grouped_commands: dict[str, list[dict]], config: ApiSourceConfig, valid_model_names: set[str]):
    for group_name, commands in grouped_commands.items():
        file_name_base = group_name.replace(" ", "_").lower()
        file_path = config.output_dir / f"{file_name_base}.py"

        is_any_paginated = any(cmd["name_camel"] in config.paginated_commands for cmd in commands)
        imports_block = _generate_imports_for_group(commands, valid_model_names, config)

        common_imports = [
            FILE_HEADER,
            "import logging",
            "from pydantic import ValidationError",
            "from multiconn_archicad.basic_types import Port",
            "from tapir_archicad_mcp.context import multi_conn_instance",
            "from tapir_archicad_mcp.tools.tool_registry import register_tool_for_dispatch",
        ]
        if is_any_paginated:
            common_imports.extend([
                "import time",
                "from typing import Any",
                "from tapir_archicad_mcp.pagination import handle_paginated_request, PAGINATION_CACHE, CACHE_LIFETIME_SECONDS",
            ])
        if REGISTER_AS_MCP_TOOLS:
            common_imports.append("from tapir_archicad_mcp.app import mcp")
        if imports_block:
            common_imports.append(imports_block)

        common_imports.append("\nlog = logging.getLogger()")

        file_content = ["\n".join(common_imports)]
        for cmd in sorted(commands, key=lambda x: x["name_camel"]):
            file_content.append(_generate_tool_function_code(cmd, valid_model_names, config))

        with open(file_path, "w", encoding="utf-8") as f:
            f.write("\n\n".join(file_content))
        log.info(f"Generated tool file: {file_path}")

def generate_init_file(config: ApiSourceConfig, module_names: set[str]):
    init_path = config.output_dir / "__init__.py"
    content = [FILE_HEADER, ""]
    for module_name in sorted(list(module_names)):
        content.append(f"from tapir_archicad_mcp.tools.generated.{config.name}.{module_name} import *")
    with open(init_path, "w", encoding="utf-8") as f:
        f.write("\n".join(content))
    log.info(f"Generated __init__.py file at {init_path}")

def run_generation_for_source(config: ApiSourceConfig) -> Set[str]:
    log.info(f"--- Starting Generation for {config.name.upper()} ---")
    command_details_raw = fetch_json_data(config.details_url, f"{config.name} command details")
    valid_model_names_list = fetch_json_data(config.model_names_url, f"{config.name} valid model names")

    if not command_details_raw or not valid_model_names_list:
        log.critical(f"Could not fetch data for {config.name}. Aborting this source.")
        return set()

    processed_commands = []
    for cmd in command_details_raw:
        name_for_api = cmd["name"]
        name_camel = name_for_api.removeprefix(config.prefix_to_strip)
        if name_camel in config.commands_to_exclude:
            continue
        cmd["name_camel"] = name_camel
        cmd["name_for_api"] = name_for_api
        processed_commands.append(cmd)

    log.info(f"Generating tools for {len(processed_commands)} commands from {config.name}.")
    grouped_commands = group_commands_by_category(processed_commands)
    valid_model_names = set(valid_model_names_list)

    prepare_output_directory(config.output_dir)
    generate_tool_files(grouped_commands, config, valid_model_names)

    generated_modules = {group_name.replace(" ", "_").lower() for group_name in grouped_commands.keys()}
    generate_init_file(config, generated_modules)

    log.info(f"--- Finished Generation for {config.name.upper()} ---")
    return {cmd['name_camel'] for cmd in processed_commands}


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    log.info("--- Starting Archicad MCP Tool Generator ---")

    run_generation_for_source(TAPIR_CONFIG)
    run_generation_for_source(OFFICIAL_CONFIG)

    log.info("--- Tool Generation Completed Successfully for All Sources ---")