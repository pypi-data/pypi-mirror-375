#!/usr/bin/env python

from __future__ import annotations

import json
import os
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Sequence


try:
    from core.su2_json import state  
    from core.logger import log      
except ModuleNotFoundError:         
    class _DummyLogger:              
        @staticmethod
        def log(lvl: str, msg: str) -> None:
            print(f"[{lvl.upper():5}] {msg}")
    log = _DummyLogger().log          
    state = type("DummyState", (),   
                 {"case_name": "dummy_case",
                  "counter": 0,
                  "jsonData": {},
                  "config_desc": "# SU2 configuration generated by su2_py_wrapper"})()

BASE_DIR = Path(__file__).resolve().parent.parent      # project root

# ----------------------------------------------------------------------
# Temperature constants for dynamic boundary conditions
# ----------------------------------------------------------------------
BASE_TEMPERATURE = 293.0  # base wall temperature in Kelvin
AMPLITUDE = 57.0          # temperature oscillation amplitude
FREQUENCY = 2.0           # oscillation frequency



def _flatten(lst: Sequence[Any]) -> List[Any]:
    # Recursively flatten any nested sequence (list/tuple).
    flat: List[Any] = []
    for item in lst:
        if isinstance(item, (list, tuple)):
            flat.extend(_flatten(item))
        else:
            flat.append(item)
    return flat


_VAR_PATTERN = re.compile(r"\b([A-Za-z_]\w*)\b")


def _replace_variables(text: str, variables: Dict[str, Any]) -> str:

    def repl(match: re.Match[str]) -> str:
        key = match.group(1)
        return str(variables.get(key, key))
    return _VAR_PATTERN.sub(repl, text)


def _to_cfg_value(value: Any,
                  variables: Dict[str, Any]) -> str | None:
    
    if value is None or (isinstance(value, str) and value.lower() == "none"):
        return None

    if isinstance(value, bool):
        return "YES" if value else "NO"

    if isinstance(value, (list, tuple)):
        flat = [_replace_variables(str(v), variables) for v in _flatten(value)]
        return "(" + ", ".join(flat) + ")"

    # plain scalar / str
    return _replace_variables(str(value), variables)


# ----------------------------------------------------------------------
# main generator
# ----------------------------------------------------------------------
def generate_python_wrapper(
        json_data: Dict[str, Any],
        filename_py_export: str | Path,
        *,
        variables: Dict[str, Any] | None = None,
        derived_parameters: Dict[str, str] | None = None,
        dynamic_wall_temp_markers: Dict[str, str] | None = None,
        output_dir: str | Path | None = None,
        config_filename: str = "config.cfg"
) -> Path:
    
    variables = variables or {}
    derived_parameters = derived_parameters or {}
    dynamic_wall_temp_markers = dynamic_wall_temp_markers or {}

    log("info", "Generating Python wrapper script")
    filename_py_export = Path(filename_py_export).with_suffix(".py")

    # decide where to put the result
    if output_dir is None:
        output_dir = BASE_DIR / "user" / state.case_name
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    target_file = output_dir / filename_py_export
    log("info", f"Output file: {target_file}")

    # ---------- write file -------------------------------------------------
    with target_file.open("w", encoding="utf-8") as f:
        
        f.write("#!/usr/bin/env python\n\n")
        f.write("import pysu2\n")
        f.write("import numpy as np\n")
        f.write("from mpi4py import MPI\n")
        f.write("import math, os, sys\n\n")

        # user variables
        if variables:
            f.write("# ----------------------\n# Variables injected by user\n")
            for k, v in variables.items():
                f.write(f"{k} = {v!r}\n")
            f.write("\n")

        # derived parameters (stubs)
        if derived_parameters:
            f.write("# ----------------------\n# Derived-parameter helpers\n")
            for name, doc in derived_parameters.items():
                f.write(f"def calculate_{name}(driver):\n")
                f.write(f"    \"\"\"{doc}\"\"\"\n")
                f.write("    # TODO: implement the real formula\n")
                f.write("    return 0.0\n\n")        # configuration file reference
        f.write("# ----------------------\n# SU2 configuration file path\n")
        f.write(f"config_file = '{config_filename}'\n\n")        # driver
        f.write(
            "def main():\n"
            "    comm  = MPI.COMM_WORLD\n"
            "    rank  = comm.Get_rank()\n"
            "    \n"
            "    # Check if config file exists\n"
            "    if not os.path.exists(config_file):\n"
            "        if rank == 0:\n"
            "            print(f'Error: Configuration file {config_file} not found')\n"
            "        return 1\n"
            "    \n"
            "    try:\n"
            "        driver = pysu2.CSinglezoneDriver(config_file, 1, comm)\n"
            "        driver.Preprocess(0)\n"
            "        driver.Run()\n"
            "        driver.Postprocess()\n"
            "        if rank == 0:\n"
            "            print('SU2 simulation completed successfully')\n"
            "    except Exception as exc:\n"
            "        if rank == 0:\n"
            "            print(f'Error running SU2: {exc}')\n"
            "        return 1\n"
            "    return 0\n\n\n"
            "if __name__ == '__main__':\n"
            "    raise SystemExit(main())\n"
        )

    # make executable 
    try:
        target_file.chmod(target_file.stat().st_mode | 0o111)
    except PermissionError:
        pass

    log("info", f"Python wrapper generated at: {target_file}")
    return target_file

def generate_dynamic_temperature_wrapper(
        boundary_marker: str,
        base_temperature: float = 300.0,
        filename_py_export: str | Path = "run_su2_dynamic.py",
        *,
        output_dir: str | Path | None = None,
        variables: Dict[str, Any] | None = None,
        temperature_formula: str | None = None,
        wrapper_type: str = "simple"  # Force simple position-based only
) -> Path:
    # Force position-based mode only
    wrapper_type = "simple"
    
    log("info", f"Generating dynamic temperature wrapper for marker: {boundary_marker}")
    # Initialize defaults - no user variables for position-based
    variables = {}  # Disabled for position-based only
    if temperature_formula is None:
        temperature_formula = "560.0 - 260.0*sin(x*pi / 4)"  # Position-based formula that works
    
    # Use only user-provided variables - DISABLED FOR POSITION-BASED
    all_variables = {}  # No variables needed for position-based
    
    filename_py_export = Path(filename_py_export).with_suffix(".py")
    
    # 
    if output_dir is None:
        output_dir = BASE_DIR / "user" / state.case_name
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    target_file = output_dir / filename_py_export
    log("info", f"Output file: {target_file}")    # ---------- write file - POSITION-BASED ONLY -------------------------------------------------
    with target_file.open("w", encoding="utf-8") as f:
        # Write the exact header from your template
        f.write("#!/usr/bin/env python\n\n")
        
        # Only position-based wrapper supported
        f.write("# ----------------------------------------------------------------------\n")
        f.write("#  Imports\n")
        f.write("# ----------------------------------------------------------------------\n\n")
        f.write("import pysu2\n")
        f.write("from math import sin,pi,cos,sqrt,exp,tan,log,fabs \n")
        f.write("# Note: built-in abs is available in safe_locals without import\n")
        f.write("from mpi4py import MPI\n\n")
          
        f.write("# ----------------------------------------------------------------------\n")
        f.write("#  Temperature Constants\n")
        f.write("# ----------------------------------------------------------------------\n\n")
        f.write(f"BASE_TEMPERATURE = {base_temperature}  # Base wall temperature (K)\n")
        f.write(f"AMPLITUDE = {AMPLITUDE}  # Temperature amplitude\n")
        f.write(f"FREQUENCY = {FREQUENCY}  # Frequency parameter\n")
        f.write("# Note: x = raw coordinate, x_norm = normalized coordinate [0,1]\n")
        f.write("# x_min, x_max = coordinate range of the marker\n")
        f.write("# x_range = x_max - x_min\n\n")
        
        # No user variables section for position-based
        
        # wrapper main function
        f.write("def main():\n")
        f.write("  comm = MPI.COMM_WORLD\n\n")
        f.write("  try:\n")
        f.write("    SU2Driver = pysu2.CSinglezoneDriver('turb_SA_flatplate (1).cfg', 1, comm)\n")
        f.write("  except TypeError as exception:\n")
        f.write("    print('A TypeError occured in pysu2.CDriver : ', exception)\n")
        f.write("    raise\n\n")
        f.write("  AllMarkerIDs = SU2Driver.GetMarkerIndices()\n")
        f.write(f"  MarkerName = '{boundary_marker}'\n")
        f.write("  MarkerID = AllMarkerIDs[MarkerName] if MarkerName in AllMarkerIDs else -1\n\n")
        f.write("  nVertex = SU2Driver.GetNumberMarkerNodes(MarkerID) if MarkerID >= 0 else 0\n\n")
        f.write("  if nVertex > 0:\n")
        f.write("    marker_coords = SU2Driver.MarkerCoordinates(MarkerID)\n")
        f.write("    \n")
        f.write("    # Determine problem dimensionality by trying to access z-coordinate\n")
        f.write("    try:\n")
        f.write("      # Test if we can access the z-coordinate (index 2)\n")
        f.write("      test_z = marker_coords(0, 2)\n")
        f.write("      nDim = 3  # 3D problem\n")
        f.write("    except:\n")
        f.write("      nDim = 2  # 2D problem\n")
        f.write("    \n")
        f.write("    x_min = float('inf')\n")
        f.write("    x_max = float('-inf')\n")
        f.write("    \n")
        f.write("    for i_vertex in range(SU2Driver.GetNumberMarkerNodes(MarkerID)):\n")
        f.write("      x = marker_coords(i_vertex, 0)\n")
        f.write("      x_min = min(x_min, x)\n")
        f.write("      x_max = max(x_max, x)\n")
        f.write("    \n")
        f.write("    x_range = x_max - x_min\n")
        f.write("    \n")
        
        f.write("    for i_vertex in range(SU2Driver.GetNumberMarkerNodes(MarkerID)):\n")
        f.write("      x = marker_coords(i_vertex, 0)\n")
        f.write("      y = marker_coords(i_vertex, 1)\n") 
        f.write("      z = marker_coords(i_vertex, 2) if nDim == 3 else 0.0\n")
        
        f.write("      x_norm = (x - x_min) / x_range if x_range > 0 else 0.0\n")
        
        f.write(f"      # User expression with x,y,z available\n")
        f.write(f"      code = compile('{temperature_formula}', '<user-bc>', 'eval')\n")
        f.write(f"      safe_locals = {{'x': x, 'y': y, 'z': z, 'sin': sin, 'pi': pi, 'cos': cos, 'sqrt': sqrt, 'exp': exp, 'tan': tan, 'log': log, 'abs': abs, 'fabs': fabs}}\n")
        f.write(f"      WallTemp = eval(code, {{}}, safe_locals)\n")
        f.write("      SU2Driver.SetMarkerCustomTemperature(MarkerID, i_vertex, WallTemp)\n")
        f.write("    \n")
        f.write("  \n")
        f.write("  SU2Driver.StartSolver()\n")
        f.write("  SU2Driver.Finalize()\n\n")
        f.write("\nif __name__ == '__main__':\n")
        f.write("  main()\n")

    
    try:
        target_file.chmod(target_file.stat().st_mode | 0o111)
    except PermissionError:
        pass

    log("info", f"Dynamic temperature wrapper generated at: {target_file}")
    
    
    _generate_dynamic_config_file(boundary_marker, base_temperature, output_dir)
    
    return target_file

def _generate_dynamic_config_file(boundary_marker: str, base_temperature: float, output_dir: Path):
    
    try:
        config_path = output_dir / "config.cfg"
        
        
        config_lines = []
        if config_path.exists():
            with config_path.open("r", encoding="utf-8") as f:
                config_lines = f.readlines()
        
        
        has_isothermal = False
        has_python_custom = False
        
        for i, line in enumerate(config_lines):
            if line.strip().startswith("MARKER_ISOTHERMAL"):
                
                config_lines[i] = f"MARKER_ISOTHERMAL= ({boundary_marker}, {base_temperature})\n"
                has_isothermal = True
            elif line.strip().startswith("MARKER_PYTHON_CUSTOM"):
            
                config_lines[i] = f"MARKER_PYTHON_CUSTOM= ({boundary_marker})\n"
                has_python_custom = True
        
        
        if not has_isothermal:
            config_lines.append(f"MARKER_ISOTHERMAL= ({boundary_marker}, {base_temperature})\n")
        if not has_python_custom:
            config_lines.append(f"MARKER_PYTHON_CUSTOM= ({boundary_marker})\n")
        
        
        with config_path.open("w", encoding="utf-8") as f:
            f.writelines(config_lines)
            
        log("info", f"Updated config file with dynamic temperature markers: {config_path}")
        
    except Exception as e:
        log("warn", f"Could not update config file: {e}")

# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
def save_json_cfg_py_file(
        filename_json_export: str | Path,
        filename_cfg_export : str | Path,
        filename_py_export : str | Path,
        *,
        variables: Dict[str, Any] | None = None,        derived_parameters: Dict[str, str] | None = None,
        dynamic_wall_temp_markers: Dict[str, str] | None = None
) -> str | None:
    
    if not getattr(state, "case_name", ""):
        log("warn", "Case name not defined – nothing exported")
        return None

    variables = variables or {}
    derived_parameters = derived_parameters or {}
    dynamic_wall_temp_markers = dynamic_wall_temp_markers or {}

    export_dir = BASE_DIR / "user" / state.case_name
    export_dir.mkdir(parents=True, exist_ok=True)

    # -------- JSON --------------------------------------------------------
    json_path = export_dir / Path(filename_json_export).with_suffix(".json")
    with json_path.open("w", encoding="utf-8") as fp:
        json.dump(state.jsonData, fp, indent=4, sort_keys=True, ensure_ascii=False)
    log("info", f"Wrote JSON     {json_path}")

    # -------- CFG ---------------------------------------------------------
    cfg_path = export_dir / Path(filename_cfg_export).with_suffix(".cfg")
    with cfg_path.open("w", encoding="utf-8") as fp:
        fp.write(f"{state.config_desc}\n")
        for k, v in state.jsonData.items():
            cfg_val = _to_cfg_value(v, variables)
            if cfg_val is None:
                continue
            fp.write(f"{k}= {cfg_val}\n")
    log("info", f"Wrote .cfg     {cfg_path}")
    
    
    python_wrapper_path = None    
    if dynamic_wall_temp_markers:
        
        for marker, temp_function in dynamic_wall_temp_markers.items():
            python_wrapper_path = generate_dynamic_temperature_wrapper(
                boundary_marker=marker,
                base_temperature=300.0,  # Default base temp
                filename_py_export=filename_py_export,
                output_dir=export_dir,
                variables=variables,
                temperature_formula=temp_function
            )
            break  
    else:        
        python_wrapper_path = generate_python_wrapper(
            state.jsonData,
            filename_py_export=filename_py_export,
            variables=variables,
            derived_parameters=derived_parameters,
            dynamic_wall_temp_markers=dynamic_wall_temp_markers,
            output_dir=export_dir,
            config_filename=Path(filename_cfg_export).with_suffix(".cfg").name,
        )

    
    state.counter = getattr(state, "counter", 0) + 1
    log("info", f"Export counter: {state.counter}")
    
    return str(python_wrapper_path) if python_wrapper_path else None
