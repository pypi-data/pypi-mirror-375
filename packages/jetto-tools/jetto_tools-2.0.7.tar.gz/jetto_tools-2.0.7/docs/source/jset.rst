.. _jset-label:

===========
JSET module
===========

Introduction
============

JSET files are the configuration files of the JAMS application. They are used to record and retrieve the
configuration of JAMS, as set by the user via the JAMS GUI. This Python module allows a client application to read,
modify and write a JSET file. The module attempts to maintain compatibility with the JAMS application to the extent
possible. In particular, any JSET file generated by this module should be loadable in JAMS without issue.

This module does not support creation of a JSET file *ab initio*: a template file must be provided, in which all of the
settings that the client wishes to modify are already present. A ``JSET`` object can be created from this file, and the
client can modify the JSET using the interface provided by the ``JSET`` class.

This module is primarily intended to be used by other library code in the ``jetto-pythontools`` package for configuring
JETTO runs and scans. However, with care, it can be used by any client application to perform low-level manipulation of
JSET files.

The bulk of the module is contained in the ``JSET`` class; however, the module also provides two convenience functions,
``read`` and ``write``, which can be used to quickly read in and write out ``JSET`` objects from and to JSET files.

Basic usage
===========

The ``JSET`` class can be used to parse, update and write the contents of a JSET. ``JSET`` object creation is simple: just pass
the contents of the JSET file to the class initialiser:

.. highlight:: python

>>> from jetto_tools.jset import JSET
>>> with open("jetto.jset") as f:
>>>   jset = JSET(f.read())

A client can access the contents of a JSET via the class interface. The contents of the 'File Details' section are
accessible via the properties ``cname``, ``cdate``, ``ctime`` and ``version``. For example, given the following File
Details section:

::

    *
    *File Details
    Creation Name                                               : /work/fcasson/jetto/runs/runtestdata5i/jetto.jset
    Creation Date                                               : 08/07/2019
    Creation Time                                               : 16:43:37
    Version                                                     : v060619

We can access the details as follows:

.. highlight:: python

>>> jset.cname
'/work/fcasson/jetto/runs/runtestdata5i/jetto.jset'
>>> jset.cdate
datetime.date(2019, 7, 8)
>>> jset.ctime
datetime.time(16, 43, 37)
>>> jset.version
'v060619'

The details can be updated by the client using the same properties. Note that ``cdate`` and ``ctime`` are stored as
Python ``datetime.date`` and ``datetime.time`` objects. The remaining details are stored as strings.

The contents of the JSET settings can be accessed using dictionary syntax. For example, given the following portions
of the Settings section:

::

    *
    *Settings
    AdvancedPanel.catCodeID                                     : jetto
    ...
    AdvancedPanel.catSeqNum                                     :
    AdvancedPanel.selReadContinue                               : false
    ...
    BallooningL1RefPanel.DurationFallTime                       : 3.0e-4
    ...
    BallooningL1RefPanelR1.EnhancementElectrons                 : 100
    ...

The client can access and update the settings as follows:

.. highlight:: python

>>> jset['AdvancedPanel.catCodeID']
'jetto'
>>> j['BallooningL1RefPanel.DurationFallTime'] = 2.0e-4
>>> j['BallooningL1RefPanel.DurationFallTime']
0.0002

In order to facilitate interoperability with Python client code, the ``JSET`` class stores field values from the Settings
section as typed variables, according to the following scheme:

- 'true' and 'false' are stored as boolean True and False
- Any field containing a valid integer is stored as an int
- Any field containing a non-integer numeric value is stored as a float
- Empty fields are stored as None
- Any other fields are stored as strings

Note that because a JSET file is allowed to have empty settings, there is limited scope for type-checking by the
``jset`` module. The client is responsible for ensuring that any update to the settings fields is performed with
values of the correct types.

The ``JSET`` class also supports checking for the existence of a setting:

.. highlight:: python

>>> 'BallooningL1RefPanel.DurationFallTime' in jset
True
>>> 'Nonexistent.Setting' in jset
False

Unlike dictionaries though, it is not permitted to add or delete a setting to or from a JSET. Attempting to do so
will raise an exception:

.. highlight:: python

>>> del j['BallooningL1RefPanel.DurationFallTime']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "...jetto-pythontools/jetto_tools/jset.py", line 212, in __delitem__
    :type s: str
jetto_tools.jset.JSETError: Cannot delete setting from JSET

When creating a ``JSET`` object, the following conditions must be met by the input JSET file:

- The JSET file should contain the three standard sections: **File Details**, **Settings** and **EOF**, in that order, and no others
- The header is optional, and blank lines will be ignored.
- The **File Details** section must contain the fields '**Creation Name**', '**Creation Date**', '**Creation Time**' and '**Version**', in that order, although the fields are allowed to be empty
- If either '**Creation Date**' or '**Creation Time**' is blank, they are set internally to the default values 01/01/1970 and 00:00:00.
- If the **Creation Date** or **Creation Time** are present, they must be in the format **dd/mm/yyy** and **hh:mm:ss**, respectively.
- The **Settings** section may be empty.

If the file does not meet one or more of the above criteria, a ``JSETError`` will be raised on object creation. Furthermore,
each line in the input file must be well formed: if any line fails to parse, a ``JSETError`` will be raised.

.. _jset-collapse-vectors-label:

Collapsing JSET vector settings
-------------------------------

Users may find it easier to work with the JSET class when its internal representation of array-like settings are
collapsed into Python lists. Switching back and forth can easily be done using the ``collapse_all_arrays`` and
``expand_all_arrays`` functions. The default representation upon initialization remains exactly the input JSET
string contents, and explicitly calling ``collapse_all_arrays`` is needed to access the vector-based functionality.

Any collapsed vectors will automatically be expanded when writing, but the state of the JSET instance in memory
will not be altered.

JSET properties
---------------

Some of the more commonly used JSET settings can be accessed via properties, in addition to the dictionary syntax used
above. A description of some of these properties is given here: the remainining properties are described in the API
documentation below.

The number of processors configured can be accessed via the ``processors`` property:

.. highlight:: python

>>> jset.processors
2

The configured ex-file can be accessed via the ``exfile`` property:

.. highlight:: python

>>> jset.exfile
'/u/fcasson/cmg/jams/data/exfile/testdata4.ex'

The configured load module version can be accessed via the ``binary`` property:

.. highlight:: python

>>> jset.binary
'v060619'

The configured load module user can be accessed via the ``userid`` property:

.. highlight:: python

>>> jset.userid
'sim'

The impurities select flag can be accessed via the ``impurities`` property:

.. highlight:: python

>>> jset.impurities
True

Whether or not Sanco is set as the impurities source can be accessed via the ``sanco`` property (note that this property
is read-only):

.. highlight:: python

>>> jset.sanco
True

Whether or not this is a restart case can be accessed via the ``restart`` property:

.. highlight:: python

Whether or not this is a continuation case can be accessed via the ``continue_`` property:

.. highlight:: python

>>> jset.continue_
False

Whether or not this is a repeat case can be accessed via the ``repeat`` property:

.. highlight:: python

>>> jset.repeat
False

Writing a JSET
--------------

A ``jset`` object also supports writing to a string, via the ``str()`` builtin:

.. highlight:: python

>>> print(str(jset))
!===============================================================================
!                              JETTO SETTINGS FILE
!===============================================================================
*
*File Details
Creation Name                                               : /work/fcasson/jetto/runs/runtestdata5i/jetto.jset
Creation Date                                               : 08/07/2019
Creation Time                                               : 16:43:37
Version                                                     : v060619
*
*Settings
AdvancedPanel.catCodeID                                     : jetto
...

All fields are written in the same order in which they appeared in the input file. Fields which have been modified
by the client are updated automatically in the output string.

Any collapsed vectors will automatically be expanded when writing, but the state of the JSET instance in memory
will not be altered.

Applying a BLUEPRINT coilset
----------------------------

The JSET API includes a function which allows a BLUEPRINT coilset file to be imported into the JSET's extra namelists.
This can be done via the ``apply_bp_coilset`` function.

The following commands illustrate how this can be done, with a JSET file ``jetto.jset`` and coilset file
``coilset.json``, both in the current working directory:

.. highlight:: python

>>> import jetto_tools.jset
>>> jset = jetto_tools.jset.read('jetto.jset')
>>> import json
>>> coilset_file = open('coilset.json')
>>> coilset = json.load(coilset_file)
>>> jset.apply_bp_coilset(coilset)
>>> jetto_tools.jset.write(jset, 'new_jetto.jset')

Following the ``apply_bp_coilset`` call, the coilset variables (``PFCNUM``, ``PFCRCEN``, ``PFCZCEN``, ``PFCRWID`` and
``PFCZWID``) in the JSET's extra namelists are updated with the contents of the coilset file. Note that, by default,
any coils in the coilset file which have zero current will be skipped and not included in the JSET. To include **all**
coils, regardless of current, use the ``include_zero_current_coils`` parameter to ``apply_bp_coilset``:

.. highlight:: python

>>> jset.apply_bp_coilset(coilset, include_zero_current_coils=True)


Furthermore, if the initial JSET contains the extra namelist variable ``PFCIPLINNUM`` (which specifies how many points
appear in the coil current time polygons for the ESCO free boundary case), the ``apply_bp_coilset`` function will
also populate the ``PFCIPLIN`` variable with constant-current time polygons of the corresponding length. If the
``PFCIPLINNUM`` variable is *not* present in the initial JSET, this step is skipped.

API Reference
=============

.. automodule:: jetto_tools.jset

.. autofunction:: jetto_tools.jset.read
.. autofunction:: jetto_tools.jset.write

.. autoclass:: jetto_tools.jset.JSET
    :members: __init__, exfile, binary, userid, processors, impurities, sanco, cname, cdate, ctime, version, extras, sanco_extras, __getitem__, __setitem__, set_catalogued_files, set_backwards_compatibility, walltime, get, restart, driver, shot, machine, read_ids, write_ids, continue_, repeat, set_restart_flags, apply_bp_coilset, collapse_all_arrays, expand_all_arrays, input_ids_source

.. autoexception:: jetto_tools.jset.JSETError

.. autoclass:: jetto_tools.jset.ExtraNamelists
    :members: __init__, prefix, as_jset_settings, __getitem__, __setitem__, __len__, __delitem, __contains__

.. autoclass:: jetto_tools.jset.ExtraNamelistItem
    :members: __init__, is_scalar, type, as_dict, combine, __getitem__, __setitem__, __eq__, __ne__,

.. autoclass:: jetto_tools.jset.ExtraNamelistTraits
    :members: __init__

.. autoexception:: jetto_tools.jset.ExtraNamelistsError
