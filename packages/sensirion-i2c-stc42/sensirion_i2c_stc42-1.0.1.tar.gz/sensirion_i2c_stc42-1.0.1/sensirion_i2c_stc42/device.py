#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2025 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 1.3.4
# Product:       stc42
# Model-Version: 1.0.1
#
"""
The class Stc42DeviceBase implements the low level interface of the sensor.
The class Stc42Device extends the Stc42DeviceBase. It provides additional functions to ease the use of the
sensor.
"""

from sensirion_driver_adapters.transfer import execute_transfer
from sensirion_driver_support_types.mixin_access import MixinAccess
from sensirion_i2c_stc42.commands import (CompensateHumidityWithSht4x, CompensateTemperatureWithSht4x,
                                          DisableAutomaticSelfCalibration, EnableAutomaticSelfCalibration,
                                          EnableManualHumidityCompensation, EnableManualPressureCompensation,
                                          EnableManualTemperatureCompensation, EnterSleepMode,
                                          PerformForcedRecalibrationTicks, ReadErrorFlags, ReadMeasurementTicks,
                                          ReadProductInfo, ScaleFactorType, SetCompensationHumidityTicks,
                                          SetCompensationPressureMbar, SetCompensationTemperatureTicks,
                                          StartConcentrationMeasurement, StopMeasurement)

from sensirion_i2c_stc42.result_types import (SignalHydrogen, SignalRelativeHumidity, SignalTemperature)


class Stc42DeviceBase:
    """Low level API implementation of STC42"""

    def __init__(self, channel):
        self._channel = channel

    @property
    def channel(self):
        return self._channel

    def read_product_info(self):
        """
        Read product type and serial number

        :return product_number:

        :return serial_number:

        """
        transfer = ReadProductInfo()
        return execute_transfer(self._channel, transfer)

    def start_concentration_measurement(self, measurement_period):
        """
        Start measuring the H₂ concentration

        :param measurement_period:
            Defines how the measurement shall be carried out:

            - measurement_period = 0:

              A single shot measurement is done. The measurement value is available after a ``measure-time`` of
              about 75ms.

            - measurement_period > 0:
              Once a measurement is started with measurement_period > 0,
              the sensor will repeatedly measure the gas concentration until the measurement is
              stopped or the sensor is power cycled. During this time, the measurement data can
              be read out using the ``read_measurement_ticks command``.

              The value measurement_period gives an indication how fast new measurement data
              is available.

              In case ``measurement_period <= the measure-time`` the readout frequency is about ~10Hz.
              In case ``measurement_period > the measure-time`` the readout frequency is approximated with the formula:

              ``Readout frequency in Hz = 1000 / (measurement_period)``


              The maximum value for ``measurement_period`` is 65536

        :Example:
            .. code-block:: python

                sensor.start_concentration_measurement(1000)

        """
        transfer = StartConcentrationMeasurement(measurement_period)
        return execute_transfer(self._channel, transfer)

    def read_measurement_ticks(self):
        """
        Read the measurement values from the sensor.

        Between the command ``start_concentration_measurement`` and the command read_measurement_ticks
        it is required to wait for the maximum value of measure-time ms and measurement_period ms. Otherwise the sensor will NACK the request.
        The same wait time needs to be observed between two successive calls to ``read_measurement_ticks``.

        :return h2_concentration:
            The H₂ concentration as ticks. The returned value can be converted
            into volume % in air using the following formula:

            ``H₂[vol % in air] = (H2_concentration - 2**14)/2**15 * scale_factor``
        :return temperature:
            The temperature as ticks. The returned value can be converted into a
            temperature °C using the following formula:

            ``T [°C] = -45 + 175*temperature/(2**16-1)``
        :return relative_humidity:
            The relative humidity as ticks. The returned value can be converted into
            relative humidity % using the following formula:

            ``RH % = -6 + 125*relative_humidity/(2**16-1)``
        :return ambient_pressure:
            The ambient pressure in mBar. No further conversion is required.
        :return error_flags:
            Error information for current data reading.
        :return scale_factor:
            The first 12 bits contain the factor that needs to be applied to convert the raw value into the physical unit.
            The bits 12 to 15 contain information about the unit:

            - 1 = %vol
            - 2 = ‰vol
            - 3 = hPa partial pressure
            - 4 = mmHg partial pressure

        .. note::
            It is not required to read all values. The read can be stopped after each field
        """
        transfer = ReadMeasurementTicks()
        res_0, res_1, res_2, res_3, res_4, res_5 = execute_transfer(self._channel, transfer)
        return res_0, res_1, res_2, res_3, ReadErrorFlags(res_4), ScaleFactorType(res_5)

    def stop_measurement(self):
        """The sensor will stop measuring"""
        transfer = StopMeasurement()
        return execute_transfer(self._channel, transfer)

    def compensate_temperature_with_sht4x(self):
        """
        When using this option the STC4x will read temperature values from an **SHT4x** sensor that
        is attached to the I²C master bus of the STC (Pin 9 and 1).
        """
        transfer = CompensateTemperatureWithSht4x()
        return execute_transfer(self._channel, transfer)

    def enable_manual_temperature_compensation(self):
        """Allows to write temperature values to the sensor"""
        transfer = EnableManualTemperatureCompensation()
        return execute_transfer(self._channel, transfer)

    def set_compensation_temperature_ticks(self, temperature_ticks):
        """
        Write a new temperature value to the sensor. The value is used as temperature compensation value
        until another value is written to the sensor.

        :param temperature_ticks:
            Value to be used to compensate temperature as ticks.

        :Example:
            .. code-block:: python

                sensor.set_compensation_temperature_ticks(26214)

        """
        transfer = SetCompensationTemperatureTicks(temperature_ticks)
        return execute_transfer(self._channel, transfer)

    def compensate_humidity_with_sht4x(self):
        """
        When using this option the STC4x will read relative humidity values from an **SHT4x** sensor that
        is attached to the I²C master bus of the STC (Pin 9 and 1).
        """
        transfer = CompensateHumidityWithSht4x()
        return execute_transfer(self._channel, transfer)

    def enable_manual_humidity_compensation(self):
        """
        Enables the option to adjust the readings for humidity impact using values written by
        application software.
        """
        transfer = EnableManualHumidityCompensation()
        return execute_transfer(self._channel, transfer)

    def set_compensation_humidity_ticks(self, relative_humidity_ticks):
        """
        Write a new relative humidity value to the sensor. The value is used as relative_humidity
        compensation value until another value is written to the sensor.

        :param relative_humidity_ticks:
            Value to the as relative humidity compensation value as ticks

        :Example:
            .. code-block:: python

                sensor.set_compensation_humidity_ticks(29359)

        """
        transfer = SetCompensationHumidityTicks(relative_humidity_ticks)
        return execute_transfer(self._channel, transfer)

    def enable_manual_pressure_compensation(self):
        """
        Enables the option to adjust the readings for pressure impact using values written by
        application software.
        """
        transfer = EnableManualPressureCompensation()
        return execute_transfer(self._channel, transfer)

    def set_compensation_pressure_mbar(self, pressure_mbar):
        """
        Write a new pressure value [mbar] to the sensor. The value is used as pressure
        compensation value until another value is written to the sensor.

        :param pressure_mbar:
            Pressure compensation value

        :Example:
            .. code-block:: python

                sensor.set_compensation_pressure_mbar(1013)

        """
        transfer = SetCompensationPressureMbar(pressure_mbar)
        return execute_transfer(self._channel, transfer)

    def perform_forced_recalibration_ticks(self, hydrogen_concentration):
        """
        Forced recalibration is used to improve the sensor output with a known reference value.

        Before initiating forced recalibration, the sensor needs to be configured for proper compensation of ambient conditions (temperature, relative humidity and pressure).
        The effect of FRC takes place immediately after the command is executed and takes effect with the first subsequent measurement.

        FRC must only be performed when a well-known accurate reference concentration value is available, e.g. in a production facility where only air is present.
        Sensors can be permanently compromised if FRC is performed with a parameter ``hydrogen_concentration`` that largely deviates from the actual gas concentrations.
        For the best possible performance, the FRC should be executed close to the median operating temperature, humidity, pressure, and concentration of the end application.

        Typical applications for FRC:

        - After soldering and assembly
        - Before commissioning a product
        - Before starting a measurement series


        The forced recalibration requires that the command ``start_concentration_measurement`` was called before with ``measurement_period > 0``.
        The command is only started if the error-bits ``i2c_error``, ``vdd_out_of_range`` and
        ``memory_access_error`` are not set.

        :param hydrogen_concentration:
            The tick value is obtained by the form the formula:

            ``H₂[vol % in air] * 2**15 / scale_factor + 2**14 ``

            Therefore, to compensate to a H₂ concentration in Air with 0% H₂ we need to set the value to 16384.

        :Example:
            .. code-block:: python

                sensor.perform_forced_recalibration_ticks(16384)

        """
        transfer = PerformForcedRecalibrationTicks(hydrogen_concentration)
        return execute_transfer(self._channel, transfer)

    def enable_automatic_self_calibration(self):
        """
        **Enable automatic self calibration**

        The sensor runs by default in Automatic Self-Calibration mode.
        This mode will enhance the accuracy for applications where the target gas is not present for most of the time and is mandatory for long term use.
        This feature can be disabled and enabled with the following commands.
        """
        transfer = EnableAutomaticSelfCalibration()
        return execute_transfer(self._channel, transfer)

    def disable_automatic_self_calibration(self):
        """
        **Disable automatic self calibration**

        Allows to disable automatic self calibration.
        """
        transfer = DisableAutomaticSelfCalibration()
        return execute_transfer(self._channel, transfer)

    def enter_sleep_mode(self):
        """
        The enter_sleep_mode command sets the sensor to sleep mode through the I2C interface. The written relative humidity,
        temperature, and pressure compensation values as well as the ASC state will be retained while in sleep mode.
        """
        transfer = EnterSleepMode()
        return execute_transfer(self._channel, transfer)


class Stc42Device(Stc42DeviceBase):
    """Driver class implementation of STC42"""

    #: Access to base class
    stc42 = MixinAccess()

    def __init__(self, channel):
        super().__init__(channel)

    def read_measurements(self):
        """
        Read measurement values and convert them to the appropriate physical units.

        :return hydrogen:
            H₂ in [vol % in air]
        :return temperature:
            Temperature in [°C]
        :return humidity:
            Relative humidity in [%]
        :return ambient_pressure:
            Ambient pressure in [mBar]
        :return error_flags:
            Error flags for the read data
        """
        (h2_raw, t_raw, rh_raw, p, flags, scaling
         ) = self.stc42.read_measurement_ticks()
        return (SignalHydrogen(h2_raw, scaling.scale_factor), SignalTemperature(t_raw),
                SignalRelativeHumidity(rh_raw), p, flags)

    def perform_forced_recalibration(self, h2, scale_factor):
        """
        Perform an FRC with argument H₂ in [vol % in air].

        :param h2:
            H₂ in [vol % in air]
        :param scale_factor:

        """
        full_scale = float(scale_factor & 4095)
        hydrogen_ticks = int(((h2 * 32768.0) / full_scale) + 16384.0)
        self.stc42.perform_forced_recalibration_ticks(hydrogen_ticks)

    def set_compensation_temperature(self, t):
        """
        Set the temperature compensation with argument T [°C]

        :param t:
            Temperature T [°C]
        """
        temperature_ticks = int(((t + 45.0) * 65535.0) / 175)
        self.stc42.set_compensation_temperature_ticks(temperature_ticks)

    def set_compensation_humidity(self, rh):
        """
        Set the humidity compensation with argument RH [%]

        :param rh:
            Relative humidity RH [%]
        """
        humidity_ticks = int(((rh + 6.0) * 65535.0) / 125)
        self.stc42.set_compensation_humidity_ticks(humidity_ticks)
