/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_EXTRACTTMAINFOPASS
#define GEN_PASS_DECL_GENERALIZEKERNELSIGNATUREPASS
#define GEN_PASS_DECL_LOADINT4REWRITEPASS
#define GEN_PASS_DECL_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#define GEN_PASS_DECL_TRITONXLAEXTRACTINSERTTOTRITONPASS
#define GEN_PASS_DECL_TRITONXLAFOLDTRANSPOSEPASS
#define GEN_PASS_DECL_TRITONXLALOWERGETTIDPASS
#define GEN_PASS_DECL_TRITONXLASQUEEZEDIMSPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ExtractTmaInfoPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXTRACTTMAINFOPASS
#undef GEN_PASS_DECL_EXTRACTTMAINFOPASS
#endif // GEN_PASS_DECL_EXTRACTTMAINFOPASS
#ifdef GEN_PASS_DEF_EXTRACTTMAINFOPASS
namespace impl {

template <typename DerivedT>
class ExtractTmaInfoPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExtractTmaInfoPassBase;

  ExtractTmaInfoPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExtractTmaInfoPassBase(const ExtractTmaInfoPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ExtractTmaInfoPassBase& operator=(const ExtractTmaInfoPassBase &) = delete;
  ExtractTmaInfoPassBase(ExtractTmaInfoPassBase &&) = delete;
  ExtractTmaInfoPassBase& operator=(ExtractTmaInfoPassBase &&) = delete;
  ~ExtractTmaInfoPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("extract-tma-info");
  }
  ::llvm::StringRef getArgument() const override { return "extract-tma-info"; }

  ::llvm::StringRef getDescription() const override { return "Extract TMA info during Triton lowering."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExtractTmaInfoPass");
  }
  ::llvm::StringRef getName() const override { return "ExtractTmaInfoPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExtractTmaInfoPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXTRACTTMAINFOPASS
#endif // GEN_PASS_DEF_EXTRACTTMAINFOPASS

//===----------------------------------------------------------------------===//
// GeneralizeKernelSignaturePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GENERALIZEKERNELSIGNATUREPASS
#undef GEN_PASS_DECL_GENERALIZEKERNELSIGNATUREPASS
#endif // GEN_PASS_DECL_GENERALIZEKERNELSIGNATUREPASS
#ifdef GEN_PASS_DEF_GENERALIZEKERNELSIGNATUREPASS
namespace impl {

template <typename DerivedT>
class GeneralizeKernelSignaturePassBase : public ::mlir::OperationPass<> {
public:
  using Base = GeneralizeKernelSignaturePassBase;

  GeneralizeKernelSignaturePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GeneralizeKernelSignaturePassBase(const GeneralizeKernelSignaturePassBase &other) : ::mlir::OperationPass<>(other) {}
  GeneralizeKernelSignaturePassBase& operator=(const GeneralizeKernelSignaturePassBase &) = delete;
  GeneralizeKernelSignaturePassBase(GeneralizeKernelSignaturePassBase &&) = delete;
  GeneralizeKernelSignaturePassBase& operator=(GeneralizeKernelSignaturePassBase &&) = delete;
  ~GeneralizeKernelSignaturePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("generalize-kernel-signature");
  }
  ::llvm::StringRef getArgument() const override { return "generalize-kernel-signature"; }

  ::llvm::StringRef getDescription() const override { return "Rewrite kernels to use generic data pointer arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GeneralizeKernelSignaturePass");
  }
  ::llvm::StringRef getName() const override { return "GeneralizeKernelSignaturePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GeneralizeKernelSignaturePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GENERALIZEKERNELSIGNATUREPASS
#endif // GEN_PASS_DEF_GENERALIZEKERNELSIGNATUREPASS

//===----------------------------------------------------------------------===//
// LoadInt4RewritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOADINT4REWRITEPASS
std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass();
#undef GEN_PASS_DECL_LOADINT4REWRITEPASS
#endif // GEN_PASS_DECL_LOADINT4REWRITEPASS
#ifdef GEN_PASS_DEF_LOADINT4REWRITEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class LoadInt4RewritePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LoadInt4RewritePassBase;

  LoadInt4RewritePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LoadInt4RewritePassBase(const LoadInt4RewritePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LoadInt4RewritePassBase& operator=(const LoadInt4RewritePassBase &) = delete;
  LoadInt4RewritePassBase(LoadInt4RewritePassBase &&) = delete;
  LoadInt4RewritePassBase& operator=(LoadInt4RewritePassBase &&) = delete;
  ~LoadInt4RewritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("int4-to-packed-int4-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "int4-to-packed-int4-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Converts ops with int4 tensors to the ops with int4 packed to int8 tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoadInt4RewritePass");
  }
  ::llvm::StringRef getName() const override { return "LoadInt4RewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoadInt4RewritePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass() {
  return impl::createLoadInt4RewritePass();
}
#undef GEN_PASS_DEF_LOADINT4REWRITEPASS
#endif // GEN_PASS_DEF_LOADINT4REWRITEPASS

//===----------------------------------------------------------------------===//
// RoundF32ToTF32ForTf32DotRewritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#undef GEN_PASS_DECL_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#endif // GEN_PASS_DECL_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#ifdef GEN_PASS_DEF_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
namespace impl {

template <typename DerivedT>
class RoundF32ToTF32ForTf32DotRewritePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = RoundF32ToTF32ForTf32DotRewritePassBase;

  RoundF32ToTF32ForTf32DotRewritePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RoundF32ToTF32ForTf32DotRewritePassBase(const RoundF32ToTF32ForTf32DotRewritePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  RoundF32ToTF32ForTf32DotRewritePassBase& operator=(const RoundF32ToTF32ForTf32DotRewritePassBase &) = delete;
  RoundF32ToTF32ForTf32DotRewritePassBase(RoundF32ToTF32ForTf32DotRewritePassBase &&) = delete;
  RoundF32ToTF32ForTf32DotRewritePassBase& operator=(RoundF32ToTF32ForTf32DotRewritePassBase &&) = delete;
  ~RoundF32ToTF32ForTf32DotRewritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("round-f32-to-tf32-for-tf32-dot-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "round-f32-to-tf32-for-tf32-dot-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "dot with tf32 algorithm requires explicit rounding."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RoundF32ToTF32ForTf32DotRewritePass");
  }
  ::llvm::StringRef getName() const override { return "RoundF32ToTF32ForTf32DotRewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RoundF32ToTF32ForTf32DotRewritePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#endif // GEN_PASS_DEF_ROUNDF32TOTF32FORTF32DOTREWRITEPASS

//===----------------------------------------------------------------------===//
// TritonXLAExtractInsertToTritonPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLAEXTRACTINSERTTOTRITONPASS
struct TritonXLAExtractInsertToTritonPassOptions {
  bool allow_tma_ = false;
};
#undef GEN_PASS_DECL_TRITONXLAEXTRACTINSERTTOTRITONPASS
#endif // GEN_PASS_DECL_TRITONXLAEXTRACTINSERTTOTRITONPASS
#ifdef GEN_PASS_DEF_TRITONXLAEXTRACTINSERTTOTRITONPASS
namespace impl {

template <typename DerivedT>
class TritonXLAExtractInsertToTritonPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAExtractInsertToTritonPassBase;

  TritonXLAExtractInsertToTritonPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAExtractInsertToTritonPassBase(const TritonXLAExtractInsertToTritonPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAExtractInsertToTritonPassBase& operator=(const TritonXLAExtractInsertToTritonPassBase &) = delete;
  TritonXLAExtractInsertToTritonPassBase(TritonXLAExtractInsertToTritonPassBase &&) = delete;
  TritonXLAExtractInsertToTritonPassBase& operator=(TritonXLAExtractInsertToTritonPassBase &&) = delete;
  ~TritonXLAExtractInsertToTritonPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-extract-insert-to-triton");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-extract-insert-to-triton"; }

  ::llvm::StringRef getDescription() const override { return "Convert Triton XLA extract and insert ops to Triton ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAExtractInsertToTritonPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAExtractInsertToTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<triton::TritonDialect>();
    registry.insert<::xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAExtractInsertToTritonPassBase<DerivedT>)

  TritonXLAExtractInsertToTritonPassBase(TritonXLAExtractInsertToTritonPassOptions options) : TritonXLAExtractInsertToTritonPassBase() {
    allow_tma_ = std::move(options.allow_tma_);
  }
protected:
  ::mlir::Pass::Option<bool> allow_tma_{*this, "allow_tma", ::llvm::cl::desc("Whether to permit lowering to TMA."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLAEXTRACTINSERTTOTRITONPASS
#endif // GEN_PASS_DEF_TRITONXLAEXTRACTINSERTTOTRITONPASS

//===----------------------------------------------------------------------===//
// TritonXLAFoldTransposePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLAFOLDTRANSPOSEPASS
#undef GEN_PASS_DECL_TRITONXLAFOLDTRANSPOSEPASS
#endif // GEN_PASS_DECL_TRITONXLAFOLDTRANSPOSEPASS
#ifdef GEN_PASS_DEF_TRITONXLAFOLDTRANSPOSEPASS
namespace impl {

template <typename DerivedT>
class TritonXLAFoldTransposePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAFoldTransposePassBase;

  TritonXLAFoldTransposePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAFoldTransposePassBase(const TritonXLAFoldTransposePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAFoldTransposePassBase& operator=(const TritonXLAFoldTransposePassBase &) = delete;
  TritonXLAFoldTransposePassBase(TritonXLAFoldTransposePassBase &&) = delete;
  TritonXLAFoldTransposePassBase& operator=(TritonXLAFoldTransposePassBase &&) = delete;
  ~TritonXLAFoldTransposePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-fold-transpose");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-fold-transpose"; }

  ::llvm::StringRef getDescription() const override { return "Folds transposes into loads."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAFoldTransposePass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAFoldTransposePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::triton::xla::XlaTritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAFoldTransposePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLAFOLDTRANSPOSEPASS
#endif // GEN_PASS_DEF_TRITONXLAFOLDTRANSPOSEPASS

//===----------------------------------------------------------------------===//
// TritonXLALowerGetTidPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLALOWERGETTIDPASS
#undef GEN_PASS_DECL_TRITONXLALOWERGETTIDPASS
#endif // GEN_PASS_DECL_TRITONXLALOWERGETTIDPASS
#ifdef GEN_PASS_DEF_TRITONXLALOWERGETTIDPASS
namespace impl {

template <typename DerivedT>
class TritonXLALowerGetTidPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerGetTidPassBase;

  TritonXLALowerGetTidPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerGetTidPassBase(const TritonXLALowerGetTidPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerGetTidPassBase& operator=(const TritonXLALowerGetTidPassBase &) = delete;
  TritonXLALowerGetTidPassBase(TritonXLALowerGetTidPassBase &&) = delete;
  TritonXLALowerGetTidPassBase& operator=(TritonXLALowerGetTidPassBase &&) = delete;
  ~TritonXLALowerGetTidPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-get-tid");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-get-tid"; }

  ::llvm::StringRef getDescription() const override { return "Lower get_tid to the PTX intrinsic."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerGetTidPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerGetTidPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerGetTidPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLALOWERGETTIDPASS
#endif // GEN_PASS_DEF_TRITONXLALOWERGETTIDPASS

//===----------------------------------------------------------------------===//
// TritonXLASqueezeDimsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLASQUEEZEDIMSPASS
struct TritonXLASqueezeDimsPassOptions {
  bool finalize_ = true;
};
#undef GEN_PASS_DECL_TRITONXLASQUEEZEDIMSPASS
#endif // GEN_PASS_DECL_TRITONXLASQUEEZEDIMSPASS
#ifdef GEN_PASS_DEF_TRITONXLASQUEEZEDIMSPASS
namespace impl {

template <typename DerivedT>
class TritonXLASqueezeDimsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLASqueezeDimsPassBase;

  TritonXLASqueezeDimsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLASqueezeDimsPassBase(const TritonXLASqueezeDimsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLASqueezeDimsPassBase& operator=(const TritonXLASqueezeDimsPassBase &) = delete;
  TritonXLASqueezeDimsPassBase(TritonXLASqueezeDimsPassBase &&) = delete;
  TritonXLASqueezeDimsPassBase& operator=(TritonXLASqueezeDimsPassBase &&) = delete;
  ~TritonXLASqueezeDimsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-squeeze-dims");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-squeeze-dims"; }

  ::llvm::StringRef getDescription() const override { return "Remove superfluous size-1 dimensions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLASqueezeDimsPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLASqueezeDimsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::triton::xla::XlaTritonDialect>();
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLASqueezeDimsPassBase<DerivedT>)

  TritonXLASqueezeDimsPassBase(TritonXLASqueezeDimsPassOptions options) : TritonXLASqueezeDimsPassBase() {
    finalize_ = std::move(options.finalize_);
  }
protected:
  ::mlir::Pass::Option<bool> finalize_{*this, "finalize", ::llvm::cl::desc("Convert squeeze_dims back to reshape. Disable for testing only."), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLASQUEEZEDIMSPASS
#endif // GEN_PASS_DEF_TRITONXLASQUEEZEDIMSPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ExtractTmaInfoPass Registration
//===----------------------------------------------------------------------===//

inline void registerExtractTmaInfoPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExtractTmaInfoPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExtractTmaInfoPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExtractTmaInfoPass();
  });
}

//===----------------------------------------------------------------------===//
// GeneralizeKernelSignaturePass Registration
//===----------------------------------------------------------------------===//

inline void registerGeneralizeKernelSignaturePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateGeneralizeKernelSignaturePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGeneralizeKernelSignaturePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateGeneralizeKernelSignaturePass();
  });
}

//===----------------------------------------------------------------------===//
// LoadInt4RewritePass Registration
//===----------------------------------------------------------------------===//

inline void registerLoadInt4RewritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLoadInt4RewritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLoadInt4RewritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLoadInt4RewritePass();
  });
}

//===----------------------------------------------------------------------===//
// RoundF32ToTF32ForTf32DotRewritePass Registration
//===----------------------------------------------------------------------===//

inline void registerRoundF32ToTF32ForTf32DotRewritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRoundF32ToTF32ForTf32DotRewritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRoundF32ToTF32ForTf32DotRewritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRoundF32ToTF32ForTf32DotRewritePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLAExtractInsertToTritonPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLAExtractInsertToTritonPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAExtractInsertToTritonPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLAExtractInsertToTritonPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAExtractInsertToTritonPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLAFoldTransposePass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLAFoldTransposePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAFoldTransposePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLAFoldTransposePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAFoldTransposePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLALowerGetTidPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLALowerGetTidPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerGetTidPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLALowerGetTidPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerGetTidPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLASqueezeDimsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLASqueezeDimsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLASqueezeDimsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLASqueezeDimsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLASqueezeDimsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXlaTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXlaTransformsPasses() {
  registerExtractTmaInfoPass();
  registerGeneralizeKernelSignaturePass();
  registerLoadInt4RewritePass();
  registerRoundF32ToTF32ForTf32DotRewritePass();
  registerTritonXLAExtractInsertToTritonPass();
  registerTritonXLAFoldTransposePass();
  registerTritonXLALowerGetTidPass();
  registerTritonXLASqueezeDimsPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ExtractTmaInfoPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExtractTmaInfoPassBase;

  ExtractTmaInfoPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExtractTmaInfoPassBase(const ExtractTmaInfoPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ExtractTmaInfoPassBase& operator=(const ExtractTmaInfoPassBase &) = delete;
  ExtractTmaInfoPassBase(ExtractTmaInfoPassBase &&) = delete;
  ExtractTmaInfoPassBase& operator=(ExtractTmaInfoPassBase &&) = delete;
  ~ExtractTmaInfoPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("extract-tma-info");
  }
  ::llvm::StringRef getArgument() const override { return "extract-tma-info"; }

  ::llvm::StringRef getDescription() const override { return "Extract TMA info during Triton lowering."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExtractTmaInfoPass");
  }
  ::llvm::StringRef getName() const override { return "ExtractTmaInfoPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExtractTmaInfoPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GeneralizeKernelSignaturePassBase : public ::mlir::OperationPass<> {
public:
  using Base = GeneralizeKernelSignaturePassBase;

  GeneralizeKernelSignaturePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GeneralizeKernelSignaturePassBase(const GeneralizeKernelSignaturePassBase &other) : ::mlir::OperationPass<>(other) {}
  GeneralizeKernelSignaturePassBase& operator=(const GeneralizeKernelSignaturePassBase &) = delete;
  GeneralizeKernelSignaturePassBase(GeneralizeKernelSignaturePassBase &&) = delete;
  GeneralizeKernelSignaturePassBase& operator=(GeneralizeKernelSignaturePassBase &&) = delete;
  ~GeneralizeKernelSignaturePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("generalize-kernel-signature");
  }
  ::llvm::StringRef getArgument() const override { return "generalize-kernel-signature"; }

  ::llvm::StringRef getDescription() const override { return "Rewrite kernels to use generic data pointer arguments."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GeneralizeKernelSignaturePass");
  }
  ::llvm::StringRef getName() const override { return "GeneralizeKernelSignaturePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GeneralizeKernelSignaturePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LoadInt4RewritePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LoadInt4RewritePassBase;

  LoadInt4RewritePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LoadInt4RewritePassBase(const LoadInt4RewritePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LoadInt4RewritePassBase& operator=(const LoadInt4RewritePassBase &) = delete;
  LoadInt4RewritePassBase(LoadInt4RewritePassBase &&) = delete;
  LoadInt4RewritePassBase& operator=(LoadInt4RewritePassBase &&) = delete;
  ~LoadInt4RewritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("int4-to-packed-int4-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "int4-to-packed-int4-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Converts ops with int4 tensors to the ops with int4 packed to int8 tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoadInt4RewritePass");
  }
  ::llvm::StringRef getName() const override { return "LoadInt4RewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoadInt4RewritePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RoundF32ToTF32ForTf32DotRewritePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = RoundF32ToTF32ForTf32DotRewritePassBase;

  RoundF32ToTF32ForTf32DotRewritePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RoundF32ToTF32ForTf32DotRewritePassBase(const RoundF32ToTF32ForTf32DotRewritePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  RoundF32ToTF32ForTf32DotRewritePassBase& operator=(const RoundF32ToTF32ForTf32DotRewritePassBase &) = delete;
  RoundF32ToTF32ForTf32DotRewritePassBase(RoundF32ToTF32ForTf32DotRewritePassBase &&) = delete;
  RoundF32ToTF32ForTf32DotRewritePassBase& operator=(RoundF32ToTF32ForTf32DotRewritePassBase &&) = delete;
  ~RoundF32ToTF32ForTf32DotRewritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("round-f32-to-tf32-for-tf32-dot-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "round-f32-to-tf32-for-tf32-dot-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "dot with tf32 algorithm requires explicit rounding."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RoundF32ToTF32ForTf32DotRewritePass");
  }
  ::llvm::StringRef getName() const override { return "RoundF32ToTF32ForTf32DotRewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RoundF32ToTF32ForTf32DotRewritePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLAExtractInsertToTritonPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAExtractInsertToTritonPassBase;

  TritonXLAExtractInsertToTritonPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAExtractInsertToTritonPassBase(const TritonXLAExtractInsertToTritonPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAExtractInsertToTritonPassBase& operator=(const TritonXLAExtractInsertToTritonPassBase &) = delete;
  TritonXLAExtractInsertToTritonPassBase(TritonXLAExtractInsertToTritonPassBase &&) = delete;
  TritonXLAExtractInsertToTritonPassBase& operator=(TritonXLAExtractInsertToTritonPassBase &&) = delete;
  ~TritonXLAExtractInsertToTritonPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-extract-insert-to-triton");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-extract-insert-to-triton"; }

  ::llvm::StringRef getDescription() const override { return "Convert Triton XLA extract and insert ops to Triton ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAExtractInsertToTritonPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAExtractInsertToTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<triton::TritonDialect>();
    registry.insert<::xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAExtractInsertToTritonPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> allow_tma_{*this, "allow_tma", ::llvm::cl::desc("Whether to permit lowering to TMA."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TritonXLAFoldTransposePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAFoldTransposePassBase;

  TritonXLAFoldTransposePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAFoldTransposePassBase(const TritonXLAFoldTransposePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAFoldTransposePassBase& operator=(const TritonXLAFoldTransposePassBase &) = delete;
  TritonXLAFoldTransposePassBase(TritonXLAFoldTransposePassBase &&) = delete;
  TritonXLAFoldTransposePassBase& operator=(TritonXLAFoldTransposePassBase &&) = delete;
  ~TritonXLAFoldTransposePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-fold-transpose");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-fold-transpose"; }

  ::llvm::StringRef getDescription() const override { return "Folds transposes into loads."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAFoldTransposePass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAFoldTransposePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::triton::xla::XlaTritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAFoldTransposePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLALowerGetTidPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerGetTidPassBase;

  TritonXLALowerGetTidPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerGetTidPassBase(const TritonXLALowerGetTidPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerGetTidPassBase& operator=(const TritonXLALowerGetTidPassBase &) = delete;
  TritonXLALowerGetTidPassBase(TritonXLALowerGetTidPassBase &&) = delete;
  TritonXLALowerGetTidPassBase& operator=(TritonXLALowerGetTidPassBase &&) = delete;
  ~TritonXLALowerGetTidPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-get-tid");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-get-tid"; }

  ::llvm::StringRef getDescription() const override { return "Lower get_tid to the PTX intrinsic."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerGetTidPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerGetTidPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerGetTidPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLASqueezeDimsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLASqueezeDimsPassBase;

  TritonXLASqueezeDimsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLASqueezeDimsPassBase(const TritonXLASqueezeDimsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLASqueezeDimsPassBase& operator=(const TritonXLASqueezeDimsPassBase &) = delete;
  TritonXLASqueezeDimsPassBase(TritonXLASqueezeDimsPassBase &&) = delete;
  TritonXLASqueezeDimsPassBase& operator=(TritonXLASqueezeDimsPassBase &&) = delete;
  ~TritonXLASqueezeDimsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-squeeze-dims");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-squeeze-dims"; }

  ::llvm::StringRef getDescription() const override { return "Remove superfluous size-1 dimensions."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLASqueezeDimsPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLASqueezeDimsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::triton::xla::XlaTritonDialect>();
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLASqueezeDimsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> finalize_{*this, "finalize", ::llvm::cl::desc("Convert squeeze_dims back to reshape. Disable for testing only."), ::llvm::cl::init(true)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
