from __future__ import annotations
import numpy
import ostk.core.type
import typing
from . import object
__all__ = ['Intersection', 'Object', 'Transformation', 'object']
class Intersection:
    class Type:
        """
        Members:
        
          Undefined
        
          Empty
        
          Point
        
          PointSet
        
          Line
        
          LineString
        
          Segment
        
          Polygon
        
          Complex
        """
        Complex: typing.ClassVar[Intersection.Type]  # value = <Type.Complex: 8>
        Empty: typing.ClassVar[Intersection.Type]  # value = <Type.Empty: 1>
        Line: typing.ClassVar[Intersection.Type]  # value = <Type.Line: 4>
        LineString: typing.ClassVar[Intersection.Type]  # value = <Type.LineString: 6>
        Point: typing.ClassVar[Intersection.Type]  # value = <Type.Point: 2>
        PointSet: typing.ClassVar[Intersection.Type]  # value = <Type.PointSet: 3>
        Polygon: typing.ClassVar[Intersection.Type]  # value = <Type.Polygon: 7>
        Segment: typing.ClassVar[Intersection.Type]  # value = <Type.Segment: 5>
        Undefined: typing.ClassVar[Intersection.Type]  # value = <Type.Undefined: 0>
        __members__: typing.ClassVar[dict[str, Intersection.Type]]  # value = {'Undefined': <Type.Undefined: 0>, 'Empty': <Type.Empty: 1>, 'Point': <Type.Point: 2>, 'PointSet': <Type.PointSet: 3>, 'Line': <Type.Line: 4>, 'LineString': <Type.LineString: 6>, 'Segment': <Type.Segment: 5>, 'Polygon': <Type.Polygon: 7>, 'Complex': <Type.Complex: 8>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def empty() -> Intersection:
        ...
    @staticmethod
    def line(line: object.Line) -> Intersection:
        ...
    @staticmethod
    def point(point: object.Point) -> Intersection:
        ...
    @staticmethod
    def point_set(point_set: object.PointSet) -> Intersection:
        ...
    @staticmethod
    def segment(segment: object.Segment) -> Intersection:
        ...
    @staticmethod
    def string_from_type(arg0: typing.Any) -> ostk.core.type.String:
        ...
    @staticmethod
    def undefined() -> Intersection:
        ...
    def __add__(self, arg0: Intersection) -> Intersection:
        ...
    def __eq__(self, arg0: Intersection) -> bool:
        ...
    def __iadd__(self, arg0: Intersection) -> Intersection:
        ...
    def __ne__(self, arg0: Intersection) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def access_composite(self) -> object.Composite:
        ...
    def as_composite(self) -> object.Composite:
        ...
    def as_line(self) -> object.Line:
        ...
    def as_line_string(self) -> object.LineString:
        ...
    def as_point(self) -> object.Point:
        ...
    def as_point_set(self) -> object.PointSet:
        ...
    def as_polygon(self) -> object.Polygon:
        ...
    def as_segment(self) -> object.Segment:
        ...
    def get_type(self) -> ...:
        ...
    def is_complex(self) -> bool:
        ...
    def is_composite(self) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
    def is_empty(self) -> bool:
        ...
    def is_line(self) -> bool:
        ...
    def is_line_string(self) -> bool:
        ...
    def is_point(self) -> bool:
        ...
    def is_point_set(self) -> bool:
        ...
    def is_polygon(self) -> bool:
        ...
    def is_segment(self) -> bool:
        ...
class Object:
    class Format:
        """
        Members:
        
          Undefined
        
          Standard
        
          WKT
        """
        Standard: typing.ClassVar[Object.Format]  # value = <Format.Standard: 1>
        Undefined: typing.ClassVar[Object.Format]  # value = <Format.Undefined: 0>
        WKT: typing.ClassVar[Object.Format]  # value = <Format.WKT: 2>
        __members__: typing.ClassVar[dict[str, Object.Format]]  # value = {'Undefined': <Format.Undefined: 0>, 'Standard': <Format.Standard: 1>, 'WKT': <Format.WKT: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: Object) -> bool:
        ...
    def __ne__(self, arg0: Object) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def apply_transformation(self, transformation: typing.Any) -> None:
        ...
    def contains(self, object: Object) -> bool:
        ...
    def intersects(self, object: Object) -> bool:
        ...
    def is_defined(self) -> bool:
        ...
class Transformation:
    class Type:
        """
        Members:
        
          Undefined
        
          Identity
        
          Translation
        
          Rotation
        
          Scaling
        
          Reflection
        
          Shear
        
          Affine
        """
        Affine: typing.ClassVar[Transformation.Type]  # value = <Type.Affine: 7>
        Identity: typing.ClassVar[Transformation.Type]  # value = <Type.Identity: 1>
        Reflection: typing.ClassVar[Transformation.Type]  # value = <Type.Reflection: 5>
        Rotation: typing.ClassVar[Transformation.Type]  # value = <Type.Rotation: 3>
        Scaling: typing.ClassVar[Transformation.Type]  # value = <Type.Scaling: 4>
        Shear: typing.ClassVar[Transformation.Type]  # value = <Type.Shear: 6>
        Translation: typing.ClassVar[Transformation.Type]  # value = <Type.Translation: 2>
        Undefined: typing.ClassVar[Transformation.Type]  # value = <Type.Undefined: 0>
        __members__: typing.ClassVar[dict[str, Transformation.Type]]  # value = {'Undefined': <Type.Undefined: 0>, 'Identity': <Type.Identity: 1>, 'Translation': <Type.Translation: 2>, 'Rotation': <Type.Rotation: 3>, 'Scaling': <Type.Scaling: 4>, 'Reflection': <Type.Reflection: 5>, 'Shear': <Type.Shear: 6>, 'Affine': <Type.Affine: 7>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def identity() -> Transformation:
        ...
    @staticmethod
    def rotation(rotation_angle: typing.Any) -> Transformation:
        ...
    @staticmethod
    def rotation_around(point: object.Point, rotation_angle: typing.Any) -> Transformation:
        ...
    @staticmethod
    def string_from_type(type: typing.Any) -> ostk.core.type.String:
        ...
    @staticmethod
    def translation(transaction_vector: numpy.ndarray[numpy.float64[2, 1]]) -> Transformation:
        ...
    @staticmethod
    def type_of_matrix(matrix: numpy.ndarray[numpy.float64[3, 3]]) -> ...:
        ...
    @staticmethod
    def undefined() -> Transformation:
        ...
    def __eq__(self, arg0: Transformation) -> bool:
        ...
    def __init__(self, matrix: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    def __ne__(self, arg0: Transformation) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @typing.overload
    def apply_to(self, point: object.Point) -> object.Point:
        ...
    @typing.overload
    def apply_to(self, vector: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def get_inverse(self) -> Transformation:
        ...
    def get_matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def get_type(self) -> ...:
        ...
    def is_defined(self) -> bool:
        ...
