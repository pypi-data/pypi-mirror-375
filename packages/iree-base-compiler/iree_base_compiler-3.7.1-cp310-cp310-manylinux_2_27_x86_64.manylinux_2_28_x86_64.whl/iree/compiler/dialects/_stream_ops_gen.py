
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "stream"

@_ods_cext.register_operation(_Dialect)
class AsyncAllocaOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, storage_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(storage_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage_size(self):
    return self.operation.operands[0]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_alloca(result, storage_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncAllocaOp(result=result, storage_size=storage_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def size(self):
    return self.operation.operands[1]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_barrier(source, size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncBarrierOp(source=source, size=size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncCallOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.call"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_ends, resource_operand_lengths, result_sizes, *, tied_operands=None, arg_attrs=None, res_attrs=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(resource_operand_offsets))
    operands.append(_get_op_results_or_values(resource_operand_ends))
    operands.append(_get_op_results_or_values(resource_operand_lengths))
    operands.append(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resource_operand_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def resource_operand_ends(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def resource_operand_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def callee(self):
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def async_call(results_, callee, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_ends, resource_operand_lengths, result_sizes, *, tied_operands=None, arg_attrs=None, res_attrs=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AsyncCallOp(results_=results_, callee=callee, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, resource_operand_offsets=resource_operand_offsets, resource_operand_ends=resource_operand_ends, resource_operand_lengths=resource_operand_lengths, result_sizes=result_sizes, tied_operands=tied_operands, arg_attrs=arg_attrs, res_attrs=res_attrs, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AsyncCloneOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.clone"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result_size(self):
    return self.operation.operands[2]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_clone(result, source, source_size, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncCloneOp(result=result, source=source, source_size=source_size, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncCollectiveOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.collective"

  _ODS_REGIONS = (0, True)

  def __init__(self, op, target, target_size, target_offset, target_end, target_length, source, source_size, source_offset, source_end, source_length, element_count, channel, *, param=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_end)
    operands.append(target_length)
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_end)
    operands.append(source_length)
    operands.append(element_count)
    operands.append(channel)
    if param is not None: operands.append(param)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op"] = (op if (
    isinstance(op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_CollectiveAttr')) else
      _ods_ir.AttrBuilder.get('Stream_CollectiveAttr')(op, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_end(self):
    return self.operation.operands[3]

  @builtins.property
  def target_length(self):
    return self.operation.operands[4]

  @builtins.property
  def source(self):
    return self.operation.operands[5]

  @builtins.property
  def source_size(self):
    return self.operation.operands[6]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[7]

  @builtins.property
  def source_end(self):
    return self.operation.operands[8]

  @builtins.property
  def source_length(self):
    return self.operation.operands[9]

  @builtins.property
  def element_count(self):
    return self.operation.operands[10]

  @builtins.property
  def channel(self):
    return self.operation.operands[11]

  @builtins.property
  def param(self):
    return None if len(self.operation.operands) < 13 else self.operation.operands[12]

  @builtins.property
  def op(self):
    return self.operation.attributes["op"]

  @op.setter
  def op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_collective(op, target, target_size, target_offset, target_end, target_length, source, source_size, source_offset, source_end, source_length, element_count, channel, *, param=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncCollectiveOp(op=op, target=target, target_size=target_size, target_offset=target_offset, target_end=target_end, target_length=target_length, source=source, source_size=source_size, source_offset=source_offset, source_end=source_end, source_length=source_length, element_count=element_count, channel=channel, param=param, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncConcurrentOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.concurrent"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, resource_operands, resource_operand_sizes, result_sizes, *, tied_operands=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

def async_concurrent(results_, resource_operands, resource_operand_sizes, result_sizes, *, tied_operands=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AsyncConcurrentOp(results_=results_, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, result_sizes=result_sizes, tied_operands=tied_operands, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AsyncConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_size(self):
    return self.operation.operands[0]

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_constant(result, value, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncConstantOp(result=result, value=value, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_end, source, source_size, source_offset, source_end, length, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_end)
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_end)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_end(self):
    return self.operation.operands[3]

  @builtins.property
  def source(self):
    return self.operation.operands[4]

  @builtins.property
  def source_size(self):
    return self.operation.operands[5]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[6]

  @builtins.property
  def source_end(self):
    return self.operation.operands[7]

  @builtins.property
  def length(self):
    return self.operation.operands[8]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_copy(target, target_size, target_offset, target_end, source, source_size, source_offset, source_end, length, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncCopyOp(target=target, target_size=target_size, target_offset=target_offset, target_end=target_end, source=source, source_size=source_size, source_offset=source_offset, source_end=source_end, length=length, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncDispatchOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, workload, entry_points, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_ends, resource_operand_lengths, result_sizes, *, tied_operands=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(resource_operand_offsets))
    operands.append(_get_op_results_or_values(resource_operand_ends))
    operands.append(_get_op_results_or_values(resource_operand_lengths))
    operands.append(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_points"] = (entry_points if (
    isinstance(entry_points, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(entry_points, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def resource_operand_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def resource_operand_ends(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def resource_operand_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def result_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def entry_points(self):
    return self.operation.attributes["entry_points"]

  @entry_points.setter
  def entry_points(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_points"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def async_dispatch(results_, workload, entry_points, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_ends, resource_operand_lengths, result_sizes, *, tied_operands=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(AsyncDispatchOp(results_=results_, workload=workload, entry_points=entry_points, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, resource_operand_offsets=resource_operand_offsets, resource_operand_ends=resource_operand_ends, resource_operand_lengths=resource_operand_lengths, result_sizes=result_sizes, tied_operands=tied_operands, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AsyncExecuteOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.execute"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,0,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, result_timepoint, resource_operands, resource_operand_sizes, result_sizes, *, await_timepoint=None, tied_operands=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(result_sizes))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def await_timepoint(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def body(self):
    return self.regions[0]

def async_execute(results_, result_timepoint, resource_operands, resource_operand_sizes, result_sizes, *, await_timepoint=None, tied_operands=None, affinity=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(AsyncExecuteOp(results_=results_, result_timepoint=result_timepoint, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, result_sizes=result_sizes, await_timepoint=await_timepoint, tied_operands=tied_operands, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class AsyncFillOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.fill"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_end, target_length, value, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_end)
    operands.append(target_length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_end(self):
    return self.operation.operands[3]

  @builtins.property
  def target_length(self):
    return self.operation.operands[4]

  @builtins.property
  def value(self):
    return self.operation.operands[5]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_fill(target, target_size, target_offset, target_end, target_length, value, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncFillOp(target=target, target_size=target_size, target_offset=target_offset, target_end=target_end, target_length=target_length, value=value, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncFuncOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_750')) else
      _ods_ir.AttrBuilder.get('anonymous_750')(function_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self):
    return self.regions[0]

def async_func(sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return AsyncFuncOp(sym_name=sym_name, function_type=function_type, tied_operands=tied_operands, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AsyncLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, source_offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_load(result, source, source_size, source_offset, *, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncLoadOp(result=result, source=source, source_size=source_size, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, source_end, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_end)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def source_end(self):
    return self.operation.operands[3]

  @builtins.property
  def result_size(self):
    return self.operation.operands[4]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_slice(source, source_size, source_offset, source_end, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncSliceOp(source=source, source_size=source_size, source_offset=source_offset, source_end=source_end, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncSplatOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.splat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def result_size(self):
    return self.operation.operands[1]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_splat(result, value, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncSplatOp(result=result, value=value, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def value(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_store(target, target_size, target_offset, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncStoreOp(target=target, target_size=target_size, target_offset=target_offset, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncTransferOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, result_size, *, source_affinity=None, result_affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_affinity is not None: attributes["source_affinity"] = (source_affinity if (
        isinstance(source_affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(source_affinity, context=_ods_context))
    if result_affinity is not None: attributes["result_affinity"] = (result_affinity if (
        isinstance(result_affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(result_affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result_size(self):
    return self.operation.operands[2]

  @builtins.property
  def source_affinity(self):
    if "source_affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_affinity"]

  @source_affinity.setter
  def source_affinity(self, value):
    if value is not None:
      self.operation.attributes["source_affinity"] = value
    elif "source_affinity" in self.operation.attributes:
      del self.operation.attributes["source_affinity"]

  @source_affinity.deleter
  def source_affinity(self):
    del self.operation.attributes["source_affinity"]

  @builtins.property
  def result_affinity(self):
    if "result_affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["result_affinity"]

  @result_affinity.setter
  def result_affinity(self, value):
    if value is not None:
      self.operation.attributes["result_affinity"] = value
    elif "result_affinity" in self.operation.attributes:
      del self.operation.attributes["result_affinity"]

  @result_affinity.deleter
  def result_affinity(self):
    del self.operation.attributes["result_affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_transfer(result, source, source_size, result_size, *, source_affinity=None, result_affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncTransferOp(result=result, source=source, source_size=source_size, result_size=result_size, source_affinity=source_affinity, result_affinity=result_affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AsyncUpdateOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.async.update"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_end, update, update_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_end)
    operands.append(update)
    operands.append(update_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_end(self):
    return self.operation.operands[3]

  @builtins.property
  def update(self):
    return self.operation.operands[4]

  @builtins.property
  def update_size(self):
    return self.operation.operands[5]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def async_update(target, target_size, target_offset, target_end, update, update_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return AsyncUpdateOp(target=target, target_size=target_size, target_offset=target_offset, target_end=target_end, update=update, update_size=update_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BindingSubspanOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.binding.subspan"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, binding, byte_offset, dynamic_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(binding)
    operands.append(byte_offset)
    operands.extend(_get_op_results_or_values(dynamic_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def binding(self):
    return self.operation.operands[0]

  @builtins.property
  def byte_offset(self):
    return self.operation.operands[1]

  @builtins.property
  def dynamic_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def binding_subspan(result, binding, byte_offset, dynamic_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return BindingSubspanOp(result=result, binding=binding, byte_offset=byte_offset, dynamic_dims=dynamic_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelCountOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.channel.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_count(channel, *, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelCountOp(channel=channel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelCreateOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.channel.create"

  _ODS_OPERAND_SEGMENTS = [0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, *, id=None, group=None, rank=None, count=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(id)
    operands.append(rank)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    if group is not None: attributes["group"] = (group if (
        isinstance(group, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(group, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def rank(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def count(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def group(self):
    if "group" not in self.operation.attributes:
      return None
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is not None:
      self.operation.attributes["group"] = value
    elif "group" in self.operation.attributes:
      del self.operation.attributes["group"]

  @group.deleter
  def group(self):
    del self.operation.attributes["group"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_create(*, id=None, group=None, rank=None, count=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelCreateOp(id=id, group=group, rank=rank, count=count, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelRankOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.channel.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_rank(channel, *, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelRankOp(channel=channel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelSplitOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.channel.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, color, key, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    operands.append(color)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    return self.operation.operands[0]

  @builtins.property
  def color(self):
    return self.operation.operands[1]

  @builtins.property
  def key(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_split(channel, color, key, *, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelSplitOp(channel=channel, color=color, key=key, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmdCallOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.call"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_lengths, result_sizes, resource_operand_accesses, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(_get_op_results_or_values(resource_operand_offsets))
    operands.append(_get_op_results_or_values(resource_operand_lengths))
    operands.append(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    attributes["resource_operand_accesses"] = (resource_operand_accesses if (
    isinstance(resource_operand_accesses, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_ResourceAccessArrayAttr')) else
      _ods_ir.AttrBuilder.get('Stream_ResourceAccessArrayAttr')(resource_operand_accesses, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resource_operand_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def resource_operand_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def callee(self):
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def resource_operand_accesses(self):
    return self.operation.attributes["resource_operand_accesses"]

  @resource_operand_accesses.setter
  def resource_operand_accesses(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resource_operand_accesses"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def cmd_call(results_, callee, resource_operands, resource_operand_sizes, resource_operand_offsets, resource_operand_lengths, result_sizes, resource_operand_accesses, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CmdCallOp(results_=results_, callee=callee, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, resource_operand_offsets=resource_operand_offsets, resource_operand_lengths=resource_operand_lengths, result_sizes=result_sizes, resource_operand_accesses=resource_operand_accesses, tied_operands=tied_operands, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class CmdCollectiveOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.collective"

  _ODS_OPERAND_SEGMENTS = [1,1,0,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, op, channel, element_count, resources, resource_sizes, resource_offsets, resource_lengths, resource_accesses, *, param=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    operands.append(element_count)
    operands.append(param)
    operands.append(_get_op_results_or_values(resources))
    operands.append(_get_op_results_or_values(resource_sizes))
    operands.append(_get_op_results_or_values(resource_offsets))
    operands.append(_get_op_results_or_values(resource_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["op"] = (op if (
    isinstance(op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_CollectiveAttr')) else
      _ods_ir.AttrBuilder.get('Stream_CollectiveAttr')(op, context=_ods_context))
    attributes["resource_accesses"] = (resource_accesses if (
    isinstance(resource_accesses, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_ResourceAccessArrayAttr')) else
      _ods_ir.AttrBuilder.get('Stream_ResourceAccessArrayAttr')(resource_accesses, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def element_count(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def param(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def resources(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def resource_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def resource_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def resource_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def op(self):
    return self.operation.attributes["op"]

  @op.setter
  def op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["op"] = value

  @builtins.property
  def resource_accesses(self):
    return self.operation.attributes["resource_accesses"]

  @resource_accesses.setter
  def resource_accesses(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resource_accesses"] = value

def cmd_collective(op, channel, element_count, resources, resource_sizes, resource_offsets, resource_lengths, resource_accesses, *, param=None, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdCollectiveOp(op=op, channel=channel, element_count=element_count, resources=resources, resource_sizes=resource_sizes, resource_offsets=resource_offsets, resource_lengths=resource_lengths, resource_accesses=resource_accesses, param=param, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdConcurrentOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.concurrent"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self):
    return self.regions[0]

def cmd_concurrent(*, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdConcurrentOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdCopyOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.copy"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, target, target_size, target_offset, length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target(self):
    return self.operation.operands[3]

  @builtins.property
  def target_size(self):
    return self.operation.operands[4]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[5]

  @builtins.property
  def length(self):
    return self.operation.operands[6]

def cmd_copy(source, source_size, source_offset, target, target_size, target_offset, length, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdCopyOp(source=source, source_size=source_size, source_offset=source_offset, target=target, target_size=target_size, target_offset=target_offset, length=length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdDiscardOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.discard"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_length, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_length(self):
    return self.operation.operands[3]

def cmd_discard(target, target_size, target_offset, target_length, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdDiscardOp(target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdDispatchOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, workload, entry_points, uniform_operands, resources, resource_sizes, resource_offsets, resource_lengths, resource_accesses, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(uniform_operands))
    operands.append(_get_op_results_or_values(resources))
    operands.append(_get_op_results_or_values(resource_sizes))
    operands.append(_get_op_results_or_values(resource_offsets))
    operands.append(_get_op_results_or_values(resource_lengths))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_points"] = (entry_points if (
    isinstance(entry_points, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(entry_points, context=_ods_context))
    attributes["resource_accesses"] = (resource_accesses if (
    isinstance(resource_accesses, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_ResourceAccessArrayAttr')) else
      _ods_ir.AttrBuilder.get('Stream_ResourceAccessArrayAttr')(resource_accesses, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def uniform_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resources(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def resource_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def resource_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def resource_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def entry_points(self):
    return self.operation.attributes["entry_points"]

  @entry_points.setter
  def entry_points(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_points"] = value

  @builtins.property
  def resource_accesses(self):
    return self.operation.attributes["resource_accesses"]

  @resource_accesses.setter
  def resource_accesses(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resource_accesses"] = value

def cmd_dispatch(workload, entry_points, uniform_operands, resources, resource_sizes, resource_offsets, resource_lengths, resource_accesses, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdDispatchOp(workload=workload, entry_points=entry_points, uniform_operands=uniform_operands, resources=resources, resource_sizes=resource_sizes, resource_offsets=resource_offsets, resource_lengths=resource_lengths, resource_accesses=resource_accesses, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdExecuteOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.execute"

  _ODS_OPERAND_SEGMENTS = [-1,-1,0,]

  _ODS_REGIONS = (1, True)

  def __init__(self, result_timepoint, resource_operands, resource_operand_sizes, *, once=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(once): attributes["once"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def await_timepoint(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def once(self):
    return "once" in self.operation.attributes

  @once.setter
  def once(self, value):
    if bool(value):
      self.operation.attributes["once"] = _ods_ir.UnitAttr.get()
    elif "once" in self.operation.attributes:
      del self.operation.attributes["once"]

  @once.deleter
  def once(self):
    del self.operation.attributes["once"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

  @builtins.property
  def body(self):
    return self.regions[0]

def cmd_execute(result_timepoint, resource_operands, resource_operand_sizes, *, once=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return CmdExecuteOp(result_timepoint=result_timepoint, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, once=once, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CmdFillOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.fill"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_length, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_length(self):
    return self.operation.operands[3]

  @builtins.property
  def value(self):
    return self.operation.operands[4]

def cmd_fill(target, target_size, target_offset, target_length, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdFillOp(target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdFlushOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.flush"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_length, *, source_affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_affinity is not None: attributes["source_affinity"] = (source_affinity if (
        isinstance(source_affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(source_affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_length(self):
    return self.operation.operands[3]

  @builtins.property
  def source_affinity(self):
    if "source_affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_affinity"]

  @source_affinity.setter
  def source_affinity(self, value):
    if value is not None:
      self.operation.attributes["source_affinity"] = value
    elif "source_affinity" in self.operation.attributes:
      del self.operation.attributes["source_affinity"]

  @source_affinity.deleter
  def source_affinity(self):
    del self.operation.attributes["source_affinity"]

def cmd_flush(target, target_size, target_offset, target_length, *, source_affinity=None, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdFlushOp(target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, source_affinity=source_affinity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdFuncOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_750')) else
      _ods_ir.AttrBuilder.get('anonymous_750')(function_type, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self):
    return self.regions[0]

def cmd_func(sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdFuncOp(sym_name=sym_name, function_type=function_type, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdInvalidateOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.invalidate"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, target_length, *, source_affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_affinity is not None: attributes["source_affinity"] = (source_affinity if (
        isinstance(source_affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(source_affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target_length(self):
    return self.operation.operands[3]

  @builtins.property
  def source_affinity(self):
    if "source_affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_affinity"]

  @source_affinity.setter
  def source_affinity(self, value):
    if value is not None:
      self.operation.attributes["source_affinity"] = value
    elif "source_affinity" in self.operation.attributes:
      del self.operation.attributes["source_affinity"]

  @source_affinity.deleter
  def source_affinity(self):
    del self.operation.attributes["source_affinity"]

def cmd_invalidate(target, target_size, target_offset, target_length, *, source_affinity=None, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdInvalidateOp(target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, source_affinity=source_affinity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CmdSerialOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.cmd.serial"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def body(self):
    return self.regions[0]

def cmd_serial(*, loc=None, ip=None) -> _ods_ir.Operation:
  return CmdSerialOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ContextResolveOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.context.resolve"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def context_resolve(results_, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ContextResolveOp(results_=results_, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupCountOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.dispatch.workgroup.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_count(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupCountOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupIDOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.dispatch.workgroup.id"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_id(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupIDOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.dispatch.workgroup.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_size(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupSizeOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecutableEndOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.executable.end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_end(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.executable.export"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_ref, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_ref"] = (function_ref if (
    isinstance(function_ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(function_ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_ref(self):
    return self.operation.attributes["function_ref"]

  @function_ref.setter
  def function_ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_ref"] = value

  @builtins.property
  def workgroup_count(self):
    return self.regions[0]

def executable_export(sym_name, function_ref, *, sym_visibility=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableExportOp(sym_name=sym_name, function_ref=function_ref, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.executable"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self):
    return self.regions[0]

def executable(sym_name, *, sym_visibility=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableOp(sym_name=sym_name, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FileConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.file.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, source_length, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_length)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def source_length(self):
    return self.operation.operands[3]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def file_constant(source, source_size, source_offset, source_length, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return FileConstantOp(source=source, source_size=source_size, source_offset=source_offset, source_length=source_length, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FileReadOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.file.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_offset, target, target_size, target_offset, length, *, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(length)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[1]

  @builtins.property
  def target(self):
    return self.operation.operands[2]

  @builtins.property
  def target_size(self):
    return self.operation.operands[3]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[4]

  @builtins.property
  def length(self):
    return self.operation.operands[5]

  @builtins.property
  def await_timepoint(self):
    return None if len(self.operation.operands) < 7 else self.operation.operands[6]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def file_read(source, source_offset, target, target_size, target_offset, length, *, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return FileReadOp(source=source, source_offset=source_offset, target=target, target_size=target_size, target_offset=target_offset, length=length, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FileWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.file.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, target, target_offset, length, *, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_offset)
    operands.append(length)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def target(self):
    return self.operation.operands[3]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[4]

  @builtins.property
  def length(self):
    return self.operation.operands[5]

  @builtins.property
  def await_timepoint(self):
    return None if len(self.operation.operands) < 7 else self.operation.operands[6]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def file_write(source, source_size, source_offset, target, target_offset, length, *, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return FileWriteOp(source=source, source_size=source_size, source_offset=source_offset, target=target, target_offset=target_offset, length=length, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ParameterGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.parameter.gather"

  _ODS_OPERAND_SEGMENTS = [-1,1,1,-1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source_keys, source_offsets, target, target_size, target_offsets, target_lengths, *, source_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(source_offsets))
    operands.append(target)
    operands.append(target_size)
    operands.append(_get_op_results_or_values(target_offsets))
    operands.append(_get_op_results_or_values(target_lengths))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_scope is not None: attributes["source_scope"] = (source_scope if (
        isinstance(source_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(source_scope, context=_ods_context))
    attributes["source_keys"] = (source_keys if (
    isinstance(source_keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(source_keys, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def target_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def target_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def target_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def await_timepoint(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def source_scope(self):
    if "source_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_scope"]

  @source_scope.setter
  def source_scope(self, value):
    if value is not None:
      self.operation.attributes["source_scope"] = value
    elif "source_scope" in self.operation.attributes:
      del self.operation.attributes["source_scope"]

  @source_scope.deleter
  def source_scope(self):
    del self.operation.attributes["source_scope"]

  @builtins.property
  def source_keys(self):
    return self.operation.attributes["source_keys"]

  @source_keys.setter
  def source_keys(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_keys"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def parameter_gather(source_keys, source_offsets, target, target_size, target_offsets, target_lengths, *, source_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ParameterGatherOp(source_keys=source_keys, source_offsets=source_offsets, target=target, target_size=target_size, target_offsets=target_offsets, target_lengths=target_lengths, source_scope=source_scope, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ParameterLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.parameter.load"

  _ODS_OPERAND_SEGMENTS = [-1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, result_timepoint, source_keys, source_offsets, result_sizes, *, source_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(source_offsets))
    operands.append(_get_op_results_or_values(result_sizes))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_scope is not None: attributes["source_scope"] = (source_scope if (
        isinstance(source_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(source_scope, context=_ods_context))
    attributes["source_keys"] = (source_keys if (
    isinstance(source_keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(source_keys, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def result_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def await_timepoint(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def source_scope(self):
    if "source_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_scope"]

  @source_scope.setter
  def source_scope(self, value):
    if value is not None:
      self.operation.attributes["source_scope"] = value
    elif "source_scope" in self.operation.attributes:
      del self.operation.attributes["source_scope"]

  @source_scope.deleter
  def source_scope(self):
    del self.operation.attributes["source_scope"]

  @builtins.property
  def source_keys(self):
    return self.operation.attributes["source_keys"]

  @source_keys.setter
  def source_keys(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_keys"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def parameter_load(results_, result_timepoint, source_keys, source_offsets, result_sizes, *, source_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(ParameterLoadOp(results_=results_, result_timepoint=result_timepoint, source_keys=source_keys, source_offsets=source_offsets, result_sizes=result_sizes, source_scope=source_scope, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ParameterReadOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.parameter.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, source_key, source_offset, target, target_size, target_offset, target_length, *, source_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source_offset)
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(target_length)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if source_scope is not None: attributes["source_scope"] = (source_scope if (
        isinstance(source_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(source_scope, context=_ods_context))
    attributes["source_key"] = (source_key if (
    isinstance(source_key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(source_key, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source_offset(self):
    return self.operation.operands[0]

  @builtins.property
  def target(self):
    return self.operation.operands[1]

  @builtins.property
  def target_size(self):
    return self.operation.operands[2]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[3]

  @builtins.property
  def target_length(self):
    return self.operation.operands[4]

  @builtins.property
  def await_timepoint(self):
    return None if len(self.operation.operands) < 6 else self.operation.operands[5]

  @builtins.property
  def source_scope(self):
    if "source_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_scope"]

  @source_scope.setter
  def source_scope(self, value):
    if value is not None:
      self.operation.attributes["source_scope"] = value
    elif "source_scope" in self.operation.attributes:
      del self.operation.attributes["source_scope"]

  @source_scope.deleter
  def source_scope(self):
    del self.operation.attributes["source_scope"]

  @builtins.property
  def source_key(self):
    return self.operation.attributes["source_key"]

  @source_key.setter
  def source_key(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_key"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def parameter_read(source_key, source_offset, target, target_size, target_offset, target_length, *, source_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ParameterReadOp(source_key=source_key, source_offset=source_offset, target=target, target_size=target_size, target_offset=target_offset, target_length=target_length, source_scope=source_scope, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ParameterScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.parameter.scatter"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offsets, source_lengths, target_keys, target_offsets, *, target_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(_get_op_results_or_values(source_offsets))
    operands.append(_get_op_results_or_values(source_lengths))
    operands.append(_get_op_results_or_values(target_offsets))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if target_scope is not None: attributes["target_scope"] = (target_scope if (
        isinstance(target_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(target_scope, context=_ods_context))
    attributes["target_keys"] = (target_keys if (
    isinstance(target_keys, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(target_keys, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def source_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def source_lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def target_offsets(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def await_timepoint(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def target_scope(self):
    if "target_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["target_scope"]

  @target_scope.setter
  def target_scope(self, value):
    if value is not None:
      self.operation.attributes["target_scope"] = value
    elif "target_scope" in self.operation.attributes:
      del self.operation.attributes["target_scope"]

  @target_scope.deleter
  def target_scope(self):
    del self.operation.attributes["target_scope"]

  @builtins.property
  def target_keys(self):
    return self.operation.attributes["target_keys"]

  @target_keys.setter
  def target_keys(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_keys"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def parameter_scatter(source, source_size, source_offsets, source_lengths, target_keys, target_offsets, *, target_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ParameterScatterOp(source=source, source_size=source_size, source_offsets=source_offsets, source_lengths=source_lengths, target_keys=target_keys, target_offsets=target_offsets, target_scope=target_scope, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ParameterWriteOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.parameter.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, source_length, target_key, target_offset, *, target_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(source_length)
    operands.append(target_offset)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if target_scope is not None: attributes["target_scope"] = (target_scope if (
        isinstance(target_scope, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(target_scope, context=_ods_context))
    attributes["target_key"] = (target_key if (
    isinstance(target_key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(target_key, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def source_length(self):
    return self.operation.operands[3]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[4]

  @builtins.property
  def await_timepoint(self):
    return None if len(self.operation.operands) < 6 else self.operation.operands[5]

  @builtins.property
  def target_scope(self):
    if "target_scope" not in self.operation.attributes:
      return None
    return self.operation.attributes["target_scope"]

  @target_scope.setter
  def target_scope(self, value):
    if value is not None:
      self.operation.attributes["target_scope"] = value
    elif "target_scope" in self.operation.attributes:
      del self.operation.attributes["target_scope"]

  @target_scope.deleter
  def target_scope(self):
    del self.operation.attributes["target_scope"]

  @builtins.property
  def target_key(self):
    return self.operation.attributes["target_key"]

  @target_key.setter
  def target_key(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_key"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def parameter_write(source, source_size, source_offset, source_length, target_key, target_offset, *, target_scope=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ParameterWriteOp(source=source, source_size=source_size, source_offset=source_offset, source_length=source_length, target_key=target_key, target_offset=target_offset, target_scope=target_scope, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceAllocOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.alloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, storage_size, *, uninitialized=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(storage_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(uninitialized): attributes["uninitialized"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage_size(self):
    return self.operation.operands[0]

  @builtins.property
  def uninitialized(self):
    return "uninitialized" in self.operation.attributes

  @uninitialized.setter
  def uninitialized(self, value):
    if bool(value):
      self.operation.attributes["uninitialized"] = _ods_ir.UnitAttr.get()
    elif "uninitialized" in self.operation.attributes:
      del self.operation.attributes["uninitialized"]

  @uninitialized.deleter
  def uninitialized(self):
    del self.operation.attributes["uninitialized"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resource_alloc(result, storage_size, *, uninitialized=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ResourceAllocOp(result=result, storage_size=storage_size, uninitialized=uninitialized, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceAllocaOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, result_timepoint, storage_size, *, indeterminate_lifetime=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(storage_size)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(indeterminate_lifetime): attributes["indeterminate_lifetime"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage_size(self):
    return self.operation.operands[0]

  @builtins.property
  def await_timepoint(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def indeterminate_lifetime(self):
    return "indeterminate_lifetime" in self.operation.attributes

  @indeterminate_lifetime.setter
  def indeterminate_lifetime(self, value):
    if bool(value):
      self.operation.attributes["indeterminate_lifetime"] = _ods_ir.UnitAttr.get()
    elif "indeterminate_lifetime" in self.operation.attributes:
      del self.operation.attributes["indeterminate_lifetime"]

  @indeterminate_lifetime.deleter
  def indeterminate_lifetime(self):
    del self.operation.attributes["indeterminate_lifetime"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[1]

def resource_alloca(result, result_timepoint, storage_size, *, indeterminate_lifetime=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return ResourceAllocaOp(result=result, result_timepoint=result_timepoint, storage_size=storage_size, indeterminate_lifetime=indeterminate_lifetime, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ResourceConstantsOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.constants"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, result_timepoint, values, result_sizes, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["values"] = (values if (
    isinstance(values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_709')) else
      _ods_ir.AttrBuilder.get('anonymous_709')(values, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    results.append(result_timepoint)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_sizes(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def values(self):
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1 + _ods_variadic_group_length - 1]

def resource_constants(results_, result_timepoint, values, result_sizes, *, affinity=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(ResourceConstantsOp(results_=results_, result_timepoint=result_timepoint, values=values, result_sizes=result_sizes, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ResourceDeallocaOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.dealloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, prefer_origin=None, await_timepoint=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    if await_timepoint is not None: operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(prefer_origin): attributes["prefer_origin"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self):
    return self.operation.operands[1]

  @builtins.property
  def await_timepoint(self):
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def prefer_origin(self):
    return "prefer_origin" in self.operation.attributes

  @prefer_origin.setter
  def prefer_origin(self, value):
    if bool(value):
      self.operation.attributes["prefer_origin"] = _ods_ir.UnitAttr.get()
    elif "prefer_origin" in self.operation.attributes:
      del self.operation.attributes["prefer_origin"]

  @prefer_origin.deleter
  def prefer_origin(self):
    del self.operation.attributes["prefer_origin"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def resource_dealloca(operand, operand_size, *, prefer_origin=None, await_timepoint=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ResourceDeallocaOp(operand=operand, operand_size=operand_size, prefer_origin=prefer_origin, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceIsTerminalOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.is_terminal"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resource_is_terminal(operand, operand_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return ResourceIsTerminalOp(operand=operand, operand_size=operand_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_size, source_offset, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resource_load(result, source, source_size, source_offset, *, loc=None, ip=None) -> _ods_ir.Value:
  return ResourceLoadOp(result=result, source=source, source_size=source_size, source_offset=source_offset, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourcePackOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.pack"

  _ODS_OPERAND_SEGMENTS = [0,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, total_length, packed_offsets, lifetime_intervals, dynamic_slice_sizes, *, offset=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(offset)
    operands.append(_get_op_results_or_values(dynamic_slice_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["lifetime_intervals"] = (lifetime_intervals if (
    isinstance(lifetime_intervals, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('Stream_IndexArrayAttr')) else
      _ods_ir.AttrBuilder.get('Stream_IndexArrayAttr')(lifetime_intervals, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(total_length)
    results.extend(packed_offsets)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def offset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def dynamic_slice_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def lifetime_intervals(self):
    return self.operation.attributes["lifetime_intervals"]

  @lifetime_intervals.setter
  def lifetime_intervals(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["lifetime_intervals"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def total_length(self):
    return self.operation.results[0]

  @builtins.property
  def packed_offsets(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

def resource_pack(total_length, packed_offsets, lifetime_intervals, dynamic_slice_sizes, *, offset=None, affinity=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return _get_op_result_or_op_results(ResourcePackOp(total_length=total_length, packed_offsets=packed_offsets, lifetime_intervals=lifetime_intervals, dynamic_slice_sizes=dynamic_slice_sizes, offset=offset, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ResourceReleaseOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.release"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self):
    return self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resource_release(operand, operand_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return ResourceReleaseOp(operand=operand, operand_size=operand_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceRetainOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.retain"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(operand_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_size(self):
    return self.operation.operands[1]

def resource_retain(operand, operand_size, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ResourceRetainOp(operand=operand, operand_size=operand_size, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ResourceSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resource_size(operand, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return ResourceSizeOp(operand=operand, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_size, target_offset, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(target_size)
    operands.append(target_offset)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_size(self):
    return self.operation.operands[1]

  @builtins.property
  def target_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def value(self):
    return self.operation.operands[3]

def resource_store(target, target_size, target_offset, value, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ResourceStoreOp(target=target, target_size=target_size, target_offset=target_offset, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ResourceSubviewOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.subview"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_size, source_offset, result_size, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_size)
    operands.append(source_offset)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_size(self):
    return self.operation.operands[1]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[2]

  @builtins.property
  def result_size(self):
    return self.operation.operands[3]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def resource_subview(source, source_size, source_offset, result_size, *, loc=None, ip=None) -> _ods_ir.Value:
  return ResourceSubviewOp(source=source, source_size=source_size, source_offset=source_offset, result_size=result_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ResourceTryMapOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.resource.try_map"

  _ODS_REGIONS = (0, True)

  def __init__(self, did_map, result, source, source_offset, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(source_offset)
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(did_map)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_offset(self):
    return self.operation.operands[1]

  @builtins.property
  def result_size(self):
    return self.operation.operands[2]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def did_map(self):
    return self.operation.results[0]

  @builtins.property
  def result(self):
    return self.operation.results[1]

def resource_try_map(did_map, result, source, source_offset, result_size, *, affinity=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return ResourceTryMapOp(did_map=did_map, result=result, source=source, source_offset=source_offset, result_size=result_size, affinity=affinity, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorCloneOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.clone"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    operands.append(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def source_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def result_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def source_encoding(self):
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def result_encoding(self):
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_clone(result, source, source_encoding, source_encoding_dims, source_size, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorCloneOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_encoding, result_encoding_dims, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_encoding_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_encoding_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result_encoding(self):
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_constant(result, value, result_encoding, result_encoding_dims, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorConstantOp(result=result, value=value, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorDispatchOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, workload, entry_points, mixed_operands, operand_sizes, operand_encodings, operand_encoding_dims, result_sizes, result_encodings, result_encoding_dims, *, tied_operands=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(mixed_operands))
    operands.append(_get_op_results_or_values(operand_sizes))
    operands.append(_get_op_results_or_values(operand_encoding_dims))
    operands.append(_get_op_results_or_values(result_sizes))
    operands.append(_get_op_results_or_values(result_encoding_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_points"] = (entry_points if (
    isinstance(entry_points, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(entry_points, context=_ods_context))
    attributes["operand_encodings"] = (operand_encodings if (
    isinstance(operand_encodings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('TypeArrayAttr')(operand_encodings, context=_ods_context))
    attributes["result_encodings"] = (result_encodings if (
    isinstance(result_encodings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('TypeArrayAttr')(result_encodings, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def mixed_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def operand_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def operand_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def entry_points(self):
    return self.operation.attributes["entry_points"]

  @entry_points.setter
  def entry_points(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_points"] = value

  @builtins.property
  def operand_encodings(self):
    return self.operation.attributes["operand_encodings"]

  @operand_encodings.setter
  def operand_encodings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["operand_encodings"] = value

  @builtins.property
  def result_encodings(self):
    return self.operation.attributes["result_encodings"]

  @result_encodings.setter
  def result_encodings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encodings"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def tensor_dispatch(results_, workload, entry_points, mixed_operands, operand_sizes, operand_encodings, operand_encoding_dims, result_sizes, result_encodings, result_encoding_dims, *, tied_operands=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TensorDispatchOp(results_=results_, workload=workload, entry_points=entry_points, mixed_operands=mixed_operands, operand_sizes=operand_sizes, operand_encodings=operand_encodings, operand_encoding_dims=operand_encoding_dims, result_sizes=result_sizes, result_encodings=result_encodings, result_encoding_dims=result_encoding_dims, tied_operands=tied_operands, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TensorEmptyOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_encoding_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_size(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1 + _ods_variadic_group_length - 1]

  @builtins.property
  def result_encoding(self):
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_empty(result, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorEmptyOp(result=result, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorEncodeOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.encode"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    operands.append(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def source_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def result_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def source_encoding(self):
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def result_encoding(self):
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_encode(result, source, source_encoding, source_encoding_dims, source_size, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorEncodeOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorExportOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.extend(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def source_encoding_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source_size(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def source_encoding(self):
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_export(result, source, source_encoding, source_encoding_dims, source_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorExportOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorFillOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.fill"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_encoding, target_encoding_dims, target_size, start_indices, lengths, value, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(target_encoding_dims))
    operands.append(target_size)
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(_get_op_results_or_values(lengths))
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_encoding"] = (target_encoding if (
    isinstance(target_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def target_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def start_indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0]

  @builtins.property
  def target_encoding(self):
    return self.operation.attributes["target_encoding"]

  @target_encoding.setter
  def target_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_fill(target, target_encoding, target_encoding_dims, target_size, start_indices, lengths, value, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorFillOp(target=target, target_encoding=target_encoding, target_encoding_dims=target_encoding_dims, target_size=target_size, start_indices=start_indices, lengths=lengths, value=value, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorImportOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.import"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, result_encoding, result_encoding_dims, result_size, *, consume=None, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.extend(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if bool(consume): attributes["consume"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def result_encoding_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result_size(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def result_encoding(self):
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def consume(self):
    return "consume" in self.operation.attributes

  @consume.setter
  def consume(self, value):
    if bool(value):
      self.operation.attributes["consume"] = _ods_ir.UnitAttr.get()
    elif "consume" in self.operation.attributes:
      del self.operation.attributes["consume"]

  @consume.deleter
  def consume(self):
    del self.operation.attributes["consume"]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_import(result, source, result_encoding, result_encoding_dims, result_size, *, consume=None, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorImportOp(result=result, source=source, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, consume=consume, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.load"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    operands.append(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def source_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def source_encoding(self):
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_load(result, source, source_encoding, source_encoding_dims, source_size, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorLoadOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSizeOfOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.sizeof"

  _ODS_REGIONS = (0, True)

  def __init__(self, encoding, encoding_dims, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(encoding_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["encoding"] = (encoding if (
    isinstance(encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def encoding_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def encoding(self):
    return self.operation.attributes["encoding"]

  @encoding.setter
  def encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def storage_size(self):
    return self.operation.results[0]

def tensor_sizeof(encoding, encoding_dims, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorSizeOfOp(encoding=encoding, encoding_dims=encoding_dims, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.slice"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,-1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_encoding, source_encoding_dims, source_size, start_indices, lengths, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_encoding_dims))
    operands.append(source_size)
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(_get_op_results_or_values(lengths))
    operands.append(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["source_encoding"] = (source_encoding if (
    isinstance(source_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(source_encoding, context=_ods_context))
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def source_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def start_indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def result_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0]

  @builtins.property
  def source_encoding(self):
    return self.operation.attributes["source_encoding"]

  @source_encoding.setter
  def source_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["source_encoding"] = value

  @builtins.property
  def result_encoding(self):
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_slice(result, source, source_encoding, source_encoding_dims, source_size, start_indices, lengths, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorSliceOp(result=result, source=source, source_encoding=source_encoding, source_encoding_dims=source_encoding_dims, source_size=source_size, start_indices=start_indices, lengths=lengths, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSplatOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.splat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.extend(_get_op_results_or_values(result_encoding_dims))
    operands.append(result_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["result_encoding"] = (result_encoding if (
    isinstance(result_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(result_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def result_encoding_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result_size(self):
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def result_encoding(self):
    return self.operation.attributes["result_encoding"]

  @result_encoding.setter
  def result_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["result_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_splat(result, value, result_encoding, result_encoding_dims, result_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorSplatOp(result=result, value=value, result_encoding=result_encoding, result_encoding_dims=result_encoding_dims, result_size=result_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.store"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_encoding, target_encoding_dims, target_size, indices, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(target_encoding_dims))
    operands.append(target_size)
    operands.append(_get_op_results_or_values(indices))
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_encoding"] = (target_encoding if (
    isinstance(target_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_encoding, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def target_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def target_encoding(self):
    return self.operation.attributes["target_encoding"]

  @target_encoding.setter
  def target_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_encoding"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_store(target, target_encoding, target_encoding_dims, target_size, indices, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorStoreOp(target=target, target_encoding=target_encoding, target_encoding_dims=target_encoding_dims, target_size=target_size, indices=indices, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorTraceOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.trace"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, key, resources, resource_sizes, resource_encodings, resource_encoding_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resources))
    operands.append(_get_op_results_or_values(resource_sizes))
    operands.append(_get_op_results_or_values(resource_encoding_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    attributes["resource_encodings"] = (resource_encodings if (
    isinstance(resource_encodings, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('TypeArrayAttr')(resource_encodings, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resources(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def resource_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def key(self):
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

  @builtins.property
  def resource_encodings(self):
    return self.operation.attributes["resource_encodings"]

  @resource_encodings.setter
  def resource_encodings(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["resource_encodings"] = value

def tensor_trace(key, resources, resource_sizes, resource_encodings, resource_encoding_dims, *, loc=None, ip=None) -> _ods_ir.Operation:
  return TensorTraceOp(key=key, resources=resources, resource_sizes=resource_sizes, resource_encodings=resource_encodings, resource_encoding_dims=resource_encoding_dims, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorUpdateOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.tensor.update"

  _ODS_OPERAND_SEGMENTS = [1,-1,1,-1,1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_encoding, target_encoding_dims, target_size, start_indices, update, update_encoding, update_encoding_dims, update_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(target_encoding_dims))
    operands.append(target_size)
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(update)
    operands.append(_get_op_results_or_values(update_encoding_dims))
    operands.append(update_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target_encoding"] = (target_encoding if (
    isinstance(target_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(target_encoding, context=_ods_context))
    attributes["update_encoding"] = (update_encoding if (
    isinstance(update_encoding, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(update_encoding, context=_ods_context))
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def target_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def start_indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def update(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0]

  @builtins.property
  def update_encoding_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def update_size(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0]

  @builtins.property
  def target_encoding(self):
    return self.operation.attributes["target_encoding"]

  @target_encoding.setter
  def target_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target_encoding"] = value

  @builtins.property
  def update_encoding(self):
    return self.operation.attributes["update_encoding"]

  @update_encoding.setter
  def update_encoding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["update_encoding"] = value

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_update(target, target_encoding, target_encoding_dims, target_size, start_indices, update, update_encoding, update_encoding_dims, update_size, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TensorUpdateOp(target=target, target_encoding=target_encoding, target_encoding_dims=target_encoding_dims, target_size=target_size, start_indices=start_indices, update=update, update_encoding=update_encoding, update_encoding_dims=update_encoding_dims, update_size=update_size, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TimepointAwaitOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.timepoint.await"

  _ODS_OPERAND_SEGMENTS = [-1,-1,1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, resource_operands, resource_operand_sizes, await_timepoint, *, sync=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(resource_operands))
    operands.append(_get_op_results_or_values(resource_operand_sizes))
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(sync): attributes["sync"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def resource_operand_sizes(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def await_timepoint(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def sync(self):
    return "sync" in self.operation.attributes

  @sync.setter
  def sync(self, value):
    if bool(value):
      self.operation.attributes["sync"] = _ods_ir.UnitAttr.get()
    elif "sync" in self.operation.attributes:
      del self.operation.attributes["sync"]

  @sync.deleter
  def sync(self):
    del self.operation.attributes["sync"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def timepoint_await(results_, resource_operands, resource_operand_sizes, await_timepoint, *, sync=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TimepointAwaitOp(results_=results_, resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, await_timepoint=await_timepoint, sync=sync, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TimepointBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.timepoint.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, resource, resource_size, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(resource)
    operands.append(resource_size)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource(self):
    return self.operation.operands[0]

  @builtins.property
  def resource_size(self):
    return self.operation.operands[1]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[1]

def timepoint_barrier(resource, resource_size, *, affinity=None, loc=None, ip=None) -> _Sequence[_ods_ir.Value]:
  return TimepointBarrierOp(resource=resource, resource_size=resource_size, affinity=affinity, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class TimepointChainExternalOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.timepoint.chain_external"

  _ODS_REGIONS = (0, True)

  def __init__(self, await_timepoint, external_values, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(await_timepoint)
    operands.extend(_get_op_results_or_values(external_values))
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def await_timepoint(self):
    return self.operation.operands[0]

  @builtins.property
  def external_values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

def timepoint_chain_external(await_timepoint, external_values, *, affinity=None, loc=None, ip=None) -> _ods_ir.Operation:
  return TimepointChainExternalOp(await_timepoint=await_timepoint, external_values=external_values, affinity=affinity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TimepointExportOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.timepoint.export"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, await_timepoint, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(await_timepoint)
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def await_timepoint(self):
    return self.operation.operands[0]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def timepoint_export(results_, await_timepoint, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(TimepointExportOp(results_=results_, await_timepoint=await_timepoint, affinity=affinity, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TimepointImmediateOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.timepoint.immediate"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def timepoint_immediate(*, loc=None, ip=None) -> _ods_ir.Value:
  return TimepointImmediateOp(loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TimepointImportOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.timepoint.import"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, affinity=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    if affinity is not None: attributes["affinity"] = (affinity if (
        isinstance(affinity, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Stream_AffinityAttr')) else
          _ods_ir.AttrBuilder.get('Stream_AffinityAttr')(affinity, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def affinity(self):
    if "affinity" not in self.operation.attributes:
      return None
    return self.operation.attributes["affinity"]

  @affinity.setter
  def affinity(self, value):
    if value is not None:
      self.operation.attributes["affinity"] = value
    elif "affinity" in self.operation.attributes:
      del self.operation.attributes["affinity"]

  @affinity.deleter
  def affinity(self):
    del self.operation.attributes["affinity"]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def timepoint_import(operands_, *, affinity=None, loc=None, ip=None) -> _ods_ir.Value:
  return TimepointImportOp(operands_=operands_, affinity=affinity, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TimepointJoinOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.timepoint.join"

  _ODS_REGIONS = (0, True)

  def __init__(self, await_timepoints, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(await_timepoints))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def await_timepoints(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result_timepoint(self):
    return self.operation.results[0]

def timepoint_join(await_timepoints, *, loc=None, ip=None) -> _ods_ir.Value:
  return TimepointJoinOp(await_timepoints=await_timepoints, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "stream.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, resource_operands, resource_operand_sizes, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(resource_operands))
    operands.extend(_get_op_results_or_values(resource_operand_sizes))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def resource_operands(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def resource_operand_sizes(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 0, 2, 0, 1)
    return self.operation.operands[start:start + elements_per_group]

def yield_(resource_operands, resource_operand_sizes, *, loc=None, ip=None) -> _ods_ir.Operation:
  return YieldOp(resource_operands=resource_operands, resource_operand_sizes=resource_operand_sizes, loc=loc, ip=ip)
