---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/ast_rewrite_parameter_shadow/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
models = _cribo.types.SimpleNamespace(__name__='models')
"""Models module containing classes that will be shadowed by parameters."""
class User:
    """User class that will be shadowed by function parameters."""

    def __init__(self, name: str):
        self.name = name
        self.id = hash(name) % 10000

    def __repr__(self):
        return f"User(name={self.name!r}, id={self.id})"
User.__module__ = 'models'
class Connection:
    """Connection class that will be shadowed by function parameters."""

    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port
        self.connected = False

    def connect(self):
        """Simulate connection."""
        self.connected = True
        return f"Connected to {self.host}:{self.port}"

    def __repr__(self):
        return f"Connection(host={self.host!r}, port={self.port}, connected={self.connected})"
Connection.__module__ = 'models'
models.Connection = Connection
models.User = User
"""Test fixture for parameter names shadowing global/class names.\n\nThis fixture demonstrates the pattern where function parameters shadow\nimportant module-level names (classes, functions, constants).\n"""
result = "global_result"
def process_user(User: "User") -> str:
    """Function with parameter shadowing the imported User class."""
    return f"Processing: {User.name}"
def create_connection(Connection: str) -> str:
    """Function with parameter shadowing the imported Connection class."""
    return f"Connection string: {Connection}"
def manipulate_result(result: int) -> int:
    """Function with parameter shadowing the global variable."""
    return result * 2
class Manager:
    """Class with methods that have shadowing parameters."""

    def __init__(self):
        self.users = []
        self.connections = []

    def add_user(self, User: "User") -> None:
        """Method with parameter shadowing the User class."""
        self.users.append(User)
        print(f"Added user: {User.name}")

    def add_connection(self, Connection: "Connection") -> None:
        """Method with parameter shadowing the Connection class."""
        self.connections.append(Connection)
        print(f"Added connection: {Connection.host}")

    def process_with_shadow(self, result: str) -> str:
        """Method with parameter shadowing the global variable."""
        global_val = globals()["result"]
        return f"Param: {result}, Global: {global_val}"
def complex_shadowing(User: type, Connection: callable, result: list) -> dict:
    """Function with multiple shadowing parameters of different types."""
    return {"user_type": User.__name__ if hasattr(User, "__name__") else str(User), "connection_callable": Connection() if callable(Connection) else None, "result_list": len(result) if isinstance(result, list) else 0}
def main():
    """Demonstrate the shadowing patterns."""
    user = User("Alice")
    conn = Connection("localhost", 5432)
    print(process_user(user))
    print(create_connection("postgres://localhost"))
    print(manipulate_result(10))
    manager = Manager()
    manager.add_user(user)
    manager.add_connection(conn)
    print(manager.process_with_shadow("parameter_value"))
    shadow_result = complex_shadowing(User=type("DynamicUser", (), {}), Connection=lambda: "dynamic_connection", result=[1, 2, 3])
    print(f"Complex shadowing result: {shadow_result}")
    print(f"Global result value: {result}")
    print(f"User class accessible: {User}")
    print(f"Connection class accessible: {Connection}")
if __name__ == "__main__":
    main()
