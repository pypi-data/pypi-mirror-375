# Generated by Django 5.2.3 on 2025-06-18 15:56

from django.db import migrations, models
from django.db.migrations.recorder import MigrationRecorder

migration_table = (
    ("BlogConfig", "StoriesConfig"),
    ("BlogConfigTranslation", "StoriesConfigTranslation"),
    ("BlogCategory", "PostCategory"),
    ("BlogCategoryTranslation", "PostCategoryTranslation"),
    ("Post", "Post"),
    ("PostContent", "PostContent"),
    ("LatestPostsPlugin", "LatestPostsPlugin"),
    ("AuthorEntriesPlugin", "AuthorEntriesPlugin"),
    ("FeaturedPostsPlugin", "FeaturedPostsPlugin"),
    ("GenericBlogPlugin", "GenericBlogPlugin"),
)


def copy_data(pk_maps: dict, pass_2: list, source_model: models.Model, target_model: models.Model):
    source_objects = source_model.objects.all()
    fields = [
        field.name
        for field in source_model._meta.get_fields()
        if not (field.many_to_one or field.many_to_many or field.one_to_many)
    ]
    # Add <field>_id for ForeignKey fields if not already present
    for field in source_model._meta.fields:
        if field.is_relation and field.many_to_one and field.remote_field:
            fk_id_field = f"{field.name}_id"
            if fk_id_field not in fields:
                fields.append(fk_id_field)
    for obj in source_objects:
        obj_dict = {field: getattr(obj, field) for field in fields}

        old_pk = obj_dict.pop("id")
        unresolved = []
        # Update any foreign keys using pk_maps
        for field in target_model._meta.fields:
            if field.is_relation and field.many_to_one and field.remote_field:
                fk_name = field.name + "_id"
                rel_model = field.remote_field.model
                rel_model_name = rel_model.__name__
                old_fk = obj_dict.get(fk_name)
                if old_fk is not None:
                    # Foreign key needs to be translated
                    if rel_model_name in pk_maps and old_fk in pk_maps[rel_model_name]:
                        obj_dict[fk_name] = pk_maps[rel_model_name][old_fk]
                    else:
                        # No value available, mark for pass 2
                        unresolved.append((rel_model_name, fk_name, old_fk))
        new_obj = target_model.objects.create(**obj_dict)
        pk_maps.setdefault(target_model.__name__, {})[old_pk] = new_obj.pk
        for rel_model_name, fk_name, old_fk in unresolved:
            pass_2.append((target_model, new_obj.pk, rel_model_name, fk_name, old_fk, ))


def finish_pass_2(pk_maps, pass_2):
    for model, pk, rel_model_name, fk_name, old_fk in pass_2:
        if rel_model_name in pk_maps and old_fk in pk_maps[rel_model_name]:
            model.objects.filter(pk=pk).update(**{fk_name: pk_maps.get(rel_model_name, {}).get(old_fk)})

def copy_m2m(apps, pk_maps, m2m_relation):
    src_app, src_model, src_field, tgt_app, tgt_model, tgt_field = m2m_relation

    SrcModel = apps.get_model(src_app, src_model)
    TgtModel = apps.get_model(tgt_app, tgt_model)

    tgt_field_obj = TgtModel._meta.get_field(tgt_field)
    src_field_obj = SrcModel._meta.get_field(src_field)
    src_through_model = src_field_obj.remote_field.through
    tgt_through_model = tgt_field_obj.remote_field.through
    src_left = next(
        f for f in src_through_model._meta.get_fields()
        if f.is_relation and f.many_to_one and f.related_model is SrcModel
    ).name + "_id"
    src_right = next(
        f for f in src_through_model._meta.get_fields()
        if f.is_relation and f.many_to_one and f.related_model is src_field_obj.remote_field.model and f.name + "_id" != src_left
    ).name + "_id"
    tgt_left = next(
        f for f in tgt_through_model._meta.get_fields()
        if f.is_relation and f.many_to_one and f.related_model is TgtModel
    ).name + "_id"
    tgt_right = next(
        f for f in tgt_through_model._meta.get_fields()
        if f.is_relation and f.many_to_one and f.related_model is tgt_field_obj.remote_field.model and f.name + "_id" != tgt_left
    ).name + "_id"

    left_key = TgtModel.__name__
    right_key = tgt_field_obj.remote_field.model.__name__
    for src_obj in src_through_model.objects.all():
        left, right = getattr(src_obj, src_left), getattr(src_obj, src_right)
        new_left = pk_maps.get(left_key, {}).get(left, left)  # Leave unchanged if not present
        new_right = pk_maps.get(right_key, {}).get(right, right)  # Leave unchanged if not present
        assert new_left is not None, f"Missing mapping for {left_key} {left}"
        assert new_right is not None, f"Missing mapping for {right_key} {right}"
        tgt_through_model.objects.create(**{
            tgt_left: new_left,
            tgt_right: new_right,
        })


def migrate_from_blog_to_stories(apps, schema_editor):
    """
    Migrate data from djangocms_blog to djangocms_stories.
    This function assumes that the models and fields in djangocms_stories
    are compatible with those in djangocms_blog - which they only are if all
    blog migrations have been applied.
    """

    ContentType = apps.get_model("contenttypes", "ContentType")

    # 1. Check if the djangocms_blog Post table exists
    print()
    print("# 1. Check if the djangocms_blog Post table exists")
    table_name = "djangocms_blog_post"
    with schema_editor.connection.cursor() as cursor:
        tables = schema_editor.connection.introspection.table_names(cursor)

    if table_name not in tables:
        # No migration needed, djangocms_blog Post table does not exist
        return

    # 2. Check that all migrations in OUR djangocms_blog app have been applied
    print("# 2. Check that all migrations in OUR djangocms_blog app have been applied")
    recorder = MigrationRecorder(schema_editor.connection)
    required_migration = ("djangocms_blog", "0051_alter_blogconfig_type_and_more")
    if required_migration not in recorder.applied_migrations():
        raise RuntimeError("First run 'python manage migrate djangocms_blog'.")

    # 3. Migrate each model from djangocms_blog to djangocms_stories
    print("# 3. Migrate each model from djangocms_blog to djangocms_stories")
    pk_maps = {}
    pass_2 = []

    for source, target in migration_table:
        SourceModel = apps.get_model("djangocms_blog", source)
        TargetModel = apps.get_model("djangocms_stories", target)
        # Copy data from source to target
        copy_data(pk_maps, pass_2, SourceModel, TargetModel)

    # Try to finish the open relations in pass 2
    finish_pass_2(pk_maps, pass_2)

    # 4. Copy many-to-many relationships
    print("# 4. Copy many-to-many relationships")
    m2m_models = [
        # (source_app, source_model, source_field, target_app, target_model, target_field)
        ("djangocms_blog", "Post", "categories", "djangocms_stories", "Post", "categories"),
        ("djangocms_blog", "Post", "related", "djangocms_stories", "Post", "related"),
        ("djangocms_blog", "Post", "sites", "djangocms_stories", "Post", "sites"),
        (
            "djangocms_blog",
            "AuthorEntriesPlugin",
            "authors",
            "djangocms_stories",
            "AuthorEntriesPlugin",
            "authors",
        ),
    ]

    for m2m_relation in m2m_models:
        copy_m2m(
            apps, pk_maps,
            m2m_relation,
        )
    # 5. Update generic releations
    print("# 5. Update generic relations")

    TaggedItem = apps.get_model("taggit", "TaggedItem")
    Placeholder = apps.get_model("cms", "Placeholder")
    try:
        Version = apps.get_model("djangocms_versioning", "Version")
    except LookupError:
        Version = None

    generic_relations = {
        "Post": [TaggedItem],
        "PostContent": [Placeholder, Version] if Version else [Placeholder],
    }

    for model_name, fields in generic_relations.items():
        source_model = apps.get_model("djangocms_blog", model_name)
        source_ct = ContentType.objects.get_for_model(source_model)
        target_model = apps.get_model("djangocms_stories", model_name)
        target_ct = ContentType.objects.get_for_model(target_model)
        for model in fields:
            qs = model.objects.filter(content_type=source_ct)
            objs_to_update = []
            for obj in qs:
                obj.content_type = target_ct
                obj.object_id = pk_maps[model_name].get(obj.object_id, obj.object_id)
                objs_to_update.append(obj)
            model.objects.bulk_update(objs_to_update, ["content_type", "object_id"])

    # 6. Drop all djangocms_blog tables from the database
    print("# 6. Drop all djangocms_blog tables from the database")

    with schema_editor.connection.cursor() as cursor:
        tables = schema_editor.connection.introspection.table_names(cursor)
        blog_m2n_tables = [t for t in tables if t.startswith("djangocms_blog_") and t.count("_") > 2]
        blog_plugin_tables = [t for t in tables if t.startswith("djangocms_blog_") and t.endswith("plugin") and t.count("_") <= 2]
        blog_other_tables = [t for t in tables if t.startswith("djangocms_blog_") and t not in (blog_m2n_tables + blog_plugin_tables)]
        blog_ordered_other_tables = [
            'djangocms_blog_blogcategory',
            'djangocms_blog_postcontent',
            'djangocms_blog_post',
            'djangocms_blog_blogconfig',
        ]
        for table in blog_m2n_tables:
            cursor.execute(f"DROP TABLE IF EXISTS `{table}`;")
        for table in blog_plugin_tables:
            cursor.execute(f"DROP TABLE IF EXISTS `{table}`;")
        for table in blog_ordered_other_tables:
            cursor.execute(f"DROP TABLE IF EXISTS `{table}`;")
            if table in blog_other_tables:
                blog_other_tables.remove(table)
        # Drop remaining blog tables if any
        for table in blog_other_tables:
            cursor.execute(f"DROP TABLE IF EXISTS `{table}`;")

    # 7. Remove djangocms_blog migration records
    print("# 7. Remove djangocms_blog migration records")
    recorder = MigrationRecorder(schema_editor.connection)
    recorder.migration_qs.filter(app="djangocms_blog").delete()

def adjust_apphooks(apps, schema_editor):
    Page = apps.get_model("cms", "Page")

    print()
    print("# 8. Adjust apphooks")

    Page.objects.filter(application_urls="BlogApp").update(
        application_urls="StoriesApp"
    )
    Page.objects.filter(navigation_extenders="BlogCategoryMenu").update(
        navigation_extenders="PostCategoryMenu"
    )



class Migration(migrations.Migration):
    dependencies = [
        ("djangocms_stories", "0001_initial"),
    ]

    operations = [
        migrations.RunPython(
            code=migrate_from_blog_to_stories,
            elidable=True,
        ),
        migrations.RunPython(
            code=adjust_apphooks,
            elidable=True,
        ),
    ]
