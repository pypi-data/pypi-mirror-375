'''
This file contains a utility class to work with python file tresto metadata.
Each test file should have a header that contains following docstring:

"""Generated by Tresto v{version}

Test name: {test_name}
Test description: {test_description}
Created Date: {created_date}

"""

This is used to automatically save the AI information about the test.

'''

import re
import textwrap
from datetime import datetime
from pathlib import Path
from typing import Self

from pydantic import BaseModel, Field

from tresto import __version__


class TrestoFileHeaderCorrupted(ValueError):
    """Raised when the Tresto file header format is invalid or missing."""


class FileHeader(BaseModel):
    test_name: str
    test_description: str
    created_date: str = Field(default_factory=lambda: datetime.now().strftime("%Y-%m-%d"))
    content: str

    def write_to_file(self, file_path: Path) -> None:
        """Write content to file with Tresto header, replacing any existing docstring."""
        # Generate the new header docstring
        header_docstring = self.to_docstring()

        # Remove existing module docstring if present
        content_without_docstring = self._remove_module_docstring(self.content)

        # Add our header docstring at the beginning
        final_content = f'"""{header_docstring}"""\n\n{content_without_docstring}'

        # Write to file
        file_path.write_text(final_content)

    @classmethod
    def read_from_file(cls, file_path: Path) -> Self:
        """Read Tresto header from file and parse it into FileHeader instance."""
        if not file_path.exists():
            raise TrestoFileHeaderCorrupted(f"File does not exist: {file_path}")

        file_content = file_path.read_text()

        # Extract the first docstring (module docstring)
        docstring = cls._extract_module_docstring(file_content)
        if not docstring:
            raise TrestoFileHeaderCorrupted("No module docstring found")

        # Parse the docstring to extract header information
        header = cls._parse_header_docstring(docstring)

        # Add the content without the header docstring
        content_without_docstring = cls._remove_module_docstring(file_content)
        header.content = content_without_docstring

        return header

    def to_docstring(self) -> str:
        """Convert header to docstring format."""
        return textwrap.dedent(
            f"""\
            Generated by Tresto v{__version__}

            Test name: {self.test_name}
            Test description: {self.test_description}
            Created Date: {self.created_date}"""
        ).strip()

    @staticmethod
    def _remove_module_docstring(content: str) -> str:
        """Remove the first docstring (module docstring) from Python code."""
        # Pattern to match module docstring (first string literal in the file)
        # Matches triple quotes (both """ and ''') with content
        pattern = r'^\s*(?:"""[\s\S]*?"""|\'\'\'[\s\S]*?\'\'\')\s*\n?'

        # Remove the first docstring if it exists
        return re.sub(pattern, "", content, count=1).lstrip()

    @staticmethod
    def _extract_module_docstring(content: str) -> str | None:
        """Extract the first docstring (module docstring) from Python code."""
        # Pattern to match module docstring
        triple_quote_pattern = r'^\s*(""")([\s\S]*?)\1'
        single_quote_pattern = r"^\s*(''')([\s\S]*?)\1"

        # Try triple double quotes first
        match = re.match(triple_quote_pattern, content)
        if match:
            return match.group(2)

        # Try triple single quotes
        match = re.match(single_quote_pattern, content)
        if match:
            return match.group(2)

        return None

    @classmethod
    def _parse_header_docstring(cls, docstring: str) -> Self:
        """Parse Tresto header docstring and extract metadata."""
        # Expected format:
        # Generated by Tresto v{version}
        #
        # Test name: {test_name}
        # Test description: {test_description}
        # Created Date: {created_date}

        docstring_content = docstring.strip()

        # Parse the header
        header_lines = [line.strip() for line in docstring_content.split("\n")]

        # Check first line format
        if not header_lines or not header_lines[0].startswith("Generated by Tresto v"):
            raise TrestoFileHeaderCorrupted("Invalid header format: missing 'Generated by Tresto' line")

        # Extract metadata fields
        test_name = None
        test_description = None
        created_date = None

        for line in header_lines:
            if line.startswith("Test name:"):
                test_name = line[len("Test name:") :].strip()
            elif line.startswith("Test description:"):
                test_description = line[len("Test description:") :].strip()
            elif line.startswith("Created Date:"):
                created_date = line[len("Created Date:") :].strip()

        # Validate all required fields are present
        if not test_name:
            raise TrestoFileHeaderCorrupted("Missing 'Test name' field in header")
        if not test_description:
            raise TrestoFileHeaderCorrupted("Missing 'Test description' field in header")
        if not created_date:
            raise TrestoFileHeaderCorrupted("Missing 'Created Date' field in header")

        return cls(
            test_name=test_name,
            test_description=test_description,
            created_date=created_date,
            content="",  # Will be set by read_from_file
        )
