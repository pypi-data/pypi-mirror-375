# This file is a template, and might need editing before it works on your project.
# To contribute improvements to CI/CD templates, please follow the Development guide at:
# https://docs.gitlab.com/ee/development/cicd/templates.html
# This specific template is located at:
# https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/ci/templates/Python.gitlab-ci.yml

# Official language image. Look for the different tagged releases at:
# https://hub.docker.com/r/library/python/tags/

image: python:latest

# Change pip's cache directory to be inside the project directory since we can
# only cache local items.
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

# Pip's cache doesn't store the python packages
# https://pip.pypa.io/en/stable/topics/caching/

# The following example is for a project that runs branch and merge request pipelines
# only, but does not run pipelines for any other case. It runs:
#    Branch pipelines when a merge request is not open for the branch.
#    Merge request pipelines when a merge request is open for the branch.
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    #- if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
    #  when: never
    #- if: $CI_COMMIT_BRANCH

#
# If you want to also cache the installed packages, you have to install
# them in a virtualenv and cache it as well.
cache:
  paths:
    - .cache/pip
    - venv/

before_script:
  - python --version ; pip --version  # For debugging
  - pip install virtualenv uv build
  - uv venv
  - source venv/bin/activate

run:
  script:
    - pip install .
    - pip install tox flake8 pytest # you can also use tox
    - if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    #- tox -e py,flake8
    #- pytest -vs
    - cd tests/

    # init app_config - copies config.py to src (performed by test setup module)
    - cd src
    - app_config-init
    - cd ..

    - ls .
    - ls src/
    - python -m unittest discover

# test:
#   script:
#     - pip install ruff tox  # you can also use tox
#     - pip install --editable ".[test]"
#     - tox -e py,ruff

# run:
#   script:
#     - pip install .
#     # run the command here
#   artifacts:
#     paths:
#       - build/*

# pages:
#   script:
#     - pip install sphinx sphinx-rtd-theme
#     - cd doc
#     - make html
#     - mv build/html/ ../public/
#   artifacts:
#     paths:
#       - public
#   rules:
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# deploy:
#   stage: deploy
#   script: echo "Define your deployment script!"
#   environment: production

# build-job:
#   stage: build
#   image: python:latest
#   script:
#     - python -m pip install -U build
#     - cd python_pkg && python -m build
#   artifacts:
#     paths:
#       - "python_pkg/dist/"

build-job:
  stage: build
  script:
    - 'uv build --out-dir=dist'
  artifacts:
    paths:
      - "dist/"

# To improve readability and avoid issues with excaping,
#   we’ll use YAML multiline strings.
#
# The >- operator joins the following lines without a line break
#   and strips additional whitespace.
#

.release-base:
  # Abstract base job for "release" jobs.
  # Extending jobs must define the following variables:
  # - PYPI_OIDC_AUD: Audience for the ID token that GitLab
  #   issues to the pipeline job
  # - PYPI_OIDC_URL: PyPI endpoint for retrieving a publish
  #   token with GitLab’s ID token
  # - UV_PUBLISH_URL: PyPI endpoint for the actual upload
  stage: 'deploy'
  id_tokens:
    PYPI_ID_TOKEN:
      aud: '$PYPI_OIDC_AUD'
  script:
    # Use the GitLab ID token to retrieve an API token from PyPI
    - >-
      resp="$(curl -X POST "${PYPI_OIDC_URL}" -d "{\"token\":\"${PYPI_ID_TOKEN}\"}")"
    # Parse the response and extract the token
    - >-
      publish_token="$(python -c "import json; print(json.load('${resp}')['token'])")"
    # Upload the files from "dist/"
    - 'uv publish --token "$publish_token"'
    # Print the link to PyPI so we can quickly go there to verify the result:
    # - 'version="$(uv run --with hatch-vcs hatchling version)"'
    - 'version="$(uv run setuptools_scm )"'
    - 'echo -e "\033[34;1mPackage on PyPI:\033[0m ${CI_ENVIRONMENT_URL}${version}/"'

release-staging:
  extends: '.release-base'
  rules:
    # Only run if it's a pipeline for the default branch or a tag:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_COMMIT_TAG'
  environment:
    name: 'release-test'
    url: 'https://test.pypi.org/project/typed-settings/'
  variables:
    PYPI_OIDC_AUD: 'testpypi'
    PYPI_OIDC_URL: 'https://test.pypi.org/_/oidc/mint-token'
    UV_PUBLISH_URL: 'https://test.pypi.org/legacy/'

release:
  extends: '.release-base'
  rules:
    # Only run in tag pipelines:
    - if: '$CI_COMMIT_TAG'
  environment:
    name: 'release'
    url: 'https://pypi.org/project/typed-settings/'
  variables:
    PYPI_OIDC_AUD: 'pypi'
    PYPI_OIDC_URL: 'https://pypi.org/_/oidc/mint-token'
    UV_PUBLISH_URL: 'https://upload.pypi.org/legacy/'

# publish-job:
#   stage: deploy
#   image: python:3-bookworm
#   dependencies:
#     - build-job
#   id_tokens:
#     PYPI_ID_TOKEN:
#       # Use "testpypi" if uploading to TestPyPI
#       aud: pypi
#   script:
#     # Install dependencies
#     - python -m pip install -U twine

#     # Upload to PyPI, add "--repository testpypi" if uploading to TestPyPI
#     # With no token specified, twine will use Trusted Publishing
#     - twine upload python_pkg/dist/*
