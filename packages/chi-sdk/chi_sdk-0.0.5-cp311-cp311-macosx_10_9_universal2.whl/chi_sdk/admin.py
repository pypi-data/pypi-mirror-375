from __future__ import annotations

import os
import re
import shutil
import stat
from pathlib import Path
import zipfile
import json
import platform
import urllib.request
import urllib.error
from typing import Optional, Tuple

import click
import importlib.metadata as importlib_metadata

from .sdk import emit_error, emit_ok


def _json_mode(ctx: Optional[click.Context] = None) -> bool:
    ctx = ctx or click.get_current_context(silent=True)
    env = os.getenv("CHI_TUI_JSON", "")
    return bool(
        (ctx and ctx.obj and ctx.obj.get("json")) or env in ("1", "true", "yes")
    )


def _read_app_bin_from_config(config_dir: Path) -> Optional[str]:
    cfg = config_dir / "config.yaml"
    if not cfg.exists():
        return None
    try:
        text = cfg.read_text(encoding="utf-8")
        # very minimal parse: look for a line like `app_bin: value` (value may be quoted)
        m = re.search(r"(?m)^\s*app_bin\s*:\s*['\"]?([^'\"\s]+)['\"]?\s*$", text)
        if m:
            return m.group(1)
    except Exception:
        return None
    return None


def _which(prog: str) -> Optional[str]:
    return shutil.which(prog)


def _ensure_executable(p: Path) -> None:
    try:
        if os.name == "posix":
            p.chmod(p.stat().st_mode | stat.S_IXUSR)
    except Exception:
        pass


def _user_cache_dir() -> Path:
    sysname = platform.system().lower()
    home = Path.home()
    if sysname == "darwin":
        return home / "Library" / "Caches" / "chi-tui"
    if sysname == "windows":
        base = os.environ.get("LOCALAPPDATA") or str(home / "AppData" / "Local")
        return Path(base) / "chi-tui"
    # linux and others
    return Path(os.environ.get("XDG_CACHE_HOME", str(home / ".cache"))) / "chi-tui"


def _cache_bin_path() -> Path:
    return _user_cache_dir() / "bin"


def _chi_sdk_cached_binary() -> Optional[Path]:
    bin_dir = _cache_bin_path()
    name = "chi-tui.exe" if os.name == "nt" else "chi-tui"
    p = bin_dir / name
    return p if p.exists() else None


def _make_wrapper_scripts(
    config_dir: Path, binary_name: str
) -> Tuple[Optional[Path], Optional[Path]]:
    bindir = config_dir / "bin"
    bindir.mkdir(parents=True, exist_ok=True)

    # POSIX shell wrapper
    posix_path = bindir / f"{binary_name}-ui"
    posix_script = f"""#!/usr/bin/env sh
set -e
CHI_APP_BIN="{binary_name}" CHI_TUI_JSON=1 exec chi-tui "$@"
"""
    posix_path.write_text(posix_script, encoding="utf-8")
    _ensure_executable(posix_path)

    # Windows cmd wrapper
    win_path = bindir / f"{binary_name}-ui.bat"
    win_script = f"@echo off\r\nset CHI_APP_BIN={binary_name}\r\nset CHI_TUI_JSON=1\r\nchi-tui %*\r\n"
    win_path.write_text(win_script, encoding="utf-8")
    return posix_path, win_path


@click.group(
    help="chi-admin â€” scaffold and maintain CHI TUI integration",
    invoke_without_command=True,
)
@click.option("--json", "json_mode", is_flag=True, help="Emit JSON envelope to stdout")
@click.option("--version", "show_version", is_flag=True, help="Show version and exit")
@click.pass_context
def cli(ctx, json_mode: bool, show_version: bool):
    ctx.ensure_object(dict)
    ctx.obj["json"] = json_mode
    if show_version:
        try:
            ver = str(importlib_metadata.version("chi-sdk"))
        except Exception:
            ver = "0.0.0.dev"
        if _json_mode(ctx):
            emit_ok({"app": "chi-admin", "version": ver}, command="version")
        else:
            click.echo(f"chi-admin {ver}")
        raise click.exceptions.Exit(0)


@cli.command("init", help="Scaffold .tui/ and wrapper for your CLI")
@click.argument("path", type=click.Path(file_okay=False, dir_okay=True), default=".")
@click.option("--binary-name", required=True, help="Your CLI name to act as backend")
@click.option(
    "--config", "config_path", default=".tui", show_default=True, help="Config dir"
)
@click.option(
    "--create-demo", is_flag=True, help="Include demo notes in .tui/README.md"
)
@click.option("--force", is_flag=True, help="Overwrite existing files if present")
@click.pass_context
def init_cmd(
    ctx, path: str, binary_name: str, config_path: str, create_demo: bool, force: bool
):
    root = Path(path).resolve()
    cfg_dir = (root / config_path).resolve()
    cfg_dir.mkdir(parents=True, exist_ok=True)

    # Write config.yaml
    cfg_file = cfg_dir / "config.yaml"
    if not cfg_file.exists() or force:
        cfg_file.write_text(
            f'app_bin: {binary_name}\nextra_env:\n  CHI_TUI_JSON: "1"\n',
            encoding="utf-8",
        )

    # Write .tui/README.md
    readme = cfg_dir / "README.md"
    if not readme.exists() or force:
        readme.write_text(
            (
                "# CHI TUI Integration\n\n"
                "This directory was generated by `chi-admin init`.\n\n"
                "## Run with prebuilt TUI\n\n"
                "If you installed chi-sdk (`pip install chi-sdk`), run:\n\n"
                f"    CHI_APP_BIN={binary_name} chi-tui\n\n"
                "## Wrapper scripts\n\n"
                "Generated under `.tui/bin/`:\n\n"
                f"- POSIX: .tui/bin/{binary_name}-ui\n"
                f"- Windows: .tui/bin/{binary_name}-ui.bat\n\n"
                "They set `CHI_APP_BIN` and `CHI_TUI_JSON=1` and then run `chi-tui`.\n\n"
                "### PATH options\n\n"
                '- POSIX: add `.tui/bin` to PATH: `export PATH="$PWD/.tui/bin:$PATH"`\n'
                '- POSIX (symlink): `ln -s "$PWD/.tui/bin/{binary_name}-ui" ~/.local/bin/{binary_name}-ui`\n'
                "- Windows: call `.tui\\bin\\{binary_name}-ui.bat` directly or add it to PATH\n\n"
                "## Validate setup\n\n"
                "Run diagnostic checks:\n\n"
                "    chi-admin doctor\n\n"
                "For JSON output:\n\n"
                "    CHI_TUI_JSON=1 chi-admin doctor\n\n"
                "## Default nav config\n\n"
                "This folder supports a default nav file at `.tui/main.yaml`.\n"
                "If present, the TUI will pick it up automatically without setting env vars.\n\n"
            ),
            encoding="utf-8",
        )

    # Create wrapper scripts
    posix_path, win_path = _make_wrapper_scripts(cfg_dir, binary_name)

    # Create comprehensive default nav (`.tui/main.yaml`) with helpful comments
    main_yaml = cfg_dir / "main.yaml"
    if not main_yaml.exists() or force:
        main_yaml.write_text(
            f"""# CHI TUI Configuration for {binary_name}
# Generated by: chi-admin init
# Docs: https://github.com/jacekjursza/chi_sdk

# Header shown at the top of the TUI
header: "{binary_name.replace('-', ' ').title()} - Terminal UI"

# Main menu structure
menu:
  # Simple command example
  - id: "hello"
    title: "Hello World"
    # Uncomment if your CLI has a 'hello' command:
    # cmd: "${{APP_BIN}} hello --name TUI"
    
  # List/table view example  
  - id: "list"
    title: "List Items"
    # Uncomment and adjust to your list command:
    # cmd: "${{APP_BIN}} list-items"
    
  # Panel layout example (split view)
  - id: "panel_demo"
    title: "Split View Demo"
    widget: "panel"
    panel_layout: "horizontal"  # or "vertical"
    panel_size: "1:1"           # ratio like "2:1" or "1:2"
    pane_b_yaml: "panel_b.yaml" # right/bottom pane config
    
  # Nested menu example
  - id: "advanced"
    title: "Advanced Options"
    children:
      - id: "settings"
        title: "Settings"
        # cmd: "${{APP_BIN}} settings"
      - id: "about"
        title: "About"
        # cmd: "${{APP_BIN}} --version"

# Keyboard shortcuts (optional)
# shortcuts:
#   - key: "q"
#     action: "quit"
#   - key: "r" 
#     action: "refresh"
""",
            encoding="utf-8",
        )
    panel_b = cfg_dir / "panel_b.yaml"
    if not panel_b.exists() or force:
        panel_b.write_text(
            f"""# Right/Bottom pane configuration for split view
# Used by items with widget: "panel" and pane_b_yaml reference

type: json_viewer  # or "menu" for nested navigation

# Command to execute for this pane
# ${{APP_BIN}} will be replaced with: {binary_name}
cmd: "${{APP_BIN}} --json schema"  # Shows your CLI's schema

# Alternative: show a specific command output
# cmd: "${{APP_BIN}} list-items"

# For menu type, define items:
# type: menu
# items:
#   - id: "item1"
#     title: "First Item"
#     cmd: "${{APP_BIN}} get-item --id 1"
""",
            encoding="utf-8",
        )

    # Create styles configuration (optional but helpful)
    styles_yaml = cfg_dir / "styles.yaml"
    if not styles_yaml.exists() or force:
        styles_yaml.write_text(
            """# Visual styling configuration (optional)
# Customize colors and appearance of your TUI

# Color palette (using terminal color names or hex codes)
colors:
  primary: "cyan"
  secondary: "magenta"
  success: "green"
  warning: "yellow"
  error: "red"
  
# Component styles
header:
  fg: "white"
  bg: "blue"
  bold: true
  
menu:
  selected:
    fg: "black"
    bg: "cyan"
  normal:
    fg: "white"
    bg: "default"
    
# Border styles: "plain", "rounded", "double", "thick"
borders: "rounded"

# Layout preferences
layout:
  margin: 1
  padding: 1
""",
            encoding="utf-8",
        )

    payload = {
        "path": str(root),
        "config_dir": str(cfg_dir),
        "default_nav": str(main_yaml),
        "panel_config": str(panel_b),
        "styles_config": str(styles_yaml),
        "wrapper_posix": str(posix_path),
        "wrapper_windows": str(win_path),
        "notes": "Customize .tui/*.yaml files to personalize your TUI",
    }
    if _json_mode(ctx):
        emit_ok(payload, command="chi-admin init")
    else:
        click.echo(f"Scaffolded .tui/ under: {cfg_dir}")
        click.echo(f"Wrapper (POSIX): {posix_path}")
        click.echo(f"Wrapper (Windows): {win_path}")


@cli.command("doctor", help="Validate setup: chi-tui on PATH, backend available")
@click.option(
    "--config", "config_path", default=".tui", show_default=True, help="Config dir"
)
@click.option(
    "--binary-name", default=None, help="Backend CLI name (overrides config/env)"
)
@click.pass_context
def doctor_cmd(ctx, config_path: str, binary_name: Optional[str]):
    problems = []
    info = {}

    chi_tui = _which("chi-tui")
    info["chi_tui"] = chi_tui
    if not chi_tui:
        cached = _chi_sdk_cached_binary()
        info["chi_sdk_cache"] = str(cached) if cached else None
        if not cached:
            problems.append("chi-tui not found on PATH. Install: pip install chi-sdk")

    cfg_dir = Path(config_path)
    app_bin = (
        os.getenv("CHI_APP_BIN") or binary_name or _read_app_bin_from_config(cfg_dir)
    )
    info["app_bin"] = app_bin
    if not app_bin:
        problems.append(
            "Backend app_bin not set. Set CHI_APP_BIN or .tui/config.yaml: app_bin: <name>"
        )
    else:
        backend = _which(app_bin)
        info["backend_path"] = backend
        if not backend:
            problems.append(f"Backend '{app_bin}' not found on PATH.")

    ok = len(problems) == 0
    if _json_mode(ctx):
        emit_ok(
            {"ok": ok, "problems": problems, "info": info}, command="chi-admin doctor"
        )
    else:
        if ok:
            click.echo("OK: chi-tui and backend available.")
        else:
            click.echo("Problems detected:")
            for p in problems:
                click.echo(f"- {p}")
            raise click.exceptions.Exit(2)


@cli.command("download", help="Check TUI installation and provide guidance")
@click.pass_context
def download_cmd(ctx):
    # If present on PATH, report OK
    chi_tui = _which("chi-tui")
    if chi_tui:
        msg = {"installed": True, "path": chi_tui, "source": "PATH"}
        if _json_mode(ctx):
            emit_ok(msg, command="chi-admin download")
        else:
            click.echo(f"chi-tui already installed: {chi_tui}")
        return

    # If present in cache, report and instructions
    cached = _chi_sdk_cached_binary()
    if cached:
        msg = {
            "installed": True,
            "path": str(cached),
            "source": "cache",
            "note": "Add to PATH or invoke directly.",
        }
        if _json_mode(ctx):
            emit_ok(msg, command="chi-admin download")
        else:
            click.echo(
                f"chi-tui cached at: {cached}\nAdd to PATH or run via full path."
            )
        return

    # Attempt to download the wheel asset for this platform and extract the binary
    owner_repo = os.environ.get("CHI_TUI_GH_REPO", "jacekjursza/chi_sdk")
    tag = os.environ.get("CHI_TUI_BIN_TAG")  # if not set, use latest

    def _fetch_json(url: str):
        req = urllib.request.Request(
            url, headers={"Accept": "application/vnd.github+json"}
        )
        with urllib.request.urlopen(req, timeout=20) as resp:
            return json.loads(resp.read().decode("utf-8"))

    try:
        if tag:
            rel = _fetch_json(
                f"https://api.github.com/repos/{owner_repo}/releases/tags/{tag}"
            )
        else:
            rel = _fetch_json(
                f"https://api.github.com/repos/{owner_repo}/releases/latest"
            )
    except Exception:
        guidance = (
            "Install TUI with: pip install chi-sdk (GitHub Releases not reachable)"
        )
        if _json_mode(ctx):
            emit_error(
                "download_failed", guidance, command="chi-admin download", exit_code=3
            )
        else:
            click.echo(guidance)
        return

    assets = rel.get("assets", [])
    sysname = platform.system().lower()
    mach = platform.machine().lower()

    def _match_wheel(asset_name: str) -> bool:
        if not asset_name.endswith(".whl"):
            return False
        n = asset_name.lower()
        if sysname == "windows":
            return "win_amd64" in n or "win_arm64" in n
        if sysname == "darwin":
            return ("macosx" in n) and (
                "arm64" in n if "arm" in mach else "x86_64" in n
            )
        # linux
        return ("manylinux" in n or "linux" in n) and (
            "aarch64" in n
            if "aarch64" in mach or "arm64" in mach
            else "x86_64" in n or "amd64" in n
        )

    def _match_raw(asset_name: str) -> bool:
        n = asset_name.lower()
        if (
            not n.startswith("chi-tui-")
            and not n.startswith("chi-tui.")
            and not n.startswith("chi-tui")
        ):
            return False
        if sysname == "windows":
            return n.endswith(".exe") and ("windows" in n or "win" in n)
        if sysname == "darwin":
            return ("macos" in n) or ("darwin" in n)
        return "linux" in n

    # Check if chi-sdk package should be installed instead
    guidance = "TUI is now included in chi-sdk. Install with: pip install chi-sdk"
    if _json_mode(ctx):
        emit_ok(
            {"installed": False, "guidance": guidance}, command="chi-admin download"
        )
    else:
        click.echo(guidance)
    return

    # Legacy download code (kept for reference but not reached)
    raw = next((a for a in assets if _match_raw(a.get("name", ""))), None)
    if raw:
        url = raw.get("browser_download_url")
        bin_dir = _cache_bin_path()
        bin_dir.mkdir(parents=True, exist_ok=True)
        name = "chi-tui.exe" if os.name == "nt" else "chi-tui"
        target = bin_dir / name
        try:
            with urllib.request.urlopen(url, timeout=60) as resp, open(
                target, "wb"
            ) as dst:
                shutil.copyfileobj(resp, dst)
            _ensure_executable(target)
        except Exception:
            guidance = "Download failed. Prefer: pip install 'chi-sdk[tui]'"
            if _json_mode(ctx):
                emit_error(
                    "download_failed",
                    guidance,
                    command="chi-admin download",
                    exit_code=3,
                )
            else:
                click.echo(guidance)
            return

        msg = {
            "installed": True,
            "path": str(target),
            "source": "downloaded_raw",
            "note": "Add this directory to PATH to use 'chi-tui' directly.",
        }
        if _json_mode(ctx):
            emit_ok(msg, command="chi-admin download")
        else:
            click.echo(f"Downloaded chi-tui to: {target}\nAdd to PATH: {bin_dir}")
        return

    # Fallback to wheel extraction
    wheel = next((a for a in assets if _match_wheel(a.get("name", ""))), None)
    if not wheel:
        guidance = "No suitable asset found in Release. Install via pip: pip install 'chi-sdk[tui]'"
        if _json_mode(ctx):
            emit_error("no_asset", guidance, command="chi-admin download", exit_code=3)
        else:
            click.echo(guidance)
        return

    url = wheel.get("browser_download_url")
    bin_dir = _cache_bin_path()
    bin_dir.mkdir(parents=True, exist_ok=True)
    name = "chi-tui.exe" if os.name == "nt" else "chi-tui"
    target = bin_dir / name
    try:
        with urllib.request.urlopen(url, timeout=60) as resp:
            import io

            data = resp.read()
            zf = zipfile.ZipFile(io.BytesIO(data))
            # Extract the packaged binary
            inner = None
            for zi in zf.infolist():
                if zi.filename.endswith(
                    "/chi_sdk_bin/bin/"
                    + ("chi-tui.exe" if os.name == "nt" else "chi-tui")
                ):
                    inner = zi
                    break
                if zi.filename.endswith(
                    "chi_sdk_bin/bin/"
                    + ("chi-tui.exe" if os.name == "nt" else "chi-tui")
                ):
                    inner = zi
                    break
            if inner is None:
                raise RuntimeError("Binary not found in wheel")
            with zf.open(inner) as src, open(target, "wb") as dst:
                shutil.copyfileobj(src, dst)
        _ensure_executable(target)
    except Exception:
        guidance = "Download failed. Prefer: pip install 'chi-sdk[tui]'"
        if _json_mode(ctx):
            emit_error(
                "download_failed", guidance, command="chi-admin download", exit_code=3
            )
        else:
            click.echo(guidance)
        return

    msg = {
        "installed": True,
        "path": str(target),
        "source": "downloaded",
        "note": "Add this directory to PATH to use 'chi-tui' directly.",
    }
    if _json_mode(ctx):
        emit_ok(msg, command="chi-admin download")
    else:
        click.echo(f"Downloaded chi-tui to: {target}\nAdd to PATH: {bin_dir}")


def main():
    cli()


if __name__ == "__main__":  # pragma: no cover
    main()
