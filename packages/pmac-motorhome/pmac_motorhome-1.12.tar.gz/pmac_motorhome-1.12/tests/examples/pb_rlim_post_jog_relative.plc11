CLOSE

//#################################################################
// Autogenerated Homing PLC for PowerBrick, DO NOT MODIFY
// Group 2:
//
// Manual homing instructions:
// Run homing for group GROUP_NUM: P1102 = GROUP_NUM enable PLC11
// Run homing: enable PLC11
// Run homing in debug mode: P1101 = 9 enable PLC11
// Pause homing: P1101 = 8
// Abort homing: P1101 = 2
// See definitions below to understand the status and the state.
//#################################################################


// Homing State P Variable
#define PLC11_HomingState       P1100
#define PLC11_StateIdle         0
#define PLC11_StateConfiguring  1
#define PLC11_StateMoveNeg      2
#define PLC11_StateMovePos      3
#define PLC11_StateHoming       4
#define PLC11_StatePostHomeMove 5
#define PLC11_StateAligning     6
#define PLC11_StateDone         7
#define PLC11_StateFastSearch   8
#define PLC11_StateFastRetrace  9
#define PLC11_StatePreHomeMove  10
PLC11_HomingState = PLC11_StateIdle

// Homing Status P Variable
#define PLC11_HomingStatus      P1101
#define PLC11_StatusDone        0
#define PLC11_StatusHoming      1
#define PLC11_StatusAborted     2
#define PLC11_StatusTimeout     3
#define PLC11_StatusFFErr       4
#define PLC11_StatusLimit       5
#define PLC11_StatusIncomplete  6
#define PLC11_StatusInvalid     7
#define PLC11_StatusPaused      8
#define PLC11_StatusDebugHoming 9
PLC11_HomingStatus = PLC11_StatusDone

// Homing Group P Variable
#define PLC11_HomingGroup       P1102
PLC11_HomingGroup = 0

// Homing Group Backup P Variable
#define PLC11_HomingBackupGroup P1103
PLC11_HomingBackupGroup = 0

open plc 11

if (PLC11_HomingStatus != PLC11_StatusHoming && PLC11_HomingStatus != PLC11_StatusDebugHoming){
    PLC11_HomingStatus = PLC11_StatusHoming
}

//---- Configuring State ----
PLC11_HomingState=PLC11_StateConfiguring
//Save the Homing group to px03
PLC11_HomingBackupGroup=PLC11_HomingGroup
//Save high soft limits to P variables px04..x19
P1104=Motor[1].MaxPos
//Save the low soft limits to P variables px20..x35
P1120=Motor[1].MinPos
//Save the home capture flags to P variables px36..x51
P1136=Gate3[0].Chan[0].CaptCtrl
//Store 'not flag' to use in moving off a flag in P variables px52..x67
P1152=P1136^12
//Save the limit flags to P variables px68..x83
P1168=Motor[1].pLimits
//Save the current position to P variables px84..x99
P1184=Motor[1].Pos - Motor[1].HomePos
//Clear the soft limits
Motor[1].MaxPos=0
Motor[1].MinPos=0

if ((PLC11_HomingBackupGroup == 1 || PLC11_HomingBackupGroup == 2) && (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming)){
    PLC11_HomingGroup=2

    //Clear home flags
    // Can't clear home on PBRICK
    // Wait for user to tell us to continue if in debug
    if (PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingStatus = PLC11_StatusPaused
        while (PLC11_HomingStatus == PLC11_StatusPaused){}
    }

    //---- PreHomeMove State ----
    if (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingState=PLC11_StatePreHomeMove
        // Execute the move commands
        Motor[1].ProgJogPos=100000000*(-Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[11]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[11] > 0) && (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC11_HomingStatus = PLC11_StatusFFErr
        }
        if (Sys.CdTimer[11]<=0 ){ // If we timed out
            PLC11_HomingStatus = PLC11_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingStatus = PLC11_StatusPaused
        while (PLC11_HomingStatus == PLC11_StatusPaused){}
    }

    //---- FastSearch State ----
    if (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingState=PLC11_StateFastSearch
        // Execute the move commands
        Motor[1].ProgJogPos=100000000*(Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*^0
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[11]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[11] > 0) && (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC11_HomingStatus = PLC11_StatusFFErr
        }
        if (Sys.CdTimer[11]<=0 ){ // If we timed out
            PLC11_HomingStatus = PLC11_StatusTimeout
        }
    }

    //---- Store the difference between current pos and start pos ----
    if (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming){
        P1184=(P1184 - (Motor[1].Pos - Motor[1].HomePos)) + 0 - Motor[1].HomeOffset
    }

    // Wait for user to tell us to continue if in debug
    if (PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingStatus = PLC11_StatusPaused
        while (PLC11_HomingStatus == PLC11_StatusPaused){}
    }

    //---- FastRetrace State ----
    if (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingState=PLC11_StateFastRetrace
        // Execute the move commands
        Gate3[0].Chan[0].CaptCtrl=P1152 Motor[1].ProgJogPos=100000000*(-Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*^0
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[11]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[11] > 0) && (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC11_HomingStatus = PLC11_StatusFFErr
        }
        if (Sys.CdTimer[11]<=0 ){ // If we timed out
            PLC11_HomingStatus = PLC11_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingStatus = PLC11_StatusPaused
        while (PLC11_HomingStatus == PLC11_StatusPaused){}
    }

    //---- Homing State ----
    if (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingState=PLC11_StateHoming
        // Execute the move commands
        Gate3[0].Chan[0].CaptCtrl=P1136
        home1
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[11]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[11] > 0) && (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC11_HomingStatus = PLC11_StatusFFErr
        }
        if (Sys.CdTimer[11]<=0 ){ // If we timed out
            PLC11_HomingStatus = PLC11_StatusTimeout
        }
    }

    //---- Zero encoder channels ----
    if ((PLC11_HomingStatus == PLC11_StatusHoming) || (PLC11_HomingStatus == PLC11_StatusDebugHoming)){
        homez9
    }
    //---- Check if all motors have homed ----
    if ((PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming) &&(Motor[1].HomeComplete == 0 )){
        PLC11_HomingStatus=PLC11_StatusIncomplete
    }

    // Wait for user to tell us to continue if in debug
    if (PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingStatus = PLC11_StatusPaused
        while (PLC11_HomingStatus == PLC11_StatusPaused){}
    }

    //---- PostHomeMove State ----
    if (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming){
        PLC11_HomingState=PLC11_StatePostHomeMove
        // Execute the move commands
        jog1=200
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[11]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 ) && (Motor[1].LimitStop == 0 ) && (Sys.CdTimer[11] > 0) && (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC11_HomingStatus = PLC11_StatusFFErr
        }
        if (Motor[1].LimitStop != 0 ){ // Limit check failed
            PLC11_HomingStatus = PLC11_StatusLimit
        }
        if (Sys.CdTimer[11]<=0 ){ // If we timed out
            PLC11_HomingStatus = PLC11_StatusTimeout
        }
    }

}

//---- Done ----
if (PLC11_HomingStatus == PLC11_StatusHoming || PLC11_HomingStatus == PLC11_StatusDebugHoming){
    //If we've got this far without failing, set status and state done
    PLC11_HomingStatus=PLC11_StatusDone
    PLC11_HomingState=PLC11_StateDone
    //Restore the homing group from px03
    PLC11_HomingGroup=PLC11_HomingBackupGroup
}

//---- Tidy Up ----
//Stop all motors if they don't have a following error
if (Motor[1].FeFatal == 0){
    jog/1
}
//Restore the high soft limits from P variables px04..x19
Motor[1].MaxPos=P1104
//Restore the low soft limits from P variables px20..x35
Motor[1].MinPos=P1120
//Restore the home capture flags from P variables px36..x51
Gate3[0].Chan[0].CaptCtrl=P1136
//Restore the limit flags to P variables px68..x83
Motor[1].pLimits=P1168

disable plc 11
close
