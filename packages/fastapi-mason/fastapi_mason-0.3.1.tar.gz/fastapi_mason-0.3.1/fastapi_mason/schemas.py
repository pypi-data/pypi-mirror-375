from dataclasses import dataclass
from typing import Any, Optional, Tuple

from pydantic import ConfigDict
from tortoise import Model
from tortoise.contrib.pydantic import PydanticModel, pydantic_model_creator
from tortoise.contrib.pydantic.descriptions import PydanticMetaData


@dataclass
class SchemaMeta:
    include: Tuple[str, ...] = ()
    exclude: Tuple[str, ...] = ()
    optional: Tuple[str, ...] = ()
    computed: Tuple[str, ...] = ()


@dataclass
class ConfigSchemaMeta(PydanticMetaData):
    validators: Optional[dict[str, Any]] = None


def build_schema_meta(
    *meta_structure: type[SchemaMeta] | tuple[str, type[SchemaMeta]] | None, schema_class_name: str = 'SchemaMeta'
) -> type[SchemaMeta]:
    if not meta_structure:
        return SchemaMeta

    result_attrs = {'include': [], 'exclude': [], 'optional': [], 'computed': []}

    for item in meta_structure:
        if item is None:
            continue
        if isinstance(item, tuple):
            field_name, meta_cls = item
            for attr_name in result_attrs:
                fields = getattr(meta_cls, attr_name, ())
                if fields:
                    result_attrs[attr_name].append(field_name)
                    result_attrs[attr_name].extend(f'{field_name}.{field}' for field in fields)
        else:
            for attr_name in result_attrs:
                fields = getattr(item, attr_name, ())
                result_attrs[attr_name].extend(fields)

    return type(
        schema_class_name,
        (SchemaMeta,),
        {key: tuple(result_attrs[key]) for key in result_attrs},
    )


def _override_schema_meta(
    meta: Optional[type[SchemaMeta]], config: Optional[ConfigSchemaMeta]
) -> type[ConfigSchemaMeta]:
    meta = meta or SchemaMeta
    config = config or ConfigSchemaMeta()
    config.include = tuple(set(config.include + meta.include))
    config.exclude = tuple(set(config.exclude + meta.exclude))
    config.computed = tuple(set(config.computed + meta.computed))
    return type(
        'ConfigSchemaMeta',
        (ConfigSchemaMeta,),
        {key: getattr(config, key) for key in config.__dataclass_fields__},
    )


def build_schema(
    cls: type[Model],
    *,
    meta: type[SchemaMeta] | tuple[str, type[SchemaMeta]] | None = None,
    config: Optional[ConfigSchemaMeta] = None,
    exclude_readonly: bool = False,
    name=None,
) -> type[PydanticModel]:
    schema_meta = build_schema_meta(meta) if meta else SchemaMeta

    if not name:
        name = f'{cls.__name__}{"Read" if not exclude_readonly else "Write"}Schema'
    meta_overide = _override_schema_meta(meta=schema_meta, config=config)
    model_config = meta_overide.model_config or ConfigDict()
    if model_config.get('extra') is None:
        model_config['extra'] = 'ignore'
    meta_overide.model_config = None

    schema = pydantic_model_creator(
        cls,
        meta_override=meta_overide,
        optional=schema_meta.optional,
        name=name,
        model_config=model_config,
        exclude_readonly=exclude_readonly,
        validators=config.validators if config else None,
    )
    setattr(
        schema,
        '_mason_config',
        {'cls': cls, 'meta': meta, 'config': config, 'name': name, 'exclude_readonly': exclude_readonly},
    )
    return schema


def rebuild_schema(
    schema: type[PydanticModel],
    meta: SchemaMeta | tuple[str, SchemaMeta] | None = None,
    config: Optional[ConfigSchemaMeta] = None,
    exclude_readonly: Optional[bool] = None,
    name=None,
) -> type[PydanticModel]:
    params: dict[str, Any] | None = getattr(schema, '_mason_config', None)
    if not params:
        raise ValueError('Schema should be generated by fastapi_mason.schemas.build_schema')
    new_params = {'meta': meta, 'config': config, 'exclude_readonly': exclude_readonly}
    for key, value in new_params.items():
        if value is not None:
            params[key] = value
    params['name'] = name
    return build_schema(**params)
