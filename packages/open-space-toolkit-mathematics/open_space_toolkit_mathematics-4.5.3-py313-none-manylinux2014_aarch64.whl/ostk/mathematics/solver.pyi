from __future__ import annotations
import numpy
import ostk.core.type
import typing
__all__ = ['NumericalSolver']
class NumericalSolver:
    class LogType:
        """
        Members:
        
          NoLog
        
          LogConstant
        
          LogAdaptive
        """
        LogAdaptive: typing.ClassVar[NumericalSolver.LogType]  # value = <LogType.LogAdaptive: 2>
        LogConstant: typing.ClassVar[NumericalSolver.LogType]  # value = <LogType.LogConstant: 1>
        NoLog: typing.ClassVar[NumericalSolver.LogType]  # value = <LogType.NoLog: 0>
        __members__: typing.ClassVar[dict[str, NumericalSolver.LogType]]  # value = {'NoLog': <LogType.NoLog: 0>, 'LogConstant': <LogType.LogConstant: 1>, 'LogAdaptive': <LogType.LogAdaptive: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class StepperType:
        """
        Members:
        
          RungeKutta4
        
          RungeKuttaCashKarp54
        
          RungeKuttaFehlberg78
        
          RungeKuttaDopri5
        """
        RungeKutta4: typing.ClassVar[NumericalSolver.StepperType]  # value = <StepperType.RungeKutta4: 0>
        RungeKuttaCashKarp54: typing.ClassVar[NumericalSolver.StepperType]  # value = <StepperType.RungeKuttaCashKarp54: 1>
        RungeKuttaDopri5: typing.ClassVar[NumericalSolver.StepperType]  # value = <StepperType.RungeKuttaDopri5: 3>
        RungeKuttaFehlberg78: typing.ClassVar[NumericalSolver.StepperType]  # value = <StepperType.RungeKuttaFehlberg78: 2>
        __members__: typing.ClassVar[dict[str, NumericalSolver.StepperType]]  # value = {'RungeKutta4': <StepperType.RungeKutta4: 0>, 'RungeKuttaCashKarp54': <StepperType.RungeKuttaCashKarp54: 1>, 'RungeKuttaFehlberg78': <StepperType.RungeKuttaFehlberg78: 2>, 'RungeKuttaDopri5': <StepperType.RungeKuttaDopri5: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def default() -> NumericalSolver:
        ...
    @staticmethod
    def string_from_log_type(log_type: typing.Any) -> ostk.core.type.String:
        ...
    @staticmethod
    def string_from_stepper_type(stepper_type: typing.Any) -> ostk.core.type.String:
        ...
    @staticmethod
    def undefined() -> NumericalSolver:
        ...
    def __eq__(self, arg0: NumericalSolver) -> bool:
        ...
    def __init__(self, log_type: typing.Any, stepper_type: typing.Any, time_step: ostk.core.type.Real, relative_tolerance: ostk.core.type.Real, absolute_tolerance: ostk.core.type.Real) -> None:
        ...
    def __ne__(self, arg0: NumericalSolver) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def get_absolute_tolerance(self) -> ostk.core.type.Real:
        ...
    def get_log_type(self) -> ...:
        ...
    def get_observed_state_vectors(self) -> list[tuple[numpy.ndarray[numpy.float64[m, 1]], float]]:
        ...
    def get_relative_tolerance(self) -> ostk.core.type.Real:
        ...
    def get_stepper_type(self) -> ...:
        ...
    def get_time_step(self) -> ostk.core.type.Real:
        ...
    @typing.overload
    def integrate_duration(self, arg0: numpy.ndarray[numpy.float64[m, 1]], arg1: ostk.core.type.Real, arg2: typing.Any) -> tuple[numpy.ndarray[numpy.float64[m, 1]], float]:
        ...
    @typing.overload
    def integrate_duration(self, arg0: numpy.ndarray[numpy.float64[m, 1]], arg1: list[ostk.core.type.Real], arg2: typing.Any) -> list[tuple[numpy.ndarray[numpy.float64[m, 1]], float]]:
        ...
    @typing.overload
    def integrate_time(self, arg0: numpy.ndarray[numpy.float64[m, 1]], arg1: ostk.core.type.Real, arg2: ostk.core.type.Real, arg3: typing.Any) -> tuple[numpy.ndarray[numpy.float64[m, 1]], float]:
        ...
    @typing.overload
    def integrate_time(self, arg0: numpy.ndarray[numpy.float64[m, 1]], arg1: ostk.core.type.Real, arg2: list[ostk.core.type.Real], arg3: typing.Any) -> list[tuple[numpy.ndarray[numpy.float64[m, 1]], float]]:
        ...
    def is_defined(self) -> bool:
        ...
