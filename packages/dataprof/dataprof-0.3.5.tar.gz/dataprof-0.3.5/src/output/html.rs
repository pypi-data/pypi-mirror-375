use crate::types::{ColumnProfile, ColumnStats, DataType, QualityIssue, QualityReport, Severity};
use anyhow::Result;
use std::fs;
use std::path::Path;

pub fn generate_html_report(report: &QualityReport, output_path: &Path) -> Result<()> {
    let html_content = build_html(report);
    fs::write(output_path, html_content)?;
    Ok(())
}

fn build_html(report: &QualityReport) -> String {
    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataProfiler Report - {}</title>
    <style>
        {}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä DataProfiler Report</h1>
            <div class="file-info">
                <h2>{}</h2>
                <div class="stats-grid">
                    <div class="stat">
                        <span class="label">File Size</span>
                        <span class="value">{:.1} MB</span>
                    </div>
                    <div class="stat">
                        <span class="label">Total Rows</span>
                        <span class="value">{}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Columns</span>
                        <span class="value">{}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Scan Time</span>
                        <span class="value">{} ms</span>
                    </div>
                </div>
                {}
            </div>
        </header>

        {}

        <section class="columns">
            <h2>üìà Column Analysis</h2>
            <div class="columns-grid">
                {}
            </div>
        </section>

        <footer>
            <p>Generated by <strong>DataProfiler CLI</strong> v0.2.0</p>
        </footer>
    </div>
</body>
</html>"#,
        Path::new(&report.file_info.path)
            .file_name()
            .unwrap_or_default()
            .to_string_lossy(),
        get_css(),
        report.file_info.path,
        report.file_info.file_size_mb,
        report
            .file_info
            .total_rows
            .map_or("Unknown".to_string(), |r| r.to_string()),
        report.file_info.total_columns,
        report.scan_info.scan_time_ms,
        build_sampling_info(&report.scan_info),
        build_quality_section(&report.issues),
        build_columns_section(&report.column_profiles)
    )
}

fn build_sampling_info(scan_info: &crate::types::ScanInfo) -> String {
    if scan_info.sampling_ratio < 1.0 {
        format!(
            r#"<div class="sampling-info">
                <span class="sampling-badge">Sampled {} rows ({:.1}%)</span>
            </div>"#,
            scan_info.rows_scanned,
            scan_info.sampling_ratio * 100.0
        )
    } else {
        String::new()
    }
}

fn build_quality_section(issues: &[QualityIssue]) -> String {
    if issues.is_empty() {
        return r#"<section class="quality">
            <h2>‚ú® Data Quality</h2>
            <div class="no-issues">
                <span class="success-icon">‚úÖ</span>
                <span>No quality issues found!</span>
            </div>
        </section>"#
            .to_string();
    }

    let mut critical_count = 0;
    let mut warning_count = 0;
    let mut info_count = 0;

    let issues_html: String = issues
        .iter()
        .enumerate()
        .map(|(i, issue)| {
            let (icon, severity_class, severity_text) = match issue.severity() {
                Severity::High => {
                    critical_count += 1;
                    ("üî¥", "critical", "CRITICAL")
                }
                Severity::Medium => {
                    warning_count += 1;
                    ("üü°", "warning", "WARNING")
                }
                Severity::Low => {
                    info_count += 1;
                    ("üîµ", "info", "INFO")
                }
            };

            format!(
                r#"<div class="issue {}">
                    <div class="issue-header">
                        <span class="issue-number">{}</span>
                        <span class="issue-icon">{}</span>
                        <span class="severity">{}</span>
                        <span class="issue-description">{}</span>
                    </div>
                    {}
                </div>"#,
                severity_class,
                i + 1,
                icon,
                severity_text,
                format_issue_description(issue),
                format_issue_details(issue)
            )
        })
        .collect();

    let summary = build_quality_summary(critical_count, warning_count, info_count);

    format!(
        r#"<section class="quality">
            <h2>‚ö†Ô∏è Data Quality Issues ({})</h2>
            {}
            <div class="issues-list">
                {}
            </div>
        </section>"#,
        issues.len(),
        summary,
        issues_html
    )
}

fn format_issue_description(issue: &QualityIssue) -> String {
    match issue {
        QualityIssue::NullValues {
            column,
            count,
            percentage,
        } => {
            format!("[{}]: {} null values ({:.1}%)", column, count, percentage)
        }
        QualityIssue::MixedDateFormats { column, .. } => {
            format!("[{}]: Mixed date formats", column)
        }
        QualityIssue::Duplicates { column, count } => {
            format!("[{}]: {} duplicate values", column, count)
        }
        QualityIssue::Outliers {
            column,
            values,
            threshold,
        } => {
            format!(
                "[{}]: {} outliers detected (>{}œÉ)",
                column,
                values.len(),
                threshold
            )
        }
        QualityIssue::MixedTypes { column, .. } => {
            format!("[{}]: Mixed data types", column)
        }
    }
}

fn format_issue_details(issue: &QualityIssue) -> String {
    match issue {
        QualityIssue::MixedDateFormats { formats, .. } => {
            let details: String = formats
                .iter()
                .map(|(format, count)| format!("<li>{}: {} rows</li>", format, count))
                .collect();
            format!("<div class=\"issue-details\"><ul>{}</ul></div>", details)
        }
        QualityIssue::Outliers { values, .. } => {
            let details: String = values
                .iter()
                .take(3)
                .map(|val| format!("<li>{}</li>", val))
                .collect();
            let extra = if values.len() > 3 {
                format!("<li>... and {} more</li>", values.len() - 3)
            } else {
                String::new()
            };
            format!(
                "<div class=\"issue-details\"><ul>{}{}</ul></div>",
                details, extra
            )
        }
        QualityIssue::MixedTypes { types, .. } => {
            let details: String = types
                .iter()
                .map(|(dtype, count)| format!("<li>{}: {} rows</li>", dtype, count))
                .collect();
            format!("<div class=\"issue-details\"><ul>{}</ul></div>", details)
        }
        _ => String::new(),
    }
}

fn build_quality_summary(critical: usize, warning: usize, info: usize) -> String {
    let mut summary_parts = Vec::new();

    if critical > 0 {
        summary_parts.push(format!(
            "<span class=\"critical\">{} critical</span>",
            critical
        ));
    }
    if warning > 0 {
        summary_parts.push(format!(
            "<span class=\"warning\">{} warnings</span>",
            warning
        ));
    }
    if info > 0 {
        summary_parts.push(format!("<span class=\"info\">{} info</span>", info));
    }

    format!(
        r#"<div class="quality-summary">
            üìä Summary: {}
        </div>"#,
        summary_parts.join(" ")
    )
}

fn build_columns_section(columns: &[ColumnProfile]) -> String {
    columns
        .iter()
        .map(|profile| {
            format!(
                r#"<div class="column-card">
                    <h3>{}</h3>
                    <div class="column-meta">
                        <span class="type-badge type-{}">{}</span>
                        <span class="records">{} records</span>
                        {}
                    </div>
                    {}
                    {}
                </div>"#,
                profile.name,
                format_type_class(&profile.data_type),
                format_data_type(&profile.data_type),
                profile.total_count,
                format_null_info(profile.null_count, profile.total_count),
                format_column_stats(&profile.stats),
                format_patterns(&profile.patterns)
            )
        })
        .collect()
}

fn format_data_type(data_type: &DataType) -> String {
    match data_type {
        DataType::String => "String",
        DataType::Integer => "Integer",
        DataType::Float => "Float",
        DataType::Date => "Date",
    }
    .to_string()
}

fn format_type_class(data_type: &DataType) -> String {
    match data_type {
        DataType::String => "string",
        DataType::Integer => "integer",
        DataType::Float => "float",
        DataType::Date => "date",
    }
    .to_string()
}

fn format_null_info(null_count: usize, total_count: usize) -> String {
    if null_count > 0 {
        let pct = (null_count as f64 / total_count as f64) * 100.0;
        format!(
            "<span class=\"nulls warning\">{} nulls ({:.1}%)</span>",
            null_count, pct
        )
    } else {
        "<span class=\"nulls success\">No nulls</span>".to_string()
    }
}

fn format_column_stats(stats: &ColumnStats) -> String {
    match stats {
        ColumnStats::Numeric { min, max, mean } => {
            format!(
                r#"<div class="stats numeric-stats">
                    <div class="stat"><label>Min:</label> <span>{:.2}</span></div>
                    <div class="stat"><label>Max:</label> <span>{:.2}</span></div>
                    <div class="stat"><label>Mean:</label> <span>{:.2}</span></div>
                </div>"#,
                min, max, mean
            )
        }
        ColumnStats::Text {
            min_length,
            max_length,
            avg_length,
        } => {
            format!(
                r#"<div class="stats text-stats">
                    <div class="stat"><label>Min Length:</label> <span>{}</span></div>
                    <div class="stat"><label>Max Length:</label> <span>{}</span></div>
                    <div class="stat"><label>Avg Length:</label> <span>{:.1}</span></div>
                </div>"#,
                min_length, max_length, avg_length
            )
        }
    }
}

fn format_patterns(patterns: &[crate::types::Pattern]) -> String {
    if patterns.is_empty() {
        return String::new();
    }

    let patterns_html: String = patterns
        .iter()
        .map(|pattern| {
            format!(
                "<div class=\"pattern\"><span class=\"pattern-name\">{}</span> - {} matches ({:.1}%)</div>",
                pattern.name, pattern.match_count, pattern.match_percentage
            )
        })
        .collect();

    format!(
        r#"<div class="patterns">
            <h4>Detected Patterns</h4>
            {}
        </div>"#,
        patterns_html
    )
}

fn get_css() -> &'static str {
    r#"
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .file-info h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 15px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat .label {
            font-size: 0.85rem;
            color: #64748b;
            font-weight: 500;
        }

        .stat .value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e293b;
        }

        .sampling-info {
            margin-top: 15px;
        }

        .sampling-badge {
            background: #fbbf24;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        section h2 {
            font-size: 1.8rem;
            margin-bottom: 25px;
            color: #2d3748;
        }

        .no-issues {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.2rem;
            color: #059669;
            font-weight: 500;
        }

        .success-icon {
            font-size: 1.5rem;
        }

        .quality-summary {
            background: #f1f5f9;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            font-weight: 500;
        }

        .quality-summary .critical { color: #dc2626; }
        .quality-summary .warning { color: #d97706; }
        .quality-summary .info { color: #2563eb; }

        .issues-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .issue {
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid;
        }

        .issue.critical {
            background: #fef2f2;
            border-left-color: #dc2626;
        }

        .issue.warning {
            background: #fffbeb;
            border-left-color: #d97706;
        }

        .issue.info {
            background: #eff6ff;
            border-left-color: #2563eb;
        }

        .issue-header {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .issue-number {
            background: #64748b;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .severity {
            font-weight: bold;
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        .issue.critical .severity { color: #dc2626; }
        .issue.warning .severity { color: #d97706; }
        .issue.info .severity { color: #2563eb; }

        .issue-details {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #64748b;
        }

        .issue-details ul {
            list-style: none;
            padding-left: 20px;
        }

        .issue-details li {
            margin-bottom: 5px;
        }

        .columns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
        }

        .column-card {
            background: #fafafa;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #e2e8f0;
        }

        .column-card h3 {
            font-size: 1.3rem;
            color: #1e293b;
            margin-bottom: 15px;
        }

        .column-meta {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .type-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .type-string { background: #10b981; color: white; }
        .type-integer { background: #3b82f6; color: white; }
        .type-float { background: #06b6d4; color: white; }
        .type-date { background: #8b5cf6; color: white; }

        .records {
            font-size: 0.9rem;
            color: #64748b;
        }

        .nulls.success { color: #059669; }
        .nulls.warning { color: #d97706; }

        .stats {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            background: none;
            padding: 0;
            border: none;
        }

        .stat label {
            font-weight: 500;
            color: #64748b;
        }

        .stat span {
            font-weight: bold;
            color: #1e293b;
        }

        .patterns {
            background: white;
            padding: 20px;
            border-radius: 8px;
        }

        .patterns h4 {
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 1rem;
        }

        .pattern {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .pattern:last-child {
            border-bottom: none;
        }

        .pattern-name {
            font-weight: 500;
            color: #667eea;
        }

        footer {
            text-align: center;
            padding: 30px;
            color: #64748b;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container { padding: 10px; }
            header, section { padding: 20px; }
            h1 { font-size: 2rem; }
            .stats-grid { grid-template-columns: 1fr 1fr; }
            .columns-grid { grid-template-columns: 1fr; }
        }
    "#
}
