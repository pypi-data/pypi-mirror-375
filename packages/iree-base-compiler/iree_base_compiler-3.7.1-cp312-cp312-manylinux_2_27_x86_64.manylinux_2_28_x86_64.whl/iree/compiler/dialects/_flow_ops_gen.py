
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "flow"

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.call"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, callee, arguments, argument_dims, result_dims, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arguments(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def argument_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def callee(self):
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def call(results_, callee, arguments, argument_dims, result_dims, *, tied_operands=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(CallOp(results_=results_, callee=callee, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, tied_operands=tied_operands, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ChannelCountOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.channel.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_count(channel, *, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelCountOp(channel=channel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelDefaultOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.channel.default"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, group=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if group is not None: attributes["group"] = (group if (
        isinstance(group, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(group, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def group(self):
    if "group" not in self.operation.attributes:
      return None
    return self.operation.attributes["group"]

  @group.setter
  def group(self, value):
    if value is not None:
      self.operation.attributes["group"] = value
    elif "group" in self.operation.attributes:
      del self.operation.attributes["group"]

  @group.deleter
  def group(self):
    del self.operation.attributes["group"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_default(*, group=None, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelDefaultOp(group=group, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelRankOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.channel.rank"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_rank(channel, *, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelRankOp(channel=channel, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ChannelSplitOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.channel.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, channel, color, key, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(channel)
    operands.append(color)
    operands.append(key)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def channel(self):
    return self.operation.operands[0]

  @builtins.property
  def color(self):
    return self.operation.operands[1]

  @builtins.property
  def key(self):
    return self.operation.operands[2]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def channel_split(channel, color, key, *, loc=None, ip=None) -> _ods_ir.Value:
  return ChannelSplitOp(channel=channel, color=color, key=key, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveAllGatherOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.collective.all_gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, element_type, target, target_dims, source, channel, *, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def element_type(self):
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def collective_all_gather(element_type, target, target_dims, source, channel, *, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return CollectiveAllGatherOp(element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, tied_operands=tied_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveAllReduceOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.collective.all_reduce"

  _ODS_REGIONS = (0, True)

  def __init__(self, reduction_op, element_type, target, target_dims, source, channel, *, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reduction_op"] = (reduction_op if (
    isinstance(reduction_op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveReductionOpAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveReductionOpAttr')(reduction_op, context=_ods_context))
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def reduction_op(self):
    return self.operation.attributes["reduction_op"]

  @reduction_op.setter
  def reduction_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction_op"] = value

  @builtins.property
  def element_type(self):
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def collective_all_reduce(reduction_op, element_type, target, target_dims, source, channel, *, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return CollectiveAllReduceOp(reduction_op=reduction_op, element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, tied_operands=tied_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveAllToAllOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.collective.all_to_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, element_type, target, target_dims, source, channel, *, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def element_type(self):
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def collective_all_to_all(element_type, target, target_dims, source, channel, *, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return CollectiveAllToAllOp(element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, tied_operands=tied_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveReduceScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.collective.reduce_scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, reduction_op, element_type, target, target_dims, source, channel, *, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["reduction_op"] = (reduction_op if (
    isinstance(reduction_op, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveReductionOpAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveReductionOpAttr')(reduction_op, context=_ods_context))
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self):
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def reduction_op(self):
    return self.operation.attributes["reduction_op"]

  @reduction_op.setter
  def reduction_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reduction_op"] = value

  @builtins.property
  def element_type(self):
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def collective_reduce_scatter(reduction_op, element_type, target, target_dims, source, channel, *, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return CollectiveReduceScatterOp(reduction_op=reduction_op, element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, tied_operands=tied_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CollectiveSendRecvOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.collective.send_recv"

  _ODS_REGIONS = (0, True)

  def __init__(self, element_type, target, target_dims, source, channel, send, recv, *, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.extend(_get_op_results_or_values(target_dims))
    operands.append(source)
    operands.append(channel)
    operands.append(send)
    operands.append(recv)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FLOW_CollectiveElementTypeAttr')) else
      _ods_ir.AttrBuilder.get('FLOW_CollectiveElementTypeAttr')(element_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def target_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def source(self):
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[2 + _ods_variadic_group_length - 1]

  @builtins.property
  def channel(self):
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[3 + _ods_variadic_group_length - 1]

  @builtins.property
  def send(self):
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[4 + _ods_variadic_group_length - 1]

  @builtins.property
  def recv(self):
    _ods_variadic_group_length = len(self.operation.operands) - 6 + 1
    return self.operation.operands[5 + _ods_variadic_group_length - 1]

  @builtins.property
  def element_type(self):
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def collective_send_recv(element_type, target, target_dims, source, channel, send, recv, *, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return CollectiveSendRecvOp(element_type=element_type, target=target, target_dims=target_dims, source=source, channel=channel, send=send, recv=recv, tied_operands=tied_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.dispatch"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, workload, entry_points, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["entry_points"] = (entry_points if (
    isinstance(entry_points, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(entry_points, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def arguments(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def argument_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def entry_points(self):
    return self.operation.attributes["entry_points"]

  @entry_points.setter
  def entry_points(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["entry_points"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def dispatch(results_, workload, entry_points, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DispatchOp(results_=results_, workload=workload, entry_points=entry_points, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, tied_operands=tied_operands, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DispatchRegionOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.dispatch.region"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (2, True)

  def __init__(self, result, result_dims, workload, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(result_dims))
    operands.append(_get_op_results_or_values(workload))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def workload(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self):
    return self.regions[0]

  @builtins.property
  def workgroup_count(self):
    return self.regions[1]

def dispatch_region(result, result_dims, workload, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DispatchRegionOp(result=result, result_dims=result_dims, workload=workload, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DispatchTieShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.dispatch.tie_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, dynamic_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(dynamic_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_tie_shape(operand, dynamic_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchTieShapeOp(operand=operand, dynamic_dims=dynamic_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupCountOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.dispatch.workgroup.count"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_count(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupCountOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupIDOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.dispatch.workgroup.id"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_id(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupIDOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.dispatch.workgroup.size"

  _ODS_REGIONS = (0, True)

  def __init__(self, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    isinstance(dimension, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IndexAttr')) else
      _ods_ir.AttrBuilder.get('IndexAttr')(dimension, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def dispatch_workgroup_size(dimension, *, loc=None, ip=None) -> _ods_ir.Value:
  return DispatchWorkgroupSizeOp(dimension=dimension, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DispatchWorkgroupsOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.dispatch.workgroups"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,]

  _ODS_REGIONS = (2, True)

  def __init__(self, results_, workload, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(workload))
    operands.append(_get_op_results_or_values(arguments))
    operands.append(_get_op_results_or_values(argument_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def workload(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def arguments(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def argument_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def workgroup_body(self):
    return self.regions[0]

  @builtins.property
  def workgroup_count(self):
    return self.regions[1]

def dispatch_workgroups(results_, workload, arguments, argument_dims, result_dims, *, tied_operands=None, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(DispatchWorkgroupsOp(results_=results_, workload=workload, arguments=arguments, argument_dims=argument_dims, result_dims=result_dims, tied_operands=tied_operands, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ExecutableEndOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.executable_end"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def executable_end(*, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableEndOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableExportOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.executable.export"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_ref, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_ref"] = (function_ref if (
    isinstance(function_ref, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(function_ref, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_ref(self):
    return self.operation.attributes["function_ref"]

  @function_ref.setter
  def function_ref(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_ref"] = value

  @builtins.property
  def workgroup_count(self):
    return self.regions[0]

def executable_export(sym_name, function_ref, *, sym_visibility=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableExportOp(sym_name=sym_name, function_ref=function_ref, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutableOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.executable"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, sym_visibility=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self):
    return self.regions[0]

def executable(sym_name, *, sym_visibility=None, loc=None, ip=None) -> _ods_ir.Operation:
  return ExecutableOp(sym_name=sym_name, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_659')) else
      _ods_ir.AttrBuilder.get('anonymous_659')(function_type, context=_ods_context))
    if tied_operands is not None: attributes["tied_operands"] = (tied_operands if (
        isinstance(tied_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('Util_TiedOpStorageAttr')) else
          _ods_ir.AttrBuilder.get('Util_TiedOpStorageAttr')(tied_operands, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self):
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self):
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def tied_operands(self):
    if "tied_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["tied_operands"]

  @tied_operands.setter
  def tied_operands(self, value):
    if value is not None:
      self.operation.attributes["tied_operands"] = value
    elif "tied_operands" in self.operation.attributes:
      del self.operation.attributes["tied_operands"]

  @tied_operands.deleter
  def tied_operands(self):
    del self.operation.attributes["tied_operands"]

  @builtins.property
  def sym_visibility(self):
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self):
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self):
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self):
    return self.regions[0]

def func(sym_name, function_type, *, tied_operands=None, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir.Operation:
  return FuncOp(sym_name=sym_name, function_type=function_type, tied_operands=tied_operands, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorAllocaOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.alloca"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_alloca(result, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorAllocaOp(result=result, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_dims, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(operand_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(target, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def target(self):
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_barrier(operand, operand_dims, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorBarrierOp(operand=operand, operand_dims=operand_dims, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorBitCastOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.bitcast"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_bitcast(result, source, source_dims, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorBitCastOp(result=result, source=source, source_dims=source_dims, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorCloneOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.clone"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(operand_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_clone(operand, operand_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorCloneOp(operand=operand, operand_dims=operand_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_constant(value, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorConstantOp(value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorDynamicConstantOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.dynamic_constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(value, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_dynamic_constant(result, value, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorDynamicConstantOp(result=result, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorEmptyOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.empty"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_empty(result, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorEmptyOp(result=result, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorEncodeOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.encode"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, operand_dims, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(_get_op_results_or_values(operand_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def operand_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_encode(result, operand, operand_dims, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorEncodeOp(result=result, operand=operand, operand_dims=operand_dims, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.load"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, source, source_dims, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_load(source, source_dims, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorLoadOp(source=source, source_dims=source_dims, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorReshapeOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.reshape"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_reshape(result, source, source_dims, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorReshapeOp(result=result, source=source, source_dims=source_dims, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSliceOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.slice"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, source_dims, start_indices, lengths, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.append(_get_op_results_or_values(source_dims))
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(_get_op_results_or_values(lengths))
    operands.append(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def source_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def start_indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def lengths(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_slice(result, source, source_dims, start_indices, lengths, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorSliceOp(result=result, source=source, source_dims=source_dims, start_indices=start_indices, lengths=lengths, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorSplatOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.splat"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, value, result_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.extend(_get_op_results_or_values(result_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def result_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_splat(result, value, result_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorSplatOp(result=result, value=value, result_dims=result_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.store"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, target, target_dims, indices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(target)
    operands.append(_get_op_results_or_values(target_dims))
    operands.append(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def target_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_store(value, target, target_dims, indices, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorStoreOp(value=value, target=target, target_dims=target_dims, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorTieShapeOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.tie_shape"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, dynamic_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(dynamic_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_tie_shape(operand, dynamic_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorTieShapeOp(operand=operand, dynamic_dims=dynamic_dims, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorTraceOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.trace"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, key, values, value_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(values))
    operands.append(_get_op_results_or_values(value_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["key"] = (key if (
    isinstance(key, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(key, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def value_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def key(self):
    return self.operation.attributes["key"]

  @key.setter
  def key(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["key"] = value

def tensor_trace(key, values, value_dims, *, loc=None, ip=None) -> _ods_ir.Operation:
  return TensorTraceOp(key=key, values=values, value_dims=value_dims, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TensorTransferOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.transfer"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, operand_dims, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.extend(_get_op_results_or_values(operand_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["target"] = (target if (
    isinstance(target, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(target, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self):
    return self.operation.operands[0]

  @builtins.property
  def operand_dims(self):
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def target(self):
    return self.operation.attributes["target"]

  @target.setter
  def target(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["target"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_transfer(operand, operand_dims, target, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorTransferOp(operand=operand, operand_dims=operand_dims, target=target, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TensorUpdateOp(_ods_ir.OpView):
  OPERATION_NAME = "flow.tensor.update"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, target, target_dims, start_indices, update, update_dims, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(_get_op_results_or_values(target_dims))
    operands.append(_get_op_results_or_values(start_indices))
    operands.append(update)
    operands.append(_get_op_results_or_values(update_dims))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def target_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def start_indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def update(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0]

  @builtins.property
  def update_dims(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def result(self):
    return self.operation.results[0]

def tensor_update(target, target_dims, start_indices, update, update_dims, *, loc=None, ip=None) -> _ods_ir.Value:
  return TensorUpdateOp(target=target, target_dims=target_dims, start_indices=start_indices, update=update, update_dims=update_dims, loc=loc, ip=ip).result
