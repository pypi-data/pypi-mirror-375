from __future__ import annotations
import numpy
import ostk.core.type
import typing
__all__ = ['EulerAngle', 'Quaternion', 'RotationMatrix', 'RotationVector', 'set_quaternion_array']
class EulerAngle:
    class AxisSequence:
        """
        Members:
        
          Undefined
        
          XYZ
        
          ZXY
        
          ZYX
        """
        Undefined: typing.ClassVar[EulerAngle.AxisSequence]  # value = <AxisSequence.Undefined: 0>
        XYZ: typing.ClassVar[EulerAngle.AxisSequence]  # value = <AxisSequence.XYZ: 1>
        ZXY: typing.ClassVar[EulerAngle.AxisSequence]  # value = <AxisSequence.ZXY: 2>
        ZYX: typing.ClassVar[EulerAngle.AxisSequence]  # value = <AxisSequence.ZYX: 3>
        __members__: typing.ClassVar[dict[str, EulerAngle.AxisSequence]]  # value = {'Undefined': <AxisSequence.Undefined: 0>, 'XYZ': <AxisSequence.XYZ: 1>, 'ZXY': <AxisSequence.ZXY: 2>, 'ZYX': <AxisSequence.ZYX: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def quaternion(quaternion: Quaternion, axis_sequence: typing.Any) -> EulerAngle:
        ...
    @staticmethod
    def rotation_matrix(rotation_matrix: RotationMatrix, axis_sequence: typing.Any) -> EulerAngle:
        ...
    @staticmethod
    def rotation_vector(rotation_vector: RotationVector, axis_sequence: typing.Any) -> EulerAngle:
        ...
    @staticmethod
    def undefined() -> EulerAngle:
        ...
    @staticmethod
    def unit() -> EulerAngle:
        ...
    @staticmethod
    def xyz(phi: typing.Any, theta: typing.Any, psi: typing.Any) -> EulerAngle:
        ...
    @staticmethod
    def zxy(phi: typing.Any, theta: typing.Any, psi: typing.Any) -> EulerAngle:
        ...
    @staticmethod
    def zyx(phi: typing.Any, theta: typing.Any, psi: typing.Any) -> EulerAngle:
        ...
    def __eq__(self, arg0: EulerAngle) -> bool:
        ...
    @typing.overload
    def __init__(self, phi: typing.Any, theta: typing.Any, psi: typing.Any, axis_sequence: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, vector: numpy.ndarray[numpy.float64[3, 1]], angle_unit: typing.Any, axis_sequence: typing.Any) -> None:
        ...
    def __ne__(self, arg0: EulerAngle) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def is_defined(self) -> bool:
        ...
    def is_near(self, euler_angle: EulerAngle, angular_tolerance: typing.Any) -> bool:
        ...
    def is_unitary(self) -> bool:
        ...
    @typing.overload
    def to_string(self) -> ostk.core.type.String:
        ...
    @typing.overload
    def to_string(self, angle_unit: typing.Any) -> ostk.core.type.String:
        ...
    def to_vector(self, angle_unit: typing.Any) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def axis_sequence(self) -> ...:
        ...
    @property
    def phi(self) -> ...:
        ...
    @property
    def psi(self) -> ...:
        ...
    @property
    def theta(self) -> ...:
        ...
class Quaternion:
    class Format:
        """
        Members:
        
          XYZS
        
          SXYZ
        """
        SXYZ: typing.ClassVar[Quaternion.Format]  # value = <Format.SXYZ: 1>
        XYZS: typing.ClassVar[Quaternion.Format]  # value = <Format.XYZS: 0>
        __members__: typing.ClassVar[dict[str, Quaternion.Format]]  # value = {'XYZS': <Format.XYZS: 0>, 'SXYZ': <Format.SXYZ: 1>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def euler_angle(euler_angle: typing.Any) -> Quaternion:
        ...
    @staticmethod
    def lerp(first_quaternion: Quaternion, second_quaternion: Quaternion, ratio: ostk.core.type.Real) -> Quaternion:
        ...
    @staticmethod
    def nlerp(first_quaternion: Quaternion, second_quaternion: Quaternion, ratio: ostk.core.type.Real) -> Quaternion:
        ...
    @staticmethod
    def parse(string: ostk.core.type.String, format: typing.Any) -> Quaternion:
        ...
    @staticmethod
    def rotation_matrix(rotation_matrix: typing.Any) -> Quaternion:
        ...
    @staticmethod
    def rotation_vector(rotation_vector: typing.Any) -> Quaternion:
        ...
    @staticmethod
    def shortest_rotation(first_vector: numpy.ndarray[numpy.float64[3, 1]], second_vector: numpy.ndarray[numpy.float64[3, 1]]) -> Quaternion:
        ...
    @staticmethod
    def slerp(first_quaternion: Quaternion, second_quaternion: Quaternion, ratio: ostk.core.type.Real) -> Quaternion:
        ...
    @staticmethod
    def undefined() -> Quaternion:
        ...
    @staticmethod
    def unit() -> Quaternion:
        ...
    @staticmethod
    def xyzs(first_component: ostk.core.type.Real, second_component: ostk.core.type.Real, third_component: ostk.core.type.Real, fourth_component: ostk.core.type.Real) -> Quaternion:
        ...
    def __add__(self, arg0: Quaternion) -> Quaternion:
        ...
    def __eq__(self, arg0: Quaternion) -> bool:
        ...
    def __iadd__(self, arg0: Quaternion) -> Quaternion:
        ...
    @typing.overload
    def __init__(self, first_component: ostk.core.type.Real, second_component: ostk.core.type.Real, third_component: ostk.core.type.Real, fourth_component: ostk.core.type.Real, format: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, vector: numpy.ndarray[numpy.float64[4, 1]], format: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, vector_part: numpy.ndarray[numpy.float64[3, 1]], scalar_part: ostk.core.type.Real) -> None:
        ...
    @typing.overload
    def __init__(self, quaternion: Quaternion) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Quaternion) -> Quaternion:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Quaternion:
        ...
    def __ne__(self, arg0: Quaternion) -> bool:
        ...
    def __pow__(self, arg0: float) -> Quaternion:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Quaternion:
        ...
    def __str__(self) -> str:
        ...
    def __truediv__(self, arg0: Quaternion) -> Quaternion:
        ...
    def angular_difference_with(self, quaternion: Quaternion) -> ...:
        ...
    def conjugate(self) -> None:
        ...
    def cross_multiply(self, quaternion: Quaternion) -> Quaternion:
        ...
    def dot_multiply(self, quaternion: Quaternion) -> Quaternion:
        ...
    def dot_product(self, quaternion: Quaternion) -> ostk.core.type.Real:
        ...
    def exp(self) -> Quaternion:
        ...
    def get_scalar_part(self) -> ostk.core.type.Real:
        ...
    def get_vector_part(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def inverse(self) -> None:
        ...
    def is_defined(self) -> bool:
        ...
    def is_near(self, quaternion: Quaternion, angular_tolerance: typing.Any) -> bool:
        ...
    def is_unitary(self, norm_tolerance: ostk.core.type.Real = ...) -> bool:
        ...
    def log(self) -> Quaternion:
        ...
    def norm(self) -> ostk.core.type.Real:
        ...
    def normalize(self) -> None:
        ...
    def pow(self, value: ostk.core.type.Real) -> Quaternion:
        ...
    def rectify(self) -> None:
        ...
    def rotate_vector(self, vector: numpy.ndarray[numpy.float64[3, 1]], norm_tolerance: ostk.core.type.Real = ...) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def s(self) -> ostk.core.type.Real:
        ...
    def to_conjugate(self) -> Quaternion:
        ...
    def to_inverse(self) -> Quaternion:
        ...
    def to_normalized(self) -> Quaternion:
        ...
    @typing.overload
    def to_string(self) -> ostk.core.type.String:
        ...
    @typing.overload
    def to_string(self, arg0: typing.Any) -> ostk.core.type.String:
        ...
    def to_vector(self, format: typing.Any) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def x(self) -> ostk.core.type.Real:
        ...
    def y(self) -> ostk.core.type.Real:
        ...
    def z(self) -> ostk.core.type.Real:
        ...
class RotationMatrix:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def columns(first_column: numpy.ndarray[numpy.float64[3, 1]], second_column: numpy.ndarray[numpy.float64[3, 1]], third_column: numpy.ndarray[numpy.float64[3, 1]]) -> RotationMatrix:
        ...
    @staticmethod
    def euler_angle(euler_angle: typing.Any) -> RotationMatrix:
        ...
    @staticmethod
    def quaternion(quaternion: Quaternion) -> RotationMatrix:
        ...
    @staticmethod
    def rotation_vector(rotation_vector: RotationVector) -> RotationMatrix:
        ...
    @staticmethod
    def rows(first_row: numpy.ndarray[numpy.float64[3, 1]], second_row: numpy.ndarray[numpy.float64[3, 1]], third_row: numpy.ndarray[numpy.float64[3, 1]]) -> RotationMatrix:
        ...
    @staticmethod
    def rx(rotation_angle: typing.Any) -> RotationMatrix:
        ...
    @staticmethod
    def ry(rotation_angle: typing.Any) -> RotationMatrix:
        ...
    @staticmethod
    def rz(rotation_angle: typing.Any) -> RotationMatrix:
        ...
    @staticmethod
    def undefined() -> RotationMatrix:
        ...
    @staticmethod
    def unit() -> RotationMatrix:
        ...
    def __eq__(self, arg0: RotationMatrix) -> bool:
        ...
    @typing.overload
    def __init__(self, matrix: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    @typing.overload
    def __init__(self, first_coefficient: ostk.core.type.Real, second_coefficient: ostk.core.type.Real, third_coefficient: ostk.core.type.Real, fourth_coefficient: ostk.core.type.Real, fifth_coefficient: ostk.core.type.Real, sixth_coefficient: ostk.core.type.Real, seventh_coefficient: ostk.core.type.Real, eighth_coefficient: ostk.core.type.Real, ninth_coefficient: ostk.core.type.Real) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: RotationMatrix) -> RotationMatrix:
        ...
    @typing.overload
    def __mul__(self, arg0: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def __ne__(self, arg0: RotationMatrix) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def get_column_at(self, index: int) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def get_matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def get_row_at(self, index: int) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def is_defined(self) -> bool:
        ...
    def to_transposed(self) -> RotationMatrix:
        ...
    def transpose(self) -> None:
        ...
class RotationVector:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def euler_angle(euler_angle: typing.Any) -> RotationVector:
        ...
    @staticmethod
    def quaternion(quaternion: Quaternion) -> RotationVector:
        ...
    @staticmethod
    def rotation_matrix(rotation_matrix: typing.Any) -> RotationVector:
        ...
    @staticmethod
    def undefined() -> RotationVector:
        ...
    @staticmethod
    def unit() -> RotationVector:
        ...
    @staticmethod
    def x(angle: typing.Any) -> RotationVector:
        ...
    @staticmethod
    def y(angle: typing.Any) -> RotationVector:
        ...
    @staticmethod
    def z(angle: typing.Any) -> RotationVector:
        ...
    def __eq__(self, arg0: RotationVector) -> bool:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64[3, 1]], angle: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, vector: numpy.ndarray[numpy.float64[3, 1]], angle_unit: typing.Any) -> None:
        ...
    def __ne__(self, arg0: RotationVector) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def get_angle(self) -> ...:
        ...
    def get_axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def is_defined(self) -> bool:
        ...
    def rectify(self) -> None:
        ...
    @typing.overload
    def to_string(self) -> ostk.core.type.String:
        ...
    @typing.overload
    def to_string(self, arg0: ostk.core.type.Integer) -> ostk.core.type.String:
        ...
def set_quaternion_array(arg0: list[Quaternion]) -> None:
    ...
