import tempfile
from pathlib import Path
import asyncio
from zipfile import ZipFile

import polars as pl
import httpx
import requests

from libsms.data_model import EcoliExperiment, SimulationRun


async def run_simulation(
    config_id: str,
    max_retries: int = 20,
    delay_s: float = 1.0,
    verbose: bool = False,
    **body
) -> EcoliExperiment:
    """Run a SMS API vEcoli simulation workflow.

    :param config_id: (str) Configuration ID of desired simulation experiment workflow. Defaults to "sms" (single cell)
    :param max_retries: (int) Maximum number of times to retry the workflow before giving up. Defaults to 20.
    :param delay_s: (float) Delay time between retries in seconds. Defaults to 1.0.
    :param verbose: (bool) Verbose mode. If set to ``True``, log print statements. Defaults to False.
    :param body: (kwargs/dict) Key/value pairs including: "overrides": {"config": {...}}, "variants": {"config": {...}}

    :rtype: EcoliExperiment
    :return: EcoliExperiment object with queriable experiment_id and experiment_tag
    """
    url = f"https://sms.cam.uchc.edu/wcm/simulation/run?config_id={config_id}"
    if not body:
        body = {
            "overrides": {"config": {}},
            "variants": {"config": {}},
        }

    attempt = 0
    async with httpx.AsyncClient() as client:
        while attempt < max_retries:
            attempt += 1
            try:
                if verbose:
                    print(f"Attempt {attempt}...")
                response = await client.post(
                    url,
                    json=body,
                    headers={"Accept": "application/json"},
                    timeout=30.0,  # optional, adjust as needed
                )

                response.raise_for_status()  # raises for 4xx/5xx

                data = response.json()
                if verbose:
                    print("Success on attempt", attempt)
                return EcoliExperiment(**data)

            except (httpx.RequestError, httpx.HTTPStatusError) as err:
                if attempt == max_retries:
                    print(f"Attempt {attempt} failed:", err)
                    raise
                await asyncio.sleep(delay_s)


async def check_simulation_status(
    experiment: EcoliExperiment,
    max_retries: int = 20,
    delay_s: float = 1.0,
    verbose: bool = False
) -> SimulationRun:
    """Run a SMS API vEcoli simulation workflow.

    :param experiment: (EcoliExperiment) Experiment generated by run_simulation.
    :param max_retries: (int) Maximum number of times to retry the workflow before giving up. Defaults to 20.
    :param delay_s: (float) Delay time between retries in seconds. Defaults to 1.0.
    :param verbose: (bool) Verbose mode. If set to ``True``, log print statements. Defaults to False.
    :rtype: SimulationRun
    :return: SimulationRun confirming run status (status will be one of "waiting", "running", "completed", "failed"
    """
    url = f"https://sms.cam.uchc.edu/wcm/simulation/run/status?experiment_tag={experiment.experiment_tag}"
    attempt = 0
    async with httpx.AsyncClient() as client:
        while attempt < max_retries:
            attempt += 1
            try:
                if verbose:
                    print(f"Attempt {attempt}...")
                response = await client.get(
                    url,
                    headers={"Accept": "application/json"},
                    timeout=30.0,  # optional, adjust as needed
                )

                response.raise_for_status()  # raises for 4xx/5xx

                data = response.json()
                if verbose:
                    print("Success on attempt", attempt)
                return SimulationRun(**data)

            except (httpx.RequestError, httpx.HTTPStatusError) as err:
                if attempt == max_retries:
                    print(f"Attempt {attempt} failed:", err)
                    raise
                await asyncio.sleep(delay_s)


async def get_analysis_manifest(
    experiment: EcoliExperiment,
    max_retries: int = 20,
    delay_s: float = 1.0,
    verbose: bool = False
) -> dict[str, list[str]]:
    url = f"https://sms.cam.uchc.edu/wcm/analysis/outputs?experiment_id={experiment.experiment_id}"
    attempt = 0
    async with httpx.AsyncClient() as client:
        while attempt < max_retries:
            attempt += 1
            try:
                if verbose:
                    print(f"Attempt {attempt}...")
                response = await client.get(
                    url,
                    headers={"Accept": "application/json"},
                    timeout=30.0,  # optional, adjust as needed
                )

                response.raise_for_status()  # raises for 4xx/5xx

                data = response.json()
                if verbose:
                    print("Success on attempt", attempt)
                return data

            except (httpx.RequestError, httpx.HTTPStatusError) as err:
                if attempt == max_retries:
                    print(f"Attempt {attempt} failed:", err)
                    raise
                await asyncio.sleep(delay_s)


def unzip_parquet(zip_file_path: Path, local_dirpath: Path):
    extraction_path = local_dirpath
    try:
        with ZipFile(zip_file_path, 'r') as zip_ref:
            zip_ref.extractall(extraction_path)
        print(f"Successfully unzipped '{zip_file_path}' to '{extraction_path}'")
    except FileNotFoundError:
        print(f"Error: The file '{zip_file_path}' was not found.")
    except Exception as e:
        print(f"An error occurred: {e}")


def download_parquet(local_dirpath: Path, experiment_id: str) -> Path:
    url = f"https://sms.cam.uchc.edu/core/download/parquet?experiment_id={experiment_id}"

    response = requests.post(url, headers={"Accept": "*/*"})

    if response.status_code != 200:
        raise Exception(f"HTTP error! status: {response.status_code}")

    zippath = local_dirpath / f"{experiment_id}.zip"
    with open(zippath, "wb") as f:
        f.write(response.content)

    return zippath


def get_observables_data(
        observables: list[str] | None = None,
        experiment_id: str | None = None
) -> pl.DataFrame:
    """Get the output data from parquet files generated from a given vEcoli simulation as a dataframe containing all simulation timepoints.

    :param observables: list of observables(dataframe columns) to include. If None is passed, defaults to all columns.
    :param experiment_id: the experiment ID for the simulation that you wish to query. If None is passed, defaults to the exampled
        pinned simulation: "sms_single".

    :rtype: polars.DataFrame
    :return: A dataframe containing all simulation timepoints.

    """
    expid = experiment_id or "sms_single"
    tmpdir = tempfile.TemporaryDirectory()
    dirpath = Path(tmpdir.name)
    zippath = download_parquet(dirpath, expid)
    unzip_parquet(zippath, dirpath)
    df = pl.scan_parquet(f"{str(dirpath)}/*.pq").select(observables).collect()
    tmpdir.cleanup()
    return df
